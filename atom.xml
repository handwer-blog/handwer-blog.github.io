<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Handwer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.handwer-std.top/"/>
  <updated>2019-01-20T14:11:43.197Z</updated>
  <id>https://blog.handwer-std.top/</id>
  
  <author>
    <name>Handwer STD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公告栏</title>
    <link href="https://blog.handwer-std.top/2019-10-31/BulletinBoard/"/>
    <id>https://blog.handwer-std.top/2019-10-31/BulletinBoard/</id>
    <published>2019-10-31T12:30:10.000Z</published>
    <updated>2019-01-20T14:11:43.197Z</updated>
    
    <content type="html"><![CDATA[<p><font style="color:#66ccff"></font></p><p><center>这里可能会挂些什么东西。 <br>There may be something here.<br></center><br><br><img src="https://v2.jinrishici.com/one.svg" alt="今日诗词"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font style=&quot;color:#66ccff&quot;&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;这里可能会挂些什么东西。 &lt;br&gt;There may be something here.&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://v2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ST算法学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-02-15/RMQ-SparseTable/"/>
    <id>https://blog.handwer-std.top/2019-02-15/RMQ-SparseTable/</id>
    <published>2019-02-15T12:58:48.000Z</published>
    <updated>2019-02-15T23:59:19.236Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>$O(1)$查询区间最值</p></blockquote><a id="more"></a><h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>RMQ (Range Minimum/Maximum Query)问题是指：对于长度为n的数列A，回答若干询问RMQ(A,i,j)(i,j&lt;=n)，返回数列A中下标在i,j里的最小(大）值，也就是说，RMQ问题是指求区间最值的问题。</p><p style="text-align:right"> ——百度百科 </p><p>ST（Sparse Table，稀疏表）算法是求解RMQ问题的经典在线算法，以O(nlogn)时间预处理，然后在O(1)时间内回答每个查询。</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>ST算法实际上采用了DP的思想</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>定义 $F(i,j)$ 表示区间 $[i, i + 2^j - 1]$ 内的最小值，$P[i]$ 为原序列</p><p>那么显然<br>$$ F(i,0) = P[i] $$</p><p>状态转移方程？</p><hr><p>首先，任意一个区间的最小值等于 $min($这个区间前一半的最小值$,$ 这个区间后一半点最小值$)$<br>这个很好理解吧<br>把$F(\ )$结合进去，就是</p><p>$$ F(i,j) = min(F(i,j-1),F(i + 2^{j-1}, j - 1)) $$</p><hr><p>还有什么细节？<br>上面的式子看的你很想递归是吧（反正我是）<br>如果你不想递归的话，你八成会：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ...)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; ...)</span><br><span class="line">        F[i][j] = ...</span><br></pre></td></tr></table></figure><p>其实……这样都是<strong>错</strong>的，这样会导致有几个状态被过早地枚举</p><p>我们要把枚举 $j$ 的循环<strong>放在外层</strong>，至于为什么……你模<small><small>拟</small></small>一下就行了</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>此处的内容可能有点<strong>难以理解</strong>，请消化不了的同学多看几遍</p><hr><p>上面说了查询是 $O(1)$ 的<del>听起来就好简单啊</del></p><p>实现确实是很简单，但是原理就……<del>也是很简单</del></p><hr><p>首先给你一个定理：<br>对于任意 $x \in \mathbb{N^*}$ ，都有 $ 2^{\lfloor log_2(x) \rfloor} &gt; \lfloor \frac{x}{2} \rfloor $</p><p>然后令查询区间$[l,r]$的长度 $\text{len} = r - (l - 1),\ \text{ll} = log_2(\text{len})$<br>那么根据上边可得 $ 2^{\text{ll}} &gt; \lfloor \frac{len}{2} \rfloor $<br>这意味着什么？<br>这意味着查询的区间有重叠！<br>不过这并不能意味啥，重叠又怎么样，只是查询的区间变了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原来我们查询区间，都是查询这个区间的一半</span><br><span class="line">比如更新[l,r]之间的最小值就是</span><br><span class="line">f[<span class="string">l</span>][<span class="symbol">r</span>] = std::min(f[<span class="string">l</span>][<span class="symbol">mid</span>], f[<span class="string">mid + 1</span>][<span class="symbol">r</span>]);</span><br><span class="line"></span><br><span class="line">但是这次不一样，这次的mid超过了区间的一半</span><br><span class="line">那就可以这么写：</span><br><span class="line"></span><br><span class="line">int Query(int l, int r) &#123;</span><br><span class="line"><span class="code">    int k = std::log(r - (l - 1)) / std::log(2);</span></span><br><span class="line"><span class="code">    return std::min(f[l][k], f[r - ((1 &lt;&lt; k) -1)][k]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是 $O(1)$ 的吧</p><p>它查询的区间相当于是这样的：<br><strong>（画的不准确，仅供参考）</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> </span><br><span class="line">-------====       f[l][k]</span><br><span class="line">       ====------ f[r - ((<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>)][k]</span><br><span class="line">       </span><br><span class="line">等号就是两个查询区间的并集</span><br></pre></td></tr></table></figure><p>这也就是它为什么不能查询区间和的原因<br><del>前缀和足够了</del></p><p><img src="https://cdn.luogu.org/upload/pic/5010.png" alt="qwq"></p><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ \text{Algorithm 1: Sparse Table} $<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ \text{Init(The Sparse Table } f, \text{The original sequence } a, \text{no return value})$<br>&nbsp;&nbsp;$ 1. \text{For } i \text{ from 1 to n do}$<br>&nbsp;&nbsp;$ 2. \ \ \ \ f[i][0] = a[i] $<br>&nbsp;&nbsp;$ 3. \text{End For} $<br>&nbsp;&nbsp;$ 4. \ j \leftarrow 1, i \leftarrow 1$<br>&nbsp;&nbsp;$ 5. \text{While } 2^j \leq n \text{ do} $<br>&nbsp;&nbsp;$ 6. \ \ \ \ \text{While } i + 2^j - 1 \leq n \text{ do} $<br>&nbsp;&nbsp;$ 7. \ \ \ \ \ \ \ \ f[i][j] = min(f[i][j-1], f[i + 2^{j-1}][j-1]) $<br>&nbsp;&nbsp;$ 8. \ \ \ \ \ \ \ \ i \leftarrow i + 1 $<br>&nbsp;&nbsp;$ 9. \ \ \ \ \text{End While}$<br>$ 10. \ \ \ \ j \leftarrow j + 1 $<br>$ 11. \text{End While} $ </p><p>$ \text{Query(}l,r\text{,return a value x}) $<br>$ 1. k \leftarrow log_2(r - l + 1)$<br>$ 2. \text{return } x = min(f[l][k], f[r - (2^k - 1)][k]$<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">100000</span> + <span class="number">10</span>) * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLOG = <span class="number">17</span> + <span class="number">10</span>; <span class="comment">// floor(log2(100000 + 10))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> Table[MAXN][MAXLOG];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">            Table[i][j] = <span class="built_in">std</span>::max(Table[i][j<span class="number">-1</span>], Table[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">std</span>::<span class="built_in">log</span>(r - (l - <span class="number">1</span>)) / <span class="built_in">std</span>::<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::max(Table[l][k], Table[r - ((<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>)][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Table[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 这里可以省去seq[i]，对Table[i][0]进行直接写入</span></span><br><span class="line">    BuildTable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">洛谷P3865【模板】ST表</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;$O(1)$查询区间最值&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.handwer-std.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ST表" scheme="https://blog.handwer-std.top/tags/ST%E8%A1%A8/"/>
    
      <category term="RMQ问题" scheme="https://blog.handwer-std.top/tags/RMQ%E9%97%AE%E9%A2%98/"/>
    
      <category term="模板" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Handwer&#39;s Blog 突破100篇文章</title>
    <link href="https://blog.handwer-std.top/2019-02-14/100-articles/"/>
    <id>https://blog.handwer-std.top/2019-02-14/100-articles/</id>
    <published>2019-02-14T14:51:18.000Z</published>
    <updated>2019-02-14T15:08:45.675Z</updated>
    
    <content type="html"><![CDATA[<p>2019年2月14日22点，在键盘的敲击声中，Handwer’s Blog的第100篇博客诞生了。</p><p>第一个里程碑已经达成，下一个里程碑：200篇</p><p>2019也要加油啊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019年2月14日22点，在键盘的敲击声中，Handwer’s Blog的第100篇博客诞生了。&lt;/p&gt;
&lt;p&gt;第一个里程碑已经达成，下一个里程碑：200篇&lt;/p&gt;
&lt;p&gt;2019也要加油啊&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="博客相关" scheme="https://blog.handwer-std.top/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
      <category term="只有经历过的人才知道的世界" scheme="https://blog.handwer-std.top/tags/%E5%8F%AA%E6%9C%89%E7%BB%8F%E5%8E%86%E8%BF%87%E7%9A%84%E4%BA%BA%E6%89%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2504《[HAOI2006]聪明的猴子》</title>
    <link href="https://blog.handwer-std.top/2019-02-14/Luogu-P2504/"/>
    <id>https://blog.handwer-std.top/2019-02-14/Luogu-P2504/</id>
    <published>2019-02-14T14:40:55.000Z</published>
    <updated>2019-02-14T14:48:07.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最小生成树板子题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。</p><p>现在，在这个地区露出水面的有N棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。</p><p>在这个地区住着的猴子有M个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。</p><p>【问题】现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件monkey.in包括：</p><p>第1行为一个整数，表示猴子的个数M(2&lt;=M&lt;=500)；</p><p>第2行为M个整数，依次表示猴子的最大跳跃距离（每个整数值在1–1000之间）；</p><p>第3行为一个整数表示树的总棵数N(2&lt;=N&lt;=1000)；</p><p>第4行至第N+3行为N棵树的坐标（横纵坐标均为整数，范围为：-1000–1000）。</p><p>（同一行的整数间用空格分开）</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件monkey.out包括一个整数，表示可以在这个地区的所有树冠上觅食的猴子数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">-2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模】</p><p>对于40%的数据，保证有2&lt;=N &lt;=100，1&lt;=M&lt;=100</p><p>对于全部的数据，保证有2&lt;=N &lt;= 1000，1&lt;=M=500</p><p>感谢@charlie003 修正数据</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先构造完全图（边数为初二数学内容），再跑一遍最小生成树</p><p>之后枚举每一个猴子，判断它的跳跃距离是否大于等于生成树的最大边权即可</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>                  + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">500</span>                   + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXE = (MAXN - <span class="number">1</span>) * MAXN / <span class="number">2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    Node() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> previd, nextid;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    </span><br><span class="line">    Edge() &#123; previd = nextid = <span class="number">0</span>; weight = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; that.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edge[MAXE];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">    </span><br><span class="line">    UnionFind() &#123; <span class="built_in">memset</span>(seq, <span class="number">0</span>, <span class="keyword">sizeof</span> seq); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> !seq[x] ? x : (seq[x] = Find(seq[x])); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = Find(x); y = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        seq[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; U;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetDist</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> idy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> absx = <span class="built_in">std</span>::<span class="built_in">abs</span>(node[idx].x - node[idy].x);</span><br><span class="line">    <span class="keyword">int</span> absy = <span class="built_in">std</span>::<span class="built_in">abs</span>(node[idx].y - node[idy].y);</span><br><span class="line">    ret = <span class="built_in">sqrt</span>(absx * absx + absy * absy);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> monkey[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> maxWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (U.Union(edge[i].previd, edge[i].nextid)) &#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            maxWeight = <span class="built_in">std</span>::max(maxWeight, edge[i].weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tot == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">cin</span> &gt;&gt; monkey[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">    <span class="comment">// initialize edges</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            edge[++cnt].previd = i;</span><br><span class="line">            edge[cnt].nextid = j;</span><br><span class="line">            edge[cnt].weight = GetDist(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> maxW = Kruskal();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (monkey[i] &gt;= maxW) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最小生成树板子题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="生成树" scheme="https://blog.handwer-std.top/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="最小生成树" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3243《[HNOI2015]菜肴制作》</title>
    <link href="https://blog.handwer-std.top/2019-02-14/Luogu-P3243/"/>
    <id>https://blog.handwer-std.top/2019-02-14/Luogu-P3243/</id>
    <published>2019-02-14T14:30:59.000Z</published>
    <updated>2019-02-14T14:40:23.558Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>反向建图 + 反向输出</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>知名美食家小 A被邀请至ATM 大酒店，为其品评菜肴。 ATM 酒店为小 A 准备了 N 道菜肴，酒店按照为菜肴预估的质量从高到低给予1到N的顺序编号，预估质量最高的菜肴编号为1。</p><p>由于菜肴之间口味搭配的问题，某些菜肴必须在另一些菜肴之前制作，具体的，一共有 M 条形如”i 号菜肴’必须’先于 j 号菜肴制作“的限制，我们将这样的限制简写为&lt;i,j&gt;。</p><p>现在，酒店希望能求出一个最优的菜肴的制作顺序，使得小 A能尽量先吃到质量高的菜肴：</p><p>也就是说，</p><p>(1)在满足所有限制的前提下，1 号菜肴”尽量“优先制作；</p><p>(2)在满足所有限制，1号菜肴”尽量“优先制作的前提下，2号菜肴”尽量“优先制作；</p><p>(3)在满足所有限制，1号和2号菜肴”尽量“优先的前提下，3号菜肴”尽量“优先制作</p><p>；(4)在满足所有限制，1 号和 2 号和 3 号菜肴”尽量“优先的前提下，4 号菜肴”尽量“优先制作；</p><p>(5)以此类推。</p><p>例1：共4 道菜肴，两条限制&lt;3,1&gt;、&lt;4,1&gt;，那么制作顺序是 3,4,1,2。</p><p>例2：共5道菜肴，两条限制&lt;5,2&gt;、 &lt;4,3&gt;，那么制作顺序是 1,5,2,4,3。</p><p>例1里，首先考虑 1，因为有限制&lt;3,1&gt;和&lt;4,1&gt;，所以只有制作完 3 和 4 后才能制作 1，而根据(3)，3 号又应”尽量“比 4 号优先，所以当前可确定前三道菜的制作顺序是 3,4,1；接下来考虑2，确定最终的制作顺序是 3,4,1,2。</p><p>例 2里，首先制作 1是不违背限制的；接下来考虑 2 时有&lt;5,2&gt;的限制，所以接下来先制作 5 再制作 2；接下来考虑 3 时有&lt;4,3&gt;的限制，所以接下来先制作 4再制作 3，从而最终的顺序是 1,5,2,4,3。 现在你需要求出这个最优的菜肴制作顺序。无解输出”Impossible!“ （不含引号，首字母大写，其余字母小写）</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个正整数D，表示数据组数。 接下来是D组数据。 对于每组数据： 第一行两个用空格分开的正整数N和M，分别表示菜肴数目和制作顺序限制的条目数。 接下来M行，每行两个正整数x,y，表示”x号菜肴必须先于y号菜肴制作“的限制。（注意：M条限制中可能存在完全相同的限制）</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件仅包含 D 行，每行 N 个整数，表示最优的菜肴制作顺序，或者“Impossible!“表示无解（不含引号）。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> </span><br><span class="line">Impossible! </span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【样例解释】</p><p>第二组数据同时要求菜肴1先于菜肴2制作，菜肴2先于菜肴3制作，菜肴3先于</p><p>菜肴1制作，而这是无论如何也不可能满足的，从而导致无解。</p><p>100%的数据满足N,M&lt;=100000,D&lt;=3。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目要求「“尽量”优先」<br>那么跑字典序最小拓扑肯定是不行的</p><p>那么……<br>考虑反向建图。<br>反向建图跑字典序最大拓扑，这时的拓扑序是「一直选择大的，不行再选择小的」，那么反向输出即可</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXNM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rtop;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rhead[MAXNM];</span><br><span class="line"><span class="keyword">int</span> id[MAXNM], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!id[i]) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        rtop.push(u);</span><br><span class="line">        <span class="keyword">int</span> siz = (<span class="keyword">int</span>) rhead[u].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = rhead[u][i];</span><br><span class="line">            --id[v];</span><br><span class="line">            <span class="keyword">if</span> (id[v]) <span class="keyword">continue</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(id, <span class="number">0</span>, <span class="keyword">sizeof</span> id);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, next = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; next &gt;&gt; prev; <span class="comment">// reverse</span></span><br><span class="line">        rhead[prev].push_back(next);</span><br><span class="line">        ++id[next];</span><br><span class="line">    &#125;</span><br><span class="line">    Topsort();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        rhead[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rtop.size() &lt; n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span> (!rtop.empty()) rtop.pop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!rtop.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rtop.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        rtop.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;反向建图 + 反向输出&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="拓扑序" scheme="https://blog.handwer-std.top/tags/%E6%8B%93%E6%89%91%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P4047《[JSOI2010]部落划分》</title>
    <link href="https://blog.handwer-std.top/2019-02-14/Luogu-P4047/"/>
    <id>https://blog.handwer-std.top/2019-02-14/Luogu-P4047/</id>
    <published>2019-02-14T14:00:22.000Z</published>
    <updated>2019-02-14T14:27:28.895Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最小生成树后删边</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。</p><p>不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了N个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了K个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：</p><p>对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。</p><p>例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件第一行包含两个整数N和K(1&lt;=N&lt;=1000,1&lt;K&lt;=N)，分别代表了野人居住点的数量和部落的数量。</p><p>接下来N行，每行包含两个正整数x,y，描述了一个居住点的坐标(0&lt;=x, y&lt;=10000)。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，为最优划分时，最近的两个部落的距离，精确到小数点后两位。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1<span class="selector-class">.00</span></span><br></pre></td></tr></table></figure><h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">9 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">6</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">6</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2<span class="selector-class">.00</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们首先对这几个点构建一个完全图</p><p>边数的计算属于初中数学内容（$\frac{n(n-1)}{2}$）</p><p>然后对这个图跑一遍最小生成树</p><p>删去生成树中最大的 $k-1$ 条边，这时候整个图就变成了 $k$ 个联通块，即为题目要求的部落</p><p>输出删去边的最小边权即可</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = (MAXN * (MAXN - <span class="number">1</span>)) / <span class="number">2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    Node() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prev;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    </span><br><span class="line">    Edge() &#123; prev = next = <span class="number">0</span>; weight = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; that.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">    </span><br><span class="line">    UnionFind() &#123; <span class="built_in">memset</span>(seq, <span class="number">0</span>, <span class="keyword">sizeof</span> seq); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> !seq[x] ? x : (seq[x] = Find(seq[x])); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = Find(x); y = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        seq[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; U;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetPath</span><span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="built_in">std</span>::<span class="built_in">abs</span>(x.x - y.x);</span><br><span class="line">    <span class="keyword">int</span> Y = <span class="built_in">std</span>::<span class="built_in">abs</span>(x.y - y.y);</span><br><span class="line">    ret = <span class="built_in">sqrt</span>(X * X + Y * Y);</span><br><span class="line">    <span class="comment">// 勾股定理，初中数学</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> routput = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tot == n - k) routput = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 这里用了一个小技巧，加到 (n - k + 1) 条边的时候就可以输出，</span></span><br><span class="line">        <span class="comment">// 而不用到最后删边，因为边权是经过排序的</span></span><br><span class="line">        <span class="keyword">if</span> (U.Union(edge[i].prev, edge[i].next)) &#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            <span class="keyword">if</span> (routput) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">2</span>) &lt;&lt; edge[i].weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造完全图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            edge[++cnt].prev = i;</span><br><span class="line">            edge[cnt].next = j;</span><br><span class="line">            edge[cnt].weight = GetPath(node[i], node[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最小生成树后删边&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最小生成树" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1108《低价购买》</title>
    <link href="https://blog.handwer-std.top/2019-02-14/Luogu-P1108/"/>
    <id>https://blog.handwer-std.top/2019-02-14/Luogu-P1108/</id>
    <published>2019-02-14T12:35:07.000Z</published>
    <updated>2019-02-14T13:31:54.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最长下降子序列套一个玄学计数</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价($2^{16}$范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。</p><p>这里是某支股票的价格清单：</p><p>日期 1,2,3,4,5,6,7,8,9,10,11,12<br>价格 68,69,54,64,68,64,70,67,78,62,98,87<br>最优秀的投资者可以购买最多44次股票，可行方案中的一种是：</p><p>日期 2,5,6,10<br>价格 69,68,64,62</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1行: N(1≤N≤5000)，股票发行天数</p><p>第2行: N个数，是每天的股票价格。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>两个数:<br>最大购买次数和拥有最大购买次数的方案数( $\le 2^{31}$ )当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这22种方案被认为是相同的。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">68</span> <span class="number">69</span> <span class="number">54</span> <span class="number">64</span> <span class="number">68</span> <span class="number">64</span> <span class="number">70</span> <span class="number">67</span> <span class="number">78</span> <span class="number">62</span> <span class="number">98</span> <span class="number">87</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先第一问肯定谁都会求<br>跑一遍最长下降子序列算完</p><p>关键是第二问</p><hr><p>令 $ dp[i] $ 表示以 $i$ 结尾的最长下降子序列的长度，$cdp[i]$ 表示以 $i$ 结尾的最长下降子序列的个数<br>规定 $s[\ ]$ 为「原序列」</p><p>那么就有</p><ul><li>当 $dp[i] = dp[j]$ 且 $s[i] = s[j]$ 时，就直接把 $cdp[j]$ 记为 $0$，防止重复计数</li><li>当 $dp[i] = dp[j] + 1$ 且 $s[i] &lt; s[j]$ 时，说明数列能接上了，$cdp[i] = cdp[i] + cdp[j]$</li></ul><p>最后答案输出 </p><p>$$ \sum_{i = 1}^{n} cdp[i] \ (dp[i] = \text{The max value of array } dp[i] ) $$ </p><p>即可</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[MAXN], dp[MAXN], cdp[MAXN], maxLen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[j]) dp[i] = <span class="built_in">std</span>::max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == <span class="number">0</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">        maxLen = <span class="built_in">std</span>::max(maxLen, dp[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[j] &amp;&amp; a[i] == a[j]) cdp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == dp[j] + <span class="number">1</span> &amp;&amp; a[i] &lt; a[j]) cdp[i] += cdp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cdp[i] == <span class="number">0</span>) cdp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == maxLen) ans += cdp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxLen &lt;&lt; <span class="string">' '</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最长下降子序列套一个玄学计数&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="「序列」DP" scheme="https://blog.handwer-std.top/tags/%E3%80%8C%E5%BA%8F%E5%88%97%E3%80%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1896《[SCOI2005]互不侵犯》</title>
    <link href="https://blog.handwer-std.top/2019-02-14/Luogu-P1896/"/>
    <id>https://blog.handwer-std.top/2019-02-14/Luogu-P1896/</id>
    <published>2019-02-14T11:45:17.000Z</published>
    <updated>2019-02-14T12:25:56.529Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ProjectDP - 27</p></blockquote><blockquote><p>最基础的状压DP</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。</p><p>注：数据有加强（2018/4/25）</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N）</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>所得的方案数</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑状压DP</p><p>我们设 $ dp[i][j][k] $ 表示第 $i$ 行的状态的编号为 $j$，放了 $k$ 个国王</p><p>转移方程显然<br>$$ dp[i][j][pct(stat[j]) + l] = dp[i][j][pct(stat[j]) + l] +  dp[i-1][k][l]$$<br>其中 $pct(x)$ 表示 $x$ 的二进制1的个数</p><p>边界条件：<br>$$ dp[1][nowStat][pct(nowStat)] = 1 $$<br>其中 $nowStat$ 表示当前枚举到的<strong>合法的</strong>状态</p><p>剩下的……就没啥好说的了（</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPIO() std::ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__file) freopen(__file, <span class="meta-string">'r'</span>, stdin);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__file) freopen(__file, <span class="meta-string">'w'</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">9</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> stats[(<span class="number">1</span> &lt;&lt; MAXN) - <span class="number">1</span> + <span class="number">10</span>], popc[(<span class="number">1</span> &lt;&lt; MAXN) - <span class="number">1</span> + <span class="number">10</span>], cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dp[MAXN][(<span class="number">1</span> &lt;&lt; MAXN) - <span class="number">1</span> + <span class="number">10</span>][MAXK];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[i][stat][k]: line i, status stat, k kings</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Popcount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x) &#123;</span><br><span class="line"><span class="keyword">if</span> (x &amp; <span class="number">1</span>) ++ret;</span><br><span class="line">x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckFailed</span><span class="params">(<span class="keyword">int</span> stat1, <span class="keyword">int</span> stat2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((stat1 &amp; stat2) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> ((stat1 &amp; (stat2 &lt;&lt; <span class="number">1</span>)) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (((stat1 &lt;&lt; <span class="number">1</span>) &amp; stat2) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">IMPIO();</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> ((i &amp; (i &lt;&lt; <span class="number">1</span>)) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">stats[++cnt] = i;</span><br><span class="line">dp[<span class="number">1</span>][cnt][Popcount(i)] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> idj = <span class="number">1</span>; idj &lt;= cnt; ++idj) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> idk = <span class="number">1</span>; idk &lt;= cnt; ++idk) &#123;</span><br><span class="line"><span class="keyword">if</span> (CheckFailed(stats[idj], stats[idk])) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k; ++l) &#123;</span><br><span class="line">   dp[i][idj][Popcount(stats[idj]) + l]</span><br><span class="line">+= dp[i - <span class="number">1</span>][idk][l];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">ans += dp[n][i][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ProjectDP - 27&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最基础的状压DP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ProjectDP" scheme="https://blog.handwer-std.top/tags/ProjectDP/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="状压DP" scheme="https://blog.handwer-std.top/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>关于新开的「Handwer&#39;s Problems」</title>
    <link href="https://blog.handwer-std.top/2019-02-13/MathProblems-NewSite/"/>
    <id>https://blog.handwer-std.top/2019-02-13/MathProblems-NewSite/</id>
    <published>2019-02-13T06:12:30.000Z</published>
    <updated>2019-02-13T12:39:58.724Z</updated>
    
    <content type="html"><![CDATA[<p>「Handwer’s Problems」主要转载一些经过挑选的文化课题目。</p><p>每一道题都会在不久之后更新题解，同时会更新下一道题。</p><p>现在主要上数学题，预计不久之后会更新物理以及英语题目。</p><p>面向任何人开放，如无特殊情况（包括但不限于考试）不会设置密码。</p><p>链接：<a href="https://problem.handwer-std.top" target="_blank" rel="noopener">Handwer’s Problems</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;「Handwer’s Problems」主要转载一些经过挑选的文化课题目。&lt;/p&gt;
&lt;p&gt;每一道题都会在不久之后更新题解，同时会更新下一道题。&lt;/p&gt;
&lt;p&gt;现在主要上数学题，预计不久之后会更新物理以及英语题目。&lt;/p&gt;
&lt;p&gt;面向任何人开放，如无特殊情况（包括但不限于考试
      
    
    </summary>
    
    
      <category term="文化课" scheme="https://blog.handwer-std.top/tags/%E6%96%87%E5%8C%96%E8%AF%BE/"/>
    
      <category term="简介" scheme="https://blog.handwer-std.top/tags/%E7%AE%80%E4%BB%8B/"/>
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2704《[NOI2001]炮兵阵地》</title>
    <link href="https://blog.handwer-std.top/2019-02-04/Luogu-P2704/"/>
    <id>https://blog.handwer-std.top/2019-02-04/Luogu-P2704/</id>
    <published>2019-02-04T01:05:43.000Z</published>
    <updated>2019-02-13T12:43:16.368Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ProjectDP - 29</p></blockquote><blockquote><p>需要维护两行状态的状压DP</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>司令部的将军们打算在N*M的网格地图上部署他们的炮兵部队。一个N*M的地图由N行M列组成，地图的每一格可能是山地（用“H” 表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p><p><img src="https://cdn.luogu.org/upload/pic/1881.png" alt="description1"></p><p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个由空格分割开的正整数，分别表示N和M；</p><p>接下来的N行，每一行含有连续的M个字符（‘P’或者‘H’），中间没有空格。按顺序表示地图中每一行的数据。N≤100；M≤10。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line">PHPP</span><br><span class="line">PPHH</span><br><span class="line">PPPP</span><br><span class="line">PHPP</span><br><span class="line">PHHP</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>看到这个玄学的数据范围，第一反应就是状压DP</p><p>我们设 $ dp[i][j][k] $ 表示当前正在摆放第 $i$ 行，当前行的状态<strong>编号</strong>为 $j$，上一行的状态编号为 $k$ 时的最大数量</p><p>我们先把所有的可能状态预处理出来，记为 <code>stats[]</code></p><p>初始状态时所有的<code>dp[1][i][1] = Popcount(stats[i])</code>，其中 <code>Popcount(x)</code>表示<code>x</code>的二进制1的个数</p><p>转移方程显然，<br>$ dp[i][j][k] = max(dp[i][j][k], dp[i-1][k][l] + $ <code>Popcount(stats[j])</code> $ ) $，<br>其中 $j$ 表示当前行的状态编号，$k$ 表示上一行的，$l$ 表示再上一行的</p><p>注意判一下地形是否符合，方法参见<a href="/2019-01-29/Luogu-P1879/">洛谷P1879</a></p><hr><p>我要开<big><big>滚动数组</big></big></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  29.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/1/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) - <span class="number">1</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> status[MAX], dp[<span class="number">2</span>][MAX][MAX], can[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt, n, m;</span><br><span class="line"><span class="keyword">char</span> str[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ret++;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &amp; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Check3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Check(a,b) || Check(a,c) || Check(b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(str[j] == <span class="string">'H'</span>)can[i] = (can[i] &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> can[i] = can[i] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>((!(i &amp; (i &lt;&lt; <span class="number">2</span>))) &amp;&amp; (!(i &amp; (i &lt;&lt; <span class="number">1</span>))))</span><br><span class="line">            status[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        dp[<span class="number">1</span> % <span class="number">2</span>][i][<span class="number">1</span>] = pop(status[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(status[j] &amp; can[i])) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((!(status[k] &amp; can[i - <span class="number">1</span>])) &amp;&amp; (!Check(status[j],status[k]))) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= cnt; ++l)&#123;</span><br><span class="line">                            <span class="keyword">if</span> ((!(status[l] &amp; can[i - <span class="number">2</span>])) &amp;&amp; (!Check3(status[j], status[k], status[l])))</span><br><span class="line">                                dp[i % <span class="number">2</span>][j][k] = <span class="built_in">std</span>::max(dp[i % <span class="number">2</span>][j][k], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][k][l] + pop(status[j]));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j)</span><br><span class="line">            ans = <span class="built_in">std</span>::max(ans, dp[n % <span class="number">2</span>][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ProjectDP - 29&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;需要维护两行状态的状压DP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ProjectDP" scheme="https://blog.handwer-std.top/tags/ProjectDP/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="状压DP" scheme="https://blog.handwer-std.top/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="NOI" scheme="https://blog.handwer-std.top/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3183《[HAOI2016]食物链》</title>
    <link href="https://blog.handwer-std.top/2019-02-04/Luogu-P3183/"/>
    <id>https://blog.handwer-std.top/2019-02-04/Luogu-P3183/</id>
    <published>2019-02-04T01:05:31.000Z</published>
    <updated>2019-02-13T11:46:36.399Z</updated>
    
    <content type="html"><![CDATA[<center> 本题与<a href="https://www.luogu.org/problemnew/show/P4017" target="_blank" rel="noopener">洛谷P4017</a> 重复 </center><center>代码通用</center><center>题解<a href="/2019-02-04/Luogu-P4017/">传送门</a></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt; 本题与&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4017&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P4017&lt;/a&gt; 重复 &lt;/center&gt;

&lt;center&gt;代码通用&lt;/cen
      
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="拓扑序" scheme="https://blog.handwer-std.top/tags/%E6%8B%93%E6%89%91%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P4017《最大食物链计数》</title>
    <link href="https://blog.handwer-std.top/2019-02-04/Luogu-P4017/"/>
    <id>https://blog.handwer-std.top/2019-02-04/Luogu-P4017/</id>
    <published>2019-02-04T01:05:23.000Z</published>
    <updated>2019-02-12T14:07:15.360Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>七年级上册生物题目</p></blockquote><a id="more"></a><h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>你知道食物链吗？Delia生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个食物网，你要求出这个食物网中最大食物链的数量。</p><p>（这里的“最大食物链”，指的是生物学意义上的食物链，即最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者。）</p><p>Delia非常急，所以你只有1秒的时间。</p><p>由于这个结果可能过大，你只需要输出总数模上80112002的结果。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个正整数n、m，表示生物种类n和吃与被吃的关系数m。</p><p>接下来m行，每行两个正整数，表示被吃的生物A和吃A的生物B。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，为最大食物链数量模上80112002的结果。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">7</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>各测试点满足以下约定：</p><p><img src="https://cdn.luogu.org/upload/pic/12011.png" alt="图源洛谷"></p><p>【补充说明】</p><p>数据中不会出现环，满足生物学的要求。（感谢@AKEE ）</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>有向无环？拓扑序啊！<br>仔细想一下发现思路可能是对的</p><hr><p>正向建一个图，反向建一个图</p><p>先把正向图的拓扑序跑出来，放到一个<code>vector&lt;int&gt;</code>里<br>再按照拓扑序来枚举点，这样就保证了枚举的顺序</p><p>我们设 <code>dp[node]</code> 表示以编号 <code>node</code> 为结尾的食物链个数<br>那么对于节点 <code>Node</code>，</p><ul><li>如果它没有出边，那么<code>dp[node] = 1</code></li><li>如果它有出边，那么枚举每一条出边的邻接点<code>nv</code>，<code>dp[node] += dp[nv]</code></li></ul><p>最后答案是$\sum$<code>dp[所有没有出边的点]</code></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(__x) <span class="meta-keyword">if</span> (__x &gt;= HA) __x -= HA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(__Args,...) printf(__Args,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">80112002</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reallink[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[MAXN]; <span class="comment">// id -&gt; in degree</span></span><br><span class="line"><span class="keyword">int</span> n, m, ans; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN]; </span><br><span class="line"><span class="comment">// dp[i][j] -&gt; the amount of links that the end-node = i</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!id[i]) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">            top.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> amt = head[u].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; amt; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">            --id[v];</span><br><span class="line">            <span class="keyword">if</span> (!id[v]) &#123;</span><br><span class="line">                top.push_back(v);</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> A = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    head[A].push_back(B);</span><br><span class="line">    reallink[B].push_back(A);</span><br><span class="line">    ++id[B];</span><br><span class="line">    &#125;</span><br><span class="line">    Topsort();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// enumerate Topsorted-Nodes</span></span><br><span class="line">        <span class="keyword">int</span> nnode = top[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (reallink[nnode].size() == <span class="number">0</span>) dp[nnode] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// no out-edges connected</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; reallink[nnode].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> nenode = reallink[nnode][j];</span><br><span class="line">            dp[nnode] += dp[nenode];</span><br><span class="line">            ADD(dp[nnode]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!head[nnode].size()) ans += dp[nnode];</span><br><span class="line">        ADD(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;七年级上册生物题目&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="拓扑排序" scheme="https://blog.handwer-std.top/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3060《Tour de Byteotia》</title>
    <link href="https://blog.handwer-std.top/2019-02-04/BZOJ3060/"/>
    <id>https://blog.handwer-std.top/2019-02-04/BZOJ3060/</id>
    <published>2019-02-04T01:04:48.000Z</published>
    <updated>2019-02-12T13:04:09.045Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>并查集板子题（雾</p></blockquote><a id="more"></a><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>权限题，题面请自行寻找<br><del>用小刀刮开涂层来获取题目地址</del><br><span style="background-color:black">访问 DarkBZOJ 来获取题面</span></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>用并查集维护一下连通性</p><p>下文我们称「编号小于等于k的点」为「奇特点」</p><hr><p>显然和奇特点没有关系的边删不删都无所谓，不影响答案，所以我们可以放心地把这些边加入并查集。</p><p>然后我们枚举所有的与奇特点相连的边，尝试将这条边加入并查集。<br>如果这条边的两个点不连通，就可以放心地将这条边加入并查集，否则<code>++ans</code></p><p>最后输出<code>ans</code>即可</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">    </span><br><span class="line">    UnionFind() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(seq, <span class="number">0</span>, <span class="keyword">sizeof</span> seq);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (seq[x] == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> seq[x] = Find(seq[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = Find(x);</span><br><span class="line">        y = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        seq[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; U;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> f, t;</span><br><span class="line">    <span class="comment">// from to</span></span><br><span class="line">    </span><br><span class="line">    Edge() &#123; f = t = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; edge[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[++cnt].f = u;</span><br><span class="line">    edge[cnt].t = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, next = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; prev &gt;&gt; next;</span><br><span class="line">        addEdge(prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">1</span>; e &lt;= m; ++e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(edge[e].f &lt;= k || edge[e].t &lt;= k)) &#123;</span><br><span class="line">            U.Union(edge[e].f, edge[e].t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">1</span>; e &lt;= m; ++e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[e].f &lt;= k || edge[e].t &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!U.Union(edge[e].f, edge[e].t)) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;并查集板子题（雾&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="并查集" scheme="https://blog.handwer-std.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2619《[国家集训队2]Tree I》</title>
    <link href="https://blog.handwer-std.top/2019-02-04/Luogu-P2619/"/>
    <id>https://blog.handwer-std.top/2019-02-04/Luogu-P2619/</id>
    <published>2019-02-04T01:04:17.000Z</published>
    <updated>2019-02-08T10:18:17.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><del>年轻人的第一道国家集训队</del><br>二分答案 + 最小生成树</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有need条白色边的生成树。</p><p>题目保证有解。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行V,E,need分别表示点数，边数和需要的白色边数。</p><p>接下来E行</p><p>每行s,t,c,col表示这边的端点(点从0开始标号)，边权，颜色(0白色1黑色)。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行表示所求生成树的边权和。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>0:V&lt;=10</p><p>1,2,3:V&lt;=15</p><p>0,..,19:V&lt;=50000,E&lt;=100000</p><p>所有数据边权为[1,100]中的正整数。</p><p>By WJMZBMR</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p><del>年轻人的第一道国家集训队题目</del></p><hr><p>如果我们不做任何处理，直接跑MST（Minimum Spanning Tree，最小生成树），结果会有三种：</p><ul><li><p>正好跑出 $\text{Need}$ 条白边</p></li><li><p>白边多了</p></li><li><p>白边少了</p></li></ul><p>第一种情况自然是最好的</p><p>剩下两种情况如何解决？</p><hr><p>引起白边少的原因：黑边的边权相对较小，程序贪心地选择了更多的黑边</p><p>引起白边多的原因：白边的边权相对较小，程序贪心地选择了更多的白边</p><p>那么如果我们给白边相应地减去/加上一些边权，不就可以达成目标了？</p><hr><p>考虑二分答案。</p><p>我们二分一个 $add$ 表示我们当前要给白边加上 $add$ 来达成目标</p><p>边界分别是边权最小值（-100）和边权最大值（100）</p><p>由于题面保证有答案，所以直接输出 $ ans - add \times \text{Need} $<br> 即可，其中 $ans$ 为（加上边权后）最小生成树的权值和</p><p><code>Check(mid)</code> 怎么写？</p><hr><p>我们将所有白边的边权加上$add$（即$mid$），跑一遍最小生成树，判断一下拿到的白色边数量是否大于等于要求的数量，如果是就更新一下左边界并记当前的$mid$为$tans$，否则就更新一下右边界</p><p>注意不要忘了把边权减回来</p><p>（不要在意 $tans$ 是什么意思）</p><hr><p>刚才我们不是记录了一下$tans$吗，这个$tans$就相当于是一个正确的、能选出正好 $\text{Need}$ 条白边的 $add$ 值，再将所有白边的边权都加上这个 $tans$，跑一遍最小生成树即可</p><p>答案不要忘了减去加上的边权（也就是 $ \text{Need} \times tans $）</p><p>那么最后的答案就是 $ \text{Kruskal()} - \text{Need} \times tans $</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXE = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXW = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prev, next, weight, add;</span><br><span class="line">    <span class="keyword">bool</span> color;</span><br><span class="line">    <span class="comment">// 1 -&gt; black, 0 -&gt; white</span></span><br><span class="line">    </span><br><span class="line">    Edge() &#123; prev = next = weight = color = add = <span class="number">0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weight == that.weight) <span class="keyword">return</span> color &lt; that.color;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; that.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edge[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V, E, Need, cnt, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXV &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> U[x];</span><br><span class="line">    <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = Find(x), y = Find(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    U[x] = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> whiteEdge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= V; ++i) U[i] = i;</span><br><span class="line">    <span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + E);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Union(edge[i].prev, edge[i].next)) </span><br><span class="line">            ans += edge[i].weight, ++tot, whiteEdge += (edge[i].color == WHITE);</span><br><span class="line">        <span class="keyword">if</span> (tot == V - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> whiteEdge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].color == WHITE) edge[i].weight += add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> Ans = (Kruskal() &gt;= Need);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].color == WHITE) edge[i].weight -= add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; E &gt;&gt; Need;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; ++i) &#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; edge[i].prev &gt;&gt; edge[i].next &gt;&gt; edge[i].weight &gt;&gt; edge[i].color;</span><br><span class="line">    ++edge[i].prev;</span><br><span class="line">        ++edge[i].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = -MAXW, r = MAXW;</span><br><span class="line">    <span class="keyword">int</span> Run = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((l + r) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (Check(mid)) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            Run = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Check(Run);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans - Need * Run &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;del&gt;年轻人的第一道国家集训队&lt;/del&gt;&lt;br&gt;二分答案 + 最小生成树&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="生成树" scheme="https://blog.handwer-std.top/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="二分答案" scheme="https://blog.handwer-std.top/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="国家集训队" scheme="https://blog.handwer-std.top/tags/%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1621《集合》</title>
    <link href="https://blog.handwer-std.top/2019-02-04/Luogu-P1621/"/>
    <id>https://blog.handwer-std.top/2019-02-04/Luogu-P1621/</id>
    <published>2019-02-04T01:04:11.000Z</published>
    <updated>2019-02-05T13:48:25.099Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>素数筛 + 并查集</p></blockquote><a id="more"></a><h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>John的农场缺水了！！！</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Farmer John has decided to bring water to his N (1 &lt;= N &lt;= 300) pastures which are conveniently numbered 1..N. He may bring water to a pasture either by building a well in that pasture or connecting the pasture via a pipe to another pasture which already has water.</p><p>Digging a well in pasture i costs W_i (1 &lt;= W_i &lt;= 100,000).</p><p>Connecting pastures i and j with a pipe costs P_ij (1 &lt;= P_ij &lt;= 100,000; P_ij = P_ji; P_ii=0).</p><p>Determine the minimum amount Farmer John will have to pay to water all of his pastures.</p><p>POINTS: 400</p><p>农民John 决定将水引入到他的n(1&lt;=n&lt;=300)个牧场。他准备通过挖若</p><p>干井，并在各块田中修筑水道来连通各块田地以供水。在第i 号田中挖一口井需要花费W_i(1&lt;=W_i&lt;=100,000)元。连接i 号田与j 号田需要P_ij (1 &lt;= P_ij &lt;= 100,000 , P_ji=P_ij)元。</p><p>请求出农民John 需要为使所有农场都与有水的农场相连或拥有水井所需要的钱数。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1 行为一个整数n。</p><p>第2 到n+1 行每行一个整数，从上到下分别为W_1 到W_n。</p><p>第n+2 到2n+1 行为一个矩阵，表示需要的经费（P_ij）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一行，为一个整数，表示所需要的钱数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">4</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>John等着用水，你只有1s时间！！！</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目中“质数”两个字很是显眼啊</p><p>还等啥啊</p><big><big><big><strong>筛啊</strong></big></big></big><p>素数筛很好写吧</p><hr><p>筛完了，然后呢？</p><p>题目让我们找两个公共质因数 $ \geq P $ 的，不在一个集合里的数，并合并它们。我们不这样找</p><hr><p>枚举每一个质数<code>primes[i]</code>，计算出<code>第一个</code> <code>大于A</code>的<code>primes[i]的倍数</code>（题目要求的）记为$t$，然后从$t+\text{primes[i]}$一直枚举到$B$（每次增长一个$\text{primes[i]}$，毕竟要求必须有$\text{primes[i]}$这个数作为质因数），每次用并查集合并$t$和当前枚举到的这个数</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXB = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A, B, P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[MAXB], cnt, ans;</span><br><span class="line"><span class="keyword">bool</span> npm[MAXB]; <span class="comment">// n(ot a )p(ri)m(e) -&gt; not a prime</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXB];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = Find(x), y = Find(y);</span><br><span class="line"><span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">--ans; <span class="comment">// 两个集合变成了一个，答案减一</span></span><br><span class="line">U[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; ++i) U[i] = i; <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="comment">// 筛一波素数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= B; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!npm[i]) primes[++cnt] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; primes[j] * i &lt;= B; ++j) &#123;</span><br><span class="line">    npm[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = B - A + <span class="number">1</span>; <span class="comment">// r - l + 1</span></span><br><span class="line">    <span class="comment">// 原来的答案总数是（右边界 - 左边界 + 1）</span></span><br><span class="line">    <span class="comment">//（即 B - A + 1），每次合并集合的时候两个集合变成了一个，--ans</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (primes[i] &lt; P) <span class="keyword">continue</span>; <span class="comment">// 质因数要求大于等于P</span></span><br><span class="line"><span class="keyword">int</span> np = (A + primes[i] - <span class="number">1</span>) / primes[i] * primes[i];</span><br><span class="line"><span class="comment">// np -&gt; The smallest multiple of primes[i] larger than A</span></span><br><span class="line">        <span class="comment">// np -&gt; 最小的 比A大的 primes[i]的倍数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = np + primes[i]; j &lt;= B; j += primes[i]) &#123;</span><br><span class="line">Union(np, j); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;素数筛 + 并查集&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="并查集" scheme="https://blog.handwer-std.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1879《[USACO06NOV]玉米田Corn Fields》</title>
    <link href="https://blog.handwer-std.top/2019-01-29/Luogu-P1879/"/>
    <id>https://blog.handwer-std.top/2019-01-29/Luogu-P1879/</id>
    <published>2019-01-29T09:56:11.000Z</published>
    <updated>2019-02-04T10:20:10.509Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ProjectDP - 28</p></blockquote><blockquote><p>状压DP入门题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant.</p><p>Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant.</p><p>农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。</p><p>遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。</p><p>John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：两个整数M和N，用空格隔开。</p><p>第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即牧场分配总方案数除以100,000,000的余数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一道状压DP入门题</p><p>首先我们发现对于每一行，有 N 个状态<br>那么就意味着这是一个N + 1维DP……</p><p>但是我们发现从第二维到第N维都只需要0（不种玉米）和1（种玉米）两个值<br>那么……二进制！<br>比如 1010 就表示第1、3个格种玉米，第2、4个格不种玉米</p><hr><p>设 $ f[i][\text{status}] $ 表示第 $i$ 行种玉米的状态是 $\text{status}$<br>转移方程很显然吧</p><p>$$ f[i][\text{status}] = f[i][\text{status}] + f[i - 1][<br>\text{pre_status}] $$</p><p>如何判断 $ \text{status} $ 和 $ \text{pre_status} $ 是不是互相合法？</p><hr><p>我们先来看看如何判断两行互相合法。</p><p>「合法」指两行种玉米的地方不相邻，也就是两个1不相邻。<br>我们来想想位运算 $and$ 的性质</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运算法则：</span><br><span class="line"><span class="number">1</span> &amp; <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">0</span> &amp; <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">and (aka &amp;) 是按位运算的</span><br><span class="line">例如：</span><br><span class="line">  <span class="number">10101101</span>   <span class="number">10100100</span></span><br><span class="line">&amp; <span class="number">10110100</span> &amp; <span class="number">01010001</span></span><br><span class="line">---------- ----------</span><br><span class="line">  <span class="number">10100100</span>   <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>我们发现，第二个例子放在题目中是合法的，它们进行 $and$ 运算的值为 $0$<br>那么方法不就出来了吗！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> stat1, <span class="keyword">int</span> stat2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (stat1 &amp; stat2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单行的状态也可能不合法，<del>如何对敌</del>怎么解决？</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stat1 = 01001101 就是一个不合法的状态</span><br><span class="line">我们把 stat1 左移一位（ stat1 = stat1 &lt;&lt; 1 ）</span><br><span class="line">得到了 stat2 = 10011010</span><br><span class="line"></span><br><span class="line">我们把他们 and 一下</span><br><span class="line"></span><br><span class="line"><span class="code">  01001101</span></span><br><span class="line">&amp; 10011010</span><br><span class="line">----------</span><br><span class="line"><span class="code">  00001000 &gt; 0</span></span><br></pre></td></tr></table></figure><p>那么方法就出来了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckSingleLine</span><span class="params">(<span class="keyword">int</span> stat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Check(stat, stat &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后处理一下土地的状态</p><p>我们将一行土地的利用情况记为二进制<br>0表示荒地，1表示耕地</p><p>我们判断一下当前状态与利用情况 and 起来是否还等于当前状况即可<br><del>正确性证明留作习题</del></p><hr><p>那么我们枚举所有的可能状态，挨个判断即可。<br>注意边界条件 $ f[0][0] = 1 $</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  28.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/1/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Stat(__x) FIXED_STATUS[__x]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSTATUS = (<span class="number">1</span> &lt;&lt; <span class="number">12</span>) - <span class="number">1</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXMN = <span class="number">12</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> farm[MAXMN][MAXMN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXMN][MAXSTATUS], FIXED_STATUS[MAXSTATUS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[i][stat]: line = i, status = stat (binary)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; farm[i][j];</span><br><span class="line">            Stat(i) = (Stat(i) &lt;&lt; <span class="number">1</span>) + farm[i][j]; <span class="comment">// 预处理一下土地的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> status = <span class="number">0</span>; status &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; ++status) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((status &amp; (status &lt;&lt; <span class="number">1</span>)) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// some grass are close to each other</span></span><br><span class="line">            <span class="keyword">if</span> ((status &amp; Stat(i)) != status) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// at least one grass planted on a barren place</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> pre_stat = <span class="number">0</span>; pre_stat &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; ++pre_stat) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((status &amp; pre_stat) == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][status] += dp[i - <span class="number">1</span>][pre_stat];</span><br><span class="line">                    dp[i][status] %= HA;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        ans += dp[m][i];</span><br><span class="line">        ans %= HA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ProjectDP - 28&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;状压DP入门题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ProjectDP" scheme="https://blog.handwer-std.top/tags/ProjectDP/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="状压DP" scheme="https://blog.handwer-std.top/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="进制" scheme="https://blog.handwer-std.top/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1352《没有上司的舞会》</title>
    <link href="https://blog.handwer-std.top/2019-01-28/Luogu-P1352/"/>
    <id>https://blog.handwer-std.top/2019-01-28/Luogu-P1352/</id>
    <published>2019-01-28T12:25:51.000Z</published>
    <updated>2019-02-04T05:19:46.893Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ProjectDP - 8</p></blockquote><blockquote><p>树形DP入门题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数N。(1&lt;=N&lt;=6000)</p><p>接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128&lt;=Ri&lt;=127)</p><p>接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。</p><p>最后一行输入0 0</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出最大的快乐指数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是一道树形DP板子题。</p><p>设 $ f[u][0] $ 表示不选择 $u$ 这个结点时的最大价值，$ f[u][1] $ 表示选择 $u$ 这个结点时的最大价值<br>令 $v$ 为 $u$ <strong>除父节点以外</strong>的邻接点，那么我们就能写出这样的伪代码</p><p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ \text{Algorithm 1: DFS(u)} $<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ 1: f[u][0] = 0 $<br>$ 2: f[u][1] = value[u] $<br>$ 3: \text{while u}$ 有未被遍历的<strong>出</strong>边 $ (u,v)  \text{ do} $<br>$ 4: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{DFS}(v) $<br>$ 5: $ &nbsp;&nbsp;&nbsp;&nbsp; $ f[u][0] = f[u][0] + \text{max}(f[v][0], f[v][1]) $<br>$ 6: $ &nbsp;&nbsp;&nbsp;&nbsp; $ f[u][1] = f[u][1] + f[v][0] $<br>$ 7: \text{end while}$<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p><p>最后答案即为 $ \text{max}(f[root][0], f[root][1]) $</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  8.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/1/28.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[u][true]: Choose Node[u]</span></span><br><span class="line"><span class="comment"> * dp[u][false]: Don't choose Node[u]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[MAXN], n;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">2</span>], inDegree[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[u][<span class="number">1</span>] = val[u];</span><br><span class="line">    <span class="keyword">int</span> siz = (<span class="keyword">int</span>) head[u].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">        DFS(v);</span><br><span class="line">        dp[u][<span class="number">1</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">std</span>::max(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; val[i];</span><br><span class="line">    <span class="keyword">int</span> maxNode = <span class="number">-1</span>, minNode = MAXN + <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> father = <span class="number">0</span>, child = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; child &gt;&gt; father;</span><br><span class="line">        head[father].push_back(child);</span><br><span class="line">        ++inDegree[child];</span><br><span class="line">        maxNode = <span class="built_in">std</span>::max(maxNode, <span class="built_in">std</span>::max(father, child));</span><br><span class="line">        minNode = <span class="built_in">std</span>::min(minNode, <span class="built_in">std</span>::min(father, child));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minNode; i &lt;= maxNode; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="literal">false</span>) root = i;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::max(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ProjectDP - 8&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;树形DP入门题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ProjectDP" scheme="https://blog.handwer-std.top/tags/ProjectDP/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>HDU2089《不要62》</title>
    <link href="https://blog.handwer-std.top/2019-01-28/HDU2089/"/>
    <id>https://blog.handwer-std.top/2019-01-28/HDU2089/</id>
    <published>2019-01-28T11:01:37.000Z</published>
    <updated>2019-02-04T03:19:43.026Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ProjectDP - 26</p></blockquote><blockquote><p>数位DP板子题</p></blockquote><a id="more"></a><h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。<br>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。<br>不吉利的数字为所有含有4或62的号码。例如：<br>62315 73418 88914<br>都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。<br>你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">100</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">80</span></span><br></pre></td></tr></table></figure><h1 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h1><p>qianneng</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><!--这是一道数位DP板子题我们令 $ A(x) $ 表示 $[0,x)$ 之间数字的答案数，那么答案就是 $ A(m) - A(n) $ 加上对 $n$ 的特判，这个很显然𝟠如何写这个函数 $A(x)$？---我们设 $ f[i][j] $ 表示 i 位数中开头数字为 j 的，不含4和62的数字有多少转移方程显然$$ f[i][j] = f[i][j] + f[i - 1][k]\ (j \neq 4, k \neq 2 \text{ when } j = 6) $$--><p>不会讲啊QAQ</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  26.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/1/28.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLENGTH = <span class="number">8</span> + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[i][j]: length = i, the start number = j</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXLENGTH][MAXLENGTH];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// enumeration length</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">4</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">6</span>) dp[i][j] -= dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// returns the amount in [0, x)</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num[MAXLENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// num[0] &lt;=&gt; cnt</span></span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        num[++num[<span class="number">0</span>]] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">4</span> || (num[i + <span class="number">1</span>] == <span class="number">6</span> &amp;&amp; j == <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            ans += dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[i] == <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[i + <span class="number">1</span>] == <span class="number">6</span> &amp;&amp; num[i] == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Solve((m) + <span class="number">1</span>) - Solve((n - <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ProjectDP - 26&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;数位DP板子题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ProjectDP" scheme="https://blog.handwer-std.top/tags/ProjectDP/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="数位DP" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E4%BD%8DDP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1006《传纸条》</title>
    <link href="https://blog.handwer-std.top/2019-01-28/Luogu-P1006/"/>
    <id>https://blog.handwer-std.top/2019-01-28/Luogu-P1006/</id>
    <published>2019-01-28T05:31:00.000Z</published>
    <updated>2019-01-28T11:31:51.928Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ProjectDP - 4</p></blockquote><blockquote><p>从下往上传 $ \iff $ 从上往下传</p></blockquote><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ProjectDP - 4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;从下往上传 $ \iff $ 从上往下传&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ProjectDP" scheme="https://blog.handwer-std.top/tags/ProjectDP/"/>
    
      <category term="DP" scheme="https://blog.handwer-std.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1434《[SHOI2010]滑雪》</title>
    <link href="https://blog.handwer-std.top/2019-01-27/Luogu-P1434/"/>
    <id>https://blog.handwer-std.top/2019-01-27/Luogu-P1434/</id>
    <published>2019-01-27T12:23:55.000Z</published>
    <updated>2019-01-27T12:57:50.534Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记忆化搜索好题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Michael喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>  <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="symbol">16 </span> <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span>  <span class="number">6</span></span><br><span class="line"><span class="symbol">15 </span> <span class="number">24</span>  <span class="number">25</span>  <span class="number">20</span>  <span class="number">7</span></span><br><span class="line"><span class="symbol">14 </span> <span class="number">23</span>  <span class="number">22</span>  <span class="number">21</span>  <span class="number">8</span></span><br><span class="line"><span class="symbol">13 </span> <span class="number">12</span>  <span class="number">11</span>  <span class="number">10</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure><p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可行的滑坡为24－17－16－1（从24开始，在1结束）。当然25－24－23－…－3－2－1更长。事实上，这是最长的一条。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为表示区域的二维数组的行数R和列数C（1≤R，C≤100）。下面是R行，每行有C个数，代表高度(两个数字之间用1个空格间隔)。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出区域中最长滑坡的长度。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">16 </span><span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">15 </span><span class="number">24</span> <span class="number">25</span> <span class="number">20</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">14 </span><span class="number">23</span> <span class="number">22</span> <span class="number">21</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">13 </span><span class="number">12</span> <span class="number">11</span> <span class="number">10</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一眼就能看出这是搜索题</p><p>方法很显然，枚举所有的点，从当前点开始 DFS，每次往四个方向搜索，直到不能搜为止，这时候答案就出来了一个，更新一下。</p><hr><p>考虑一下优化。<br>在每次搜索的过程中，我们有很多点是重复走过的，那么就可以把暴搜升级为记忆化搜索。<br>用 $ \text{mem}(x,y) $ 表示从点 $ (x,y) $ 出发的最长路径，在每一次搜索完成之后更新一下当前的答案，记录到 $ \text{mem}(x,y) $ 中即可。等到下一次搜到这个点（记为 $ (x’,y’) $ ），如果 $ \text{mem}(x’,y’) \geq 0 $ （也就是被更新过了），直接返回 $ \text{mem}(x’,y’) $ 就行。</p><hr><p>我们也可以把记忆化搜索升级为 DP <del>不过据说比记忆化搜索还慢</del><br>DP 做法题解已提上日程。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>,  <span class="number">0</span>, <span class="number">-1</span>,  <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXRC = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> snow[MAXRC][MAXRC];</span><br><span class="line"><span class="keyword">int</span> r, c, ans;</span><br><span class="line"><span class="keyword">int</span> mem[MAXRC][MAXRC];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mem[x][y]) t = mem[x][y];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (nx &gt; <span class="number">0</span> &amp;&amp; ny &gt; <span class="number">0</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &lt;= c &amp;&amp; snow[x][y] &lt; snow[nx][ny]) &#123;</span><br><span class="line">                t = <span class="built_in">std</span>::max(t, Search(nx, ny) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mem[x][y] = t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; snow[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = Search(i, j);</span><br><span class="line">            mem[i][j] = now;</span><br><span class="line">            ans = <span class="built_in">std</span>::max(ans, mem[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记忆化搜索好题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="省选" scheme="https://blog.handwer-std.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="记忆化搜索" scheme="https://blog.handwer-std.top/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
</feed>
