<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Handwer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.handwer-std.top/"/>
  <updated>2019-07-12T13:28:29.982Z</updated>
  <id>https://blog.handwer-std.top/</id>
  
  <author>
    <name>Handwer STD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公告栏</title>
    <link href="https://blog.handwer-std.top/2019-10-31/BulletinBoard/"/>
    <id>https://blog.handwer-std.top/2019-10-31/BulletinBoard/</id>
    <published>2019-10-31T12:30:10.000Z</published>
    <updated>2019-07-12T13:28:29.982Z</updated>
    
    <content type="html"><![CDATA[<p><font style="color:#66ccff"></font></p><p><center>这里可能会挂些什么东西。 <br>There may be something here.<br></center><br><br><img src="https://v2.jinrishici.com/one.svg" alt="今日诗词"></p><!--博客累计已突破 100 篇文章--><!--New！[《「文章」百名学生参训 礼堂“变身”教室》](/2019-02-16/SDWC-Article/)-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font style=&quot;color:#66ccff&quot;&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;这里可能会挂些什么东西。 &lt;br&gt;There may be something here.&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://v2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>中国剩余定理（CRT）学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-10-03/ChinaRemainderTheroem/"/>
    <id>https://blog.handwer-std.top/2019-10-03/ChinaRemainderTheroem/</id>
    <published>2019-10-02T22:45:50.000Z</published>
    <updated>2019-10-04T00:01:22.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>孙子定理是中国古代求解一次同余式组（见同余）的方法。是数论中一个重要定理。又称中国余数定理。</p><p style="text-align: right">——百度百科</p><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>孙子定理是用来求解这样的方程组的：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBlVUJ.png" alt="uBlVUJ.png"></p><p>（我博客行间公式渲染好像有点问题……）</p><p>CRT 的使用条件是 $m_i$ 两两互质，$m_i$ 两两不互质需要使用 exCRT 即扩展中国剩余定理</p><hr><p>首先定义 $M = \prod_{i = 1}^n m_i$，并设 $M_i = \lfloor {M \over {m_i}} \rfloor$，$t_i = M_i^{-1} \bmod M$（即$t_i$满足$M_i t_i \equiv 1 (\bmod M)$）<br>那么该同余方程的一个解为<br>$$<br>x_0=(\sum_{i=1}^{k} a_{i} M_i t_{i})\bmod M<br>$$<br>通解为 $x = x_0 + i \times M$，最小非负整数解为 $(x_0 \bmod M + M) \bmod M$</p><p>如果有 $a &lt; 0$ 的情况时要注意负数取模问题</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CRT.cpp</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/10/3.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">lli k, a[<span class="number">10000</span> + <span class="number">10</span>], m[<span class="number">10000</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ChinaRemainderTheorem &#123;</span><br><span class="line">    <span class="function">lli <span class="title">exgcd</span><span class="params">(lli a, lli b, lli &amp;x, lli &amp;y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">        lli g = exgcd(b, a % b, y, x);</span><br><span class="line">        y -= a / b * x;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">lli <span class="title">CRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lli X = <span class="number">0</span>, M = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (lli i = <span class="number">1</span>; i &lt;= k; ++i) M *= m[i];</span><br><span class="line">        <span class="keyword">for</span> (lli i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            lli ti = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            lli mmi = M / m[i];</span><br><span class="line">            exgcd(mmi, m[i], ti, y);</span><br><span class="line">            X = ((X + a[i] * mmi * ti) % M + M) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> X &lt; <span class="number">0</span> ? (X + M) : X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    k = getll();</span><br><span class="line">    <span class="comment">/// x === ai (mod mi)</span></span><br><span class="line">    rap (i, <span class="number">1</span>, k, <span class="number">1</span>) &#123; m[i] = getll(); a[i] = getll(); &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ChinaRemainderTheorem::CRT());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="中国剩余定理" scheme="https://blog.handwer-std.top/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1168《中位数》</title>
    <link href="https://blog.handwer-std.top/2019-10-02/Luogu-P1168/"/>
    <id>https://blog.handwer-std.top/2019-10-02/Luogu-P1168/</id>
    <published>2019-10-02T12:17:18.000Z</published>
    <updated>2019-10-02T12:55:02.771Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>两个优先队列</p></blockquote><a id="more"></a><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应肯定是堆，毕竟自带排序，找中位数也方便</p><p>关键是 <code>std::priority_queue</code>  不能访问内部元素就很烦</p><p>但是，要访问的内部元素好像就一个中位数啊？</p><hr><p>考虑把中位数手动记下来，然后把中位数前边的数用一个大根堆存一下，把中位数后面的数用一个小根堆存一下，这样依然能保证元素是始终有序的</p><p>依次读入每一个数，如果这个数比「当前记着的中位数」小就放进大根堆里，否则放进小根堆里</p><p>查询的时候需要对中位数进行更新：<br>如果左右两个堆的大小相等，说明中位数还是那个中位数；<br>否则分两种情况讨论：</p><ol><li>大根堆更大<br>说明中位数一定在大根堆里，那么就把中位数塞进小根堆里，再把大根堆堆顶取出来当新的中位数，重复做直到两个堆大小相等</li><li>小根堆更大<br>说明中位数一定在小根堆里，那么就把中位数塞进大根堆里，再把小根堆堆顶取出来当新的中位数，重复做直到两个堆大小相等</li></ol><p>最后输出更新完的中位数即可</p><p>本方法对应代码中的 <code>Method1</code></p><hr><p>或者可以直接使用 <code>std::vector</code> 和 <code>std::upper_bound</code> 来模拟一个堆，输出的时候直接访问 <code>vec[(i / 2 + 1) - 1]</code> 即可</p><p><code>std::upper_bound(Begin Iterator, End Iterator, Value)</code> 是一个使用二分查找，在有序序列 <code>[Begin Iterator, End Iterator)</code> 中查找第一个大于 <code>Value</code> 的位置的函数；<code>std::vector&lt;int&gt;::insert(Position Iterator, Value)</code> 可以在 <code>Position Iterator</code> 前面插入元素 <code>Value</code>，利用这两个函数可以实现插入元素而不破坏序列的有序性。</p><p>本方法对应代码中的 <code>Method2</code></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP1168.cpp</span></span><br><span class="line"><span class="comment">//  Title: 中位数</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/10/2.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Method1 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此题正解</span></span><br><span class="line"><span class="comment">     * 用一个大根堆维护中位数之前的数，一个小根堆维护中位数之后的数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; before;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; after;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> _main() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = getint();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; mid = now; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; mid) before.push(now);</span><br><span class="line">                <span class="keyword">else</span> after.push(now);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> befsiz = before.size();</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> aftsiz = after.size();</span><br><span class="line">                <span class="keyword">while</span> (befsiz != aftsiz) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (befsiz &lt; aftsiz) &#123;</span><br><span class="line">                        before.push(mid);</span><br><span class="line">                        mid = after.top(); after.pop();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        after.push(mid);</span><br><span class="line">                        mid = before.top(); before.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    befsiz = before.size(); aftsiz = after.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Method2 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 沙雕做法</span></span><br><span class="line"><span class="comment">     * 使用 std::vector 和 std::lower_bound 手写堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> _main() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = getint();</span><br><span class="line">            vec.insert(<span class="built_in">std</span>::upper_bound(vec.begin(), vec.end(), now), now);</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, vec.at(i / <span class="number">2</span> + <span class="number">1</span> - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span>) Method2::_main();</span><br><span class="line">    <span class="keyword">else</span> Method1::_main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;两个优先队列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="队列" scheme="https://blog.handwer-std.top/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="堆" scheme="https://blog.handwer-std.top/tags/%E5%A0%86/"/>
    
      <category term="STL" scheme="https://blog.handwer-std.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2158《[SDOI2008]仪仗队》</title>
    <link href="https://blog.handwer-std.top/2019-08-18/Luogu-P2158-BZOJ2190/"/>
    <id>https://blog.handwer-std.top/2019-08-18/Luogu-P2158-BZOJ2190/</id>
    <published>2019-08-18T15:40:29.000Z</published>
    <updated>2019-08-18T15:53:54.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。</p><a id="more"></a>  <p><img src="https://www.lydsy.com/JudgeOnline/images/2190.jpg" alt=""></p><p>现在，C君希望你告诉他队伍整齐时能看到的学生人数。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>共一个数 N</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>共一个数，即C君应看到的学生人数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>【数据规模和约定】</p><p>对于 100% 的数据，1 ≤ N ≤ 40000</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>来快乐推一推式子</p><p>首先考虑一下没有被看到的点长什么样<br>显然没有被看到的点$(x,y)$与原点的连线上一定有一点，记为 $(\frac x t , \frac y t )$</p><p>由于所有坐标都是整数，那么有</p><p>$$<br>t \mid x, t \mid y  \Leftrightarrow  t \mid \gcd(x, y)<br>$$</p><p>所以可以知道这个事情：<br>一个点$(x, y)$不可以被看到，等价于$\gcd(x, y) \neq 1$。<br>所以题目要求的就是所有的数对$(x,y)$的个数，满足 $\gcd(x, y) = 1$</p><hr><p>分开考虑答案</p><p>首先是坐标形如 $(0, y), (x, 0)$ 的这些点，也就是在 $x$ 轴和 $y$ 轴上的点，均只能看见一个 $(0, 1),(1, 0)$，统计答案的时候就直接 $+ 2$ 就行了。</p><p>然后是在直线 $y = x$ 上的点，也只能被看见一个 $(1, 1)$，统计答案的时候再来个 $+ 1$。</p><p>剩下的点可以用两个 $\sum$ 统计。<br>最后式子长这样（注意$\text{ans}$函数的参数值）：</p><p>$$<br>\begin{align}<br>\text{ans}(n + 1) = 3 + \sum_{x = 1}^{n} \sum_{y = 1}^{x - 1}[\gcd(x, y) = 1] + \sum_{x = 1}^{n} \sum_{y = x + 1}^{n}[\gcd(x, y) = 1]<br>\end{align}<br>$$</p><p>看一眼这张图：</p><p><img src="https://i.loli.net/2019/08/18/rDIhj6WHcpUnbNa.png" alt=""></p><p>可以发现，第一种情况对应的是点 $U, V$，第二种情况对应的是 $W$，两个 $\sum$ 分别对应点 $A \rightarrow J$ 和 $K \rightarrow T$ 的能看见的点的数量。</p><p>还是不懂？ 手动模拟一下吧，看看它会统计哪些点<br>两个 $\sum$ 相当于语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line"><span class="keyword">for</span> y = <span class="number">1</span> to x - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">ans = ans + (gcd(x,y) == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> x = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line"><span class="keyword">for</span> y = x + <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">ans = ans + (gcd(x,y) == <span class="number">1</span>)</span><br><span class="line">ans = ans + <span class="number">3</span></span><br></pre></td></tr></table></figure><p>显然可以看到的点是关于直线 $y = x$ 对称的，所以上面的式子又可以写成</p><p>$$<br>\text{ans}(n + 1) = 3 + 2\sum_{x = 1}^{n} \sum_{y = 1}^{x - 1}[\gcd(x, y) = 1]<br>$$</p><hr><p>这个式子肯定跑不过去的。把这个式子化简一下</p><p>注意到一个很常见的积性函数</p><p>$$<br>\varphi(x) = \sum_{i = 1}^{x}[\gcd(i, x) = 1]<br>$$</p><p>代入原式！</p><p>$\text{ans}(n + 1) = 3 + 2\sum_{x = 1}^{n} \sum_{y = 1}^{x - 1}[\gcd(x, y) = 1]$<br>$= 3 + 2\sum_{x = 1}^{n} (\sum_{y = 1}^{x}[\gcd(x, y) = 1] - [\gcd(x, x) = 1])$<br>$= 3 + 2\sum_{x = 1}^{n} (\varphi(x) - [\gcd(x, x) = 1])$</p><p>好了，现在就有了一个可以 $O(n)$ 计算的式子了！</p><p>（式子要分行写是因为我博客的 Math 引擎好像炸了。。。渲染不了多行，将就看吧/kk）</p><hr><p>最后说个事，$n = 1$ 的时候答案为 $0$，这个很显然吧，都没有学生了（</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2158.cpp</span></span><br><span class="line"><span class="comment">//  Title: [SDOI2008]仪仗队</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ2190</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/18.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">40000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notprime[MAXN];</span><br><span class="line"><span class="keyword">int</span> prime[MAXN], phi[MAXN], cnt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">lli ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    notprime[<span class="number">0</span>] = notprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!notprime[i]) &#123;</span><br><span class="line">            prime[++cnt] = i; phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; (i * prime[j]) &lt; MAXN; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i * prime[j];</span><br><span class="line">            notprime[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123; phi[x] = phi[i] * prime[j]; <span class="keyword">break</span>; &#125;</span><br><span class="line">            phi[x] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= fn; ++x) &#123;</span><br><span class="line">        ans += phi[x];</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) ans -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sieve();</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> (<span class="number">0</span> &amp; <span class="built_in">printf</span>(<span class="string">"0\n"</span>));</span><br><span class="line">    Solve(n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="欧拉函数" scheme="https://blog.handwer-std.top/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>HDU2196《Computer》</title>
    <link href="https://blog.handwer-std.top/2019-08-15/HDU2196/"/>
    <id>https://blog.handwer-std.top/2019-08-15/HDU2196/</id>
    <published>2019-08-15T14:08:14.000Z</published>
    <updated>2019-08-15T14:23:46.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用树的直径的性质</p></blockquote><a id="more"></a><h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information.  </p><p><img src="http://acm.hdu.edu.cn/data/images/C128-1005-1.JPG" alt=""></p><p>Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4.</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space.</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N).</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先有一个性质：在一棵树上，距离任意点最远的点一定是这棵树直径的一个端点</p><p>然后这题不就好做了吗</p><p>先以 1 为根求一遍直径，再分别以两个端点为根求一遍这个点到其他点的距离，取个最大值，输出即可，这个可以写一个DFS调用三遍</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU2196.cpp</span></span><br><span class="line"><span class="comment">//  Title: Computer</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/15.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, farthest;</span><br><span class="line">lli maxdis;</span><br><span class="line">lli f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    head[u].push_back(Edge(v, w));</span><br><span class="line">    head[v].push_back(Edge(u, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, lli dis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; maxdis) &#123; maxdis = dis; farthest = u; &#125;</span><br><span class="line">    f[u] = <span class="built_in">std</span>::max(f[u], dis);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = head[u][i].v, w = head[u][i].w;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(v, u, dis + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _main() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = getint(); <span class="keyword">int</span> w = getint();</span><br><span class="line">        addEdge(i + <span class="number">1</span>, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    p1 = farthest;</span><br><span class="line">    DFS(p1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 以上这两遍DFS是在求树的直径</span></span><br><span class="line">    <span class="comment">// 第二遍DFS顺便更新了一下从某一个端点出发的答案</span></span><br><span class="line">    p2 = farthest;</span><br><span class="line">    DFS(p2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 由于在每个点的最长路径可能到达两个端点</span></span><br><span class="line">    <span class="comment">// 所以要对两个端点分别更新一遍答案</span></span><br><span class="line">    <span class="comment">// 这一遍DFS是在更新从另一个端点出发的答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) head[i].clear();</span><br><span class="line">    n = maxdis = farthest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) _main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;利用树的直径的性质&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="树" scheme="https://blog.handwer-std.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3714《Kuglarz》</title>
    <link href="https://blog.handwer-std.top/2019-08-15/BZOJ3714/"/>
    <id>https://blog.handwer-std.top/2019-08-15/BZOJ3714/</id>
    <published>2019-08-15T01:09:58.000Z</published>
    <updated>2019-08-15T01:19:38.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是最小生成树？</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>魔术师的桌子上有n个杯子排成一行，编号为1,2,…,n，其中某些杯子底下藏有一个小球，如果你准确地猜出是哪些杯子，你就可以获得奖品。花费c_ij元，魔术师就会告诉你杯子i,i+1,…,j底下藏有球的总数的奇偶性。<br>采取最优的询问策略，你至少需要花费多少元，才能保证猜出哪些杯子底下藏着球？</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个整数n(1&lt;=n&lt;=2000)。<br>第i+1行(1&lt;=i&lt;=n)有n+1-i个整数，表示每一种询问所需的花费。其中c_ij（对区间[i,j]进行询问的费用，1&lt;=i&lt;=j&lt;=n,1&lt;=c_ij&lt;=10^9）为第i+1行第j+1-i个数。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一个整数，表示最少花费。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5  </span><br><span class="line">1 2 3 4 5  </span><br><span class="line">4 3 2 1  </span><br><span class="line">3 4 5  </span><br><span class="line">2 1  </span><br><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><del>从代码里复制过来的</del></p><p>知道两段杯子的奇偶性，相当于知道左边杯子左边的缝到右边杯子右边的缝到奇偶性</p><p>然后显然这个东西具有传递性，即知道缝a到缝b、缝b到缝c的奇偶性 $\Leftrightarrow$ 缝a到缝c的奇偶性</p><p>知道所有数列要保证缝两两之间的奇偶性都要知道</p><p>那么就可以把缝抽象成点，缝两两之间的奇偶性信息抽象成边，边权为询问的代价</p><p>一遍最小生成树完事</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  BZOJ3714.cpp</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/15.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 知道两段杯子的奇偶性，相当于知道左边杯子左边的缝到右边杯子右边的缝到奇偶性</span></span><br><span class="line"><span class="comment"> * 然后显然这个东西具有传递性，即知道缝a到缝b、缝b到缝c的奇偶性 &lt;=&gt; 缝a到缝c的奇偶性</span></span><br><span class="line"><span class="comment"> * 知道所有数列要保证缝两两之间的奇偶性都要知道</span></span><br><span class="line"><span class="comment"> * 那么就可以把缝抽象成点，缝两两之间的奇偶性信息抽象成边，边权为询问的代价</span></span><br><span class="line"><span class="comment"> * 一遍最小生成树完事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u[MAXN];</span><br><span class="line">    </span><br><span class="line">    UnionFind() &#123; <span class="built_in">memset</span>(u, <span class="number">0</span>, <span class="keyword">sizeof</span> u); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++i) u[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> u[x] == x ? x : (u[x] = Find(u[x])); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = Find(x); y = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        u[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; U;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : u(u), v(v), w(w) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; that.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt;</span><br><span class="line">lli ans;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//    std::sort(edge + 1, edge + 1 + cnt);</span></span><br><span class="line">    <span class="built_in">std</span>::sort(edge.begin(), edge.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (U.Union(edge[i].u, edge[i].v)) &#123;</span><br><span class="line">            <span class="comment">//            printf("choosed edge[%d] = &#123; %d %d %d &#125;\n", i, edge[i].u, edge[i].v, edge[i].w);</span></span><br><span class="line">            ++tot; ans += <span class="number">1l</span>l * edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    U.Init(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = getint();</span><br><span class="line">            edge.push_back(Edge(i, j, x));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = (<span class="keyword">int</span>) edge.size();</span><br><span class="line">    Kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是最小生成树？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="生成树" scheme="https://blog.handwer-std.top/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="最小生成树" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>关于新开的 cnblogs 博客的一些说明</title>
    <link href="https://blog.handwer-std.top/2019-08-14/Articles-Moving-To-cnblogs/"/>
    <id>https://blog.handwer-std.top/2019-08-14/Articles-Moving-To-cnblogs/</id>
    <published>2019-08-14T11:43:38.000Z</published>
    <updated>2019-08-14T11:58:04.938Z</updated>
    
    <content type="html"><![CDATA[<p>因为一些原因，文章没有被各大搜索引擎收录多少，PV和UV都很低（截止2019.08.12 7:20，没有破 5K），于是就想找一个博客网站放一些自己的文章，希望更多人能看到自己的文章，同时可以给自己博客引引流，最后选中了 cnblogs</p><p>文章会陆续按照创建时间排序搬上来，以后两个博客（有时候可能会在洛谷博客也更新）同步更新</p><p>一些很沙雕的文章可能不会放上去（</p><p>不过这么做可能会引来转载，比如说某aichengxu、某voidcn啊之类的，链个博客链接应该就没事了（</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为一些原因，文章没有被各大搜索引擎收录多少，PV和UV都很低（截止2019.08.12 7:20，没有破 5K），于是就想找一个博客网站放一些自己的文章，希望更多人能看到自己的文章，同时可以给自己博客引引流，最后选中了 cnblogs&lt;/p&gt;
&lt;p&gt;文章会陆续按照创建时间
      
    
    </summary>
    
    
      <category term="博客相关" scheme="https://blog.handwer-std.top/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>ZROI 918《「良心普及组」黄队的宫殿》</title>
    <link href="https://blog.handwer-std.top/2019-08-13/ZROI918/"/>
    <id>https://blog.handwer-std.top/2019-08-13/ZROI918/</id>
    <published>2019-08-13T13:26:09.000Z</published>
    <updated>2019-08-13T14:20:16.698Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）" />    <label for="pass">密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本题为权限题目，请输入密码访问。密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）
    
    </summary>
    
    
      <category term="只有经历过的人才知道的世界" scheme="https://blog.handwer-std.top/tags/%E5%8F%AA%E6%9C%89%E7%BB%8F%E5%8E%86%E8%BF%87%E7%9A%84%E4%BA%BA%E6%89%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="https://blog.handwer-std.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>HDU1483《Automatic Correction of Misspellings》</title>
    <link href="https://blog.handwer-std.top/2019-08-08/HDU1483/"/>
    <id>https://blog.handwer-std.top/2019-08-08/HDU1483/</id>
    <published>2019-08-08T15:56:55.000Z</published>
    <updated>2019-08-08T16:00:04.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Some text editors offer a feature to correct words which seem to be written incorrectly. In this problem you are asked to implement a simple Automatic Correction of Misspellings (ACM).  </p><a id="more"></a><p>ACM takes care of the following misspellings of words:  </p><p>1.One letter is missing (e.g., letter is written leter) or too much (e.g., letter is written lettter).<br>2.One letter is wrong (e.g., letter is written ketter)<br>3.The order of two adjacent letters is wrong (e.g., letter is written lettre)  </p><p>ACM is based on a dictionary of known words. When a text contains a word which is not in the dictionary, ACM will try to replace it by a similar word of the dictionary. Two words are similar if we can transform one word into the other by doing exactly one of the misspellings listed above. An unknown word is left unchanged if there is no similar word in the dictionary.  </p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>The first line of the input file will give the number n of words in the dictionary (n ≤ 10000). The next n lines contain the dictionary words. The following line contains an integer q ≤ 1000, the number of query words. The next q lines contain the query words. You may assume that each word in the input consists of 1 to 25 lower case letters (‘a’ to ‘z’).  </p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each query word, print one line with the query word followed by one of the following possibilities:  </p><ol><li>is correct, if the word occurs in the dictionary.  </li><li>is a misspelling of <x>, where <x> is a word of the dictionary similar to the query word, and the query word is not in the dictionary. In the case that there are several possibilities, select the word from the dictionary which appeared earlier in the input.  </x></x></li><li>is unknown, if cases 1 and 2 do not apply.  </li></ol><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">this</span><br><span class="line">is</span><br><span class="line">a</span><br><span class="line">dictionary</span><br><span class="line">that</span><br><span class="line">we</span><br><span class="line">will</span><br><span class="line">use</span><br><span class="line">for</span><br><span class="line">us</span><br><span class="line">6</span><br><span class="line">su</span><br><span class="line">as</span><br><span class="line">the</span><br><span class="line">dictonary</span><br><span class="line">us</span><br><span class="line">willl</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su is a misspelling of us</span><br><span class="line">as is a misspelling of is</span><br><span class="line">the is unknown</span><br><span class="line">dictonary is a misspelling of dictionary</span><br><span class="line">us is correct</span><br><span class="line">willl is a misspelling of will</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><del>还是从代码里复制过来的（</del></p><p>场上写一个 Trie 写到自闭。。。<br>赛后来补一下</p><p>道理我都懂，但是这题为什么暴力能过。。。</p><p>以下，将字典中的串称作「字典串」，将询问的串称作「匹配串」</p><p>首先扫一遍字典，有相同的直接输出 correct</p><p>然后如果没有相同的，再扫一遍字典，对于每一个字典串，做这样几件事：</p><ol><li>如果字典串和匹配串长度相等，就说明这个匹配串可能是当前字典串的一个错误拼写<br>逐位扫一遍两个串，记一下错误的次数，以及最后一次错误的下标<br>如果错误次数是 1 就直接输出 misspelling，此时匹配串相对于字典串只错了一个字符<br>如果错误次数是 2 就判断一下是否是顺序弄反了，这个用最后一次错误下标很好写，如果是就输出 misspelling<br>否则就凉凉</li><li>如果字典串比匹配串长 1，就说明这个匹配串可能是当前字典串漏了一个字<br>逐位扫一遍字典串，用一个变量 k 记录当前字典串这一位对应的是匹配串的哪一位<br>如果当前的两个串对应字符相等，就让 k 正常加一，否则就不让 k 加一<br>显然如果真的是只漏了一个字，那么最后 k 一定等于匹配串长度，输出 misspelling<br>否则 k 一定不等于匹配串长度（具体会变成什么值我也不大清楚，反正模拟一下就好了）</li><li>如果字典串比匹配串短 1，就说明这个匹配串可能是当前字典串添了一个字<br>仿照着情况 2 做就完事了</li></ol><p>最后如果三种情况都没有，输出 unknown</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU1483.cpp</span></span><br><span class="line"><span class="comment">//  Title: Automatic Correction of Misspellings</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/8.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dict[MAXN];</span><br><span class="line"><span class="keyword">int</span> dictlen[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoCorrectionMachine</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMisspelling</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wrong = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] != m[i]) &#123; ++wrong; pos = i; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wrong == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (wrong == <span class="number">2</span> &amp;&amp; (d[pos] == m[pos - <span class="number">1</span>] &amp;&amp; d[pos - <span class="number">1</span>] == m[pos])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCharacterDeletion</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> lend, <span class="keyword">int</span> lenm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lend; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] != m[k++]) --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == lenm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCharacterAddition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> lend, <span class="keyword">int</span> lenm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenm; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i] != d[k++]) --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == lend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; acm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; dict[i];</span><br><span class="line">        dictlen[i] = (<span class="keyword">int</span>) dict[i].length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> env;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; env;</span><br><span class="line">        <span class="keyword">int</span> lenenv = (<span class="keyword">int</span>) env.length();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; env;</span><br><span class="line">        <span class="keyword">bool</span> cor = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dict[i] == env) &#123; cor = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cor) <span class="built_in">cout</span> &lt;&lt; <span class="string">" is correct\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dictlen[i] == lenenv) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isMisspelling(dict[i], env, lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dictlen[i] == lenenv + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isCharacterDeletion(dict[i], env, dictlen[i], lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dictlen[i] == lenenv - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isCharacterAddition(dict[i], env, dictlen[i], lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n + <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" is unknown\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h1&gt;&lt;p&gt;Some text editors offer a feature to correct words which seem to be written incorrectly. In this problem you are asked to implement a simple Automatic Correction of Misspellings (ACM).  &lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="暴力" scheme="https://blog.handwer-std.top/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>HDU3183《A Magic Lamp》</title>
    <link href="https://blog.handwer-std.top/2019-08-08/HDU3183/"/>
    <id>https://blog.handwer-std.top/2019-08-08/HDU3183/</id>
    <published>2019-08-08T15:44:15.000Z</published>
    <updated>2019-08-08T15:47:14.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Kiki likes traveling. One day she finds a magic lamp, unfortunately the genie in the lamp is not so kind. Kiki must answer a question, and then the genie will realize one of her dreams.  </p><a id="more"></a> <p>The question is: give you an integer, you are allowed to delete exactly m digits. The left digits will form a new integer. You should make it minimum.<br>You are not allowed to change the order of the digits. Now can you help Kiki to realize her dream?  </p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>There are several test cases.<br>Each test case will contain an integer you are given (which may at most contains 1000 digits.) and the integer m (if the integer contains n digits, m will not bigger then n). The given integer will not contain leading zero.  </p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, output the minimum result you can get in one line.<br>If the result contains leading zero, ignore it.  </p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">178543 4 </span><br><span class="line">1000001 1</span><br><span class="line">100001 2</span><br><span class="line">12345 2</span><br><span class="line">54321 2</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">123</span><br><span class="line">321</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然删除从左向右遇到的第一个比下一个数大的数，也就是让最高位最小的过程。那么按这样的策略做 m 次即可获得正确答案，删除后的序列可使用双向链表（STL 里有<code>std::list&lt;int&gt;</code>）来维护。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU3183.cpp</span></span><br><span class="line"><span class="comment">//  Title: A Magic Lamp</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/8.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> charat(x) ((x - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除从左向右遇到的第一个比下一个数大的数</span></span><br><span class="line"><span class="comment"> * 用一个双向链表维护</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) s.length();</span><br><span class="line">        lst.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            lst.insert(lst.end(), s[charat(i)] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.begin(); i != lst.end(); i++) &#123;</span><br><span class="line">                i++; <span class="keyword">if</span> (i == lst.end()) &#123; --i; lst.erase(i); <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">int</span> next = (*i);</span><br><span class="line">                --i;</span><br><span class="line">                <span class="keyword">if</span> (*i &gt; next) &#123; lst.erase(i); <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> fz = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : lst) &#123; <span class="keyword">if</span> (fz &amp;&amp; i == <span class="number">0</span>) <span class="keyword">continue</span>; fz = <span class="literal">false</span>; <span class="built_in">printf</span>(<span class="string">"%d"</span>, i); &#125;</span><br><span class="line">        <span class="keyword">if</span> (fz) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;Kiki likes traveling. One day she finds a magic lamp, unfortunately the genie in the lamp is not so kind. Kiki must answer a question, and then the genie will realize one of her dreams.  &lt;/p&gt;
    
    </summary>
    
    
      <category term="贪心" scheme="https://blog.handwer-std.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 402B《Trees in a Row》</title>
    <link href="https://blog.handwer-std.top/2019-08-07/CF402B/"/>
    <id>https://blog.handwer-std.top/2019-08-07/CF402B/</id>
    <published>2019-08-07T11:59:04.000Z</published>
    <updated>2019-08-07T12:59:17.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h1><p>有n个正整数，可以对一个数进行修改(修改后也是正整数)，要求修改之后满足$a_i+k=a{i+1}$，求最少的修改次数以及具体的修改方案</p><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The Queen of England has n trees growing in a row in her garden. At that, the i-th (1 ≤ i ≤ n) tree from the left has height ai meters. Today the Queen decided to update the scenery of her garden. She wants the trees’ heights to meet the condition: for all i (1 ≤ i &lt; n), ai + 1 - ai = k, where k is the number the Queen chose.</p><p>Unfortunately, the royal gardener is not a machine and he cannot fulfill the desire of the Queen instantly! In one minute, the gardener can either decrease the height of a tree to any positive integer height or increase the height of a tree to any positive integer height. How should the royal gardener act to fulfill a whim of Her Majesty in the minimum number of minutes?</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>The first line contains two space-separated integers: n, k (1 ≤ n, k ≤ 1000). The second line contains n space-separated integers a1, a2, …, an (1 ≤ ai ≤ 1000) — the heights of the trees in the row.</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>In the first line print a single integer p — the minimum number of minutes the gardener needs. In the next p lines print the description of his actions.</p><p>If the gardener needs to increase the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, then print in the corresponding line “+ j x”. If the gardener needs to decrease the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, print on the corresponding line “- j x”.</p><p>If there are multiple ways to make a row of trees beautiful in the minimum number of actions, you are allowed to print any of them.</p><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>input<br>4 1<br>1 2 1 5</p><p>output<br>2</p><ul><li>3 2</li></ul><ul><li>4 1</li></ul><p>input<br>4 1<br>1 2 3 4</p><p>output<br>0</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本文同步发布于<a href="[https://www.luogu.org/blog/handwer-blog/](https://www.luogu.org/blog/handwer-blog/">洛谷博客</a>)</p><hr><p><del>先说点题外话</del></p><p>这道题是我今天（发题解的那一天，2019.08.07）打 ACM 的时候做的，当时看到这题口胡了一下做法，没敢写，交给队友去写了，然后一遍AC</p><p>感谢队友把我带飞</p><hr><p>言归正传。</p><p>考虑枚举第一棵树的高度，因为这样就能直接确定后面的树的高度了 </p><p>然后假设当前枚举第一棵树高度为 $l$，那么第 $i$ 棵树的高度 $h_i$ 就应该是 $l + k(i - 1)$，这个应该很好理解吧，如果不懂可以评论区留个言，我找个时间写一下</p><p>那么再套一层循环，枚举所有的树，如果当前枚举到的第 $i$ 棵树的高度不是 $l + k(i - 1)$，就意味着这棵树需要被修改，需要增高 / 降低的高度是 $\text{abs}(l - k(i - 1))$，需要增高还是降低取决于 $l - k(i - 1)$ 的符号</p><p>统计一下修改了多少次，作为一个方案，最后取一个最优方案的输出就行了</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXNKH = <span class="number">1000</span> + <span class="number">10</span>; <span class="comment">// the max of n, k, height</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOC = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MODIFY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, ans = <span class="number">0x7f7f7f7f</span>, ansf[MAXNKH][<span class="number">2</span>], p, f[MAXNKH][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> height[MAXNKH];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); k = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) height[i] = getint();</span><br><span class="line">    rap (h1, <span class="number">1</span>, <span class="number">1000</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 枚举第一棵树的高度，可以直接确定后面树的高度</span></span><br><span class="line">        p = <span class="number">0</span>; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] - (i - <span class="number">1</span>) * k != h1) &#123;</span><br><span class="line">            <span class="comment">// 记一下要修改的树的下标和要增加 / 减少的值</span></span><br><span class="line">                f[++p][LOC] = i;</span><br><span class="line">                f[p][MODIFY] = (h1 + (i - <span class="number">1</span>) * k) - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; ans) &#123;</span><br><span class="line">            <span class="comment">// 更优的方案，更新一下</span></span><br><span class="line">            ans = p;</span><br><span class="line">            <span class="built_in">memcpy</span>(ansf, f, <span class="keyword">sizeof</span> f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    rap (i, <span class="number">1</span>, ans, <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%c %d %d\n"</span>, (ansf[i][MODIFY] &lt; <span class="number">0</span> ? <span class="string">'-'</span> : <span class="string">'+'</span>), ansf[i][LOC], <span class="built_in">std</span>::<span class="built_in">abs</span>(ansf[i][MODIFY]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code by Handwer</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Translate&quot;&gt;&lt;a href=&quot;#Translate&quot; class=&quot;headerlink&quot; title=&quot;Translate&quot;&gt;&lt;/a&gt;Translate&lt;/h1&gt;&lt;p&gt;有n个正整数，可以对一个数进行修改(修改后也是正整数)，要求修改之后满足$a_i+k=a{i+1}$，求最少的修改次数以及具体的修改方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3177《[HAOI2015]树上染色》</title>
    <link href="https://blog.handwer-std.top/2019-07-31/Luogu-P3177-BZOJ4033/"/>
    <id>https://blog.handwer-std.top/2019-07-31/Luogu-P3177-BZOJ4033/</id>
    <published>2019-07-31T15:30:50.000Z</published>
    <updated>2019-07-31T15:33:23.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我推式子推了半个小时。。。</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一棵点数为N的树，树边有边权。给你一个在0~N之内的正整数K，你要在这棵树中选择K个点，将其染成黑色，并</p><p>将其他的N-K个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间距离的和的收益。</p><p>问收益最大值是多少。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个整数N,K。</p><p>接下来N-1行每行三个正整数fr,to,dis，表示该树中存在一条长度为dis的边(fr,to)。</p><p>输入保证所有点之间是联通的。</p><p>N&lt;=2000,0&lt;=K&lt;=N</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一个正整数，表示收益的最大值。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 2  </span><br><span class="line">1 2 3  </span><br><span class="line">1 5 1  </span><br><span class="line">2 3 1  </span><br><span class="line">2 4 2</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure><p>【样例解释】<br>将点1,2染黑就能获得最大收益。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应设 $\text{dp[i][j]}$ 表示以 i 为根的子树选 j 个黑点的最大收益<br>但是是错的</p><p>康了一眼<a href="https://www.luogu.org/blog/ahaha254/solution-p3177" target="_blank" rel="noopener">这个</a>我就瞬间明白了<br>关于式子的推导，组成部分的意义，还有循环顺序的选择，这篇文章都讲得很清楚</p><p>老规矩，题解都在代码里</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  BZOJ4033.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2015]树上染色</span></span><br><span class="line"><span class="comment">//  Alternatives: Luogu-P3177</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参考资料：https://www.luogu.org/blog/ahaha254/solution-p3177</span></span><br><span class="line"><span class="comment"> * 关于 val(x,y) 和枚举顺序的解释可以康一康这篇文章</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设 f[i][j] 表示以 i 为根的子树中取了 j 个黑点「对答案的贡献」</span></span><br><span class="line"><span class="comment"> * 转移方程：</span></span><br><span class="line"><span class="comment"> * f[u][j] = max(</span></span><br><span class="line"><span class="comment"> *     f[u][j],</span></span><br><span class="line"><span class="comment"> *     f[u][j - k] + f[v][k] + val(u,v)</span></span><br><span class="line"><span class="comment"> * )</span></span><br><span class="line"><span class="comment"> * 其中 v 是 u 的儿子，k 是枚举出来的</span></span><br><span class="line"><span class="comment"> * j = min(m,size(x)) -&gt; 0, k = 0 -&gt; min(j,size(y))</span></span><br><span class="line"><span class="comment"> * 其中 val(x,y) 表示边 (x,y) 对答案的贡献，它等于</span></span><br><span class="line"><span class="comment"> * 「该边两边黑点数量的乘积 乘以 边长 加上 该边两边白点数量的乘积 乘以 边长」</span></span><br><span class="line"><span class="comment"> * 也就是 val(x,y) = k * (m - k) * weight(x,y) + (size(y) - k) * ((n - m) - (size(y) - k)) * weight(x,y)</span></span><br><span class="line"><span class="comment"> * 其中 m 是总的黑点数，k 是边 (x,y) 另一边的黑点数，那么 (m - k) 就是这一边的黑点数</span></span><br><span class="line"><span class="comment"> * size(y) 是以 y 为根的子树的大小，也就意味着 (size(y) - k) 是另一边的白点数（另一边的肯定不是黑点就是白点）</span></span><br><span class="line"><span class="comment"> * (n - m) 是总的白点数，(size(y) - k) 是另一边的白点数，也就意味着 ((n - m) - (size(y) - k)) 是边 (x,y) 这一边的白点数（白点肯定不在那边就在这边）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    lli w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> v = <span class="number">0</span>, lli w = <span class="number">0</span>) : v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, size[MAXN];</span><br><span class="line">lli dp[MAXN][MAXK];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXK];</span><br><span class="line"><span class="comment">// dp 数组大概 31 MB</span></span><br><span class="line"><span class="comment">// size 数组大概 8 KB</span></span><br><span class="line"><span class="comment">// vis 数组大概 4 MB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    size[root] = <span class="number">1</span>;</span><br><span class="line">    vis[root][<span class="number">0</span>] = vis[root][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i].v;</span><br><span class="line">        <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(next, root);</span><br><span class="line">        size[root] += size[next];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i].v;</span><br><span class="line">        <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">        lli weight = head[root][i].w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">std</span>::min(m, size[root]); j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="built_in">std</span>::min(j, size[next]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= up; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[root][j - k]) <span class="keyword">continue</span>;</span><br><span class="line">                lli val = k * (m - k) * weight + (size[next] - k) * ((n - m) - (size[next] - k)) * weight;</span><br><span class="line">                dp[root][j] = <span class="built_in">std</span>::max(dp[root][j], dp[root][j - k] + dp[next][k] + val);</span><br><span class="line">                vis[root][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); m = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n - <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint(), next = getint(), weight = getint();</span><br><span class="line">        head[prev].push_back(Edge(next, weight));</span><br><span class="line">        head[next].push_back(Edge(prev, weight));</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我推式子推了半个小时。。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>TopCoder 13955《WalkOverATree》</title>
    <link href="https://blog.handwer-std.top/2019-07-31/TopCoder13955/"/>
    <id>https://blog.handwer-std.top/2019-07-31/TopCoder13955/</id>
    <published>2019-07-31T14:58:03.000Z</published>
    <updated>2019-08-07T13:12:09.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h1><p>Given is a tree on n nodes. The nodes are numbered 0 through n-1. You are given the description of the tree as a int[]  <strong>parent</strong>  with n-1 elements. For each valid i, there is an edge between vertices (i+1) and  <strong>parent</strong>[i].</p><a id="more"></a><p>A person is currently standing in node 0. In a single step, the person can move from its current node to any adjacent node. You are given an int  <strong>L</strong>. The person is allowed to make at most  <strong>L</strong>  steps.</p><p>Return the maximum number of nodes the person can visit during the walk. Node 0 (where the walk starts) and the node where the walk ends count as visited. Each visited node is only counted once, even if it is visited multiple times.</p><h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><p>Class: WalkOverATree<br>Method: maxNodesVisited<br>Parameters: int[], int<br>Returns: int<br>Method signature: int maxNodesVisited(int[] parent, int L)<br>(be sure your method is public)</p><h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><ul><li><p><strong>parent</strong>  will contain between 0 and 49 elements, inclusive.</p></li><li><p>For each i,  <strong>parent</strong>[i] will be between 0 and i, inclusive.</p></li><li><p><strong>L</strong>  will be between 1 and 100, inclusive.</p></li></ul><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>请自行到 vjudge 上寻找</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>英文很好懂，只需人教初二水平（反正我准初三选手看懂了）</p><p>题目大意：<br>给定一棵 n 个点的树，编号 0~n-1。连边方式以输入每个点的父亲给出，对于每个 i，有一条边连接点 (i+1) 和点 father[i]，而且 father[i] 是 (i+1) 的父亲。<br>有一个人站在点 0，可以向四周走不超过 L 步，求出这个人能经过多少不同的点</p><p>这题和 dp 有什么关系吗。。。</p><p>这题的难点大概就是 class 的使用和答案统计了吧</p><p>class 的使用可以参考<a href="https://blog.csdn.net/qq_31908675/article/details/81198751" target="_blank" rel="noopener">这里</a></p><p>答案统计和基本的思路见代码吧</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  TopCoder13955.cpp</span></span><br><span class="line"><span class="comment">//  Title: WalkOverATree</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt;= s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WalkOverATree</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 直接暴力就好了。。。</span></span><br><span class="line"><span class="comment">     * 一遍 DFS 预处理出所有的点的深度（根节点深度为 0）</span></span><br><span class="line"><span class="comment">     * 答案的输出见下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> depthWalk[MAXL];</span><br><span class="line">    <span class="keyword">int</span> maxstep = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>, <span class="keyword">int</span> step = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        depthWalk[root] = step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = head[root][i];</span><br><span class="line">            <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">            DFS(next, root, step + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNodesVisited</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        maxstep = L;</span><br><span class="line">        <span class="keyword">int</span> N = (<span class="keyword">int</span>) father.size() + <span class="number">1</span>; <span class="comment">// 把根节点算上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = N - <span class="number">1</span>; i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = (i + <span class="number">1</span>) + <span class="number">1</span>, next = father[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 编号整体加一</span></span><br><span class="line">            head[prev].push_back(next);</span><br><span class="line">            head[next].push_back(prev);</span><br><span class="line">        &#125;</span><br><span class="line">        DFS();</span><br><span class="line">        ans = *<span class="built_in">std</span>::max_element(depthWalk + <span class="number">1</span>, depthWalk + <span class="number">1</span> + N);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; L) <span class="keyword">return</span> L + <span class="number">1</span>; <span class="comment">// 能走的最长的路径已经超过了 L，直接返回 L + 1（把根节点算上）</span></span><br><span class="line">        ans = <span class="built_in">std</span>::min(N, ans + <span class="number">1</span> + (L - ans) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// ans + 1：走过的最长路径加上根节点</span></span><br><span class="line">        <span class="comment">// L - ans：剩下能走的路径，不能浪费</span></span><br><span class="line">        <span class="comment">// (L - ans) / 2：需要一半的路径来折返</span></span><br><span class="line">        <span class="comment">// 注意：剩下的 L - ans 这些路径可以在任何地方用来走，不只是用来在最深的点折返</span></span><br><span class="line">        <span class="comment">// 还有一种情况：所有的点都走完了，还有步数</span></span><br><span class="line">        <span class="comment">// 这时候答案就不会再继续累加了</span></span><br><span class="line">        <span class="comment">// 这种情况下 ans 就要对 N 取个 min</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得最后提交的时候不要带 main 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> int main() &#123;</span></span><br><span class="line"><span class="comment"> std::vector&lt;int&gt; fa;</span></span><br><span class="line"><span class="comment"> fa.clear();</span></span><br><span class="line"><span class="comment"> int x = 0;</span></span><br><span class="line"><span class="comment"> while (true) &#123;</span></span><br><span class="line"><span class="comment"> cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment"> if (x == -1) break;</span></span><br><span class="line"><span class="comment"> fa.push_back(x);</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> int l = 0;</span></span><br><span class="line"><span class="comment"> cin &gt;&gt; l;</span></span><br><span class="line"><span class="comment"> WalkOverATree wk;</span></span><br><span class="line"><span class="comment"> cout &lt;&lt; wk.maxNodesVisited(fa, l) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"> return 0;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Statement&quot;&gt;&lt;a href=&quot;#Problem-Statement&quot; class=&quot;headerlink&quot; title=&quot;Problem Statement&quot;&gt;&lt;/a&gt;Problem Statement&lt;/h1&gt;&lt;p&gt;Given is a tree on n nodes. The nodes are numbered 0 through n-1. You are given the description of the tree as a int[]  &lt;strong&gt;parent&lt;/strong&gt;  with n-1 elements. For each valid i, there is an edge between vertices (i+1) and  &lt;strong&gt;parent&lt;/strong&gt;[i].&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="TopCoder" scheme="https://blog.handwer-std.top/tags/TopCoder/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2519《[HAOI2011]problem a》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/Luogu-P2519-BZOJ2298/"/>
    <id>https://blog.handwer-std.top/2019-07-30/Luogu-P2519-BZOJ2298/</id>
    <published>2019-07-30T14:38:23.000Z</published>
    <updated>2019-07-30T15:27:14.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人类智慧题</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一次考试共有n个人参加，第i个人说：“有ai个人分数比我高，bi个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个整数n，接下来n行每行两个整数，第i+1行的两个整数分别代表ai、bi</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>一个整数，表示最少有几个人说谎</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3  </span><br><span class="line">2 0  </span><br><span class="line">0 2    </span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我个人对「人类智慧题」的定义是「运用人脑求特殊解也想不出来的问题」</p><p>第一眼看到这题的时候，我一脸问号<br>直到老师开始讲题……</p><hr><p>首先，把题目转化一下<br>对于每个学生，给定了有多少人成绩比他好，成绩比他差，那就把它转化为一个成绩区间，表示这个区间内的人（可能只有 1 个）成绩相同</p><p>然后考虑一下「假话」的判断方式</p><ol><li>成绩比他好的 + 成绩比他差的 + 他 &gt; 总人数<br>这个请自行理解</li><li>两个有交集的区间没有完全相同，那么两个区间必有一个是假话<br>这个很显然吧，就是两个区间有交集的话说明它们是一个成绩，然而小于这个成绩的人或大于这个成绩的人却不相同</li><li>对于一堆完全相同的区间，它们之间是真话的个数至多是[区间长度]个，超出的部分全都是假话<br>想一想区间长度的现实意义是什么：有[区间长度]个学生成绩相同。那么，一个成绩是有[区间长度]个人的，也就是说，至多有[区间长度]个属于这个区间对应的成绩的学生在说真话（可以看作他们的成绩属于这个区间对应的成绩），剩下的学生都在说假话。<br>这样说应该会好理解一些吧……实在不行我举个例子：[2,4]，意味着这个区间对应的成绩有 3 个人获得了，那么如果有 4 个人说“我获得了这个成绩”，那么肯定有 1 个人在说假话。</li></ol><p>经过筛选，区间数量减少了一些，再去个重，把相同的区间个数用权值的形式表示出来（对每种区间分配唯一 id），比如说我有三个[2,4]和一个[7,8]，我就可以对[2,4]这个区间加一个权值 3，对[7,8]这个区间加一个权值 1。</p><hr><p>那么问题现在变成了：带权值的线段覆盖，求最大权值和</p><p>这个就是一个 dp 问题了</p><p>下面这一段也是从我代码里复制过来的（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设 F[i] 表示选择右端点不超过 i 的最大权值</span><br><span class="line">// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话</span><br><span class="line">// 初始：F[i] = F[i - 1]</span><br><span class="line">// 转移：当 i 点为某一线段的右端点时，</span><br><span class="line">// F[i] = max(F[i], F[j - 1] + Weight)</span><br><span class="line">// 其中 j 为该线段的左端点，Weight 为该线段的权值</span><br><span class="line">// (j - 1) 是因为线段不能重叠</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>代码里有很多注释，应该会很好理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2519.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2011]problem a</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ2298</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, w;</span><br><span class="line">    </span><br><span class="line">    Segment(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : l(l), r(r), w(w) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Segment &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == that.r) <span class="keyword">return</span> l &lt; that.l;</span><br><span class="line">        <span class="keyword">return</span> r &lt; that.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; segt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Ls[MAXN], Rs[MAXN], Ws[MAXN];</span><br><span class="line"><span class="comment">// segt 记录读入后经过处理的线段，Ls, Rs, Ws 记录去重后的线段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt, cntnew;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="comment">// 将给定的数据转化为学生 i 的排名</span></span><br><span class="line">        <span class="comment">// 用区间[l,r]的形式表示（按成绩排名）第 l 个人到第 r 个人成绩相同</span></span><br><span class="line">        <span class="comment">// 考虑把所有完全相同的线段记为单个带权值的线段</span></span><br><span class="line">        <span class="comment">// 那么问题就变为了一个带权线段覆盖问题</span></span><br><span class="line">        <span class="keyword">if</span> (l + r &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 学生数量不合法，显然是错的</span></span><br><span class="line">        ++l; r = (n - ((r + <span class="number">1</span>) - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 避免出现左端点为 0 的情况，因为读入的 l 有可能是 0</span></span><br><span class="line">        segt[++cnt] = Segment(l, r); <span class="comment">// 记一下目前合法的线段数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(segt + <span class="number">1</span>, segt + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(segt[i].l == segt[i - <span class="number">1</span>].l &amp;&amp; segt[i].r == segt[i - <span class="number">1</span>].r)) ++cntnew;</span><br><span class="line">        <span class="comment">// 两条线段如果重合，就增加该线段的权值</span></span><br><span class="line">        <span class="comment">// 两条线段如果不重合，就新开一条线段</span></span><br><span class="line">        <span class="comment">// 本质是一个去重并合并权值的过程</span></span><br><span class="line">        Ws[cntnew] = <span class="built_in">std</span>::min((segt[i].r - segt[i].l + <span class="number">1</span>), Ws[cntnew] + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 重合的线段表示有(线段长度)个人是相同成绩的</span></span><br><span class="line">        <span class="comment">// 所以每组重合线段（按线段长度分组）的个数如果超过了它的长度</span></span><br><span class="line">        <span class="comment">// 则超出去的那部分必定是假话</span></span><br><span class="line">        Ls[cntnew] = segt[i].l; Rs[cntnew] = segt[i].r;</span><br><span class="line">        <span class="comment">// 记一下去重后的线段</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 设 F[i] 表示选择右端点不超过 i 的最大权值</span></span><br><span class="line">        <span class="comment">// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话</span></span><br><span class="line">        <span class="comment">// 初始：F[i] = F[i - 1]</span></span><br><span class="line">        <span class="comment">// 转移：当 i 点为某一线段的右端点时，</span></span><br><span class="line">        <span class="comment">// F[i] = max(F[i], F[j - 1] + Weight)</span></span><br><span class="line">        <span class="comment">// 其中 j 为该线段的左端点，Weight 为该线段的权值</span></span><br><span class="line">        <span class="comment">// (j - 1) 是因为线段不能重叠</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= cntnew &amp;&amp; Rs[j] == i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">std</span>::max(dp[i], dp[Ls[j] - <span class="number">1</span>] + Ws[j]);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于 F[i] 表示说真话的数量，所以答案为学生的数量 - 说真话的数量</span></span><br><span class="line">    <span class="comment">// 也就是 n - dp[n]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人类智慧题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://blog.handwer-std.top/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>CF816E / CF815C《Karen and Supermarket》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/CF816E-CF815C/"/>
    <id>https://blog.handwer-std.top/2019-07-30/CF816E-CF815C/</id>
    <published>2019-07-30T11:45:09.000Z</published>
    <updated>2019-07-30T12:09:15.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>On the way home, Karen decided to stop by the supermarket to buy some groceries.</p><a id="more"></a><p><img src="https://vj.ti12z.cn/7bda7944615fd91edd669116f72aa574?v=1564372682" alt=""></p><p>She needs to buy a lot of goods, but since she is a student her budget is still quite limited. In fact, she can only spend up to  $b$  dollars.</p><p>The supermarket sells  $n$  goods. The  $i$-th good can be bought for  $c_i$  dollars. Of course, each good can only be bought once.</p><p>Lately, the supermarket has been trying to increase its business. Karen, being a loyal customer, was given  $n$  coupons. If Karen purchases the  $i$-th good, she can use the  $i$-th coupon to decrease its price by  $d_i$. Of course, a coupon cannot be used without buying the corresponding good.</p><p>There is, however, a constraint with the coupons. For all  $i≥ 2$, in order to use the  $i$-th coupon, Karen must also use the  $x_i$ -th coupon (which may mean using even more coupons to satisfy the requirement for that coupon).</p><p>Karen wants to know the following. What is the maximum number of goods she can buy, without exceeding her budget  $b$?</p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>The first line of input contains two integers  nn  and  bb  (  1&lt;=n&lt;=50001&lt;=n&lt;=5000  ,  1&lt;=b&lt;=10^{9}1&lt;=b&lt;=109  ), the number of goods in the store and the amount of money Karen has, respectively.</p><p>The next  nn  lines describe the items. Specifically:</p><ul><li>The  ii  -th line among these starts with two integers,  c_{i}ci​  and  d_{i}di​  (  1&lt;=d_{i}&lt;c_{i}&lt;=10^{9}1&lt;=di​&lt;ci​&lt;=109  ), the price of the  ii  -th good and the discount when using the coupon for the  ii  -th good, respectively.</li><li>If  i&gt;=2i&gt;=2  , this is followed by another integer,  x_{i}xi​  (  1&lt;=x_{i}&lt;i1&lt;=xi​&lt;i  ), denoting that the  x_{i}xi​  -th coupon must also be used before this coupon can be used.</li></ul><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>Output a single integer on a line by itself, the number of different goods Karen can buy, without exceeding her budget.</p><h3 id="Input-Output-Samples"><a href="#Input-Output-Samples" class="headerlink" title="Input / Output Samples"></a>Input / Output Samples</h3><p><strong>Input #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 16</span><br><span class="line">10 9</span><br><span class="line">10 5 1</span><br><span class="line">12 2 1</span><br><span class="line">20 18 3</span><br><span class="line">10 2 3</span><br><span class="line">2 1 5</span><br></pre></td></tr></table></figure><p><strong>Output #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>Input #2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 10</span><br><span class="line">3 1</span><br><span class="line">3 1 1</span><br><span class="line">3 1 2</span><br><span class="line">3 1 3</span><br><span class="line">3 1 4</span><br></pre></td></tr></table></figure><p><strong>Output #2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>从代码里复制过来的（</p><p>一道树形 DP</p><p>显然优惠券的使用逻辑可以构成一棵树<br>设 $\text{f[i][j][0/1]}$ 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费<br>初始状态：</p><p>$\text{f[][][] = INF}$<br>$\text{f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read}$</p><p>转移方程：<br>$\text{f[root][i + j][0] = min{ f[root][i + j][0], f[root][i][0] + f[u][j][0] | u} \in subtree(root) \ }$<br>$\text{f[root][i + j][1] = min{ f[root][i + j][1], f[root][i][1] + min{ f[u][j][0], f[u][j][1] } | u}  \in subtree(root)\ }$</p><p>其中 $i \leq \text{size[root]}, j \leq \text{size[u]}$，i 需要倒序枚举来避免重复选商品</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CF816E.cpp</span></span><br><span class="line"><span class="comment">//  Title: Karen and Supermarket</span></span><br><span class="line"><span class="comment">//  Alternatives: CF815C</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/30.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="comment">// CodeForces 中请使用 %I64d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 显然优惠券的使用逻辑可以构成一棵树</span></span><br><span class="line"><span class="comment"> * 设 f[i][j][0/1] 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费</span></span><br><span class="line"><span class="comment"> * 初始状态：</span></span><br><span class="line"><span class="comment"> * f[][][] = INF</span></span><br><span class="line"><span class="comment"> * f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read</span></span><br><span class="line"><span class="comment"> * 转移方程：</span></span><br><span class="line"><span class="comment"> * f[root][i + j][0] = min&#123; f[root][i + j][0], f[root][i][0] + f[u][j][0] | u 为 root 的孩子 &#125;</span></span><br><span class="line"><span class="comment"> * f[root][i + j][1] = min&#123; f[root][i + j][1], f[root][i][1] + min&#123; f[u][j][0], f[u][j][1] &#125; | u 为 root 的孩子 &#125;</span></span><br><span class="line"><span class="comment"> * 其中 i &lt;= size[root], j &lt;= size[u]，i 需要倒序枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">lli dp[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> size[MAXN];</span><br><span class="line"><span class="comment">// dp 数组耗空间约 383MB</span></span><br><span class="line"><span class="comment">// size 数组耗空间约 20KB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : head[u]) &#123;</span><br><span class="line">        DFS(v, u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size[u]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= size[v]; ++j) &#123;</span><br><span class="line">                dp[u][i + j][<span class="number">0</span>] = <span class="built_in">std</span>::min(</span><br><span class="line">                    dp[u][i + j][<span class="number">0</span>],</span><br><span class="line">                    dp[u][i][<span class="number">0</span>] + dp[v][j][<span class="number">0</span>]</span><br><span class="line">                );</span><br><span class="line">                dp[u][i + j][<span class="number">1</span>] = <span class="built_in">std</span>::min(</span><br><span class="line">                    dp[u][i + j][<span class="number">1</span>],</span><br><span class="line">                    dp[u][i][<span class="number">1</span>] + <span class="built_in">std</span>::min(</span><br><span class="line">                        dp[v][j][<span class="number">0</span>],</span><br><span class="line">                        dp[v][j][<span class="number">1</span>]</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); b = getint();</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">0</span>] = getll();</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>][<span class="number">0</span>] - getll();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = getint();</span><br><span class="line">            head[next].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="keyword">int</span> i = n;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][i][<span class="number">0</span>] &lt;= b || dp[<span class="number">1</span>][i][<span class="number">1</span>] &lt;= b) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;On the way home, Karen decided to stop by the supermarket to buy some groceries.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://blog.handwer-std.top/tags/Codeforces/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2218《[HAOI2007]覆盖问题》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/Luogu-P2218-BZOJ1052/"/>
    <id>https://blog.handwer-std.top/2019-07-30/Luogu-P2218-BZOJ1052/</id>
    <published>2019-07-30T00:14:10.000Z</published>
    <updated>2019-07-30T00:34:54.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>某人在山上种了N棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用3个L*L的正方形塑料薄膜将小树遮起来。</p><a id="more"></a><p>我们不妨将山建立一个平面直角坐标系，设第i棵小树的坐标为（Xi,Yi），3个L*L的正方形的边要求平行 与坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求L最小值。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有一个正整数N，表示有多少棵树。</p><p>接下来有N行，第i+1行有2个整数Xi,Yi，表示第i棵树的坐标，保证不会有2个树的坐标相同。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一行，输出最小的L值。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 1</span><br><span class="line">0 -1</span><br><span class="line">1 0</span><br><span class="line">-1 0</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>数据范围</p><p>100%的数据，-1,000,000,000&lt;=Xi,Yi&lt;=1,000,000,000</p><p>30%的数据，N&lt;=100</p><p>50%的数据，N&lt;=2000</p><p>100%的数据，N&lt;=20000</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然答案具有单调性，因为边长为 k 的正方形能覆盖的话，边长为 k + 1 的正方形一定能覆盖<br>考虑二分答案</p><hr><p>首先用一个最小的矩形覆盖所有的点</p><p>很容易想到一个做法：先把矩形的左上角、右下角用正方形覆盖，再把中间的用正方形覆盖<br>然而这样是不行的，反例很多，这里就不写了<br>但是换个思路，矩形的四个角一定会有贴着边放的正方形</p><p>所以换一个做法：枚举矩形的四个角，放正方形；此时还剩下一些点，再找一个最小的矩形覆盖所有点，递归进去做即可，深度只有 3 层</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2218.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2007]覆盖问题</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ1052</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">lli n, maxx = -(<span class="number">0x3f3f3f3f</span>), minx = (<span class="number">0x3f3f3f3f</span>), maxy = -(<span class="number">0x3f3f3f3f</span>), miny = (<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">lli x[MAXN], y[MAXN];</span><br><span class="line"><span class="keyword">int</span> cov[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 确定一个最小的矩形使得这个矩形可以覆盖所有点。</span></span><br><span class="line"><span class="comment"> * 枚举这个矩形的四个角，把一个正方形放到这个角上，</span></span><br><span class="line"><span class="comment"> * 有一些点会被覆盖，此时递归进去确定剩下未被覆盖的点即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Cover(<span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> ly, <span class="keyword">int</span> ry, <span class="keyword">int</span> ts) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!cov[i]</span><br><span class="line">            &amp;&amp; lx &lt;= x[i] &amp;&amp; x[i] &lt;= rx</span><br><span class="line">            &amp;&amp; ly &lt;= y[i] &amp;&amp; y[i] &lt;= ry)</span><br><span class="line">            cov[i] = ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Uncover</span><span class="params">(<span class="keyword">int</span> ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cov[i] == ts)</span><br><span class="line">            cov[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _CHECK(<span class="keyword">int</span> mid, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">    lli minx = INF, maxx = -INF, miny = INF, maxy = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!cov[i]) &#123;</span><br><span class="line">            minx = min(minx, x[i]); maxx = max(maxx, x[i]);</span><br><span class="line">            miny = min(miny, y[i]); maxy = max(maxy, y[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (max(maxx - minx, maxy - miny) &lt;= mid) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    _Cover(minx, minx + mid, miny, miny + mid, depth); <span class="comment">// ld</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(minx, minx + mid, maxy - mid, maxy, depth); <span class="comment">// lu</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(maxx - mid, maxx, miny, miny + mid, depth); <span class="comment">// rd</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(maxx - mid, maxx, maxy - mid, maxy, depth); <span class="comment">// ru</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cov, <span class="number">0</span>, <span class="keyword">sizeof</span> cov);</span><br><span class="line">    <span class="keyword">return</span> _CHECK(mid, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; x[i] = getint(); y[i] = getint(); &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;某人在山上种了N棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用3个L*L的正方形塑料薄膜将小树遮起来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="贪心" scheme="https://blog.handwer-std.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="递归" scheme="https://blog.handwer-std.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2341《[HAOI2006]受欢迎的牛》</title>
    <link href="https://blog.handwer-std.top/2019-07-29/Luogu-P2341-BZOJ1051-LOJ10091/"/>
    <id>https://blog.handwer-std.top/2019-07-29/Luogu-P2341-BZOJ1051-LOJ10091/</id>
    <published>2019-07-29T14:40:15.000Z</published>
    <updated>2019-07-30T00:38:00.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Tarjan 缩点板子题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶</p><p>牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜</p><p>欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你</p><p>算出有多少头奶牛可以当明星。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行：两个用空格分开的整数：N和M</p><p>第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>第一行：单独一个整数，表示明星奶牛的数量</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>只有 3 号奶牛可以做明星</p><p>【数据范围】</p><p>10%的数据N&lt;=20, M&lt;=50</p><p>30%的数据N&lt;=1000,M&lt;=20000</p><p>70%的数据N&lt;=5000,M&lt;=50000</p><p>100%的数据N&lt;=10000,M&lt;=50000 </p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先把题目转化一下</p><p>显然能成为明星的奶牛<strong>们</strong>一定是互相喜欢的<br>那么可以这样想：能成为明星的奶牛们都是在一个强连通分量中的，这样意味着互相喜欢<br>所以问题转化为了求图中强连通分量大小，这个用 Tarjan 来完成</p><p>值得注意的是，把强连通分量缩点之后，所得的图一定是一个DAG（这是一个性质）（实际写代码的时候不需要重新建图）<br>回到题目，缩完点之后，强连通分量对应的点的出度一定为0，而且有且仅有强连通分量对应的点出度为 0，因为如果强连通分量对应的点出度大于 0，则连出去的边与其他的点连到强连通分量的边就构成了一个环，与上面的性质相矛盾</p><p>注意到强连通分量对应的点出度为 0，那么该图合法必须要保证只有一个强连通分量（想一想，为什么）</p><p>所以写代码的思路就大体形成了：<br>Tarjan求强连通分量大小➡️缩点求出度➡️判断强连通分量个数➡️输出0或者强连通分量大小</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2341.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2006]受欢迎的牛</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ1051-LOJ10091</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/28.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inStack[MAXN];</span><br><span class="line"><span class="keyword">int</span> rep[MAXM], ren[MAXM];</span><br><span class="line"><span class="comment">// 把输入数据存一下</span></span><br><span class="line"><span class="keyword">int</span> sizSC[MAXN], ode[MAXN];</span><br><span class="line"><span class="keyword">int</span> ftot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top, Stack[MAXN];</span><br><span class="line"><span class="keyword">int</span> col, timestamp, SC[MAXN];</span><br><span class="line"><span class="comment">// dfn：dfs的时间戳</span></span><br><span class="line"><span class="comment">// low：在点u的子树能到达的节点中dfn的最小值</span></span><br><span class="line"><span class="comment">// SC：点u属于哪一个强连通分量</span></span><br><span class="line"><span class="comment">// inStack：是否在栈中</span></span><br><span class="line"><span class="comment">// sizSC：该强连通分量的大小</span></span><br><span class="line"><span class="comment">// ode：该“点”的出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; head[x].push_back(y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    low[u] = dfn[u] = ++timestamp;</span><br><span class="line">    Stack[++top] = u;</span><br><span class="line">    inStack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            <span class="comment">// 没被访问过</span></span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inStack[v]) low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">        <span class="comment">// 意味着u的子树中没有能到达u的祖先的边，也就是找到了一个强连通分量</span></span><br><span class="line">        SC[u] = ++col;</span><br><span class="line">        inStack[u] = <span class="literal">false</span>;</span><br><span class="line">        ++sizSC[col];</span><br><span class="line">        <span class="keyword">while</span> (Stack[top] != u) &#123;</span><br><span class="line">            SC[Stack[top]] = col;</span><br><span class="line">            ++sizSC[col];</span><br><span class="line">            inStack[Stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        addEdge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="comment">// 对所有联通块进行tarjan</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[i].size(); j &lt; siz; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = head[i][j];</span><br><span class="line">            <span class="keyword">if</span> (SC[i] != SC[v]) ++ode[SC[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= col; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!ode[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans) &#123; <span class="built_in">printf</span>(<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">            ans = sizSC[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tm这题我调了2h</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Tarjan 缩点板子题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="Tarjan" scheme="https://blog.handwer-std.top/tags/Tarjan/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2606《排列计数》</title>
    <link href="https://blog.handwer-std.top/2019-07-21/Luogu-P2606/"/>
    <id>https://blog.handwer-std.top/2019-07-21/Luogu-P2606/</id>
    <published>2019-07-21T12:14:10.000Z</published>
    <updated>2019-07-24T00:06:24.698Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>披着数论皮的图论</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>称一个1,2,…,N的排列P1,P2…,Pn是Magic的，当且仅当2&lt;=i&lt;=N时，Pi&gt;Pi/2. 计算1，2，…N的排列中有多少是Magic的，答案可能很大，只能输出模P以后的值</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第一行包含两个整数 n和p，含义如上所述。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件中仅包含一个整数，表示计算1,2,⋯, N的排列中， Magic排列的个数模 p的值。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p>输入样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 23</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>100%的数据中，1 ≤N ≤ 10^6, P≤ 10^9，p是一个质数。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>考虑这么一个事情：<br><br>$P_i &gt; P_{i / 2}$放到一棵树上是什么？<br>把$P_i$看作第$i$个点的权值，那么…… <br>第$i$个点的权值比第$i/2$个点的权值要大，也就是第$i$个点的权值要比第$i \times 2$个点的权值要小……<br>想一想二叉树的表示方法……这好像是一个小根堆？</p><p>问题转化为了：求1-n的所有排列中，可以构成一个小根堆的排列的个数</p><p>考虑dp<br>设<code>dp[u]</code>表示以u为根结点分配1~size(u)的小根堆的方案数<br>转移：$$d p(x)=\left(\begin{array}{c}{\operatorname{sz}(x)-1} \ {\operatorname{sz}\left(u_{1}\right), s z\left(u_{2}\right), \ldots, s z\left(u_{r}\right)}\end{array}\right) \prod d p\left(u_{i}\right)$$</p><p>最终答案就是$dp(1)$</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>我开了O2才过。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n, HA, fac[MAXN], inv[MAXN], siz[MAXN], dp[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">long long int getll() &#123; </span></span><br><span class="line"><span class="comment">    long long int s = 0, x = 1; </span></span><br><span class="line"><span class="comment">    char ch = getchar(); </span></span><br><span class="line"><span class="comment">    while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; </span></span><br><span class="line"><span class="comment">    while (isdigit(ch)) &#123; s = s * x + 1ll * ch - 1ll * '0'; ch = getchar(); &#125; </span></span><br><span class="line"><span class="comment">    return 1ll * s * x; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void putll(long long int x) &#123; </span></span><br><span class="line"><span class="comment">    if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; </span></span><br><span class="line"><span class="comment">    putll(x / 10); putchar(x % 10 + '0'); </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a % HA;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % HA;</span><br><span class="line">        a = a * a % HA;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> m, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 洛谷上数据水不用 Lucas 定理</span></span><br><span class="line">    <span class="comment">// n! / (m!(n - m)!)</span></span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % HA * inv[n - m] % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    head[prev].push_back(next);</span><br><span class="line">    head[next].push_back(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> father = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    siz[root] = <span class="number">1</span>;</span><br><span class="line">    dp[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, ss = head[root].size(); i &lt; ss; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i];</span><br><span class="line">        <span class="keyword">if</span> (father == next) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(root, next);</span><br><span class="line">        siz[root] += siz[next];</span><br><span class="line">        dp[root] = <span class="number">1l</span>l * dp[root] * C(siz[next], siz[root] - <span class="number">1</span>) % HA * dp[next] % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n = getll(); HA = getll();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;n, &amp;HA);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % HA;</span><br><span class="line">        inv[i] = fastPow(fac[i], HA - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> lson = (i &lt;&lt; <span class="number">1</span>), rson = (i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (lson &lt;= n) addEdge(i, lson);</span><br><span class="line">        <span class="keyword">if</span> (rson &lt;= n) addEdge(i, rson);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="comment">//putll(dp[1] % HA);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>] % HA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;披着数论皮的图论&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>单调栈专项练习</title>
    <link href="https://blog.handwer-std.top/2019-07-21/MonotoneStack-Luogu-P1901-Luogu-P1823-Luogu-P2947/"/>
    <id>https://blog.handwer-std.top/2019-07-21/MonotoneStack-Luogu-P1901-Luogu-P1823-Luogu-P2947/</id>
    <published>2019-07-21T12:11:00.000Z</published>
    <updated>2019-07-22T10:21:25.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>单调数据结构</p></blockquote><a id="more"></a><h1 id="练习：洛谷P2947《Look-Up》"><a href="#练习：洛谷P2947《Look-Up》" class="headerlink" title="练习：洛谷P2947《Look Up》"></a>练习：洛谷P2947《Look Up》</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Farmer John’s N (1 &lt;= N &lt;= 100,000) cows, conveniently numbered 1..N, are once again standing in a row. Cow i has height H_i (1 &lt;= H_i &lt;= 1,000,000).</p><p>Each cow is looking to her left toward those with higher index numbers. We say that cow i ‘looks up’ to cow j if i &lt; j and H_i &lt; H_j. For each cow i, FJ would like to know the index of the first cow in line looked up to by cow i.</p><p>Note: about 50% of the test data will have N &lt;= 1,000.</p><p>约翰的N(1≤N≤10^5)头奶牛站成一排，奶牛i的身高是Hi(l≤Hi≤1,000,000)．现在，每只奶牛都在向右看齐．对于奶牛i，如果奶牛j满足i&lt;j且Hi&lt;Hj，我们可以说奶牛i可以仰望奶牛j． 求出每只奶牛离她最近的仰望对象．</p><p>Input</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><ul><li><p>Line 1: A single integer: N</p></li><li><p>Lines 2..N+1: Line i+1 contains the single integer: H_i</p></li></ul><p>第 1 行输入 N，之后每行输入一个身高 H_i。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><ul><li>Lines 1..N: Line i contains a single integer representing the smallest index of a cow up to which cow i looks. If no such cow exists, print 0.</li></ul><p>共 N 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 0。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">3 </span><br><span class="line">2 </span><br><span class="line">6 </span><br><span class="line">1 </span><br><span class="line">1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">3 </span><br><span class="line">0 </span><br><span class="line">6 </span><br><span class="line">6 </span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>FJ has six cows of heights 3, 2, 6, 1, 1, and 2.</p><p>Cows 1 and 2 both look up to cow 3; cows 4 and 5 both look up to cow 6; and cows 3 and 6 do not look up to any cow.</p><p>【输入说明】6 头奶牛的身高分别为 3, 2, 6, 1, 1, 2.</p><p>【输出说明】奶牛#1,#2 仰望奶牛#3，奶牛#4,#5 仰望奶牛#6，奶牛#3 和#6 没有仰望对象。</p><p>【数据规模】</p><p>对于 20%的数据： 1≤N≤10；</p><p>对于 50%的数据： 1≤N≤1,000；</p><p>对于 100%的数据：1≤N≤100,000；1≤H_i≤1,000,000；</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目就是说，依次给出一堆线段，求对于每条线段，第一个在它右面，长度大于它的线段的下标是多少<br>我们先来模拟一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1[===] 歪着看体验更佳（逃</span><br><span class="line">2[==]</span><br><span class="line">3[======]</span><br><span class="line">4[=]</span><br><span class="line">5[=]</span><br><span class="line">6[==]</span><br></pre></td></tr></table></figure><p>第一次，1号进来了，没有比它高的，让它等一会<br>第二次，2号进来了，它甚至比1号还低，对1号的答案没有什么影响，也让它等一会<br>第三次，3号进来了，它比1、2号都高！此时1、2号的答案都是3号，而且1、2号<strong>对于以后的线段答案是没有影响的</strong>，呆在队伍里已经没有什么用了，让它们出去即可<br>第四次、第五次，4号和5号依次进来，对3号的答案并没有什么影响<br>第六次，6号进来了，4号和5号的答案更新为6号，而且对以后的线段答案也是没有什么影响的（如果以后还有线段的话），出去即可<br>队伍里还有俩线段3和6，它们的答案没有被更新过，也就是没有答案</p><hr><p>这就是一个单调栈的工作流程，通过清除栈里的元素来维护单调性，而本题中第三次循环和第六次循环则是对于单调数据结构进行具体问题具体分析的关键点</p><p>可以看出，实质上是维护了一个单调不增的栈，在维护栈的单调性过程中求出了答案</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cow</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> height, id;</span><br><span class="line">    </span><br><span class="line">    Cow() : height(<span class="number">0</span>), id(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Cow(<span class="keyword">int</span> height, <span class="keyword">int</span> id) : height(height), id(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Cow&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = getint();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt; height) &#123;</span><br><span class="line">            <span class="comment">// stk.top().height &lt; height 维护栈内元素单调不增性</span></span><br><span class="line">            <span class="comment">// 如果 stk.top().height &gt; height 则单调性仍存在，不必维护</span></span><br><span class="line">            ans[stk.top().id] = i;</span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push((Cow) &#123; height, i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="巩固：洛谷P1901《发射站》"><a href="#巩固：洛谷P1901《发射站》" class="headerlink" title="巩固：洛谷P1901《发射站》"></a>巩固：洛谷P1901《发射站》</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>某地有 N 个能量发射站排成一行，每个发射站 i 都有不相同的高度 Hi，并能向两边（当 然两端的只能向一边）同时发射能量值为 Vi 的能量，并且发出的能量只被两边最近的且比 它高的发射站接收。</p><p>显然，每个发射站发来的能量有可能被 0 或 1 或 2 个其他发射站所接受，特别是为了安 全，每个发射站接收到的能量总和是我们很关心的问题。由于数据很多，现只需要你帮忙计 算出接收最多能量的发射站接收的能量是多少。</p><h2 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行：一个整数 N;</p><p>第 2 到 N+1 行：第 i+1 行有两个整数 Hi 和 Vi，表示第 i 个人发射站的高度和发射的能量值。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅一行，表示接收最多能量的发射站接收到的能量值，答案不超过 longint。</p><h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 </span><br><span class="line">3 5 </span><br><span class="line">6 10</span><br></pre></td></tr></table></figure><p>输出样例#1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>对于 40%的数据，1&lt;=N&lt;=5000；1&lt;=Hi&lt;=100000；1&lt;=Vi&lt;=10000;</p><p>对于 70%的数据，1&lt;=N&lt;=100000；1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000;</p><p>对于 100%的数据，1&lt;=N&lt;=1000000;1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000。</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>同样的，先来模拟一下这个过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1[====](2)</span><br><span class="line">2[===](5)</span><br><span class="line">3[======](10)</span><br></pre></td></tr></table></figure><p>第一次，1号发射站进来，它莫得其他发射站来传输能量<br>第二次，2号发射站进来，它可以给1号传输能量<br>第三次，3号发射站进来：<br>2号发射站可以给3号发射站传输能量，1号发射站亦可。由于这两个发射站对于其他发射站的答案已经没有贡献，自己的答案也确定了，让它们出去即可</p><hr><p>本质上也是维护了一个单调递减的栈，在维护单调性的同时确定答案</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Launcher</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> height; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> energy;</span><br><span class="line">    <span class="comment">// height: 该发射站的高度</span></span><br><span class="line">    <span class="comment">// energy: 该发射站的能量强度</span></span><br><span class="line">    Launcher() &#123; id = height = energy = <span class="number">0</span>; &#125;</span><br><span class="line">    Launcher(<span class="keyword">int</span> id, <span class="keyword">int</span> height, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> energy) : id(id), height(height), energy(energy) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans[MAXN]; <span class="comment">// 答案不超过 long int</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Launcher&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = getint();</span><br><span class="line">        <span class="keyword">int</span> energy = getint();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt; h) &#123;</span><br><span class="line">            ans[i] += stk.top().energy; <span class="comment">// 栈顶对应的发射站能「向右」发射能量到当前的发射站</span></span><br><span class="line">            stk.pop(); <span class="comment">// 维护栈的单调递减性</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stk.empty()) ans[stk.top().id] += energy; <span class="comment">// 当前发射站能「向左」发射能量到栈顶对应的发射站</span></span><br><span class="line">        stk.push((Launcher) &#123; i, h, energy &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>) *<span class="built_in">std</span>::max_element(ans + <span class="number">1</span>, ans + <span class="number">1</span> + n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="提高：洛谷P1823《Patrik-音乐会的等待》"><a href="#提高：洛谷P1823《Patrik-音乐会的等待》" class="headerlink" title="提高：洛谷P1823《Patrik 音乐会的等待》"></a>提高：洛谷P1823《Patrik 音乐会的等待》</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>N个人正在排队进入一个音乐会。人们等得很无聊，于是他们开始转来转去，想在队伍里寻找自己的熟人。队列中任意两个人A和B，如果他们是相邻或他们之间没有人比A或B高，那么他们是可以互相看得见的。</p><p>写一个程序计算出有多少对人可以互相看见。</p><h2 id="输入输出格式-2"><a href="#输入输出格式-2" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个整数N (1 ≤ N ≤ 500 000), 表示队伍中共有N个人。</p><p>接下来的N行中，每行包含一个整数，表示人的高度，以毫微米(等于10的-9次方米)为单位，每个人的调度都小于2^31毫微米。这些高度分别表示队伍中人的身高。</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅有一行，包含一个数S，表示队伍中共有S对人可以互相看见。</p><h2 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">2 </span><br><span class="line">4 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">2 </span><br><span class="line">5 </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>输出样例#1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>依然来模拟一下：，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1[==]</span><br><span class="line">2[====]</span><br><span class="line">3[=]</span><br><span class="line">4[==]</span><br><span class="line">5[==]</span><br><span class="line">6[=====]</span><br><span class="line">7[=]</span><br></pre></td></tr></table></figure><p>第一次，1号进入，它谁都望不到<br>第二次，2号进入，1、2号能互相看见，此时1号对答案已经没有贡献，出去即可<br>第三次，3号进入，2、3号能互相看见<br>第四次，4号进入，3、4号能互相看见，同时2、4号也可以互相看见，此时3号对答案已经没有贡献，出去即可<br>第五次……第六次……第七次……</p><hr><p>已经很明显了，依然是维护一个单调不增的栈，在维护元素单调性的同时更新答案<br>但是这里的代码实现有一定的技巧</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Height</span> &#123;</span></span><br><span class="line">    <span class="comment">// 按照顺序把相邻等高的人视为一组</span></span><br><span class="line">    <span class="keyword">int</span> height; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> amount;</span><br><span class="line">    <span class="comment">// height: 该组的高度</span></span><br><span class="line">    <span class="comment">// amount: 该组的人数</span></span><br><span class="line">    Height() &#123; height = amount = <span class="number">0</span>; &#125;</span><br><span class="line">    Height(<span class="keyword">int</span> height, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> amount) : height(height), amount(amount) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Height&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = getint();</span><br><span class="line">        Height hh = (Height) &#123; h, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt;= h) &#123;</span><br><span class="line">            ans += stk.top().amount; <span class="comment">// 当前人能够看见上一组整组的人</span></span><br><span class="line">            <span class="keyword">if</span> (stk.top().height == h) hh.amount += stk.top().amount; <span class="comment">// 如果两组人等高，就把两组人归到一组去</span></span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stk.empty()) ++ans;</span><br><span class="line">        <span class="comment">// 在放当前的人进栈之前，如果栈非空，说明栈顶这个人是能看见当前的人的</span></span><br><span class="line">        stk.push(hh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="comment">// C(100000, 2) &gt; (1 &lt;&lt; 31)</span></span><br><span class="line">    <span class="comment">// 答案超过 int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;单调数据结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="专项练习" scheme="https://blog.handwer-std.top/tags/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/"/>
    
      <category term="单调栈" scheme="https://blog.handwer-std.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3884 洛谷P4139《上帝与集合的正确用法》</title>
    <link href="https://blog.handwer-std.top/2019-07-18/BZOJ3884-Luogu-P4139/"/>
    <id>https://blog.handwer-std.top/2019-07-18/BZOJ3884-Luogu-P4139/</id>
    <published>2019-07-18T12:49:05.000Z</published>
    <updated>2019-07-21T02:33:37.607Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  $2^{2^{2^{2^{2^{…}}}}}$</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>根据一些书上的记载，上帝的一次失败的创世经历是这样的：<br>第一天，    上帝创造了一个世界的基本元素，称做“元”。<br>第二天，    上帝创造了一个新的元素，称作“α”。“α”被定义为“元”构成的集合。容易发现，一共有两种不同的“α”。<br>第三天，    上帝又创造了一个新的元素，称作“β”。“β”被定义为“α”构成的集合。容易发现，一共有四种不同的“β”。<br>第四天，    上帝创造了新的元素“γ”，“γ”被定义为“β”的集合。显然，一共会有16种不同的“γ”。<br>如果按照这样下去，上帝创造的第四种元素将会有65536种，第五种元素将会有2^65536种。这将会是一个天文数字。<br>然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……<br>然而不久，当上帝创造出最后一种元素“θ”时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。<br>至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素“θ”一共有多少种？<br>上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对p取模后的值即可。<br>你可以认为上帝从“α”到“θ”一共创造了10^9次元素，或10^18次，或者干脆∞次。<br>一句话题意：<br>求 $2^{2^{2^{2^{2^{…}}}}}\bmod p$的值</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>接下来T行，每行一个正整数p，代表你需要取模的值</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>T行，每行一个正整数，为答案对p取模后的值</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h1><p>对于100%的数据，T&lt;=1000,p&lt;=10^7</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>一开始看到这个题目，我是懵逼的</p><p>这题让我们求$2^\infty\bmod p$的值，考虑把它转化一下</p><p>根据扩展欧拉定理可知<br>$$<br>a ^ b= \begin{cases} a ^ {b \bmod \varphi(p)} \quad &amp; \gcd(a,p)=1 \ a ^ b \quad &amp; \gcd(a,p) \not=1, b &lt; \varphi(p)\ a ^ {b \bmod \varphi(p) + \varphi (p)} \quad &amp; \gcd(a,p) \not=1, b \ge \varphi(p)\ \end{cases}<br>$$<br>所以把它变成第三条的形式<br>$$<br>2^{2^{2^{2^{2^{…}}}}}\bmod p=2^{2^{2^{2^{2^{…}}}} \bmod \varphi(p) + \varphi(p)}<br>$$<br>把第一个2的指数摘出来单独康一康<br>$$<br>2^{2^{2^{2^{…}}}} \bmod \varphi(p) + \varphi(p)<br>$$<br>设$\varphi(p) + \varphi(p) = a$，上式变为<br>$$<br>2^{2^{2^{2^{…}}}} \bmod a<br>$$<br>好像在哪见过……那就再来一遍<br>$$<br>2^{2^{2^{2^{2^{…}}}}}\bmod a=2^{2^{2^{2^{2^{…}}}} \bmod \varphi(a) + \varphi(a)}<br>$$<br>这是个递归式！</p><p>那么解法就很显然了：<br>根据扩展欧拉定理，把指数部分变形，然后递归进去继续变形指数部分的指数部分……</p><hr><p>找一找递归出口<br>在模$p$的意义下，一个数的取值范围是$[0,p-1]$<br>考虑让这个数变成定值，显然$p=1$时，这个数为$0$<br>这个就是递归出口，当模数为1时，返回0</p><p>求$\varphi(i)$建议使用根号算法，更快一些</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &amp; <span class="number">1</span>) ret = ret * x % p;</span><br><span class="line">        x = x * x % p;</span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = x, a = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123; <span class="comment">// 如果i是a的质因子</span></span><br><span class="line">            ret = ret / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i; <span class="comment">// 筛去所有的i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) ret = ret / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> pp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> pf = phi(pp);</span><br><span class="line">    <span class="keyword">return</span> fastPower(<span class="number">2</span>, solve(pf) + pf, pp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = getint();</span><br><span class="line">    countdown (T) &#123;</span><br><span class="line">        p = getll();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  $2^{2^{2^{2^{2^{…}}}}}$&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="EXGCD" scheme="https://blog.handwer-std.top/tags/EXGCD/"/>
    
  </entry>
  
</feed>
