<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Handwer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.handwer-std.top/"/>
  <updated>2019-10-16T05:29:24.841Z</updated>
  <id>https://blog.handwer-std.top/</id>
  
  <author>
    <name>Handwer STD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公告栏</title>
    <link href="https://blog.handwer-std.top/2019-10-31/BulletinBoard/"/>
    <id>https://blog.handwer-std.top/2019-10-31/BulletinBoard/</id>
    <published>2019-10-31T12:30:00.000Z</published>
    <updated>2019-10-16T05:29:24.841Z</updated>
    
    <content type="html"><![CDATA[<p><font style="color:#66ccff"></font></p><p><center>这里可能会挂些什么东西。 <br>There may be something here.<br></center><br><br><img src="https://v2.jinrishici.com/one.svg" alt="今日诗词"></p><!--博客累计已突破 100 篇文章--><!--New！[《「文章」百名学生参训 礼堂“变身”教室》](/2019-02-16/SDWC-Article/)--><p><center><a href="/2019-08-14/Articles-Moving-To-cnblogs/">《关于新开的 cnblogs 博客的一些说明》</a></center></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font style=&quot;color:#66ccff&quot;&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;这里可能会挂些什么东西。 &lt;br&gt;There may be something here.&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://v2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>「初赛」康托展开学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-10-17/Cantor-Expansion/"/>
    <id>https://blog.handwer-std.top/2019-10-17/Cantor-Expansion/</id>
    <published>2019-10-17T08:56:54.000Z</published>
    <updated>2019-10-17T13:30:36.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>康托展开</strong>是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</p><p style="text-align: right">——Wikipedia</p><a id="more"></a><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>直接给式子吧</p><p>对于一个长度为 $n$ 的排列，它在全排列中的排名为<br>$$x=1+a_{n}(n-1) !+a_{n-1}(n-2) !+\cdots+a_{1} \cdot 0 !$$<br>其中$a_i$为给定排列前 $i - 1$个数中 <strong>小于 $a_i$ 的</strong> <em>没有出现的</em> 数的数量</p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;1, 6, 4, 5, 3, 2&#125;</span><br><span class="line">那么</span><br><span class="line">a = &#123;0, 4&lt;2,3,4,5&gt;, 2&lt;2,3&gt;, 2&lt;2,3&gt;, 1&lt;2&gt;, 0&#125;</span><br><span class="line">其中&lt;&gt;里具体说明了是哪几个数</span><br><span class="line">此时 x = 114</span><br></pre></td></tr></table></figure></p><p>另外，$x-1$就是有多少个排列比给定排列要小。这个很显然。</p><h1 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h1><p>前面说了是可逆的，那么说一说怎么逆回去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">如n=5,x=96时：</span><br><span class="line"></span><br><span class="line">首先用96-1得到95，说明x之前有95个排列.(将此数本身减去1)</span><br><span class="line">用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.</span><br><span class="line">用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.</span><br><span class="line">用5去除2!得到2余1，类似地，这一位是3.</span><br><span class="line">用1去除1!得到1余0，这一位是2.</span><br><span class="line">最后一位只能是1.</span><br><span class="line">所以这个排列是&#123;4, 5, 3, 2, 1&#125;.</span><br><span class="line"></span><br><span class="line">再给一个例子：</span><br><span class="line">n = 6, x = 123</span><br><span class="line">123 / (5!) = 1...3</span><br><span class="line">3 / (4!) = 0...3</span><br><span class="line">...（结果都是0...3）</span><br><span class="line">3 / (2!) = 1...1</span><br><span class="line">1 / (1!) = 1...0</span><br><span class="line">0 / (0!) = 0...0</span><br><span class="line"></span><br><span class="line">所以最终排列为&#123;2, 1, 3, 5, 6, 4&#125;</span><br></pre></td></tr></table></figure><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>写这玩意有什么用？打开NOIP2018提高组初赛第21题看程序写输出，他要求的就是给定排列往后数t个得到的排列</p><p>使用这个方法就可以将给定排列转化为排名，加t之后再转化回排列，进而得到结果</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;康托展开&lt;/strong&gt;是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。&lt;/p&gt;
&lt;p style=&quot;text-align: right&quot;&gt;——Wikipedia&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="初赛" scheme="https://blog.handwer-std.top/tags/%E5%88%9D%E8%B5%9B/"/>
    
      <category term="排列" scheme="https://blog.handwer-std.top/tags/%E6%8E%92%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>树状数组学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-10-17/BinaryIndexedTree/"/>
    <id>https://blog.handwer-std.top/2019-10-17/BinaryIndexedTree/</id>
    <published>2019-10-17T07:38:38.000Z</published>
    <updated>2019-10-17T13:07:35.619Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>高效又好写的数据结构</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>树状数组</strong>或<strong>二叉索引树</strong>（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以${\displaystyle O(\log n)}$的时间得到任意前缀和${\displaystyle \sum _{i=1}^{j}A[i],1&lt;=j&lt;=N}$!，并同时支持在${\displaystyle O(\log n)}$时间内支持动态单点值的修改。空间复杂度${\displaystyle O(n)}$。</p><p style="text-align: right">——Wikipedia</p><p>简单的说，树状数组就是一个便于在 $O(\log n)$ 时间内维护一个数列 / 矩阵的前缀和，可以支持单点修改、查询，区间修改、查询的数据结构。</p><p>依据支持操作的不同（包含关系），我这里把它分为六类：</p><ul><li>支持序列单点加减、区间和查询的树状数组</li><li>支持序列区间加减、单点查询的树状数组</li><li>支持序列区间加减、区间和查询的树状数组</li><li>支持矩阵单点加减、子矩阵和查询的树状数组</li><li>支持矩阵的子矩阵加减、单点查询的树状数组</li><li>支持矩阵的子矩阵加减、子矩阵和查询的树状数组</li></ul><p>这些会一个一个的讲。</p><h1 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h1><h2 id="单点加减、区间和查询"><a href="#单点加减、区间和查询" class="headerlink" title="单点加减、区间和查询"></a>单点加减、区间和查询</h2><p>这个是最基础的树状数组，应该没有人不会吧……</p><p>原理就是通过维护前缀和，修改的时候像暴力维护前缀和一样一个一个往后加，不过每次增长的值不是1而是lowbit，其中“一个数取lowbit能跳到哪”这个关系连边后就形成了一个二叉搜索树。</p><blockquote><p>按照Peter M. Fenwick的说法，正如所有的整数都可以表示成2的幂和，我们也可以把一串序列表示成一系列子序列的和。采用这个想法，我们可将一个前缀和划分成多个子序列的和，而划分的方法与数的2的幂和具有极其相似的方式。一方面，子序列的个数是其二进制表示中1的个数，另一方面，子序列代表的f[i]的个数也是2的幂。</p><p style="text-align: right">——Wikipedia</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/17/KAb2Se.png" alt="KAb2Se.png"></p><p>比如说这一棵就是八个元素的树状数组，对照下面的表可以发现上面的连边规律（点下面的是编号，请自动忽略根节点 9 以及那条边）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1&apos;s lowbit = 1, 1 + lowbit = 2</span><br><span class="line">2&apos;s lowbit = 2, 2 + lowbit = 4</span><br><span class="line">3&apos;s lowbit = 1, 3 + lowbit = 4</span><br><span class="line">4&apos;s lowbit = 4, 4 + lowbit = 8</span><br><span class="line">5&apos;s lowbit = 1, 5 + lowbit = 6</span><br><span class="line">6&apos;s lowbit = 2, 6 + lowbit = 8</span><br><span class="line">7&apos;s lowbit = 1, 7 + lowbit = 8</span><br><span class="line">8&apos;s lowbit = 8, 8 + lowbit = 16</span><br><span class="line">9&apos;s lowbit = 1, 9 + lowbit = 10</span><br><span class="line">10&apos;s lowbit = 2, 10 + lowbit = 12</span><br></pre></td></tr></table></figure><p>那么代码就很容易写出来了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, tree[MAX_SIZE];</span><br><span class="line"><span class="comment">// n 为元素个数，tree[] 为树状数组维护的前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x) &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 pos 位置的数加上 x</span></span><br><span class="line">    <span class="keyword">for</span> (; pos &lt;= n; pos += lowbit(pos)) tree[pos] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询 [1,pos] 之间的数的和</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; pos &gt;= <span class="number">1</span>; pos -= lowbit(pos)) ret += tree[pos];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeQuery</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询 [l,r] 之间的数的和</span></span><br><span class="line">    <span class="keyword">return</span> Query(r) - Query(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间加减、单点查询"><a href="#区间加减、单点查询" class="headerlink" title="区间加减、单点查询"></a>区间加减、单点查询</h2><p>不知道你们有没有听说过一个东西叫做「差分」</p><p>定义差分数组 <code>d[i] = a[i] - a[i - 1]</code>，其中 <code>a[]</code> 表示原数列<br>那么对 <code>d[i]</code> 求一个前缀和就可以得出 <code>a[i]</code>的值了<br>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组下标从 0 开始，元素存储从 1 开始，a[0] = d[0] = 0</span><br><span class="line">a[] = &#123;0, 1, 3, 4, 2&#125;</span><br><span class="line">d[] = &#123;/, 1, 2, 2, -2&#125;</span><br></pre></td></tr></table></figure></p><p>发现了什么？<br>$$\sum_{i = 1}^{n} d_i = a_i$$</p><p>如何修改$\text{[L,R]}+x$？<br>先给结论：在$\text{L}$处$+x$，在$\text{R+1}$处$-x$<br>直观理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">下标从 1 开始。</span><br><span class="line">原数列：0 0 0 0 0 0</span><br><span class="line">按照上面的方法 [2,4]+x</span><br><span class="line">0 x 0 0 -x 0</span><br><span class="line">看看前缀和之后会发生什么……</span><br><span class="line">0 x x x 0 0</span><br><span class="line">！！！！！</span><br></pre></td></tr></table></figure></p><hr><p>而维护前缀和这种事情，树状数组最在行了</p><p>可以写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, a[MAXN], bit[MAXN];  </span><br><span class="line"><span class="comment">// n 为元素个数，a 为原数组，bit 为差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (; pos &lt;= n; pos += lowbit(pos)) bit[pos] += x;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rangeModify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Modify(l, x); Modify(r + <span class="number">1</span>, -x);</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (; pos &gt;= <span class="number">1</span>; pos -= lowbit(pos)) ret += bit[pos];  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> to n increase <span class="number">1</span>) &#123;  </span><br><span class="line">        read a[i]</span><br><span class="line">        rangeModify(i, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    read x, read y, read k </span><br><span class="line">    rangeModify(x, y, k);</span><br><span class="line">    <span class="comment">// 将 [x,y] 区间内的数加上 k  </span></span><br><span class="line">    ...</span><br><span class="line">    read k</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(k));  </span><br><span class="line">    <span class="comment">// 查询 k 位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间加减、区间和查询"><a href="#区间加减、区间和查询" class="headerlink" title="区间加减、区间和查询"></a>区间加减、区间和查询</h2><p><del>线段树天下第一</del><br>但是线段树难写、难调，常数还大，占空间还多。。。</p><p>如果你只需要区间加减、区间和查询，树状数组无疑是你最好的选择</p><hr><p>区间加减维护一下差分数组就行了</p><p>考虑区间和本质是</p><p>$$\sum_{a = 1}^{p}\sum_{i = 1}^{a}d_i$$</p><p>计算一下每个 $d_i$ 被算的次数，顺便把式子变换一下</p><p>$$\sum_{a = 1}^{p}d_a \times (p - a + 1)$$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">举个例子</span><br><span class="line">比如说 p = 5 时，可以发现 </span><br><span class="line">ans = </span><br><span class="line">d[1] + </span><br><span class="line">d[1] + d[2] +</span><br><span class="line">d[1] + d[2] + d[3] + </span><br><span class="line">d[1] + d[2] + d[3] + d[4] + </span><br><span class="line">d[1] + d[2] + d[3] + d[4] + d[5]</span><br><span class="line">找一找规律就可以搞出上面的式子了</span><br></pre></td></tr></table></figure><p>拆一下 $\sum$，可以变换成</p><p>$$(p + 1)\sum_{a = 1}^{p}d_a - \sum_{a = 1}^{p}d_a \times a$$</p><p>这样的话，只需要分别维护两个差分数组，一个记 $d_a$，一个记 $d_a \times a$ 就行</p><p>修改$\text{[L,R] + }x$的时候，像上面<a href="#区间加减、单点查询">区间加减、单点查询</a>一样，把 $\text{[L]} + x,\text{[R+1]} - x$（对两个数组进行的修改可以合并到 <code>Modify()</code> 函数中，具体见代码）<br>查询的时候像上面<a href="#单点加减、区间和查询">单点加减、区间和查询</a>一样，是前缀和作差</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码没有经过提交，仅进行了一些小样例测试！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;  </span><br><span class="line">lli ss[MAXN];  </span><br><span class="line">lli biti[MAXN], bitpi[MAXN];</span><br><span class="line"><span class="comment">// ss 表示原数组，biti 表示维护 d[a] 的数组， bitpi 表示维护 d[a] * a 的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> pos, lli x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> dx = pos;  </span><br><span class="line">    <span class="keyword">for</span> (; pos &lt;= n; pos += lowbit(pos)) &#123;  </span><br><span class="line">        <span class="comment">// 为了方便，可以把 rangeModify() 里的乘法挪到 Modify() 里面</span></span><br><span class="line">        biti[pos] += x; bitpi[pos] += x * <span class="number">1l</span>l * dx;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rangeModify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, lli x)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 这是把括号里的乘法挪到 Modify() 里面的写法</span></span><br><span class="line">    Modify(l, x); Modify(r + <span class="number">1</span>, -x);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function">lli <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;  </span><br><span class="line">    lli ret = <span class="number">0</span>, dx = pos;  </span><br><span class="line">    <span class="keyword">while</span> (pos &gt;= <span class="number">1</span>) &#123; ret += (dx + <span class="number">1</span>) * <span class="number">1l</span>l * biti[pos] - bitpi[pos]; pos -= lowbit(pos); &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function">lli <span class="title">rangeQuery</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> Query(r) - Query(l - <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h1><p>一维的操作都讲完了，那能不能把它推广到二维上面呢？答案是肯定的。<br>提前说一句，以下操作从访问$n$个元素变成了$nm$个元素，时间复杂度变为$O(\log(nm))$</p><h2 id="单点加减、子矩阵和查询"><a href="#单点加减、子矩阵和查询" class="headerlink" title="单点加减、子矩阵和查询"></a>单点加减、子矩阵和查询</h2><p>前面说过，树状数组是利用前缀和的思想进行实现的，既然二维也有前缀和，何不照葫芦画瓢把而为树状数组搞出来呢？</p><hr><p>先来复习一下。</p><p>$$\sum_{i = l}^{r} a_i = \sum_{i = 1}^{r} a_i - \sum_{i = 1}^{l - 1} a_i$$</p><p>为了方便，定义 $f(x,y)=\sum_{i = 1}^{x}\sum_{j = 1}^{y}a_{i,j}$</p><p>$$\sum_{i = x_1}^{x_2}\sum_{j = y_1}^{y_2}a_{i,j}=f(x_2,y_2)-f(x_1 - 1,y_2)-f(x_2,y_1-1)+f(x_1-1,y_1-1)$$</p><p>直观来看，</p><p><img src="https://s2.ax1x.com/2019/10/17/KE3Zkj.png" alt="KE3Zkj.png"></p><p>定义$\text{Sum}(a,b,c,d)$为以$(a,b)$为左下角，$(c,d)$为右上角（对于矩阵是反着的）的矩阵元素之和，那么很显然能看出 $\text{Sum}(5,4,7,5)=\text{Sum}(1,1,7,5)-\text{Sum}(1,1,7,3)-\text{Sum}(1,1,4,5)+\text{Sum}(1,1,4,3)$，也就是四边形$\text{ABCD}-\text{ABGI}-\text{AHFD}+\text{AHEI}$元素的值</p><p>二维树状数组和一位的除了多了一维之外没多大区别，手法从一维前缀和换到了二维前缀和</p><p>看代码就知道了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码没有经过提交，仅进行了一些小样例测试！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, bit[MAXN][MAXN];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 是不是和一维的手法差不多（逃</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += lowbit(x)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fy = y; fy &lt;= m; fy += lowbit(fy)) &#123;  </span><br><span class="line">            <span class="comment">// 说一个坑：这里不要对 y 进行直接修改</span></span><br><span class="line">            <span class="comment">// 因为下一次循环 x 的时候需要用 y</span></span><br><span class="line">            <span class="comment">// 我当初在这里栽坑调了快 10min。。。</span></span><br><span class="line">            bit[x][fy] += w;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (; x &gt;= <span class="number">1</span>; x -= lowbit(x)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fy = y; fy &gt;= <span class="number">1</span>; fy -= lowbit((fy))) &#123;  </span><br><span class="line">            ans += bit[x][fy];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matrixQuery</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// x1 &lt;= x2, y1 &lt;= y2  </span></span><br><span class="line">    <span class="keyword">int</span> a = Query(x2, y2);  </span><br><span class="line">    <span class="keyword">int</span> b = Query(x1 - <span class="number">1</span>, y2);  </span><br><span class="line">    <span class="keyword">int</span> c = Query(x2, y1 - <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">int</span> d = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> a - b - c + d;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子矩阵加减、单点查询"><a href="#子矩阵加减、单点查询" class="headerlink" title="子矩阵加减、单点查询"></a>子矩阵加减、单点查询</h2><p>还记得<a href="#区间加减、单点查询">区间加减、单点查询</a>吗？<br>接下来把它推广到二维！</p><hr><p>查询手法一样的，二维前缀和</p><p>如何修改$(x_1,y_1)\text{ to }(x_2,y_2)$？<br>先说结论：<br>$d[x_1][y_1] + x,d[x_1][y_2+1]-x,d[x_2+1][y_1]-x,d[x_2+1][y_2+1]+x$<br>直观理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">下标从 1 开始</span><br><span class="line">  1 2 3 4 5</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">2 0 0 0 0 0</span><br><span class="line">3 0 0 0 0 0</span><br><span class="line">4 0 0 0 0 0</span><br><span class="line">修改(1,2)-&gt;(4,3) + x</span><br><span class="line">  1  2  3  4  5</span><br><span class="line">1 0  0  0  0  0</span><br><span class="line">2 x  0  0  0 -x</span><br><span class="line">3 0  0  0  0  0</span><br><span class="line">4 -x 0  0  0  x</span><br><span class="line">前缀和：</span><br><span class="line">  1 2 3 4 5</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">2 x x x x 0</span><br><span class="line">3 x x x x 0</span><br><span class="line">4 0 0 0 0 0</span><br></pre></td></tr></table></figure></p><p>放代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码没有经过提交，仅进行了一些小样例测试！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, bit[MAXN][MAXN];  </span><br><span class="line"><span class="comment">// n,m 为矩阵大小，bit 为差分数组</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += lowbit(j)) &#123;  </span><br><span class="line">            bit[i][j] += w;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrixModify</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// x1 &lt;= x2  </span></span><br><span class="line">    Modify(x1, y1, w); Modify(x1, y2 + <span class="number">1</span>, -w);  </span><br><span class="line">    Modify(x2 + <span class="number">1</span>, y1, -w); Modify(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>, w);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i -= lowbit(i)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &gt;= <span class="number">1</span>; j -= lowbit(j)) &#123;  </span><br><span class="line">            ret += bit[i][j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子矩阵加减、子矩阵和查询"><a href="#子矩阵加减、子矩阵和查询" class="headerlink" title="子矩阵加减、子矩阵和查询"></a>子矩阵加减、子矩阵和查询</h2><p>最后一种操作，也是最难的操作</p><p>……其实并不难，如果你把前面都学懂了。</p><p>和<a href="#区间加减、区间和查询">区间加减、区间和查询</a>一样，先看看查询操作的本质</p><p>$$<br>\sum_{i=1}^{x} \sum_{j=1}^{y} \sum_{k=1}^{i} \sum_{h=1}^{j} d[h][k]<br>$$</p><p>先统计一下 $d[i][j]$ 被访问了多少次，然后<big><big>稍微</big></big>整理一下式子，变成</p><!--$${\sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times(x+1-i) \times(y+1-j)} \\= {(x+1)(y+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j]} \\ {-(y+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times i} \\ {-(x+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times j} \\ {\quad+\sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times i \times j}$$--><p><img src="https://s2.ax1x.com/2019/10/17/KEdzbq.png" alt="KEdzbq.png"></p><p>所以，实现区修区查需要维护四个差分数组！</p><ul><li>第一个：维护$d[i][j]$</li><li>第二个：维护$d[i][j]\times i$</li><li>第三个：维护$d[i][j]\times j$</li><li>第四个：维护$d[i][j]\times i\times j$</li></ul><p>接下来是<strong>完整</strong>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/10/17.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 洛谷 P4514 《上帝造题的七分钟》</span></span><br><span class="line"><span class="comment">// 常数略大。。开O2过的  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x &amp; (-x)))  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;  </span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2048</span> + <span class="number">10</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> n, m, q;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;  </span><br><span class="line">    <span class="keyword">int</span> d[MAXN][MAXN], di[MAXN][MAXN];  </span><br><span class="line">    <span class="keyword">int</span> dj[MAXN][MAXN], dij[MAXN][MAXN];  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += lowbit(j)) &#123;  </span><br><span class="line">                d[i][j] += w; di[i][j] += w * x;  </span><br><span class="line">                dj[i][j] += w * y; dij[i][j] += w * x * y;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">matrixModify</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">        Modify(x1, y1, w); Modify(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>, w);  </span><br><span class="line">        Modify(x1, y2 + <span class="number">1</span>, -w); Modify(x2 + <span class="number">1</span>, y1, -w);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i -= lowbit(i)) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &gt;= <span class="number">1</span>; j -= lowbit(j)) &#123;  </span><br><span class="line">                ret += d[i][j] * (x + <span class="number">1</span>) * (y + <span class="number">1</span>)  </span><br><span class="line">                       - (y + <span class="number">1</span>) * di[i][j]  </span><br><span class="line">                       - (x + <span class="number">1</span>) * dj[i][j]  </span><br><span class="line">                       + dij[i][j];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">matrixQuery</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = Query(x2, y2);  </span><br><span class="line">        <span class="keyword">int</span> b = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">int</span> c = Query(x1 - <span class="number">1</span>, y2);  </span><br><span class="line">        <span class="keyword">int</span> d = Query(x2, y1 - <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">return</span> a - c - d + b;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _s; <span class="built_in">cin</span> &gt;&gt; _s;  </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;  </span><br><span class="line"><span class="comment">//    rap (i, 1, n, 1) &#123;  </span></span><br><span class="line"><span class="comment">//        rap (j, 1, m, 1) &#123;  </span></span><br><span class="line"><span class="comment">//            int fx = 0;  </span></span><br><span class="line"><span class="comment">//            scanf("%d", &amp;fx);  </span></span><br><span class="line"><span class="comment">//            BIT::matrixModify(i, j, i, j, fx);  </span></span><br><span class="line"><span class="comment">//        &#125;  </span></span><br><span class="line"><span class="comment">//    &#125;  </span></span><br><span class="line">  <span class="keyword">char</span> ch = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch) &#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, d = <span class="number">0</span>;  </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;  </span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'L'</span>) &#123;  </span><br><span class="line">            <span class="keyword">int</span> delta = <span class="number">0</span>;  </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; delta;  </span><br><span class="line">            BIT::matrixModify(a, b, c, d, delta);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line"><span class="comment">//            scanf("\n");  </span></span><br><span class="line"><span class="comment">//            printf("%d\n", BIT::matrixQuery(a, b, c, d));  </span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; BIT::matrixQuery(a, b, c, d) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"><span class="comment">//        getchar();  </span></span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;高效又好写的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="树" scheme="https://blog.handwer-std.top/tags/%E6%A0%91/"/>
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="模版" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E7%89%88/"/>
    
  </entry>
  
  <entry>
    <title>HDU6108《小C的倍数问题》</title>
    <link href="https://blog.handwer-std.top/2019-10-13/HDU6108/"/>
    <id>https://blog.handwer-std.top/2019-10-13/HDU6108/</id>
    <published>2019-10-13T00:08:09.000Z</published>
    <updated>2019-10-16T05:25:23.035Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>真·小学数学</p></blockquote><a id="more"></a><h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>根据小学数学的知识，我们知道一个正整数x是3的倍数的条件是x每一位加起来的和是3的倍数。反之，如果一个数每一位加起来是3的倍数，则这个数肯定是3的倍数。  </p><p>现在给定进制P，求有多少个B满足P进制下，一个正整数是B的倍数的充分必要条件是每一位加起来的和是B的倍数。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数T表示数据组数(1&lt;=T&lt;=20)。  </p><p>接下来T行，每行一个正整数P(2 &lt; P &lt; 1e9)，表示一组询问。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>对于每组数据输出一行，每一行一个数表示答案。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>小 学 数 学</p><hr><p>考虑$p$进制表示的实质是<br>$x = a_1p^n+a_2p^{(n - 1)} + a_3p^{(n - 2)} + \dots + a_{n+1}$<br>稍微变形一下<br>$$x=a_1(p^n-1)+a_2(p^{n-1}-1)+a_3(p^{n - 3} - 1) + \dots + \sum_{i = 1}^{n + 1}a_i$$<br>然后注意到$p^n - 1=(p - 1)(p^{n - 1} + p^{n - 2} + \dots + 1)$<br>把它代入进去<br>$$<br>\begin{aligned}<br>x&amp;=a_1(p - 1)(p^{n - 1} + p^{n - 2} + \dots + 1)<br>\&amp;+a_2(p - 1)(p^{n - 2} + p^{n - 3} + \dots + 1)<br>\&amp;+a_3(p - 1)(p^{n - 3} + p^{n - 4} + \dots + 1) + \dots<br>\&amp;+ \sum_{i = 1}^{n + 1}a_i<br>\end{aligned}<br>$$<br>发现前面几项都有一个 $p - 1$<br>那么，当且仅当$\sum_{i = 1}^{n + 1}a_i$，即 x 各位数字之和 $\equiv 0(\bmod (p - 1))$ 时，$x \equiv 0 (\bmod (p - 1))$</p><p>one more thing<br>对于任意的自然数$a,p$，如果 $a \mod p = 0$，那么有$a \mod x = 0(x \mid p)$</p><p>所以这题的思路已经很明显了，求的就是$p - 1$的因子个数</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fx = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fx); --fx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, fs = <span class="built_in">sqrt</span>(fx); i &lt;= fs; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fx % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ++ans; <span class="keyword">if</span> ((fx / i) != i) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;真·小学数学&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="进制" scheme="https://blog.handwer-std.top/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>中国剩余定理（CRT）学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-10-03/ChinaRemainderTheroem/"/>
    <id>https://blog.handwer-std.top/2019-10-03/ChinaRemainderTheroem/</id>
    <published>2019-10-02T22:45:50.000Z</published>
    <updated>2019-10-04T00:01:22.098Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>孙子定理是中国古代求解一次同余式组（见同余）的方法。是数论中一个重要定理。又称中国余数定理。</p><p style="text-align: right">——百度百科</p><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>孙子定理是用来求解这样的方程组的：</p><p><img src="https://s2.ax1x.com/2019/10/04/uBlVUJ.png" alt="uBlVUJ.png"></p><p>（我博客行间公式渲染好像有点问题……）</p><p>CRT 的使用条件是 $m_i$ 两两互质，$m_i$ 两两不互质需要使用 exCRT 即扩展中国剩余定理</p><hr><p>首先定义 $M = \prod_{i = 1}^n m_i$，并设 $M_i = \lfloor {M \over {m_i}} \rfloor$，$t_i = M_i^{-1} \bmod M$（即$t_i$满足$M_i t_i \equiv 1 (\bmod M)$）<br>那么该同余方程的一个解为<br>$$<br>x_0=(\sum_{i=1}^{k} a_{i} M_i t_{i})\bmod M<br>$$<br>通解为 $x = x_0 + i \times M$，最小非负整数解为 $(x_0 \bmod M + M) \bmod M$</p><p>如果有 $a &lt; 0$ 的情况时要注意负数取模问题</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CRT.cpp</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/10/3.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">lli k, a[<span class="number">10000</span> + <span class="number">10</span>], m[<span class="number">10000</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ChinaRemainderTheorem &#123;</span><br><span class="line">    <span class="function">lli <span class="title">exgcd</span><span class="params">(lli a, lli b, lli &amp;x, lli &amp;y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">        lli g = exgcd(b, a % b, y, x);</span><br><span class="line">        y -= a / b * x;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">lli <span class="title">CRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lli X = <span class="number">0</span>, M = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (lli i = <span class="number">1</span>; i &lt;= k; ++i) M *= m[i];</span><br><span class="line">        <span class="keyword">for</span> (lli i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            lli ti = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            lli mmi = M / m[i];</span><br><span class="line">            exgcd(mmi, m[i], ti, y);</span><br><span class="line">            X = ((X + a[i] * mmi * ti) % M + M) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> X &lt; <span class="number">0</span> ? (X + M) : X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    k = getll();</span><br><span class="line">    <span class="comment">/// x === ai (mod mi)</span></span><br><span class="line">    rap (i, <span class="number">1</span>, k, <span class="number">1</span>) &#123; m[i] = getll(); a[i] = getll(); &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ChinaRemainderTheorem::CRT());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="中国剩余定理" scheme="https://blog.handwer-std.top/tags/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1168《中位数》</title>
    <link href="https://blog.handwer-std.top/2019-10-02/Luogu-P1168/"/>
    <id>https://blog.handwer-std.top/2019-10-02/Luogu-P1168/</id>
    <published>2019-10-02T12:17:18.000Z</published>
    <updated>2019-10-02T12:55:02.771Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>两个优先队列</p></blockquote><a id="more"></a><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应肯定是堆，毕竟自带排序，找中位数也方便</p><p>关键是 <code>std::priority_queue</code>  不能访问内部元素就很烦</p><p>但是，要访问的内部元素好像就一个中位数啊？</p><hr><p>考虑把中位数手动记下来，然后把中位数前边的数用一个大根堆存一下，把中位数后面的数用一个小根堆存一下，这样依然能保证元素是始终有序的</p><p>依次读入每一个数，如果这个数比「当前记着的中位数」小就放进大根堆里，否则放进小根堆里</p><p>查询的时候需要对中位数进行更新：<br>如果左右两个堆的大小相等，说明中位数还是那个中位数；<br>否则分两种情况讨论：</p><ol><li>大根堆更大<br>说明中位数一定在大根堆里，那么就把中位数塞进小根堆里，再把大根堆堆顶取出来当新的中位数，重复做直到两个堆大小相等</li><li>小根堆更大<br>说明中位数一定在小根堆里，那么就把中位数塞进大根堆里，再把小根堆堆顶取出来当新的中位数，重复做直到两个堆大小相等</li></ol><p>最后输出更新完的中位数即可</p><p>本方法对应代码中的 <code>Method1</code></p><hr><p>或者可以直接使用 <code>std::vector</code> 和 <code>std::upper_bound</code> 来模拟一个堆，输出的时候直接访问 <code>vec[(i / 2 + 1) - 1]</code> 即可</p><p><code>std::upper_bound(Begin Iterator, End Iterator, Value)</code> 是一个使用二分查找，在有序序列 <code>[Begin Iterator, End Iterator)</code> 中查找第一个大于 <code>Value</code> 的位置的函数；<code>std::vector&lt;int&gt;::insert(Position Iterator, Value)</code> 可以在 <code>Position Iterator</code> 前面插入元素 <code>Value</code>，利用这两个函数可以实现插入元素而不破坏序列的有序性。</p><p>本方法对应代码中的 <code>Method2</code></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP1168.cpp</span></span><br><span class="line"><span class="comment">//  Title: 中位数</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/10/2.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Method1 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此题正解</span></span><br><span class="line"><span class="comment">     * 用一个大根堆维护中位数之前的数，一个小根堆维护中位数之后的数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; before;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; after;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> _main() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = getint();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; mid = now; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; mid) before.push(now);</span><br><span class="line">                <span class="keyword">else</span> after.push(now);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> befsiz = before.size();</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> aftsiz = after.size();</span><br><span class="line">                <span class="keyword">while</span> (befsiz != aftsiz) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (befsiz &lt; aftsiz) &#123;</span><br><span class="line">                        before.push(mid);</span><br><span class="line">                        mid = after.top(); after.pop();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        after.push(mid);</span><br><span class="line">                        mid = before.top(); before.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    befsiz = before.size(); aftsiz = after.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Method2 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 沙雕做法</span></span><br><span class="line"><span class="comment">     * 使用 std::vector 和 std::lower_bound 手写堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> _main() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = getint();</span><br><span class="line">            vec.insert(<span class="built_in">std</span>::upper_bound(vec.begin(), vec.end(), now), now);</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, vec.at(i / <span class="number">2</span> + <span class="number">1</span> - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span>) Method2::_main();</span><br><span class="line">    <span class="keyword">else</span> Method1::_main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;两个优先队列&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="队列" scheme="https://blog.handwer-std.top/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="堆" scheme="https://blog.handwer-std.top/tags/%E5%A0%86/"/>
    
      <category term="STL" scheme="https://blog.handwer-std.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2158《[SDOI2008]仪仗队》</title>
    <link href="https://blog.handwer-std.top/2019-08-18/Luogu-P2158-BZOJ2190/"/>
    <id>https://blog.handwer-std.top/2019-08-18/Luogu-P2158-BZOJ2190/</id>
    <published>2019-08-18T15:40:29.000Z</published>
    <updated>2019-08-18T15:53:54.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。</p><a id="more"></a>  <p><img src="https://www.lydsy.com/JudgeOnline/images/2190.jpg" alt=""></p><p>现在，C君希望你告诉他队伍整齐时能看到的学生人数。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>共一个数 N</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>共一个数，即C君应看到的学生人数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>【数据规模和约定】</p><p>对于 100% 的数据，1 ≤ N ≤ 40000</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>来快乐推一推式子</p><p>首先考虑一下没有被看到的点长什么样<br>显然没有被看到的点$(x,y)$与原点的连线上一定有一点，记为 $(\frac x t , \frac y t )$</p><p>由于所有坐标都是整数，那么有</p><p>$$<br>t \mid x, t \mid y  \Leftrightarrow  t \mid \gcd(x, y)<br>$$</p><p>所以可以知道这个事情：<br>一个点$(x, y)$不可以被看到，等价于$\gcd(x, y) \neq 1$。<br>所以题目要求的就是所有的数对$(x,y)$的个数，满足 $\gcd(x, y) = 1$</p><hr><p>分开考虑答案</p><p>首先是坐标形如 $(0, y), (x, 0)$ 的这些点，也就是在 $x$ 轴和 $y$ 轴上的点，均只能看见一个 $(0, 1),(1, 0)$，统计答案的时候就直接 $+ 2$ 就行了。</p><p>然后是在直线 $y = x$ 上的点，也只能被看见一个 $(1, 1)$，统计答案的时候再来个 $+ 1$。</p><p>剩下的点可以用两个 $\sum$ 统计。<br>最后式子长这样（注意$\text{ans}$函数的参数值）：</p><p>$$<br>\begin{align}<br>\text{ans}(n + 1) = 3 + \sum_{x = 1}^{n} \sum_{y = 1}^{x - 1}[\gcd(x, y) = 1] + \sum_{x = 1}^{n} \sum_{y = x + 1}^{n}[\gcd(x, y) = 1]<br>\end{align}<br>$$</p><p>看一眼这张图：</p><p><img src="https://i.loli.net/2019/08/18/rDIhj6WHcpUnbNa.png" alt=""></p><p>可以发现，第一种情况对应的是点 $U, V$，第二种情况对应的是 $W$，两个 $\sum$ 分别对应点 $A \rightarrow J$ 和 $K \rightarrow T$ 的能看见的点的数量。</p><p>还是不懂？ 手动模拟一下吧，看看它会统计哪些点<br>两个 $\sum$ 相当于语句</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line"><span class="keyword">for</span> y = <span class="number">1</span> to x - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">ans = ans + (gcd(x,y) == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> x = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line"><span class="keyword">for</span> y = x + <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">ans = ans + (gcd(x,y) == <span class="number">1</span>)</span><br><span class="line">ans = ans + <span class="number">3</span></span><br></pre></td></tr></table></figure><p>显然可以看到的点是关于直线 $y = x$ 对称的，所以上面的式子又可以写成</p><p>$$<br>\text{ans}(n + 1) = 3 + 2\sum_{x = 1}^{n} \sum_{y = 1}^{x - 1}[\gcd(x, y) = 1]<br>$$</p><hr><p>这个式子肯定跑不过去的。把这个式子化简一下</p><p>注意到一个很常见的积性函数</p><p>$$<br>\varphi(x) = \sum_{i = 1}^{x}[\gcd(i, x) = 1]<br>$$</p><p>代入原式！</p><p>$\text{ans}(n + 1) = 3 + 2\sum_{x = 1}^{n} \sum_{y = 1}^{x - 1}[\gcd(x, y) = 1]$<br>$= 3 + 2\sum_{x = 1}^{n} (\sum_{y = 1}^{x}[\gcd(x, y) = 1] - [\gcd(x, x) = 1])$<br>$= 3 + 2\sum_{x = 1}^{n} (\varphi(x) - [\gcd(x, x) = 1])$</p><p>好了，现在就有了一个可以 $O(n)$ 计算的式子了！</p><p>（式子要分行写是因为我博客的 Math 引擎好像炸了。。。渲染不了多行，将就看吧/kk）</p><hr><p>最后说个事，$n = 1$ 的时候答案为 $0$，这个很显然吧，都没有学生了（</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2158.cpp</span></span><br><span class="line"><span class="comment">//  Title: [SDOI2008]仪仗队</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ2190</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/18.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">40000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notprime[MAXN];</span><br><span class="line"><span class="keyword">int</span> prime[MAXN], phi[MAXN], cnt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">lli ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    notprime[<span class="number">0</span>] = notprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!notprime[i]) &#123;</span><br><span class="line">            prime[++cnt] = i; phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; (i * prime[j]) &lt; MAXN; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i * prime[j];</span><br><span class="line">            notprime[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123; phi[x] = phi[i] * prime[j]; <span class="keyword">break</span>; &#125;</span><br><span class="line">            phi[x] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= fn; ++x) &#123;</span><br><span class="line">        ans += phi[x];</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) ans -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sieve();</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> (<span class="number">0</span> &amp; <span class="built_in">printf</span>(<span class="string">"0\n"</span>));</span><br><span class="line">    Solve(n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="欧拉函数" scheme="https://blog.handwer-std.top/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>HDU2196《Computer》</title>
    <link href="https://blog.handwer-std.top/2019-08-15/HDU2196/"/>
    <id>https://blog.handwer-std.top/2019-08-15/HDU2196/</id>
    <published>2019-08-15T14:08:14.000Z</published>
    <updated>2019-08-15T14:23:46.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用树的直径的性质</p></blockquote><a id="more"></a><h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information.  </p><p><img src="http://acm.hdu.edu.cn/data/images/C128-1005-1.JPG" alt=""></p><p>Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4.</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space.</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N).</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先有一个性质：在一棵树上，距离任意点最远的点一定是这棵树直径的一个端点</p><p>然后这题不就好做了吗</p><p>先以 1 为根求一遍直径，再分别以两个端点为根求一遍这个点到其他点的距离，取个最大值，输出即可，这个可以写一个DFS调用三遍</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU2196.cpp</span></span><br><span class="line"><span class="comment">//  Title: Computer</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/15.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, farthest;</span><br><span class="line">lli maxdis;</span><br><span class="line">lli f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    head[u].push_back(Edge(v, w));</span><br><span class="line">    head[v].push_back(Edge(u, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, lli dis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; maxdis) &#123; maxdis = dis; farthest = u; &#125;</span><br><span class="line">    f[u] = <span class="built_in">std</span>::max(f[u], dis);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = head[u][i].v, w = head[u][i].w;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(v, u, dis + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _main() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = getint(); <span class="keyword">int</span> w = getint();</span><br><span class="line">        addEdge(i + <span class="number">1</span>, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    p1 = farthest;</span><br><span class="line">    DFS(p1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 以上这两遍DFS是在求树的直径</span></span><br><span class="line">    <span class="comment">// 第二遍DFS顺便更新了一下从某一个端点出发的答案</span></span><br><span class="line">    p2 = farthest;</span><br><span class="line">    DFS(p2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 由于在每个点的最长路径可能到达两个端点</span></span><br><span class="line">    <span class="comment">// 所以要对两个端点分别更新一遍答案</span></span><br><span class="line">    <span class="comment">// 这一遍DFS是在更新从另一个端点出发的答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) head[i].clear();</span><br><span class="line">    n = maxdis = farthest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) _main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;利用树的直径的性质&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="树" scheme="https://blog.handwer-std.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3714《Kuglarz》</title>
    <link href="https://blog.handwer-std.top/2019-08-15/BZOJ3714/"/>
    <id>https://blog.handwer-std.top/2019-08-15/BZOJ3714/</id>
    <published>2019-08-15T01:09:58.000Z</published>
    <updated>2019-08-15T01:19:38.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是最小生成树？</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>魔术师的桌子上有n个杯子排成一行，编号为1,2,…,n，其中某些杯子底下藏有一个小球，如果你准确地猜出是哪些杯子，你就可以获得奖品。花费c_ij元，魔术师就会告诉你杯子i,i+1,…,j底下藏有球的总数的奇偶性。<br>采取最优的询问策略，你至少需要花费多少元，才能保证猜出哪些杯子底下藏着球？</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个整数n(1&lt;=n&lt;=2000)。<br>第i+1行(1&lt;=i&lt;=n)有n+1-i个整数，表示每一种询问所需的花费。其中c_ij（对区间[i,j]进行询问的费用，1&lt;=i&lt;=j&lt;=n,1&lt;=c_ij&lt;=10^9）为第i+1行第j+1-i个数。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一个整数，表示最少花费。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5  </span><br><span class="line">1 2 3 4 5  </span><br><span class="line">4 3 2 1  </span><br><span class="line">3 4 5  </span><br><span class="line">2 1  </span><br><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><del>从代码里复制过来的</del></p><p>知道两段杯子的奇偶性，相当于知道左边杯子左边的缝到右边杯子右边的缝到奇偶性</p><p>然后显然这个东西具有传递性，即知道缝a到缝b、缝b到缝c的奇偶性 $\Leftrightarrow$ 缝a到缝c的奇偶性</p><p>知道所有数列要保证缝两两之间的奇偶性都要知道</p><p>那么就可以把缝抽象成点，缝两两之间的奇偶性信息抽象成边，边权为询问的代价</p><p>一遍最小生成树完事</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  BZOJ3714.cpp</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/15.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 知道两段杯子的奇偶性，相当于知道左边杯子左边的缝到右边杯子右边的缝到奇偶性</span></span><br><span class="line"><span class="comment"> * 然后显然这个东西具有传递性，即知道缝a到缝b、缝b到缝c的奇偶性 &lt;=&gt; 缝a到缝c的奇偶性</span></span><br><span class="line"><span class="comment"> * 知道所有数列要保证缝两两之间的奇偶性都要知道</span></span><br><span class="line"><span class="comment"> * 那么就可以把缝抽象成点，缝两两之间的奇偶性信息抽象成边，边权为询问的代价</span></span><br><span class="line"><span class="comment"> * 一遍最小生成树完事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u[MAXN];</span><br><span class="line">    </span><br><span class="line">    UnionFind() &#123; <span class="built_in">memset</span>(u, <span class="number">0</span>, <span class="keyword">sizeof</span> u); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++i) u[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> u[x] == x ? x : (u[x] = Find(u[x])); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = Find(x); y = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        u[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; U;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : u(u), v(v), w(w) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; that.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt;</span><br><span class="line">lli ans;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//    std::sort(edge + 1, edge + 1 + cnt);</span></span><br><span class="line">    <span class="built_in">std</span>::sort(edge.begin(), edge.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (U.Union(edge[i].u, edge[i].v)) &#123;</span><br><span class="line">            <span class="comment">//            printf("choosed edge[%d] = &#123; %d %d %d &#125;\n", i, edge[i].u, edge[i].v, edge[i].w);</span></span><br><span class="line">            ++tot; ans += <span class="number">1l</span>l * edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    U.Init(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = getint();</span><br><span class="line">            edge.push_back(Edge(i, j, x));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = (<span class="keyword">int</span>) edge.size();</span><br><span class="line">    Kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是最小生成树？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="生成树" scheme="https://blog.handwer-std.top/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="最小生成树" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>关于新开的 cnblogs 博客的一些说明</title>
    <link href="https://blog.handwer-std.top/2019-08-14/Articles-Moving-To-cnblogs/"/>
    <id>https://blog.handwer-std.top/2019-08-14/Articles-Moving-To-cnblogs/</id>
    <published>2019-08-14T11:43:38.000Z</published>
    <updated>2019-08-14T11:58:04.938Z</updated>
    
    <content type="html"><![CDATA[<p>因为一些原因，文章没有被各大搜索引擎收录多少，PV和UV都很低（截止2019.08.12 7:20，没有破 5K），于是就想找一个博客网站放一些自己的文章，希望更多人能看到自己的文章，同时可以给自己博客引引流，最后选中了 cnblogs</p><p>文章会陆续按照创建时间排序搬上来，以后两个博客（有时候可能会在洛谷博客也更新）同步更新</p><p>一些很沙雕的文章可能不会放上去（</p><p>不过这么做可能会引来转载，比如说某aichengxu、某voidcn啊之类的，链个博客链接应该就没事了（</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为一些原因，文章没有被各大搜索引擎收录多少，PV和UV都很低（截止2019.08.12 7:20，没有破 5K），于是就想找一个博客网站放一些自己的文章，希望更多人能看到自己的文章，同时可以给自己博客引引流，最后选中了 cnblogs&lt;/p&gt;
&lt;p&gt;文章会陆续按照创建时间
      
    
    </summary>
    
    
      <category term="博客相关" scheme="https://blog.handwer-std.top/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>ZROI 918《「良心普及组」黄队的宫殿》</title>
    <link href="https://blog.handwer-std.top/2019-08-13/ZROI918/"/>
    <id>https://blog.handwer-std.top/2019-08-13/ZROI918/</id>
    <published>2019-08-13T13:26:09.000Z</published>
    <updated>2019-08-13T14:20:16.698Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）" />    <label for="pass">密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本题为权限题目，请输入密码访问。密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）
    
    </summary>
    
    
      <category term="只有经历过的人才知道的世界" scheme="https://blog.handwer-std.top/tags/%E5%8F%AA%E6%9C%89%E7%BB%8F%E5%8E%86%E8%BF%87%E7%9A%84%E4%BA%BA%E6%89%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="https://blog.handwer-std.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>HDU1483《Automatic Correction of Misspellings》</title>
    <link href="https://blog.handwer-std.top/2019-08-08/HDU1483/"/>
    <id>https://blog.handwer-std.top/2019-08-08/HDU1483/</id>
    <published>2019-08-08T15:56:55.000Z</published>
    <updated>2019-08-08T16:00:04.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Some text editors offer a feature to correct words which seem to be written incorrectly. In this problem you are asked to implement a simple Automatic Correction of Misspellings (ACM).  </p><a id="more"></a><p>ACM takes care of the following misspellings of words:  </p><p>1.One letter is missing (e.g., letter is written leter) or too much (e.g., letter is written lettter).<br>2.One letter is wrong (e.g., letter is written ketter)<br>3.The order of two adjacent letters is wrong (e.g., letter is written lettre)  </p><p>ACM is based on a dictionary of known words. When a text contains a word which is not in the dictionary, ACM will try to replace it by a similar word of the dictionary. Two words are similar if we can transform one word into the other by doing exactly one of the misspellings listed above. An unknown word is left unchanged if there is no similar word in the dictionary.  </p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>The first line of the input file will give the number n of words in the dictionary (n ≤ 10000). The next n lines contain the dictionary words. The following line contains an integer q ≤ 1000, the number of query words. The next q lines contain the query words. You may assume that each word in the input consists of 1 to 25 lower case letters (‘a’ to ‘z’).  </p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each query word, print one line with the query word followed by one of the following possibilities:  </p><ol><li>is correct, if the word occurs in the dictionary.  </li><li>is a misspelling of <x>, where <x> is a word of the dictionary similar to the query word, and the query word is not in the dictionary. In the case that there are several possibilities, select the word from the dictionary which appeared earlier in the input.  </x></x></li><li>is unknown, if cases 1 and 2 do not apply.  </li></ol><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">this</span><br><span class="line">is</span><br><span class="line">a</span><br><span class="line">dictionary</span><br><span class="line">that</span><br><span class="line">we</span><br><span class="line">will</span><br><span class="line">use</span><br><span class="line">for</span><br><span class="line">us</span><br><span class="line">6</span><br><span class="line">su</span><br><span class="line">as</span><br><span class="line">the</span><br><span class="line">dictonary</span><br><span class="line">us</span><br><span class="line">willl</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su is a misspelling of us</span><br><span class="line">as is a misspelling of is</span><br><span class="line">the is unknown</span><br><span class="line">dictonary is a misspelling of dictionary</span><br><span class="line">us is correct</span><br><span class="line">willl is a misspelling of will</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><del>还是从代码里复制过来的（</del></p><p>场上写一个 Trie 写到自闭。。。<br>赛后来补一下</p><p>道理我都懂，但是这题为什么暴力能过。。。</p><p>以下，将字典中的串称作「字典串」，将询问的串称作「匹配串」</p><p>首先扫一遍字典，有相同的直接输出 correct</p><p>然后如果没有相同的，再扫一遍字典，对于每一个字典串，做这样几件事：</p><ol><li>如果字典串和匹配串长度相等，就说明这个匹配串可能是当前字典串的一个错误拼写<br>逐位扫一遍两个串，记一下错误的次数，以及最后一次错误的下标<br>如果错误次数是 1 就直接输出 misspelling，此时匹配串相对于字典串只错了一个字符<br>如果错误次数是 2 就判断一下是否是顺序弄反了，这个用最后一次错误下标很好写，如果是就输出 misspelling<br>否则就凉凉</li><li>如果字典串比匹配串长 1，就说明这个匹配串可能是当前字典串漏了一个字<br>逐位扫一遍字典串，用一个变量 k 记录当前字典串这一位对应的是匹配串的哪一位<br>如果当前的两个串对应字符相等，就让 k 正常加一，否则就不让 k 加一<br>显然如果真的是只漏了一个字，那么最后 k 一定等于匹配串长度，输出 misspelling<br>否则 k 一定不等于匹配串长度（具体会变成什么值我也不大清楚，反正模拟一下就好了）</li><li>如果字典串比匹配串短 1，就说明这个匹配串可能是当前字典串添了一个字<br>仿照着情况 2 做就完事了</li></ol><p>最后如果三种情况都没有，输出 unknown</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU1483.cpp</span></span><br><span class="line"><span class="comment">//  Title: Automatic Correction of Misspellings</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/8.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dict[MAXN];</span><br><span class="line"><span class="keyword">int</span> dictlen[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoCorrectionMachine</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMisspelling</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wrong = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] != m[i]) &#123; ++wrong; pos = i; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wrong == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (wrong == <span class="number">2</span> &amp;&amp; (d[pos] == m[pos - <span class="number">1</span>] &amp;&amp; d[pos - <span class="number">1</span>] == m[pos])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCharacterDeletion</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> lend, <span class="keyword">int</span> lenm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lend; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] != m[k++]) --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == lenm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCharacterAddition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> lend, <span class="keyword">int</span> lenm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenm; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i] != d[k++]) --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == lend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; acm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; dict[i];</span><br><span class="line">        dictlen[i] = (<span class="keyword">int</span>) dict[i].length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> env;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; env;</span><br><span class="line">        <span class="keyword">int</span> lenenv = (<span class="keyword">int</span>) env.length();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; env;</span><br><span class="line">        <span class="keyword">bool</span> cor = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dict[i] == env) &#123; cor = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cor) <span class="built_in">cout</span> &lt;&lt; <span class="string">" is correct\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dictlen[i] == lenenv) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isMisspelling(dict[i], env, lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dictlen[i] == lenenv + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isCharacterDeletion(dict[i], env, dictlen[i], lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dictlen[i] == lenenv - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isCharacterAddition(dict[i], env, dictlen[i], lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n + <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" is unknown\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h1&gt;&lt;p&gt;Some text editors offer a feature to correct words which seem to be written incorrectly. In this problem you are asked to implement a simple Automatic Correction of Misspellings (ACM).  &lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="暴力" scheme="https://blog.handwer-std.top/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>HDU3183《A Magic Lamp》</title>
    <link href="https://blog.handwer-std.top/2019-08-08/HDU3183/"/>
    <id>https://blog.handwer-std.top/2019-08-08/HDU3183/</id>
    <published>2019-08-08T15:44:15.000Z</published>
    <updated>2019-08-08T15:47:14.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Kiki likes traveling. One day she finds a magic lamp, unfortunately the genie in the lamp is not so kind. Kiki must answer a question, and then the genie will realize one of her dreams.  </p><a id="more"></a> <p>The question is: give you an integer, you are allowed to delete exactly m digits. The left digits will form a new integer. You should make it minimum.<br>You are not allowed to change the order of the digits. Now can you help Kiki to realize her dream?  </p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>There are several test cases.<br>Each test case will contain an integer you are given (which may at most contains 1000 digits.) and the integer m (if the integer contains n digits, m will not bigger then n). The given integer will not contain leading zero.  </p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, output the minimum result you can get in one line.<br>If the result contains leading zero, ignore it.  </p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">178543 4 </span><br><span class="line">1000001 1</span><br><span class="line">100001 2</span><br><span class="line">12345 2</span><br><span class="line">54321 2</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">123</span><br><span class="line">321</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然删除从左向右遇到的第一个比下一个数大的数，也就是让最高位最小的过程。那么按这样的策略做 m 次即可获得正确答案，删除后的序列可使用双向链表（STL 里有<code>std::list&lt;int&gt;</code>）来维护。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU3183.cpp</span></span><br><span class="line"><span class="comment">//  Title: A Magic Lamp</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/8.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> charat(x) ((x - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除从左向右遇到的第一个比下一个数大的数</span></span><br><span class="line"><span class="comment"> * 用一个双向链表维护</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) s.length();</span><br><span class="line">        lst.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            lst.insert(lst.end(), s[charat(i)] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.begin(); i != lst.end(); i++) &#123;</span><br><span class="line">                i++; <span class="keyword">if</span> (i == lst.end()) &#123; --i; lst.erase(i); <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">int</span> next = (*i);</span><br><span class="line">                --i;</span><br><span class="line">                <span class="keyword">if</span> (*i &gt; next) &#123; lst.erase(i); <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> fz = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : lst) &#123; <span class="keyword">if</span> (fz &amp;&amp; i == <span class="number">0</span>) <span class="keyword">continue</span>; fz = <span class="literal">false</span>; <span class="built_in">printf</span>(<span class="string">"%d"</span>, i); &#125;</span><br><span class="line">        <span class="keyword">if</span> (fz) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;Kiki likes traveling. One day she finds a magic lamp, unfortunately the genie in the lamp is not so kind. Kiki must answer a question, and then the genie will realize one of her dreams.  &lt;/p&gt;
    
    </summary>
    
    
      <category term="贪心" scheme="https://blog.handwer-std.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 402B《Trees in a Row》</title>
    <link href="https://blog.handwer-std.top/2019-08-07/CF402B/"/>
    <id>https://blog.handwer-std.top/2019-08-07/CF402B/</id>
    <published>2019-08-07T11:59:04.000Z</published>
    <updated>2019-08-07T12:59:17.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h1><p>有n个正整数，可以对一个数进行修改(修改后也是正整数)，要求修改之后满足$a_i+k=a{i+1}$，求最少的修改次数以及具体的修改方案</p><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The Queen of England has n trees growing in a row in her garden. At that, the i-th (1 ≤ i ≤ n) tree from the left has height ai meters. Today the Queen decided to update the scenery of her garden. She wants the trees’ heights to meet the condition: for all i (1 ≤ i &lt; n), ai + 1 - ai = k, where k is the number the Queen chose.</p><p>Unfortunately, the royal gardener is not a machine and he cannot fulfill the desire of the Queen instantly! In one minute, the gardener can either decrease the height of a tree to any positive integer height or increase the height of a tree to any positive integer height. How should the royal gardener act to fulfill a whim of Her Majesty in the minimum number of minutes?</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>The first line contains two space-separated integers: n, k (1 ≤ n, k ≤ 1000). The second line contains n space-separated integers a1, a2, …, an (1 ≤ ai ≤ 1000) — the heights of the trees in the row.</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>In the first line print a single integer p — the minimum number of minutes the gardener needs. In the next p lines print the description of his actions.</p><p>If the gardener needs to increase the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, then print in the corresponding line “+ j x”. If the gardener needs to decrease the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, print on the corresponding line “- j x”.</p><p>If there are multiple ways to make a row of trees beautiful in the minimum number of actions, you are allowed to print any of them.</p><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>input<br>4 1<br>1 2 1 5</p><p>output<br>2</p><ul><li>3 2</li></ul><ul><li>4 1</li></ul><p>input<br>4 1<br>1 2 3 4</p><p>output<br>0</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本文同步发布于<a href="[https://www.luogu.org/blog/handwer-blog/](https://www.luogu.org/blog/handwer-blog/">洛谷博客</a>)</p><hr><p><del>先说点题外话</del></p><p>这道题是我今天（发题解的那一天，2019.08.07）打 ACM 的时候做的，当时看到这题口胡了一下做法，没敢写，交给队友去写了，然后一遍AC</p><p>感谢队友把我带飞</p><hr><p>言归正传。</p><p>考虑枚举第一棵树的高度，因为这样就能直接确定后面的树的高度了 </p><p>然后假设当前枚举第一棵树高度为 $l$，那么第 $i$ 棵树的高度 $h_i$ 就应该是 $l + k(i - 1)$，这个应该很好理解吧，如果不懂可以评论区留个言，我找个时间写一下</p><p>那么再套一层循环，枚举所有的树，如果当前枚举到的第 $i$ 棵树的高度不是 $l + k(i - 1)$，就意味着这棵树需要被修改，需要增高 / 降低的高度是 $\text{abs}(l - k(i - 1))$，需要增高还是降低取决于 $l - k(i - 1)$ 的符号</p><p>统计一下修改了多少次，作为一个方案，最后取一个最优方案的输出就行了</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXNKH = <span class="number">1000</span> + <span class="number">10</span>; <span class="comment">// the max of n, k, height</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOC = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MODIFY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, ans = <span class="number">0x7f7f7f7f</span>, ansf[MAXNKH][<span class="number">2</span>], p, f[MAXNKH][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> height[MAXNKH];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); k = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) height[i] = getint();</span><br><span class="line">    rap (h1, <span class="number">1</span>, <span class="number">1000</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 枚举第一棵树的高度，可以直接确定后面树的高度</span></span><br><span class="line">        p = <span class="number">0</span>; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] - (i - <span class="number">1</span>) * k != h1) &#123;</span><br><span class="line">            <span class="comment">// 记一下要修改的树的下标和要增加 / 减少的值</span></span><br><span class="line">                f[++p][LOC] = i;</span><br><span class="line">                f[p][MODIFY] = (h1 + (i - <span class="number">1</span>) * k) - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; ans) &#123;</span><br><span class="line">            <span class="comment">// 更优的方案，更新一下</span></span><br><span class="line">            ans = p;</span><br><span class="line">            <span class="built_in">memcpy</span>(ansf, f, <span class="keyword">sizeof</span> f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    rap (i, <span class="number">1</span>, ans, <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%c %d %d\n"</span>, (ansf[i][MODIFY] &lt; <span class="number">0</span> ? <span class="string">'-'</span> : <span class="string">'+'</span>), ansf[i][LOC], <span class="built_in">std</span>::<span class="built_in">abs</span>(ansf[i][MODIFY]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code by Handwer</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Translate&quot;&gt;&lt;a href=&quot;#Translate&quot; class=&quot;headerlink&quot; title=&quot;Translate&quot;&gt;&lt;/a&gt;Translate&lt;/h1&gt;&lt;p&gt;有n个正整数，可以对一个数进行修改(修改后也是正整数)，要求修改之后满足$a_i+k=a{i+1}$，求最少的修改次数以及具体的修改方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3177《[HAOI2015]树上染色》</title>
    <link href="https://blog.handwer-std.top/2019-07-31/Luogu-P3177-BZOJ4033/"/>
    <id>https://blog.handwer-std.top/2019-07-31/Luogu-P3177-BZOJ4033/</id>
    <published>2019-07-31T15:30:50.000Z</published>
    <updated>2019-07-31T15:33:23.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我推式子推了半个小时。。。</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一棵点数为N的树，树边有边权。给你一个在0~N之内的正整数K，你要在这棵树中选择K个点，将其染成黑色，并</p><p>将其他的N-K个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间距离的和的收益。</p><p>问收益最大值是多少。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个整数N,K。</p><p>接下来N-1行每行三个正整数fr,to,dis，表示该树中存在一条长度为dis的边(fr,to)。</p><p>输入保证所有点之间是联通的。</p><p>N&lt;=2000,0&lt;=K&lt;=N</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一个正整数，表示收益的最大值。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 2  </span><br><span class="line">1 2 3  </span><br><span class="line">1 5 1  </span><br><span class="line">2 3 1  </span><br><span class="line">2 4 2</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure><p>【样例解释】<br>将点1,2染黑就能获得最大收益。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应设 $\text{dp[i][j]}$ 表示以 i 为根的子树选 j 个黑点的最大收益<br>但是是错的</p><p>康了一眼<a href="https://www.luogu.org/blog/ahaha254/solution-p3177" target="_blank" rel="noopener">这个</a>我就瞬间明白了<br>关于式子的推导，组成部分的意义，还有循环顺序的选择，这篇文章都讲得很清楚</p><p>老规矩，题解都在代码里</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  BZOJ4033.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2015]树上染色</span></span><br><span class="line"><span class="comment">//  Alternatives: Luogu-P3177</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参考资料：https://www.luogu.org/blog/ahaha254/solution-p3177</span></span><br><span class="line"><span class="comment"> * 关于 val(x,y) 和枚举顺序的解释可以康一康这篇文章</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设 f[i][j] 表示以 i 为根的子树中取了 j 个黑点「对答案的贡献」</span></span><br><span class="line"><span class="comment"> * 转移方程：</span></span><br><span class="line"><span class="comment"> * f[u][j] = max(</span></span><br><span class="line"><span class="comment"> *     f[u][j],</span></span><br><span class="line"><span class="comment"> *     f[u][j - k] + f[v][k] + val(u,v)</span></span><br><span class="line"><span class="comment"> * )</span></span><br><span class="line"><span class="comment"> * 其中 v 是 u 的儿子，k 是枚举出来的</span></span><br><span class="line"><span class="comment"> * j = min(m,size(x)) -&gt; 0, k = 0 -&gt; min(j,size(y))</span></span><br><span class="line"><span class="comment"> * 其中 val(x,y) 表示边 (x,y) 对答案的贡献，它等于</span></span><br><span class="line"><span class="comment"> * 「该边两边黑点数量的乘积 乘以 边长 加上 该边两边白点数量的乘积 乘以 边长」</span></span><br><span class="line"><span class="comment"> * 也就是 val(x,y) = k * (m - k) * weight(x,y) + (size(y) - k) * ((n - m) - (size(y) - k)) * weight(x,y)</span></span><br><span class="line"><span class="comment"> * 其中 m 是总的黑点数，k 是边 (x,y) 另一边的黑点数，那么 (m - k) 就是这一边的黑点数</span></span><br><span class="line"><span class="comment"> * size(y) 是以 y 为根的子树的大小，也就意味着 (size(y) - k) 是另一边的白点数（另一边的肯定不是黑点就是白点）</span></span><br><span class="line"><span class="comment"> * (n - m) 是总的白点数，(size(y) - k) 是另一边的白点数，也就意味着 ((n - m) - (size(y) - k)) 是边 (x,y) 这一边的白点数（白点肯定不在那边就在这边）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    lli w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> v = <span class="number">0</span>, lli w = <span class="number">0</span>) : v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, size[MAXN];</span><br><span class="line">lli dp[MAXN][MAXK];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXK];</span><br><span class="line"><span class="comment">// dp 数组大概 31 MB</span></span><br><span class="line"><span class="comment">// size 数组大概 8 KB</span></span><br><span class="line"><span class="comment">// vis 数组大概 4 MB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    size[root] = <span class="number">1</span>;</span><br><span class="line">    vis[root][<span class="number">0</span>] = vis[root][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i].v;</span><br><span class="line">        <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(next, root);</span><br><span class="line">        size[root] += size[next];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i].v;</span><br><span class="line">        <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">        lli weight = head[root][i].w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">std</span>::min(m, size[root]); j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="built_in">std</span>::min(j, size[next]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= up; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[root][j - k]) <span class="keyword">continue</span>;</span><br><span class="line">                lli val = k * (m - k) * weight + (size[next] - k) * ((n - m) - (size[next] - k)) * weight;</span><br><span class="line">                dp[root][j] = <span class="built_in">std</span>::max(dp[root][j], dp[root][j - k] + dp[next][k] + val);</span><br><span class="line">                vis[root][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); m = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n - <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint(), next = getint(), weight = getint();</span><br><span class="line">        head[prev].push_back(Edge(next, weight));</span><br><span class="line">        head[next].push_back(Edge(prev, weight));</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我推式子推了半个小时。。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>TopCoder 13955《WalkOverATree》</title>
    <link href="https://blog.handwer-std.top/2019-07-31/TopCoder13955/"/>
    <id>https://blog.handwer-std.top/2019-07-31/TopCoder13955/</id>
    <published>2019-07-31T14:58:03.000Z</published>
    <updated>2019-08-07T13:12:09.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h1><p>Given is a tree on n nodes. The nodes are numbered 0 through n-1. You are given the description of the tree as a int[]  <strong>parent</strong>  with n-1 elements. For each valid i, there is an edge between vertices (i+1) and  <strong>parent</strong>[i].</p><a id="more"></a><p>A person is currently standing in node 0. In a single step, the person can move from its current node to any adjacent node. You are given an int  <strong>L</strong>. The person is allowed to make at most  <strong>L</strong>  steps.</p><p>Return the maximum number of nodes the person can visit during the walk. Node 0 (where the walk starts) and the node where the walk ends count as visited. Each visited node is only counted once, even if it is visited multiple times.</p><h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><p>Class: WalkOverATree<br>Method: maxNodesVisited<br>Parameters: int[], int<br>Returns: int<br>Method signature: int maxNodesVisited(int[] parent, int L)<br>(be sure your method is public)</p><h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><ul><li><p><strong>parent</strong>  will contain between 0 and 49 elements, inclusive.</p></li><li><p>For each i,  <strong>parent</strong>[i] will be between 0 and i, inclusive.</p></li><li><p><strong>L</strong>  will be between 1 and 100, inclusive.</p></li></ul><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>请自行到 vjudge 上寻找</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>英文很好懂，只需人教初二水平（反正我准初三选手看懂了）</p><p>题目大意：<br>给定一棵 n 个点的树，编号 0~n-1。连边方式以输入每个点的父亲给出，对于每个 i，有一条边连接点 (i+1) 和点 father[i]，而且 father[i] 是 (i+1) 的父亲。<br>有一个人站在点 0，可以向四周走不超过 L 步，求出这个人能经过多少不同的点</p><p>这题和 dp 有什么关系吗。。。</p><p>这题的难点大概就是 class 的使用和答案统计了吧</p><p>class 的使用可以参考<a href="https://blog.csdn.net/qq_31908675/article/details/81198751" target="_blank" rel="noopener">这里</a></p><p>答案统计和基本的思路见代码吧</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  TopCoder13955.cpp</span></span><br><span class="line"><span class="comment">//  Title: WalkOverATree</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt;= s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WalkOverATree</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 直接暴力就好了。。。</span></span><br><span class="line"><span class="comment">     * 一遍 DFS 预处理出所有的点的深度（根节点深度为 0）</span></span><br><span class="line"><span class="comment">     * 答案的输出见下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> depthWalk[MAXL];</span><br><span class="line">    <span class="keyword">int</span> maxstep = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>, <span class="keyword">int</span> step = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        depthWalk[root] = step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = head[root][i];</span><br><span class="line">            <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">            DFS(next, root, step + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNodesVisited</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        maxstep = L;</span><br><span class="line">        <span class="keyword">int</span> N = (<span class="keyword">int</span>) father.size() + <span class="number">1</span>; <span class="comment">// 把根节点算上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = N - <span class="number">1</span>; i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = (i + <span class="number">1</span>) + <span class="number">1</span>, next = father[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 编号整体加一</span></span><br><span class="line">            head[prev].push_back(next);</span><br><span class="line">            head[next].push_back(prev);</span><br><span class="line">        &#125;</span><br><span class="line">        DFS();</span><br><span class="line">        ans = *<span class="built_in">std</span>::max_element(depthWalk + <span class="number">1</span>, depthWalk + <span class="number">1</span> + N);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; L) <span class="keyword">return</span> L + <span class="number">1</span>; <span class="comment">// 能走的最长的路径已经超过了 L，直接返回 L + 1（把根节点算上）</span></span><br><span class="line">        ans = <span class="built_in">std</span>::min(N, ans + <span class="number">1</span> + (L - ans) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// ans + 1：走过的最长路径加上根节点</span></span><br><span class="line">        <span class="comment">// L - ans：剩下能走的路径，不能浪费</span></span><br><span class="line">        <span class="comment">// (L - ans) / 2：需要一半的路径来折返</span></span><br><span class="line">        <span class="comment">// 注意：剩下的 L - ans 这些路径可以在任何地方用来走，不只是用来在最深的点折返</span></span><br><span class="line">        <span class="comment">// 还有一种情况：所有的点都走完了，还有步数</span></span><br><span class="line">        <span class="comment">// 这时候答案就不会再继续累加了</span></span><br><span class="line">        <span class="comment">// 这种情况下 ans 就要对 N 取个 min</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得最后提交的时候不要带 main 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> int main() &#123;</span></span><br><span class="line"><span class="comment"> std::vector&lt;int&gt; fa;</span></span><br><span class="line"><span class="comment"> fa.clear();</span></span><br><span class="line"><span class="comment"> int x = 0;</span></span><br><span class="line"><span class="comment"> while (true) &#123;</span></span><br><span class="line"><span class="comment"> cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment"> if (x == -1) break;</span></span><br><span class="line"><span class="comment"> fa.push_back(x);</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> int l = 0;</span></span><br><span class="line"><span class="comment"> cin &gt;&gt; l;</span></span><br><span class="line"><span class="comment"> WalkOverATree wk;</span></span><br><span class="line"><span class="comment"> cout &lt;&lt; wk.maxNodesVisited(fa, l) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"> return 0;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Statement&quot;&gt;&lt;a href=&quot;#Problem-Statement&quot; class=&quot;headerlink&quot; title=&quot;Problem Statement&quot;&gt;&lt;/a&gt;Problem Statement&lt;/h1&gt;&lt;p&gt;Given is a tree on n nodes. The nodes are numbered 0 through n-1. You are given the description of the tree as a int[]  &lt;strong&gt;parent&lt;/strong&gt;  with n-1 elements. For each valid i, there is an edge between vertices (i+1) and  &lt;strong&gt;parent&lt;/strong&gt;[i].&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="TopCoder" scheme="https://blog.handwer-std.top/tags/TopCoder/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2519《[HAOI2011]problem a》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/Luogu-P2519-BZOJ2298/"/>
    <id>https://blog.handwer-std.top/2019-07-30/Luogu-P2519-BZOJ2298/</id>
    <published>2019-07-30T14:38:23.000Z</published>
    <updated>2019-07-30T15:27:14.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人类智慧题</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一次考试共有n个人参加，第i个人说：“有ai个人分数比我高，bi个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个整数n，接下来n行每行两个整数，第i+1行的两个整数分别代表ai、bi</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>一个整数，表示最少有几个人说谎</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3  </span><br><span class="line">2 0  </span><br><span class="line">0 2    </span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我个人对「人类智慧题」的定义是「运用人脑求特殊解也想不出来的问题」</p><p>第一眼看到这题的时候，我一脸问号<br>直到老师开始讲题……</p><hr><p>首先，把题目转化一下<br>对于每个学生，给定了有多少人成绩比他好，成绩比他差，那就把它转化为一个成绩区间，表示这个区间内的人（可能只有 1 个）成绩相同</p><p>然后考虑一下「假话」的判断方式</p><ol><li>成绩比他好的 + 成绩比他差的 + 他 &gt; 总人数<br>这个请自行理解</li><li>两个有交集的区间没有完全相同，那么两个区间必有一个是假话<br>这个很显然吧，就是两个区间有交集的话说明它们是一个成绩，然而小于这个成绩的人或大于这个成绩的人却不相同</li><li>对于一堆完全相同的区间，它们之间是真话的个数至多是[区间长度]个，超出的部分全都是假话<br>想一想区间长度的现实意义是什么：有[区间长度]个学生成绩相同。那么，一个成绩是有[区间长度]个人的，也就是说，至多有[区间长度]个属于这个区间对应的成绩的学生在说真话（可以看作他们的成绩属于这个区间对应的成绩），剩下的学生都在说假话。<br>这样说应该会好理解一些吧……实在不行我举个例子：[2,4]，意味着这个区间对应的成绩有 3 个人获得了，那么如果有 4 个人说“我获得了这个成绩”，那么肯定有 1 个人在说假话。</li></ol><p>经过筛选，区间数量减少了一些，再去个重，把相同的区间个数用权值的形式表示出来（对每种区间分配唯一 id），比如说我有三个[2,4]和一个[7,8]，我就可以对[2,4]这个区间加一个权值 3，对[7,8]这个区间加一个权值 1。</p><hr><p>那么问题现在变成了：带权值的线段覆盖，求最大权值和</p><p>这个就是一个 dp 问题了</p><p>下面这一段也是从我代码里复制过来的（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设 F[i] 表示选择右端点不超过 i 的最大权值</span><br><span class="line">// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话</span><br><span class="line">// 初始：F[i] = F[i - 1]</span><br><span class="line">// 转移：当 i 点为某一线段的右端点时，</span><br><span class="line">// F[i] = max(F[i], F[j - 1] + Weight)</span><br><span class="line">// 其中 j 为该线段的左端点，Weight 为该线段的权值</span><br><span class="line">// (j - 1) 是因为线段不能重叠</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>代码里有很多注释，应该会很好理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2519.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2011]problem a</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ2298</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, w;</span><br><span class="line">    </span><br><span class="line">    Segment(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : l(l), r(r), w(w) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Segment &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == that.r) <span class="keyword">return</span> l &lt; that.l;</span><br><span class="line">        <span class="keyword">return</span> r &lt; that.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; segt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Ls[MAXN], Rs[MAXN], Ws[MAXN];</span><br><span class="line"><span class="comment">// segt 记录读入后经过处理的线段，Ls, Rs, Ws 记录去重后的线段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt, cntnew;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="comment">// 将给定的数据转化为学生 i 的排名</span></span><br><span class="line">        <span class="comment">// 用区间[l,r]的形式表示（按成绩排名）第 l 个人到第 r 个人成绩相同</span></span><br><span class="line">        <span class="comment">// 考虑把所有完全相同的线段记为单个带权值的线段</span></span><br><span class="line">        <span class="comment">// 那么问题就变为了一个带权线段覆盖问题</span></span><br><span class="line">        <span class="keyword">if</span> (l + r &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 学生数量不合法，显然是错的</span></span><br><span class="line">        ++l; r = (n - ((r + <span class="number">1</span>) - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 避免出现左端点为 0 的情况，因为读入的 l 有可能是 0</span></span><br><span class="line">        segt[++cnt] = Segment(l, r); <span class="comment">// 记一下目前合法的线段数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(segt + <span class="number">1</span>, segt + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(segt[i].l == segt[i - <span class="number">1</span>].l &amp;&amp; segt[i].r == segt[i - <span class="number">1</span>].r)) ++cntnew;</span><br><span class="line">        <span class="comment">// 两条线段如果重合，就增加该线段的权值</span></span><br><span class="line">        <span class="comment">// 两条线段如果不重合，就新开一条线段</span></span><br><span class="line">        <span class="comment">// 本质是一个去重并合并权值的过程</span></span><br><span class="line">        Ws[cntnew] = <span class="built_in">std</span>::min((segt[i].r - segt[i].l + <span class="number">1</span>), Ws[cntnew] + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 重合的线段表示有(线段长度)个人是相同成绩的</span></span><br><span class="line">        <span class="comment">// 所以每组重合线段（按线段长度分组）的个数如果超过了它的长度</span></span><br><span class="line">        <span class="comment">// 则超出去的那部分必定是假话</span></span><br><span class="line">        Ls[cntnew] = segt[i].l; Rs[cntnew] = segt[i].r;</span><br><span class="line">        <span class="comment">// 记一下去重后的线段</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 设 F[i] 表示选择右端点不超过 i 的最大权值</span></span><br><span class="line">        <span class="comment">// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话</span></span><br><span class="line">        <span class="comment">// 初始：F[i] = F[i - 1]</span></span><br><span class="line">        <span class="comment">// 转移：当 i 点为某一线段的右端点时，</span></span><br><span class="line">        <span class="comment">// F[i] = max(F[i], F[j - 1] + Weight)</span></span><br><span class="line">        <span class="comment">// 其中 j 为该线段的左端点，Weight 为该线段的权值</span></span><br><span class="line">        <span class="comment">// (j - 1) 是因为线段不能重叠</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= cntnew &amp;&amp; Rs[j] == i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">std</span>::max(dp[i], dp[Ls[j] - <span class="number">1</span>] + Ws[j]);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于 F[i] 表示说真话的数量，所以答案为学生的数量 - 说真话的数量</span></span><br><span class="line">    <span class="comment">// 也就是 n - dp[n]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人类智慧题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://blog.handwer-std.top/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>CF816E / CF815C《Karen and Supermarket》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/CF816E-CF815C/"/>
    <id>https://blog.handwer-std.top/2019-07-30/CF816E-CF815C/</id>
    <published>2019-07-30T11:45:09.000Z</published>
    <updated>2019-07-30T12:09:15.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>On the way home, Karen decided to stop by the supermarket to buy some groceries.</p><a id="more"></a><p><img src="https://vj.ti12z.cn/7bda7944615fd91edd669116f72aa574?v=1564372682" alt=""></p><p>She needs to buy a lot of goods, but since she is a student her budget is still quite limited. In fact, she can only spend up to  $b$  dollars.</p><p>The supermarket sells  $n$  goods. The  $i$-th good can be bought for  $c_i$  dollars. Of course, each good can only be bought once.</p><p>Lately, the supermarket has been trying to increase its business. Karen, being a loyal customer, was given  $n$  coupons. If Karen purchases the  $i$-th good, she can use the  $i$-th coupon to decrease its price by  $d_i$. Of course, a coupon cannot be used without buying the corresponding good.</p><p>There is, however, a constraint with the coupons. For all  $i≥ 2$, in order to use the  $i$-th coupon, Karen must also use the  $x_i$ -th coupon (which may mean using even more coupons to satisfy the requirement for that coupon).</p><p>Karen wants to know the following. What is the maximum number of goods she can buy, without exceeding her budget  $b$?</p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>The first line of input contains two integers  nn  and  bb  (  1&lt;=n&lt;=50001&lt;=n&lt;=5000  ,  1&lt;=b&lt;=10^{9}1&lt;=b&lt;=109  ), the number of goods in the store and the amount of money Karen has, respectively.</p><p>The next  nn  lines describe the items. Specifically:</p><ul><li>The  ii  -th line among these starts with two integers,  c_{i}ci​  and  d_{i}di​  (  1&lt;=d_{i}&lt;c_{i}&lt;=10^{9}1&lt;=di​&lt;ci​&lt;=109  ), the price of the  ii  -th good and the discount when using the coupon for the  ii  -th good, respectively.</li><li>If  i&gt;=2i&gt;=2  , this is followed by another integer,  x_{i}xi​  (  1&lt;=x_{i}&lt;i1&lt;=xi​&lt;i  ), denoting that the  x_{i}xi​  -th coupon must also be used before this coupon can be used.</li></ul><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>Output a single integer on a line by itself, the number of different goods Karen can buy, without exceeding her budget.</p><h3 id="Input-Output-Samples"><a href="#Input-Output-Samples" class="headerlink" title="Input / Output Samples"></a>Input / Output Samples</h3><p><strong>Input #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 16</span><br><span class="line">10 9</span><br><span class="line">10 5 1</span><br><span class="line">12 2 1</span><br><span class="line">20 18 3</span><br><span class="line">10 2 3</span><br><span class="line">2 1 5</span><br></pre></td></tr></table></figure><p><strong>Output #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>Input #2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 10</span><br><span class="line">3 1</span><br><span class="line">3 1 1</span><br><span class="line">3 1 2</span><br><span class="line">3 1 3</span><br><span class="line">3 1 4</span><br></pre></td></tr></table></figure><p><strong>Output #2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>从代码里复制过来的（</p><p>一道树形 DP</p><p>显然优惠券的使用逻辑可以构成一棵树<br>设 $\text{f[i][j][0/1]}$ 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费<br>初始状态：</p><p>$\text{f[][][] = INF}$<br>$\text{f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read}$</p><p>转移方程：<br>$\text{f[root][i + j][0] = min{ f[root][i + j][0], f[root][i][0] + f[u][j][0] | u} \in subtree(root) \ }$<br>$\text{f[root][i + j][1] = min{ f[root][i + j][1], f[root][i][1] + min{ f[u][j][0], f[u][j][1] } | u}  \in subtree(root)\ }$</p><p>其中 $i \leq \text{size[root]}, j \leq \text{size[u]}$，i 需要倒序枚举来避免重复选商品</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CF816E.cpp</span></span><br><span class="line"><span class="comment">//  Title: Karen and Supermarket</span></span><br><span class="line"><span class="comment">//  Alternatives: CF815C</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/30.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="comment">// CodeForces 中请使用 %I64d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 显然优惠券的使用逻辑可以构成一棵树</span></span><br><span class="line"><span class="comment"> * 设 f[i][j][0/1] 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费</span></span><br><span class="line"><span class="comment"> * 初始状态：</span></span><br><span class="line"><span class="comment"> * f[][][] = INF</span></span><br><span class="line"><span class="comment"> * f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read</span></span><br><span class="line"><span class="comment"> * 转移方程：</span></span><br><span class="line"><span class="comment"> * f[root][i + j][0] = min&#123; f[root][i + j][0], f[root][i][0] + f[u][j][0] | u 为 root 的孩子 &#125;</span></span><br><span class="line"><span class="comment"> * f[root][i + j][1] = min&#123; f[root][i + j][1], f[root][i][1] + min&#123; f[u][j][0], f[u][j][1] &#125; | u 为 root 的孩子 &#125;</span></span><br><span class="line"><span class="comment"> * 其中 i &lt;= size[root], j &lt;= size[u]，i 需要倒序枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">lli dp[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> size[MAXN];</span><br><span class="line"><span class="comment">// dp 数组耗空间约 383MB</span></span><br><span class="line"><span class="comment">// size 数组耗空间约 20KB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : head[u]) &#123;</span><br><span class="line">        DFS(v, u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size[u]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= size[v]; ++j) &#123;</span><br><span class="line">                dp[u][i + j][<span class="number">0</span>] = <span class="built_in">std</span>::min(</span><br><span class="line">                    dp[u][i + j][<span class="number">0</span>],</span><br><span class="line">                    dp[u][i][<span class="number">0</span>] + dp[v][j][<span class="number">0</span>]</span><br><span class="line">                );</span><br><span class="line">                dp[u][i + j][<span class="number">1</span>] = <span class="built_in">std</span>::min(</span><br><span class="line">                    dp[u][i + j][<span class="number">1</span>],</span><br><span class="line">                    dp[u][i][<span class="number">1</span>] + <span class="built_in">std</span>::min(</span><br><span class="line">                        dp[v][j][<span class="number">0</span>],</span><br><span class="line">                        dp[v][j][<span class="number">1</span>]</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); b = getint();</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">0</span>] = getll();</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>][<span class="number">0</span>] - getll();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = getint();</span><br><span class="line">            head[next].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="keyword">int</span> i = n;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][i][<span class="number">0</span>] &lt;= b || dp[<span class="number">1</span>][i][<span class="number">1</span>] &lt;= b) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;On the way home, Karen decided to stop by the supermarket to buy some groceries.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://blog.handwer-std.top/tags/Codeforces/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2218《[HAOI2007]覆盖问题》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/Luogu-P2218-BZOJ1052/"/>
    <id>https://blog.handwer-std.top/2019-07-30/Luogu-P2218-BZOJ1052/</id>
    <published>2019-07-30T00:14:10.000Z</published>
    <updated>2019-07-30T00:34:54.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>某人在山上种了N棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用3个L*L的正方形塑料薄膜将小树遮起来。</p><a id="more"></a><p>我们不妨将山建立一个平面直角坐标系，设第i棵小树的坐标为（Xi,Yi），3个L*L的正方形的边要求平行 与坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求L最小值。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有一个正整数N，表示有多少棵树。</p><p>接下来有N行，第i+1行有2个整数Xi,Yi，表示第i棵树的坐标，保证不会有2个树的坐标相同。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一行，输出最小的L值。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 1</span><br><span class="line">0 -1</span><br><span class="line">1 0</span><br><span class="line">-1 0</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>数据范围</p><p>100%的数据，-1,000,000,000&lt;=Xi,Yi&lt;=1,000,000,000</p><p>30%的数据，N&lt;=100</p><p>50%的数据，N&lt;=2000</p><p>100%的数据，N&lt;=20000</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然答案具有单调性，因为边长为 k 的正方形能覆盖的话，边长为 k + 1 的正方形一定能覆盖<br>考虑二分答案</p><hr><p>首先用一个最小的矩形覆盖所有的点</p><p>很容易想到一个做法：先把矩形的左上角、右下角用正方形覆盖，再把中间的用正方形覆盖<br>然而这样是不行的，反例很多，这里就不写了<br>但是换个思路，矩形的四个角一定会有贴着边放的正方形</p><p>所以换一个做法：枚举矩形的四个角，放正方形；此时还剩下一些点，再找一个最小的矩形覆盖所有点，递归进去做即可，深度只有 3 层</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2218.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2007]覆盖问题</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ1052</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">lli n, maxx = -(<span class="number">0x3f3f3f3f</span>), minx = (<span class="number">0x3f3f3f3f</span>), maxy = -(<span class="number">0x3f3f3f3f</span>), miny = (<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">lli x[MAXN], y[MAXN];</span><br><span class="line"><span class="keyword">int</span> cov[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 确定一个最小的矩形使得这个矩形可以覆盖所有点。</span></span><br><span class="line"><span class="comment"> * 枚举这个矩形的四个角，把一个正方形放到这个角上，</span></span><br><span class="line"><span class="comment"> * 有一些点会被覆盖，此时递归进去确定剩下未被覆盖的点即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Cover(<span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> ly, <span class="keyword">int</span> ry, <span class="keyword">int</span> ts) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!cov[i]</span><br><span class="line">            &amp;&amp; lx &lt;= x[i] &amp;&amp; x[i] &lt;= rx</span><br><span class="line">            &amp;&amp; ly &lt;= y[i] &amp;&amp; y[i] &lt;= ry)</span><br><span class="line">            cov[i] = ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Uncover</span><span class="params">(<span class="keyword">int</span> ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cov[i] == ts)</span><br><span class="line">            cov[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _CHECK(<span class="keyword">int</span> mid, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">    lli minx = INF, maxx = -INF, miny = INF, maxy = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!cov[i]) &#123;</span><br><span class="line">            minx = min(minx, x[i]); maxx = max(maxx, x[i]);</span><br><span class="line">            miny = min(miny, y[i]); maxy = max(maxy, y[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (max(maxx - minx, maxy - miny) &lt;= mid) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    _Cover(minx, minx + mid, miny, miny + mid, depth); <span class="comment">// ld</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(minx, minx + mid, maxy - mid, maxy, depth); <span class="comment">// lu</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(maxx - mid, maxx, miny, miny + mid, depth); <span class="comment">// rd</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(maxx - mid, maxx, maxy - mid, maxy, depth); <span class="comment">// ru</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cov, <span class="number">0</span>, <span class="keyword">sizeof</span> cov);</span><br><span class="line">    <span class="keyword">return</span> _CHECK(mid, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; x[i] = getint(); y[i] = getint(); &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;某人在山上种了N棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用3个L*L的正方形塑料薄膜将小树遮起来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="贪心" scheme="https://blog.handwer-std.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="递归" scheme="https://blog.handwer-std.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2341《[HAOI2006]受欢迎的牛》</title>
    <link href="https://blog.handwer-std.top/2019-07-29/Luogu-P2341-BZOJ1051-LOJ10091/"/>
    <id>https://blog.handwer-std.top/2019-07-29/Luogu-P2341-BZOJ1051-LOJ10091/</id>
    <published>2019-07-29T14:40:15.000Z</published>
    <updated>2019-07-30T00:38:00.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Tarjan 缩点板子题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶</p><p>牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜</p><p>欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你</p><p>算出有多少头奶牛可以当明星。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行：两个用空格分开的整数：N和M</p><p>第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>第一行：单独一个整数，表示明星奶牛的数量</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>只有 3 号奶牛可以做明星</p><p>【数据范围】</p><p>10%的数据N&lt;=20, M&lt;=50</p><p>30%的数据N&lt;=1000,M&lt;=20000</p><p>70%的数据N&lt;=5000,M&lt;=50000</p><p>100%的数据N&lt;=10000,M&lt;=50000 </p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先把题目转化一下</p><p>显然能成为明星的奶牛<strong>们</strong>一定是互相喜欢的<br>那么可以这样想：能成为明星的奶牛们都是在一个强连通分量中的，这样意味着互相喜欢<br>所以问题转化为了求图中强连通分量大小，这个用 Tarjan 来完成</p><p>值得注意的是，把强连通分量缩点之后，所得的图一定是一个DAG（这是一个性质）（实际写代码的时候不需要重新建图）<br>回到题目，缩完点之后，强连通分量对应的点的出度一定为0，而且有且仅有强连通分量对应的点出度为 0，因为如果强连通分量对应的点出度大于 0，则连出去的边与其他的点连到强连通分量的边就构成了一个环，与上面的性质相矛盾</p><p>注意到强连通分量对应的点出度为 0，那么该图合法必须要保证只有一个强连通分量（想一想，为什么）</p><p>所以写代码的思路就大体形成了：<br>Tarjan求强连通分量大小➡️缩点求出度➡️判断强连通分量个数➡️输出0或者强连通分量大小</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2341.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2006]受欢迎的牛</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ1051-LOJ10091</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/28.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inStack[MAXN];</span><br><span class="line"><span class="keyword">int</span> rep[MAXM], ren[MAXM];</span><br><span class="line"><span class="comment">// 把输入数据存一下</span></span><br><span class="line"><span class="keyword">int</span> sizSC[MAXN], ode[MAXN];</span><br><span class="line"><span class="keyword">int</span> ftot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top, Stack[MAXN];</span><br><span class="line"><span class="keyword">int</span> col, timestamp, SC[MAXN];</span><br><span class="line"><span class="comment">// dfn：dfs的时间戳</span></span><br><span class="line"><span class="comment">// low：在点u的子树能到达的节点中dfn的最小值</span></span><br><span class="line"><span class="comment">// SC：点u属于哪一个强连通分量</span></span><br><span class="line"><span class="comment">// inStack：是否在栈中</span></span><br><span class="line"><span class="comment">// sizSC：该强连通分量的大小</span></span><br><span class="line"><span class="comment">// ode：该“点”的出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; head[x].push_back(y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    low[u] = dfn[u] = ++timestamp;</span><br><span class="line">    Stack[++top] = u;</span><br><span class="line">    inStack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            <span class="comment">// 没被访问过</span></span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inStack[v]) low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">        <span class="comment">// 意味着u的子树中没有能到达u的祖先的边，也就是找到了一个强连通分量</span></span><br><span class="line">        SC[u] = ++col;</span><br><span class="line">        inStack[u] = <span class="literal">false</span>;</span><br><span class="line">        ++sizSC[col];</span><br><span class="line">        <span class="keyword">while</span> (Stack[top] != u) &#123;</span><br><span class="line">            SC[Stack[top]] = col;</span><br><span class="line">            ++sizSC[col];</span><br><span class="line">            inStack[Stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        addEdge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="comment">// 对所有联通块进行tarjan</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[i].size(); j &lt; siz; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = head[i][j];</span><br><span class="line">            <span class="keyword">if</span> (SC[i] != SC[v]) ++ode[SC[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= col; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!ode[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans) &#123; <span class="built_in">printf</span>(<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">            ans = sizSC[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tm这题我调了2h</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Tarjan 缩点板子题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="Tarjan" scheme="https://blog.handwer-std.top/tags/Tarjan/"/>
    
  </entry>
  
</feed>
