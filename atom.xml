<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Handwer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.handwer-std.top/"/>
  <updated>2019-07-12T13:28:29.982Z</updated>
  <id>https://blog.handwer-std.top/</id>
  
  <author>
    <name>Handwer STD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公告栏</title>
    <link href="https://blog.handwer-std.top/2019-10-31/BulletinBoard/"/>
    <id>https://blog.handwer-std.top/2019-10-31/BulletinBoard/</id>
    <published>2019-10-31T12:30:10.000Z</published>
    <updated>2019-07-12T13:28:29.982Z</updated>
    
    <content type="html"><![CDATA[<p><font style="color:#66ccff"></font></p><p><center>这里可能会挂些什么东西。 <br>There may be something here.<br></center><br><br><img src="https://v2.jinrishici.com/one.svg" alt="今日诗词"></p><!--博客累计已突破 100 篇文章--><!--New！[《「文章」百名学生参训 礼堂“变身”教室》](/2019-02-16/SDWC-Article/)-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font style=&quot;color:#66ccff&quot;&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;这里可能会挂些什么东西。 &lt;br&gt;There may be something here.&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://v2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>洛谷P3177《[HAOI2015]树上染色》</title>
    <link href="https://blog.handwer-std.top/2019-07-31/Luogu-P3177-BZOJ4033/"/>
    <id>https://blog.handwer-std.top/2019-07-31/Luogu-P3177-BZOJ4033/</id>
    <published>2019-07-31T15:30:50.000Z</published>
    <updated>2019-07-31T15:33:23.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我推式子推了半个小时。。。</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一棵点数为N的树，树边有边权。给你一个在0~N之内的正整数K，你要在这棵树中选择K个点，将其染成黑色，并</p><p>将其他的N-K个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间距离的和的收益。</p><p>问收益最大值是多少。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个整数N,K。</p><p>接下来N-1行每行三个正整数fr,to,dis，表示该树中存在一条长度为dis的边(fr,to)。</p><p>输入保证所有点之间是联通的。</p><p>N&lt;=2000,0&lt;=K&lt;=N</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一个正整数，表示收益的最大值。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">2</span>  </span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span>  </span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">1</span>  </span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">1</span>  </span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>【样例解释】<br>将点1,2染黑就能获得最大收益。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应设 $\text{dp[i][j]}$ 表示以 i 为根的子树选 j 个黑点的最大收益<br>但是是错的</p><p>康了一眼<a href="https://www.luogu.org/blog/ahaha254/solution-p3177" target="_blank" rel="noopener">这个</a>我就瞬间明白了<br>关于式子的推导，组成部分的意义，还有循环顺序的选择，这篇文章都讲得很清楚</p><p>老规矩，题解都在代码里</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  BZOJ4033.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2015]树上染色</span></span><br><span class="line"><span class="comment">//  Alternatives: Luogu-P3177</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参考资料：https://www.luogu.org/blog/ahaha254/solution-p3177</span></span><br><span class="line"><span class="comment"> * 关于 val(x,y) 和枚举顺序的解释可以康一康这篇文章</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设 f[i][j] 表示以 i 为根的子树中取了 j 个黑点「对答案的贡献」</span></span><br><span class="line"><span class="comment"> * 转移方程：</span></span><br><span class="line"><span class="comment"> * f[u][j] = max(</span></span><br><span class="line"><span class="comment"> *     f[u][j],</span></span><br><span class="line"><span class="comment"> *     f[u][j - k] + f[v][k] + val(u,v)</span></span><br><span class="line"><span class="comment"> * )</span></span><br><span class="line"><span class="comment"> * 其中 v 是 u 的儿子，k 是枚举出来的</span></span><br><span class="line"><span class="comment"> * j = min(m,size(x)) -&gt; 0, k = 0 -&gt; min(j,size(y))</span></span><br><span class="line"><span class="comment"> * 其中 val(x,y) 表示边 (x,y) 对答案的贡献，它等于</span></span><br><span class="line"><span class="comment"> * 「该边两边黑点数量的乘积 乘以 边长 加上 该边两边白点数量的乘积 乘以 边长」</span></span><br><span class="line"><span class="comment"> * 也就是 val(x,y) = k * (m - k) * weight(x,y) + (size(y) - k) * ((n - m) - (size(y) - k)) * weight(x,y)</span></span><br><span class="line"><span class="comment"> * 其中 m 是总的黑点数，k 是边 (x,y) 另一边的黑点数，那么 (m - k) 就是这一边的黑点数</span></span><br><span class="line"><span class="comment"> * size(y) 是以 y 为根的子树的大小，也就意味着 (size(y) - k) 是另一边的白点数（另一边的肯定不是黑点就是白点）</span></span><br><span class="line"><span class="comment"> * (n - m) 是总的白点数，(size(y) - k) 是另一边的白点数，也就意味着 ((n - m) - (size(y) - k)) 是边 (x,y) 这一边的白点数（白点肯定不在那边就在这边）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    lli w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> v = <span class="number">0</span>, lli w = <span class="number">0</span>) : v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, size[MAXN];</span><br><span class="line">lli dp[MAXN][MAXK];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXK];</span><br><span class="line"><span class="comment">// dp 数组大概 31 MB</span></span><br><span class="line"><span class="comment">// size 数组大概 8 KB</span></span><br><span class="line"><span class="comment">// vis 数组大概 4 MB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    size[root] = <span class="number">1</span>;</span><br><span class="line">    vis[root][<span class="number">0</span>] = vis[root][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i].v;</span><br><span class="line">        <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(next, root);</span><br><span class="line">        size[root] += size[next];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i].v;</span><br><span class="line">        <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">        lli weight = head[root][i].w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">std</span>::min(m, size[root]); j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="built_in">std</span>::min(j, size[next]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= up; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[root][j - k]) <span class="keyword">continue</span>;</span><br><span class="line">                lli val = k * (m - k) * weight + (size[next] - k) * ((n - m) - (size[next] - k)) * weight;</span><br><span class="line">                dp[root][j] = <span class="built_in">std</span>::max(dp[root][j], dp[root][j - k] + dp[next][k] + val);</span><br><span class="line">                vis[root][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); m = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n - <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint(), next = getint(), weight = getint();</span><br><span class="line">        head[prev].push_back(Edge(next, weight));</span><br><span class="line">        head[next].push_back(Edge(prev, weight));</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我推式子推了半个小时。。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>TopCoder13955</title>
    <link href="https://blog.handwer-std.top/2019-07-31/TopCoder13955/"/>
    <id>https://blog.handwer-std.top/2019-07-31/TopCoder13955/</id>
    <published>2019-07-31T14:58:03.000Z</published>
    <updated>2019-07-31T15:08:13.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h1><p>Given is a tree on n nodes. The nodes are numbered 0 through n-1. You are given the description of the tree as a int[]  <strong>parent</strong>  with n-1 elements. For each valid i, there is an edge between vertices (i+1) and  <strong>parent</strong>[i].</p><a id="more"></a><p>A person is currently standing in node 0. In a single step, the person can move from its current node to any adjacent node. You are given an int  <strong>L</strong>. The person is allowed to make at most  <strong>L</strong>  steps.</p><p>Return the maximum number of nodes the person can visit during the walk. Node 0 (where the walk starts) and the node where the walk ends count as visited. Each visited node is only counted once, even if it is visited multiple times.</p><h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><p>Class: WalkOverATree<br>Method: maxNodesVisited<br>Parameters: int[], int<br>Returns: int<br>Method signature: int maxNodesVisited(int[] parent, int L)<br>(be sure your method is public)</p><h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><ul><li><p><strong>parent</strong>  will contain between 0 and 49 elements, inclusive.</p></li><li><p>For each i,  <strong>parent</strong>[i] will be between 0 and i, inclusive.</p></li><li><p><strong>L</strong>  will be between 1 and 100, inclusive.</p></li></ul><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>请自行到 vjudge 上寻找</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>英文很好懂，只需人教初二水平（反正我准初三选手看懂了）</p><p>题目大意：<br>给定一棵 n 个点的树，编号 0~n-1。连边方式以输入每个点的父亲给出，对于每个 i，有一条边连接点 (i+1) 和点 father[i]，而且 father[i] 是 (i+1) 的父亲。<br>有一个人站在点 0，可以向四周走不超过 L 步，求出这个人能经过多少不同的点</p><p>这题和 dp 有什么关系吗。。。</p><p>这题的难点大概就是 class 的使用和答案统计了吧</p><p>class 的使用可以参考<a href="https://blog.csdn.net/qq_31908675/article/details/81198751" target="_blank" rel="noopener">这里</a></p><p>答案统计和基本的思路见代码吧</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  TopCoder13955.cpp</span></span><br><span class="line"><span class="comment">//  Title: WalkOverATree</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt;= s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WalkOverATree</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 直接暴力就好了。。。</span></span><br><span class="line"><span class="comment">     * 一遍 DFS 预处理出所有的点的深度（根节点深度为 0）</span></span><br><span class="line"><span class="comment">     * 答案的输出见下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> depthWalk[MAXL];</span><br><span class="line">    <span class="keyword">int</span> maxstep = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>, <span class="keyword">int</span> step = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        depthWalk[root] = step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = head[root][i];</span><br><span class="line">            <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">            DFS(next, root, step + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNodesVisited</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        maxstep = L;</span><br><span class="line">        <span class="keyword">int</span> N = (<span class="keyword">int</span>) father.size() + <span class="number">1</span>; <span class="comment">// 把根节点算上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = N - <span class="number">1</span>; i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = (i + <span class="number">1</span>) + <span class="number">1</span>, next = father[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 编号整体加一</span></span><br><span class="line">            head[prev].push_back(next);</span><br><span class="line">            head[next].push_back(prev);</span><br><span class="line">        &#125;</span><br><span class="line">        DFS();</span><br><span class="line">        ans = *<span class="built_in">std</span>::max_element(depthWalk + <span class="number">1</span>, depthWalk + <span class="number">1</span> + N);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; L) <span class="keyword">return</span> L + <span class="number">1</span>; <span class="comment">// 能走的最长的路径已经超过了 L，直接返回 L + 1（把根节点算上）</span></span><br><span class="line">        ans = <span class="built_in">std</span>::min(N, ans + <span class="number">1</span> + (L - ans) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// ans + 1：走过的最长路径加上根节点</span></span><br><span class="line">        <span class="comment">// L - ans：剩下能走的路径，不能浪费</span></span><br><span class="line">        <span class="comment">// (L - ans) / 2：需要一半的路径来折返</span></span><br><span class="line">        <span class="comment">// 注意：剩下的 L - ans 这些路径可以在任何地方用来走，不只是用来在最深的点折返</span></span><br><span class="line">        <span class="comment">// 还有一种情况：所有的点都走完了，还有步数</span></span><br><span class="line">        <span class="comment">// 这时候答案就不会再继续累加了</span></span><br><span class="line">        <span class="comment">// 这种情况下 ans 就要对 N 取个 min</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得最后提交的时候不要带 main 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> int main() &#123;</span></span><br><span class="line"><span class="comment"> std::vector&lt;int&gt; fa;</span></span><br><span class="line"><span class="comment"> fa.clear();</span></span><br><span class="line"><span class="comment"> int x = 0;</span></span><br><span class="line"><span class="comment"> while (true) &#123;</span></span><br><span class="line"><span class="comment"> cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment"> if (x == -1) break;</span></span><br><span class="line"><span class="comment"> fa.push_back(x);</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> int l = 0;</span></span><br><span class="line"><span class="comment"> cin &gt;&gt; l;</span></span><br><span class="line"><span class="comment"> WalkOverATree wk;</span></span><br><span class="line"><span class="comment"> cout &lt;&lt; wk.maxNodesVisited(fa, l) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"> return 0;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Statement&quot;&gt;&lt;a href=&quot;#Problem-Statement&quot; class=&quot;headerlink&quot; title=&quot;Problem Statement&quot;&gt;&lt;/a&gt;Problem Statement&lt;/h1&gt;&lt;p&gt;Given is a tree on n nodes. The nodes are numbered 0 through n-1. You are given the description of the tree as a int[]  &lt;strong&gt;parent&lt;/strong&gt;  with n-1 elements. For each valid i, there is an edge between vertices (i+1) and  &lt;strong&gt;parent&lt;/strong&gt;[i].&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="TopCoder" scheme="https://blog.handwer-std.top/tags/TopCoder/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2519《[HAOI2011]problem a》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/Luogu-P2519-BZOJ2298/"/>
    <id>https://blog.handwer-std.top/2019-07-30/Luogu-P2519-BZOJ2298/</id>
    <published>2019-07-30T14:38:23.000Z</published>
    <updated>2019-07-30T15:27:14.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人类智慧题</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一次考试共有n个人参加，第i个人说：“有ai个人分数比我高，bi个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个整数n，接下来n行每行两个整数，第i+1行的两个整数分别代表ai、bi</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>一个整数，表示最少有几个人说谎</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span> </span><br><span class="line"><span class="symbol">2 </span><span class="number">0</span>  </span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span>    </span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我个人对「人类智慧题」的定义是「运用人脑求特殊解也想不出来的问题」</p><p>第一眼看到这题的时候，我一脸问号<br>直到老师开始讲题……</p><hr><p>首先，把题目转化一下<br>对于每个学生，给定了有多少人成绩比他好，成绩比他差，那就把它转化为一个成绩区间，表示这个区间内的人（可能只有 1 个）成绩相同</p><p>然后考虑一下「假话」的判断方式</p><ol><li>成绩比他好的 + 成绩比他差的 + 他 &gt; 总人数<br>这个请自行理解</li><li>两个有交集的区间没有完全相同，那么两个区间必有一个是假话<br>这个很显然吧，就是两个区间有交集的话说明它们是一个成绩，然而小于这个成绩的人或大于这个成绩的人却不相同</li><li>对于一堆完全相同的区间，它们之间是真话的个数至多是[区间长度]个，超出的部分全都是假话<br>想一想区间长度的现实意义是什么：有[区间长度]个学生成绩相同。那么，一个成绩是有[区间长度]个人的，也就是说，至多有[区间长度]个属于这个区间对应的成绩的学生在说真话（可以看作他们的成绩属于这个区间对应的成绩），剩下的学生都在说假话。<br>这样说应该会好理解一些吧……实在不行我举个例子：[2,4]，意味着这个区间对应的成绩有 3 个人获得了，那么如果有 4 个人说“我获得了这个成绩”，那么肯定有 1 个人在说假话。</li></ol><p>经过筛选，区间数量减少了一些，再去个重，把相同的区间个数用权值的形式表示出来（对每种区间分配唯一 id），比如说我有三个[2,4]和一个[7,8]，我就可以对[2,4]这个区间加一个权值 3，对[7,8]这个区间加一个权值 1。</p><hr><p>那么问题现在变成了：带权值的线段覆盖，求最大权值和</p><p>这个就是一个 dp 问题了</p><p>下面这一段也是从我代码里复制过来的（</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设 F[i] 表示选择右端点不超过 i 的最大权值</span></span><br><span class="line"><span class="comment">// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话</span></span><br><span class="line"><span class="comment">// 初始：F[i] = F[i - 1]</span></span><br><span class="line"><span class="comment">// 转移：当 i 点为某一线段的右端点时，</span></span><br><span class="line"><span class="comment">// F[i] = max(F[i], F[j - 1] + Weight)</span></span><br><span class="line"><span class="comment">// 其中 j 为该线段的左端点，Weight 为该线段的权值</span></span><br><span class="line"><span class="comment">// (j - 1) 是因为线段不能重叠</span></span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>代码里有很多注释，应该会很好理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2519.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2011]problem a</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ2298</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, w;</span><br><span class="line">    </span><br><span class="line">    Segment(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : l(l), r(r), w(w) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Segment &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == that.r) <span class="keyword">return</span> l &lt; that.l;</span><br><span class="line">        <span class="keyword">return</span> r &lt; that.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; segt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Ls[MAXN], Rs[MAXN], Ws[MAXN];</span><br><span class="line"><span class="comment">// segt 记录读入后经过处理的线段，Ls, Rs, Ws 记录去重后的线段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt, cntnew;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="comment">// 将给定的数据转化为学生 i 的排名</span></span><br><span class="line">        <span class="comment">// 用区间[l,r]的形式表示（按成绩排名）第 l 个人到第 r 个人成绩相同</span></span><br><span class="line">        <span class="comment">// 考虑把所有完全相同的线段记为单个带权值的线段</span></span><br><span class="line">        <span class="comment">// 那么问题就变为了一个带权线段覆盖问题</span></span><br><span class="line">        <span class="keyword">if</span> (l + r &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 学生数量不合法，显然是错的</span></span><br><span class="line">        ++l; r = (n - ((r + <span class="number">1</span>) - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 避免出现左端点为 0 的情况，因为读入的 l 有可能是 0</span></span><br><span class="line">        segt[++cnt] = Segment(l, r); <span class="comment">// 记一下目前合法的线段数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(segt + <span class="number">1</span>, segt + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(segt[i].l == segt[i - <span class="number">1</span>].l &amp;&amp; segt[i].r == segt[i - <span class="number">1</span>].r)) ++cntnew;</span><br><span class="line">        <span class="comment">// 两条线段如果重合，就增加该线段的权值</span></span><br><span class="line">        <span class="comment">// 两条线段如果不重合，就新开一条线段</span></span><br><span class="line">        <span class="comment">// 本质是一个去重并合并权值的过程</span></span><br><span class="line">        Ws[cntnew] = <span class="built_in">std</span>::min((segt[i].r - segt[i].l + <span class="number">1</span>), Ws[cntnew] + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 重合的线段表示有(线段长度)个人是相同成绩的</span></span><br><span class="line">        <span class="comment">// 所以每组重合线段（按线段长度分组）的个数如果超过了它的长度</span></span><br><span class="line">        <span class="comment">// 则超出去的那部分必定是假话</span></span><br><span class="line">        Ls[cntnew] = segt[i].l; Rs[cntnew] = segt[i].r;</span><br><span class="line">        <span class="comment">// 记一下去重后的线段</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 设 F[i] 表示选择右端点不超过 i 的最大权值</span></span><br><span class="line">        <span class="comment">// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话</span></span><br><span class="line">        <span class="comment">// 初始：F[i] = F[i - 1]</span></span><br><span class="line">        <span class="comment">// 转移：当 i 点为某一线段的右端点时，</span></span><br><span class="line">        <span class="comment">// F[i] = max(F[i], F[j - 1] + Weight)</span></span><br><span class="line">        <span class="comment">// 其中 j 为该线段的左端点，Weight 为该线段的权值</span></span><br><span class="line">        <span class="comment">// (j - 1) 是因为线段不能重叠</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= cntnew &amp;&amp; Rs[j] == i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">std</span>::max(dp[i], dp[Ls[j] - <span class="number">1</span>] + Ws[j]);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于 F[i] 表示说真话的数量，所以答案为学生的数量 - 说真话的数量</span></span><br><span class="line">    <span class="comment">// 也就是 n - dp[n]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人类智慧题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://blog.handwer-std.top/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>CF816E / CF815C《Karen and Supermarket》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/CF816E-CF815C/"/>
    <id>https://blog.handwer-std.top/2019-07-30/CF816E-CF815C/</id>
    <published>2019-07-30T11:45:09.000Z</published>
    <updated>2019-07-30T12:09:15.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>On the way home, Karen decided to stop by the supermarket to buy some groceries.</p><a id="more"></a><p><img src="https://vj.ti12z.cn/7bda7944615fd91edd669116f72aa574?v=1564372682" alt></p><p>She needs to buy a lot of goods, but since she is a student her budget is still quite limited. In fact, she can only spend up to  $b$  dollars.</p><p>The supermarket sells  $n$  goods. The  $i$-th good can be bought for  $c_i$  dollars. Of course, each good can only be bought once.</p><p>Lately, the supermarket has been trying to increase its business. Karen, being a loyal customer, was given  $n$  coupons. If Karen purchases the  $i$-th good, she can use the  $i$-th coupon to decrease its price by  $d_i$. Of course, a coupon cannot be used without buying the corresponding good.</p><p>There is, however, a constraint with the coupons. For all  $i≥ 2$, in order to use the  $i$-th coupon, Karen must also use the  $x_i$ -th coupon (which may mean using even more coupons to satisfy the requirement for that coupon).</p><p>Karen wants to know the following. What is the maximum number of goods she can buy, without exceeding her budget  $b$?</p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>The first line of input contains two integers  nn  and  bb  (  1&lt;=n&lt;=50001&lt;=n&lt;=5000  ,  1&lt;=b&lt;=10^{9}1&lt;=b&lt;=109  ), the number of goods in the store and the amount of money Karen has, respectively.</p><p>The next  nn  lines describe the items. Specifically:</p><ul><li>The  ii  -th line among these starts with two integers,  c_{i}ci​  and  d_{i}di​  (  1&lt;=d_{i}&lt;c_{i}&lt;=10^{9}1&lt;=di​&lt;ci​&lt;=109  ), the price of the  ii  -th good and the discount when using the coupon for the  ii  -th good, respectively.</li><li>If  i&gt;=2i&gt;=2  , this is followed by another integer,  x_{i}xi​  (  1&lt;=x_{i}&lt;i1&lt;=xi​&lt;i  ), denoting that the  x_{i}xi​  -th coupon must also be used before this coupon can be used.</li></ul><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>Output a single integer on a line by itself, the number of different goods Karen can buy, without exceeding her budget.</p><h3 id="Input-Output-Samples"><a href="#Input-Output-Samples" class="headerlink" title="Input / Output Samples"></a>Input / Output Samples</h3><p><strong>Input #1</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">6 </span><span class="number">16</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">9</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">12 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">20 </span><span class="number">18</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>Output #1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>Input #2</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">10</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>Output #2</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>从代码里复制过来的（</p><p>一道树形 DP</p><p>显然优惠券的使用逻辑可以构成一棵树<br>设 $\text{f[i][j][0/1]}$ 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费<br>初始状态：</p><p>$\text{f[][][] = INF}$<br>$\text{f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read}$</p><p>转移方程：<br>$\text{f[root][i + j][0] = min{ f[root][i + j][0], f[root][i][0] + f[u][j][0] | u} \in subtree(root) \ }$<br>$\text{f[root][i + j][1] = min{ f[root][i + j][1], f[root][i][1] + min{ f[u][j][0], f[u][j][1] } | u}  \in subtree(root)\ }$</p><p>其中 $i \leq \text{size[root]}, j \leq \text{size[u]}$，i 需要倒序枚举来避免重复选商品</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CF816E.cpp</span></span><br><span class="line"><span class="comment">//  Title: Karen and Supermarket</span></span><br><span class="line"><span class="comment">//  Alternatives: CF815C</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/30.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="comment">// CodeForces 中请使用 %I64d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 显然优惠券的使用逻辑可以构成一棵树</span></span><br><span class="line"><span class="comment"> * 设 f[i][j][0/1] 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费</span></span><br><span class="line"><span class="comment"> * 初始状态：</span></span><br><span class="line"><span class="comment"> * f[][][] = INF</span></span><br><span class="line"><span class="comment"> * f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read</span></span><br><span class="line"><span class="comment"> * 转移方程：</span></span><br><span class="line"><span class="comment"> * f[root][i + j][0] = min&#123; f[root][i + j][0], f[root][i][0] + f[u][j][0] | u 为 root 的孩子 &#125;</span></span><br><span class="line"><span class="comment"> * f[root][i + j][1] = min&#123; f[root][i + j][1], f[root][i][1] + min&#123; f[u][j][0], f[u][j][1] &#125; | u 为 root 的孩子 &#125;</span></span><br><span class="line"><span class="comment"> * 其中 i &lt;= size[root], j &lt;= size[u]，i 需要倒序枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">lli dp[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> size[MAXN];</span><br><span class="line"><span class="comment">// dp 数组耗空间约 383MB</span></span><br><span class="line"><span class="comment">// size 数组耗空间约 20KB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : head[u]) &#123;</span><br><span class="line">        DFS(v, u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size[u]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= size[v]; ++j) &#123;</span><br><span class="line">                dp[u][i + j][<span class="number">0</span>] = <span class="built_in">std</span>::min(</span><br><span class="line">                    dp[u][i + j][<span class="number">0</span>],</span><br><span class="line">                    dp[u][i][<span class="number">0</span>] + dp[v][j][<span class="number">0</span>]</span><br><span class="line">                );</span><br><span class="line">                dp[u][i + j][<span class="number">1</span>] = <span class="built_in">std</span>::min(</span><br><span class="line">                    dp[u][i + j][<span class="number">1</span>],</span><br><span class="line">                    dp[u][i][<span class="number">1</span>] + <span class="built_in">std</span>::min(</span><br><span class="line">                        dp[v][j][<span class="number">0</span>],</span><br><span class="line">                        dp[v][j][<span class="number">1</span>]</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); b = getint();</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">0</span>] = getll();</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>][<span class="number">0</span>] - getll();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = getint();</span><br><span class="line">            head[next].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="keyword">int</span> i = n;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][i][<span class="number">0</span>] &lt;= b || dp[<span class="number">1</span>][i][<span class="number">1</span>] &lt;= b) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;On the way home, Karen decided to stop by the supermarket to buy some groceries.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://blog.handwer-std.top/tags/Codeforces/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2218《[HAOI2007]覆盖问题》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/Luogu-P2218-BZOJ1052/"/>
    <id>https://blog.handwer-std.top/2019-07-30/Luogu-P2218-BZOJ1052/</id>
    <published>2019-07-30T00:14:10.000Z</published>
    <updated>2019-07-30T00:34:54.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>某人在山上种了N棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用3个L*L的正方形塑料薄膜将小树遮起来。</p><a id="more"></a><p>我们不妨将山建立一个平面直角坐标系，设第i棵小树的坐标为（Xi,Yi），3个L*L的正方形的边要求平行 与坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求L最小值。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有一个正整数N，表示有多少棵树。</p><p>接下来有N行，第i+1行有2个整数Xi,Yi，表示第i棵树的坐标，保证不会有2个树的坐标相同。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一行，输出最小的L值。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">-1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>数据范围</p><p>100%的数据，-1,000,000,000&lt;=Xi,Yi&lt;=1,000,000,000</p><p>30%的数据，N&lt;=100</p><p>50%的数据，N&lt;=2000</p><p>100%的数据，N&lt;=20000</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然答案具有单调性，因为边长为 k 的正方形能覆盖的话，边长为 k + 1 的正方形一定能覆盖<br>考虑二分答案</p><hr><p>首先用一个最小的矩形覆盖所有的点</p><p>很容易想到一个做法：先把矩形的左上角、右下角用正方形覆盖，再把中间的用正方形覆盖<br>然而这样是不行的，反例很多，这里就不写了<br>但是换个思路，矩形的四个角一定会有贴着边放的正方形</p><p>所以换一个做法：枚举矩形的四个角，放正方形；此时还剩下一些点，再找一个最小的矩形覆盖所有点，递归进去做即可，深度只有 3 层</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2218.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2007]覆盖问题</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ1052</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">lli n, maxx = -(<span class="number">0x3f3f3f3f</span>), minx = (<span class="number">0x3f3f3f3f</span>), maxy = -(<span class="number">0x3f3f3f3f</span>), miny = (<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">lli x[MAXN], y[MAXN];</span><br><span class="line"><span class="keyword">int</span> cov[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 确定一个最小的矩形使得这个矩形可以覆盖所有点。</span></span><br><span class="line"><span class="comment"> * 枚举这个矩形的四个角，把一个正方形放到这个角上，</span></span><br><span class="line"><span class="comment"> * 有一些点会被覆盖，此时递归进去确定剩下未被覆盖的点即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Cover(<span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> ly, <span class="keyword">int</span> ry, <span class="keyword">int</span> ts) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!cov[i]</span><br><span class="line">            &amp;&amp; lx &lt;= x[i] &amp;&amp; x[i] &lt;= rx</span><br><span class="line">            &amp;&amp; ly &lt;= y[i] &amp;&amp; y[i] &lt;= ry)</span><br><span class="line">            cov[i] = ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Uncover</span><span class="params">(<span class="keyword">int</span> ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cov[i] == ts)</span><br><span class="line">            cov[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _CHECK(<span class="keyword">int</span> mid, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">    lli minx = INF, maxx = -INF, miny = INF, maxy = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!cov[i]) &#123;</span><br><span class="line">            minx = min(minx, x[i]); maxx = max(maxx, x[i]);</span><br><span class="line">            miny = min(miny, y[i]); maxy = max(maxy, y[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (max(maxx - minx, maxy - miny) &lt;= mid) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    _Cover(minx, minx + mid, miny, miny + mid, depth); <span class="comment">// ld</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(minx, minx + mid, maxy - mid, maxy, depth); <span class="comment">// lu</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(maxx - mid, maxx, miny, miny + mid, depth); <span class="comment">// rd</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(maxx - mid, maxx, maxy - mid, maxy, depth); <span class="comment">// ru</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cov, <span class="number">0</span>, <span class="keyword">sizeof</span> cov);</span><br><span class="line">    <span class="keyword">return</span> _CHECK(mid, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; x[i] = getint(); y[i] = getint(); &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;某人在山上种了N棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用3个L*L的正方形塑料薄膜将小树遮起来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="贪心" scheme="https://blog.handwer-std.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="递归" scheme="https://blog.handwer-std.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2341《[HAOI2006]受欢迎的牛》</title>
    <link href="https://blog.handwer-std.top/2019-07-29/Luogu-P2341-BZOJ1051-LOJ10091/"/>
    <id>https://blog.handwer-std.top/2019-07-29/Luogu-P2341-BZOJ1051-LOJ10091/</id>
    <published>2019-07-29T14:40:15.000Z</published>
    <updated>2019-07-30T00:38:00.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Tarjan 缩点板子题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶</p><p>牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜</p><p>欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你</p><p>算出有多少头奶牛可以当明星。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行：两个用空格分开的整数：N和M</p><p>第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>第一行：单独一个整数，表示明星奶牛的数量</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>只有 3 号奶牛可以做明星</p><p>【数据范围】</p><p>10%的数据N&lt;=20, M&lt;=50</p><p>30%的数据N&lt;=1000,M&lt;=20000</p><p>70%的数据N&lt;=5000,M&lt;=50000</p><p>100%的数据N&lt;=10000,M&lt;=50000 </p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先把题目转化一下</p><p>显然能成为明星的奶牛<strong>们</strong>一定是互相喜欢的<br>那么可以这样想：能成为明星的奶牛们都是在一个强连通分量中的，这样意味着互相喜欢<br>所以问题转化为了求图中强连通分量大小，这个用 Tarjan 来完成</p><p>值得注意的是，把强连通分量缩点之后，所得的图一定是一个DAG（这是一个性质）（实际写代码的时候不需要重新建图）<br>回到题目，缩完点之后，强连通分量对应的点的出度一定为0，而且有且仅有强连通分量对应的点出度为 0，因为如果强连通分量对应的点出度大于 0，则连出去的边与其他的点连到强连通分量的边就构成了一个环，与上面的性质相矛盾</p><p>注意到强连通分量对应的点出度为 0，那么该图合法必须要保证只有一个强连通分量（想一想，为什么）</p><p>所以写代码的思路就大体形成了：<br>Tarjan求强连通分量大小➡️缩点求出度➡️判断强连通分量个数➡️输出0或者强连通分量大小</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2341.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2006]受欢迎的牛</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ1051-LOJ10091</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/28.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inStack[MAXN];</span><br><span class="line"><span class="keyword">int</span> rep[MAXM], ren[MAXM];</span><br><span class="line"><span class="comment">// 把输入数据存一下</span></span><br><span class="line"><span class="keyword">int</span> sizSC[MAXN], ode[MAXN];</span><br><span class="line"><span class="keyword">int</span> ftot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top, Stack[MAXN];</span><br><span class="line"><span class="keyword">int</span> col, timestamp, SC[MAXN];</span><br><span class="line"><span class="comment">// dfn：dfs的时间戳</span></span><br><span class="line"><span class="comment">// low：在点u的子树能到达的节点中dfn的最小值</span></span><br><span class="line"><span class="comment">// SC：点u属于哪一个强连通分量</span></span><br><span class="line"><span class="comment">// inStack：是否在栈中</span></span><br><span class="line"><span class="comment">// sizSC：该强连通分量的大小</span></span><br><span class="line"><span class="comment">// ode：该“点”的出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; head[x].push_back(y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    low[u] = dfn[u] = ++timestamp;</span><br><span class="line">    Stack[++top] = u;</span><br><span class="line">    inStack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            <span class="comment">// 没被访问过</span></span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inStack[v]) low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">        <span class="comment">// 意味着u的子树中没有能到达u的祖先的边，也就是找到了一个强连通分量</span></span><br><span class="line">        SC[u] = ++col;</span><br><span class="line">        inStack[u] = <span class="literal">false</span>;</span><br><span class="line">        ++sizSC[col];</span><br><span class="line">        <span class="keyword">while</span> (Stack[top] != u) &#123;</span><br><span class="line">            SC[Stack[top]] = col;</span><br><span class="line">            ++sizSC[col];</span><br><span class="line">            inStack[Stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        addEdge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="comment">// 对所有联通块进行tarjan</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[i].size(); j &lt; siz; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = head[i][j];</span><br><span class="line">            <span class="keyword">if</span> (SC[i] != SC[v]) ++ode[SC[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= col; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!ode[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans) &#123; <span class="built_in">printf</span>(<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">            ans = sizSC[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tm这题我调了2h</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Tarjan 缩点板子题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="Tarjan" scheme="https://blog.handwer-std.top/tags/Tarjan/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2606《排列计数》</title>
    <link href="https://blog.handwer-std.top/2019-07-21/Luogu-P2606/"/>
    <id>https://blog.handwer-std.top/2019-07-21/Luogu-P2606/</id>
    <published>2019-07-21T12:14:10.000Z</published>
    <updated>2019-07-24T00:06:24.698Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>披着数论皮的图论</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>称一个1,2,…,N的排列P1,P2…,Pn是Magic的，当且仅当2&lt;=i&lt;=N时，Pi&gt;Pi/2. 计算1，2，…N的排列中有多少是Magic的，答案可能很大，只能输出模P以后的值</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第一行包含两个整数 n和p，含义如上所述。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件中仅包含一个整数，表示计算1,2,⋯, N的排列中， Magic排列的个数模 p的值。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p>输入样例</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">20 </span><span class="number">23</span></span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>100%的数据中，1 ≤N ≤ 10^6, P≤ 10^9，p是一个质数。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>考虑这么一个事情：<br><br>$P_i &gt; P_{i / 2}$放到一棵树上是什么？<br>把$P_i$看作第$i$个点的权值，那么…… <br>第$i$个点的权值比第$i/2$个点的权值要大，也就是第$i$个点的权值要比第$i \times 2$个点的权值要小……<br>想一想二叉树的表示方法……这好像是一个小根堆？</p><p>问题转化为了：求1-n的所有排列中，可以构成一个小根堆的排列的个数</p><p>考虑dp<br>设<code>dp[u]</code>表示以u为根结点分配1~size(u)的小根堆的方案数<br>转移：$$d p(x)=\left(\begin{array}{c}{\operatorname{sz}(x)-1} \ {\operatorname{sz}\left(u_{1}\right), s z\left(u_{2}\right), \ldots, s z\left(u_{r}\right)}\end{array}\right) \prod d p\left(u_{i}\right)$$</p><p>最终答案就是$dp(1)$</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>我开了O2才过。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n, HA, fac[MAXN], inv[MAXN], siz[MAXN], dp[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">long long int getll() &#123; </span></span><br><span class="line"><span class="comment">    long long int s = 0, x = 1; </span></span><br><span class="line"><span class="comment">    char ch = getchar(); </span></span><br><span class="line"><span class="comment">    while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; </span></span><br><span class="line"><span class="comment">    while (isdigit(ch)) &#123; s = s * x + 1ll * ch - 1ll * '0'; ch = getchar(); &#125; </span></span><br><span class="line"><span class="comment">    return 1ll * s * x; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void putll(long long int x) &#123; </span></span><br><span class="line"><span class="comment">    if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; </span></span><br><span class="line"><span class="comment">    putll(x / 10); putchar(x % 10 + '0'); </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a % HA;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % HA;</span><br><span class="line">        a = a * a % HA;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> m, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 洛谷上数据水不用 Lucas 定理</span></span><br><span class="line">    <span class="comment">// n! / (m!(n - m)!)</span></span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % HA * inv[n - m] % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    head[prev].push_back(next);</span><br><span class="line">    head[next].push_back(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> father = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    siz[root] = <span class="number">1</span>;</span><br><span class="line">    dp[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, ss = head[root].size(); i &lt; ss; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i];</span><br><span class="line">        <span class="keyword">if</span> (father == next) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(root, next);</span><br><span class="line">        siz[root] += siz[next];</span><br><span class="line">        dp[root] = <span class="number">1l</span>l * dp[root] * C(siz[next], siz[root] - <span class="number">1</span>) % HA * dp[next] % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n = getll(); HA = getll();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;n, &amp;HA);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % HA;</span><br><span class="line">        inv[i] = fastPow(fac[i], HA - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> lson = (i &lt;&lt; <span class="number">1</span>), rson = (i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (lson &lt;= n) addEdge(i, lson);</span><br><span class="line">        <span class="keyword">if</span> (rson &lt;= n) addEdge(i, rson);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="comment">//putll(dp[1] % HA);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>] % HA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;披着数论皮的图论&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>单调栈专项练习</title>
    <link href="https://blog.handwer-std.top/2019-07-21/MonotoneStack-Luogu-P1901-Luogu-P1823-Luogu-P2947/"/>
    <id>https://blog.handwer-std.top/2019-07-21/MonotoneStack-Luogu-P1901-Luogu-P1823-Luogu-P2947/</id>
    <published>2019-07-21T12:11:00.000Z</published>
    <updated>2019-07-22T10:21:25.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>单调数据结构</p></blockquote><a id="more"></a><h1 id="练习：洛谷P2947《Look-Up》"><a href="#练习：洛谷P2947《Look-Up》" class="headerlink" title="练习：洛谷P2947《Look Up》"></a>练习：洛谷P2947《Look Up》</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Farmer John’s N (1 &lt;= N &lt;= 100,000) cows, conveniently numbered 1..N, are once again standing in a row. Cow i has height H_i (1 &lt;= H_i &lt;= 1,000,000).</p><p>Each cow is looking to her left toward those with higher index numbers. We say that cow i ‘looks up’ to cow j if i &lt; j and H_i &lt; H_j. For each cow i, FJ would like to know the index of the first cow in line looked up to by cow i.</p><p>Note: about 50% of the test data will have N &lt;= 1,000.</p><p>约翰的N(1≤N≤10^5)头奶牛站成一排，奶牛i的身高是Hi(l≤Hi≤1,000,000)．现在，每只奶牛都在向右看齐．对于奶牛i，如果奶牛j满足i&lt;j且Hi&lt;Hj，我们可以说奶牛i可以仰望奶牛j． 求出每只奶牛离她最近的仰望对象．</p><p>Input</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><ul><li><p>Line 1: A single integer: N</p></li><li><p>Lines 2..N+1: Line i+1 contains the single integer: H_i</p></li></ul><p>第 1 行输入 N，之后每行输入一个身高 H_i。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><ul><li>Lines 1..N: Line i contains a single integer representing the smallest index of a cow up to which cow i looks. If no such cow exists, print 0.</li></ul><p>共 N 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 0。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">3 </span></span><br><span class="line"><span class="symbol">2 </span></span><br><span class="line"><span class="symbol">6 </span></span><br><span class="line"><span class="symbol">1 </span></span><br><span class="line"><span class="symbol">1 </span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span></span><br><span class="line"><span class="symbol">3 </span></span><br><span class="line"><span class="symbol">0 </span></span><br><span class="line"><span class="symbol">6 </span></span><br><span class="line"><span class="symbol">6 </span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>FJ has six cows of heights 3, 2, 6, 1, 1, and 2.</p><p>Cows 1 and 2 both look up to cow 3; cows 4 and 5 both look up to cow 6; and cows 3 and 6 do not look up to any cow.</p><p>【输入说明】6 头奶牛的身高分别为 3, 2, 6, 1, 1, 2.</p><p>【输出说明】奶牛#1,#2 仰望奶牛#3，奶牛#4,#5 仰望奶牛#6，奶牛#3 和#6 没有仰望对象。</p><p>【数据规模】</p><p>对于 20%的数据： 1≤N≤10；</p><p>对于 50%的数据： 1≤N≤1,000；</p><p>对于 100%的数据：1≤N≤100,000；1≤H_i≤1,000,000；</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目就是说，依次给出一堆线段，求对于每条线段，第一个在它右面，长度大于它的线段的下标是多少<br>我们先来模拟一下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1[</span>===] 歪着看体验更佳（逃</span><br><span class="line"><span class="attr">2[</span>==]</span><br><span class="line"><span class="attr">3[</span>======]</span><br><span class="line"><span class="attr">4[</span>=]</span><br><span class="line"><span class="attr">5[</span>=]</span><br><span class="line"><span class="attr">6[</span>==]</span><br></pre></td></tr></table></figure><p>第一次，1号进来了，没有比它高的，让它等一会<br>第二次，2号进来了，它甚至比1号还低，对1号的答案没有什么影响，也让它等一会<br>第三次，3号进来了，它比1、2号都高！此时1、2号的答案都是3号，而且1、2号<strong>对于以后的线段答案是没有影响的</strong>，呆在队伍里已经没有什么用了，让它们出去即可<br>第四次、第五次，4号和5号依次进来，对3号的答案并没有什么影响<br>第六次，6号进来了，4号和5号的答案更新为6号，而且对以后的线段答案也是没有什么影响的（如果以后还有线段的话），出去即可<br>队伍里还有俩线段3和6，它们的答案没有被更新过，也就是没有答案</p><hr><p>这就是一个单调栈的工作流程，通过清除栈里的元素来维护单调性，而本题中第三次循环和第六次循环则是对于单调数据结构进行具体问题具体分析的关键点</p><p>可以看出，实质上是维护了一个单调不增的栈，在维护栈的单调性过程中求出了答案</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cow</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> height, id;</span><br><span class="line">    </span><br><span class="line">    Cow() : height(<span class="number">0</span>), id(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Cow(<span class="keyword">int</span> height, <span class="keyword">int</span> id) : height(height), id(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Cow&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = getint();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt; height) &#123;</span><br><span class="line">            <span class="comment">// stk.top().height &lt; height 维护栈内元素单调不增性</span></span><br><span class="line">            <span class="comment">// 如果 stk.top().height &gt; height 则单调性仍存在，不必维护</span></span><br><span class="line">            ans[stk.top().id] = i;</span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push((Cow) &#123; height, i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="巩固：洛谷P1901《发射站》"><a href="#巩固：洛谷P1901《发射站》" class="headerlink" title="巩固：洛谷P1901《发射站》"></a>巩固：洛谷P1901《发射站》</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>某地有 N 个能量发射站排成一行，每个发射站 i 都有不相同的高度 Hi，并能向两边（当 然两端的只能向一边）同时发射能量值为 Vi 的能量，并且发出的能量只被两边最近的且比 它高的发射站接收。</p><p>显然，每个发射站发来的能量有可能被 0 或 1 或 2 个其他发射站所接受，特别是为了安 全，每个发射站接收到的能量总和是我们很关心的问题。由于数据很多，现只需要你帮忙计 算出接收最多能量的发射站接收的能量是多少。</p><h2 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行：一个整数 N;</p><p>第 2 到 N+1 行：第 i+1 行有两个整数 Hi 和 Vi，表示第 i 个人发射站的高度和发射的能量值。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅一行，表示接收最多能量的发射站接收到的能量值，答案不超过 longint。</p><h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span> </span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span> </span><br><span class="line"><span class="symbol">6 </span><span class="number">10</span></span><br></pre></td></tr></table></figure><p>输出样例#1</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>对于 40%的数据，1&lt;=N&lt;=5000；1&lt;=Hi&lt;=100000；1&lt;=Vi&lt;=10000;</p><p>对于 70%的数据，1&lt;=N&lt;=100000；1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000;</p><p>对于 100%的数据，1&lt;=N&lt;=1000000;1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000。</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>同样的，先来模拟一下这个过程：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1[<span class="string">====</span>](<span class="link">2</span>)</span><br><span class="line">2[<span class="string">===</span>](<span class="link">5</span>)</span><br><span class="line">3[<span class="string">======</span>](<span class="link">10</span>)</span><br></pre></td></tr></table></figure><p>第一次，1号发射站进来，它莫得其他发射站来传输能量<br>第二次，2号发射站进来，它可以给1号传输能量<br>第三次，3号发射站进来：<br>2号发射站可以给3号发射站传输能量，1号发射站亦可。由于这两个发射站对于其他发射站的答案已经没有贡献，自己的答案也确定了，让它们出去即可</p><hr><p>本质上也是维护了一个单调递减的栈，在维护单调性的同时确定答案</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Launcher</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> height; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> energy;</span><br><span class="line">    <span class="comment">// height: 该发射站的高度</span></span><br><span class="line">    <span class="comment">// energy: 该发射站的能量强度</span></span><br><span class="line">    Launcher() &#123; id = height = energy = <span class="number">0</span>; &#125;</span><br><span class="line">    Launcher(<span class="keyword">int</span> id, <span class="keyword">int</span> height, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> energy) : id(id), height(height), energy(energy) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans[MAXN]; <span class="comment">// 答案不超过 long int</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Launcher&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = getint();</span><br><span class="line">        <span class="keyword">int</span> energy = getint();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt; h) &#123;</span><br><span class="line">            ans[i] += stk.top().energy; <span class="comment">// 栈顶对应的发射站能「向右」发射能量到当前的发射站</span></span><br><span class="line">            stk.pop(); <span class="comment">// 维护栈的单调递减性</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stk.empty()) ans[stk.top().id] += energy; <span class="comment">// 当前发射站能「向左」发射能量到栈顶对应的发射站</span></span><br><span class="line">        stk.push((Launcher) &#123; i, h, energy &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>) *<span class="built_in">std</span>::max_element(ans + <span class="number">1</span>, ans + <span class="number">1</span> + n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="提高：洛谷P1823《Patrik-音乐会的等待》"><a href="#提高：洛谷P1823《Patrik-音乐会的等待》" class="headerlink" title="提高：洛谷P1823《Patrik 音乐会的等待》"></a>提高：洛谷P1823《Patrik 音乐会的等待》</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>N个人正在排队进入一个音乐会。人们等得很无聊，于是他们开始转来转去，想在队伍里寻找自己的熟人。队列中任意两个人A和B，如果他们是相邻或他们之间没有人比A或B高，那么他们是可以互相看得见的。</p><p>写一个程序计算出有多少对人可以互相看见。</p><h2 id="输入输出格式-2"><a href="#输入输出格式-2" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个整数N (1 ≤ N ≤ 500 000), 表示队伍中共有N个人。</p><p>接下来的N行中，每行包含一个整数，表示人的高度，以毫微米(等于10的-9次方米)为单位，每个人的调度都小于2^31毫微米。这些高度分别表示队伍中人的身高。</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅有一行，包含一个数S，表示队伍中共有S对人可以互相看见。</p><h2 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">7 </span></span><br><span class="line"><span class="symbol">2 </span></span><br><span class="line"><span class="symbol">4 </span></span><br><span class="line"><span class="symbol">1 </span></span><br><span class="line"><span class="symbol">2 </span></span><br><span class="line"><span class="symbol">2 </span></span><br><span class="line"><span class="symbol">5 </span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出样例#1</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>依然来模拟一下：，</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>[<span class="name">==</span>]</span><br><span class="line"><span class="number">2</span>[<span class="name">====</span>]</span><br><span class="line"><span class="number">3</span>[<span class="name"><span class="builtin-name">=</span></span>]</span><br><span class="line"><span class="number">4</span>[<span class="name">==</span>]</span><br><span class="line"><span class="number">5</span>[<span class="name">==</span>]</span><br><span class="line"><span class="number">6</span>[<span class="name">=====</span>]</span><br><span class="line"><span class="number">7</span>[<span class="name"><span class="builtin-name">=</span></span>]</span><br></pre></td></tr></table></figure><p>第一次，1号进入，它谁都望不到<br>第二次，2号进入，1、2号能互相看见，此时1号对答案已经没有贡献，出去即可<br>第三次，3号进入，2、3号能互相看见<br>第四次，4号进入，3、4号能互相看见，同时2、4号也可以互相看见，此时3号对答案已经没有贡献，出去即可<br>第五次……第六次……第七次……</p><hr><p>已经很明显了，依然是维护一个单调不增的栈，在维护元素单调性的同时更新答案<br>但是这里的代码实现有一定的技巧</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Height</span> &#123;</span></span><br><span class="line">    <span class="comment">// 按照顺序把相邻等高的人视为一组</span></span><br><span class="line">    <span class="keyword">int</span> height; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> amount;</span><br><span class="line">    <span class="comment">// height: 该组的高度</span></span><br><span class="line">    <span class="comment">// amount: 该组的人数</span></span><br><span class="line">    Height() &#123; height = amount = <span class="number">0</span>; &#125;</span><br><span class="line">    Height(<span class="keyword">int</span> height, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> amount) : height(height), amount(amount) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Height&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = getint();</span><br><span class="line">        Height hh = (Height) &#123; h, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt;= h) &#123;</span><br><span class="line">            ans += stk.top().amount; <span class="comment">// 当前人能够看见上一组整组的人</span></span><br><span class="line">            <span class="keyword">if</span> (stk.top().height == h) hh.amount += stk.top().amount; <span class="comment">// 如果两组人等高，就把两组人归到一组去</span></span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stk.empty()) ++ans;</span><br><span class="line">        <span class="comment">// 在放当前的人进栈之前，如果栈非空，说明栈顶这个人是能看见当前的人的</span></span><br><span class="line">        stk.push(hh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="comment">// C(100000, 2) &gt; (1 &lt;&lt; 31)</span></span><br><span class="line">    <span class="comment">// 答案超过 int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;单调数据结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="专项练习" scheme="https://blog.handwer-std.top/tags/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/"/>
    
      <category term="单调栈" scheme="https://blog.handwer-std.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3884 洛谷P4139《上帝与集合的正确用法》</title>
    <link href="https://blog.handwer-std.top/2019-07-18/BZOJ3884-Luogu-P4139/"/>
    <id>https://blog.handwer-std.top/2019-07-18/BZOJ3884-Luogu-P4139/</id>
    <published>2019-07-18T12:49:05.000Z</published>
    <updated>2019-07-21T02:33:37.607Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  $2^{2^{2^{2^{2^{…}}}}}$</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>根据一些书上的记载，上帝的一次失败的创世经历是这样的：<br>第一天，    上帝创造了一个世界的基本元素，称做“元”。<br>第二天，    上帝创造了一个新的元素，称作“α”。“α”被定义为“元”构成的集合。容易发现，一共有两种不同的“α”。<br>第三天，    上帝又创造了一个新的元素，称作“β”。“β”被定义为“α”构成的集合。容易发现，一共有四种不同的“β”。<br>第四天，    上帝创造了新的元素“γ”，“γ”被定义为“β”的集合。显然，一共会有16种不同的“γ”。<br>如果按照这样下去，上帝创造的第四种元素将会有65536种，第五种元素将会有2^65536种。这将会是一个天文数字。<br>然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……<br>然而不久，当上帝创造出最后一种元素“θ”时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。<br>至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素“θ”一共有多少种？<br>上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对p取模后的值即可。<br>你可以认为上帝从“α”到“θ”一共创造了10^9次元素，或10^18次，或者干脆∞次。<br>一句话题意：<br>求 $2^{2^{2^{2^{2^{…}}}}}\bmod p$的值</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>接下来T行，每行一个正整数p，代表你需要取模的值</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>T行，每行一个正整数，为答案对p取模后的值</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h1><p>对于100%的数据，T&lt;=1000,p&lt;=10^7</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>一开始看到这个题目，我是懵逼的</p><p>这题让我们求$2^\infty\bmod p$的值，考虑把它转化一下</p><p>根据扩展欧拉定理可知<br>$$<br>a ^ b= \begin{cases} a ^ {b \bmod \varphi(p)} \quad &amp; \gcd(a,p)=1 \ a ^ b \quad &amp; \gcd(a,p) \not=1, b &lt; \varphi(p)\ a ^ {b \bmod \varphi(p) + \varphi (p)} \quad &amp; \gcd(a,p) \not=1, b \ge \varphi(p)\ \end{cases}<br>$$<br>所以把它变成第三条的形式<br>$$<br>2^{2^{2^{2^{2^{…}}}}}\bmod p=2^{2^{2^{2^{2^{…}}}} \bmod \varphi(p) + \varphi(p)}<br>$$<br>把第一个2的指数摘出来单独康一康<br>$$<br>2^{2^{2^{2^{…}}}} \bmod \varphi(p) + \varphi(p)<br>$$<br>设$\varphi(p) + \varphi(p) = a$，上式变为<br>$$<br>2^{2^{2^{2^{…}}}} \bmod a<br>$$<br>好像在哪见过……那就再来一遍<br>$$<br>2^{2^{2^{2^{2^{…}}}}}\bmod a=2^{2^{2^{2^{2^{…}}}} \bmod \varphi(a) + \varphi(a)}<br>$$<br>这是个递归式！</p><p>那么解法就很显然了：<br>根据扩展欧拉定理，把指数部分变形，然后递归进去继续变形指数部分的指数部分……</p><hr><p>找一找递归出口<br>在模$p$的意义下，一个数的取值范围是$[0,p-1]$<br>考虑让这个数变成定值，显然$p=1$时，这个数为$0$<br>这个就是递归出口，当模数为1时，返回0</p><p>求$\varphi(i)$建议使用根号算法，更快一些</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &amp; <span class="number">1</span>) ret = ret * x % p;</span><br><span class="line">        x = x * x % p;</span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = x, a = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123; <span class="comment">// 如果i是a的质因子</span></span><br><span class="line">            ret = ret / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i; <span class="comment">// 筛去所有的i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) ret = ret / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> pp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> pf = phi(pp);</span><br><span class="line">    <span class="keyword">return</span> fastPower(<span class="number">2</span>, solve(pf) + pf, pp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = getint();</span><br><span class="line">    countdown (T) &#123;</span><br><span class="line">        p = getll();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  $2^{2^{2^{2^{2^{…}}}}}$&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="EXGCD" scheme="https://blog.handwer-std.top/tags/EXGCD/"/>
    
  </entry>
  
  <entry>
    <title>关于近期对博客大部分文章进行整理的说明</title>
    <link href="https://blog.handwer-std.top/2019-07-12/Articles-Reform/"/>
    <id>https://blog.handwer-std.top/2019-07-12/Articles-Reform/</id>
    <published>2019-07-12T13:47:01.000Z</published>
    <updated>2019-07-12T13:49:57.679Z</updated>
    
    <content type="html"><![CDATA[<p>利用这几天时间对博客文章的排版、一句话说明、标签等内容进行修改和更新</p><p>博客主题也有大幅度变动的可能</p><p>特此说明</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用这几天时间对博客文章的排版、一句话说明、标签等内容进行修改和更新&lt;/p&gt;
&lt;p&gt;博客主题也有大幅度变动的可能&lt;/p&gt;
&lt;p&gt;特此说明&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="博客相关" scheme="https://blog.handwer-std.top/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3907《圈的异或》</title>
    <link href="https://blog.handwer-std.top/2019-07-12/Luogu-P3907/"/>
    <id>https://blog.handwer-std.top/2019-07-12/Luogu-P3907/</id>
    <published>2019-07-12T12:12:00.000Z</published>
    <updated>2019-07-12T13:24:44.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  暴力 DFS 即可<small>(???)</small></p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出无向图G，边(A_i,B_i) 的权是C_i，判断下列性质是否成立：</p><p>对于任意圈C，其边权的异或和是0</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第1 行，1 个整数T，表示数据的组数。</p><p>每组数据第1 行，2 个整数N,M，表示图G 点和边的数量。</p><p>M 行，每行3 个整数A_i,B_i,C_i</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>对每个数据输出一行，“Yes” 或者“No”</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p>输入 #1</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出 #1</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">Yes</span></span><br><span class="line"><span class="literal">No</span></span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应搜索</p><p>其他的都没的说，如何判断异或和？</p><p>维护一个 $\text{prefix[x]}​$ 数组表示 dfs 序中从起点到点$\text{x}​$的边权异或和，可以理解为一个类似于前缀和的东西 <br>它工作是这样一个过程：</p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1g4xcci5vtrj30mg0jijsh.jpg" alt="image-20190712204439157"></p><p>比如说这么一个图，我从 6 开始搜索</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4xcltwnf5j30mg0jh0vn.jpg" alt="image-20190712205341779"></p><p>当前搜到了 5，检测出来返祖边了，在这停下不知所措<br>黑色部分是$\text{prefix[5]}$，青色部分是$\text{prefix[1]}$</p><p>那么答案就是从 1 走到 5 的异或和（设为$X$） $\text{xor}$ $\text{weight}(1,5)$ <br>$X$怎么求？来想一想 $\text{xor}$ 的性质吧：$a \text{ xor } a=0, a\text{ xor }0=a $  <br>那么……<br>$$<br>\text{sum[5]}=X\text{ xor sum[1]}\<br>\text{sum[5] xor sum[1]}<br>\=X \text{ xor sum[1] xor sum[1]}<br>\=X\text{ xor 0}<br>$$<br>$\text{prefix[5]}=X \text{ xor prefix[1]}$  <br>所以 $\text{prefix[5] xor prefix[1]}$ <br>$=X \text{ xor prefix[1] xor prefix[1]}\=X \text{ xor } 0 \ = X$</p><p>！！！<br>那么求 $X$ 就直接把上面那俩 xor 一下就行了</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> next, weight;</span><br><span class="line">        </span><br><span class="line">        Edge() &#123; next = weight = <span class="number">0</span>; &#125;</span><br><span class="line">        Edge(<span class="keyword">int</span> next, <span class="keyword">int</span> weight) : next(next), weight(weight) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> prefix[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN], exitNeeded;</span><br><span class="line"></span><br><span class="line">    Graph() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(prefix, <span class="number">0</span>, <span class="keyword">sizeof</span> prefix);</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        exitNeeded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        head[prev].push_back((Edge) &#123; next, weight &#125;);</span><br><span class="line">        head[next].push_back((Edge) &#123; prev, weight &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> last, <span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exitNeeded) <span class="keyword">return</span>;</span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line">        prefix[now] = ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[now].size(); i &lt; siz &amp;&amp; !exitNeeded; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = head[now][i].next;</span><br><span class="line">            <span class="keyword">if</span> (!vis[next]) DFS(next, now, ans ^ head[now][i].weight);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 前面的点被搜过了，返祖边！</span></span><br><span class="line">                <span class="keyword">if</span> (now != last) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (head[now][i].weight ^ prefix[now] ^ prefix[next]) &#123;</span><br><span class="line">                        <span class="comment">// 对应解析中 X 的求法</span></span><br><span class="line">                        exitNeeded = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T = getint();</span><br><span class="line">    countdown (T) &#123;</span><br><span class="line">        Graph G;</span><br><span class="line">        n = getint(); m = getint();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = getint();</span><br><span class="line">            <span class="keyword">int</span> next = getint();</span><br><span class="line">            <span class="keyword">int</span> weight = getint();</span><br><span class="line">            G.addEdge(prev, next, weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!G.vis[i]) G.DFS(i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (G.exitNeeded) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(G.exitNeeded ? <span class="string">"No"</span> : <span class="string">"Yes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  暴力 DFS 即可&lt;small&gt;(???)&lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="搜索" scheme="https://blog.handwer-std.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2023《维护序列》</title>
    <link href="https://blog.handwer-std.top/2019-07-06/Luogu-P2023/"/>
    <id>https://blog.handwer-std.top/2019-07-06/Luogu-P2023/</id>
    <published>2019-07-06T14:10:46.000Z</published>
    <updated>2019-07-08T02:43:54.878Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  多操作线段树标记下方是有顺序的</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。 有长为N的数列，不妨设为a1,a2,…,aN 。有如下三种操作形式：<br>(1)把数列中的一段数全部乘一个值;<br>(2)把数列中的一段数全部加一个值;<br>(3)询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模P的值。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行两个整数N和P(1≤P≤1000000000）。<br>第二行含有N个非负整数,从左到右依次为a1,a2,…,aN, (0≤ai≤1000000000,1≤i≤N)。<br>第三行有一个整数M，表示操作总数。<br>从第四行开始每行描述一个操作，输入的操作有以下三种形式：<br>操作1：“1 t g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai×c(1≤t≤g≤N,0≤c≤1000000000)。<br>操作2：“2 t g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai+c (1≤t≤g≤N,0≤c≤1000000000)。<br>操作3：“3 t g”(不含双引号)。询问所有满足t≤i≤g的ai的和模P的值 (1≤t≤g≤N)。<br>同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。</p><p>输出格式：</p><p>对每个操作3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">7 </span><span class="number">43</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>多操作线段树模板题，同《线段树 2》</p><h3 id="大致方向"><a href="#大致方向" class="headerlink" title="大致方向"></a>大致方向</h3><p>首先我们来康一康只有区间加的时候怎么做 <br>维护一个标记<code>add[i]</code>表示节点<code>i</code>对应的区间<code>[l,r]</code>被加了多少 <br>在下放标记时，<code>sum[i]</code>会被更新为<code>sum[i] + add[i] * (r - l + 1)</code> <br>我们把它看作 $x + b$ 的形式，其中<code>sum[i]</code>对应$x$， <code>add[i]</code> 对应$b$，后面的看作常数就好啦 <br>那么区间加乘的形式就应该是 $ax+b$，也就意味着要多维护一个标记<code>mul[i]</code>表示节点<code>i</code>对应的区间<code>[l,r]</code>被乘了多少，<code>sum[i]</code>会被更新为<code>sum[i] * mul[i] + add[i] * (r - l + 1)</code> <br></p><hr><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>先看乘法，比如<code>i</code>节点对应区间<code>[l,r]</code>被乘了一个$k$，本质上就是$k(ax+b)$，拆出来就是$kax + kb$，也就是把<code>mul[i]</code>和<code>add[i]</code>都乘上一个$k$ <br>加法本质上就是 $ax + b + k$，整理得 $ax + (b + k)$，那么把<code>add[i]</code>加上$k$就行了</p><h3 id="标记下放"><a href="#标记下放" class="headerlink" title="标记下放"></a>标记下放</h3><p>同样地，把每个节点看作 $ax+b$  的关系，在这里<code>i</code>节点对应的区间和<code>[l,r]</code>为$ax+b$，左子树<code>lc(i)</code>对应的区间和<code>[l, mid]</code>为$a’y+b’$ <br>遵循先乘后加的原则，对左子树乘上一个$a$得 <br>$$aa’y+ab’$$ <br>然后加上 $b$ <br>$$aa’y+ab’+b$$ <br>整理得 <br>$$(aa’)y + (ab’ + b)$$ <br>观察下这个式子，把它写成$ax+b$的形式 <br>$$Ay+B\ (A=aa’,B=ab’ + b)$$ <br>发现了什么？</p><p>本质上就是，<br>左子树的乘法标记 乘上 当前点的乘法标记 <br>左子树的加法标记 先乘上 当前点的乘法标记 再加上 当前点的加法标记</p><p><code>mul[lc(i)] *= mul[i], add[lc(i)] = add[lc(i)] * mul[i] + add[i]</code></p><p>对右子树进行一遍同样的操作，清空标记即可（稍有常识的人都知道<code>mul[i]</code>要初始化为1）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, CH, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a[MAXN / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> mul[MAXN &lt;&lt; <span class="number">2</span>], add[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) ((x &lt;&lt; 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) ((x &lt;&lt; 1 | 1))</span></span><br><span class="line">    </span><br><span class="line">    SegmentTree() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="built_in">memset</span>(mul, <span class="number">1</span>, <span class="keyword">sizeof</span> mul);</span><br><span class="line">        <span class="built_in">memset</span>(add, <span class="number">0</span>, <span class="keyword">sizeof</span> add);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PushTag</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mul[root] == <span class="number">1</span> &amp;&amp; add[root] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 该处标记不存在或已被下放</span></span><br><span class="line">        <span class="keyword">if</span> (l != r) &#123;</span><br><span class="line">            mul[lc(root)] = mul[lc(root)] * mul[root] % CH;</span><br><span class="line">            mul[rc(root)] = mul[rc(root)] * mul[root] % CH;</span><br><span class="line">            add[lc(root)] = (add[lc(root)] * mul[root] % CH + add[root]) % CH;</span><br><span class="line">            add[rc(root)] = (add[rc(root)] * mul[root] % CH + add[root]) % CH;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[root] = (sum[root] * mul[root] % CH + add[root] * (r - l + <span class="number">1</span>) % CH) % CH;</span><br><span class="line">        mul[root] = <span class="number">1</span>; add[root] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *seq)</span> </span>&#123;</span><br><span class="line">        mul[root] = <span class="number">1</span>; add[root] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; sum[root] = seq[l]; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        buildTree(lc(root), l, mid, seq);</span><br><span class="line">        buildTree(rc(root), mid + <span class="number">1</span>, r, seq);</span><br><span class="line">        sum[root] = (sum[lc(root)] + sum[rc(root)]) % CH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">        PushTag(root, l, r);</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> sum[root];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= mid) ret = (ret + Query(lc(root), l, mid, ll, rr)) % CH;</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= rr) ret = (ret + Query(rc(root), mid + <span class="number">1</span>, r, ll, rr)) % CH;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> method, <span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PushTag(root, l, r);</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method == <span class="number">1</span>) &#123;</span><br><span class="line">                mul[root] = mul[root] * k % CH;</span><br><span class="line">                add[root] = add[root] * k % CH;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add[root] = (add[root] + k) % CH;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= mid) Modify(method, lc(root), l, mid, ll, rr, k);</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= rr) Modify(method, rc(root), mid + <span class="number">1</span>, r, ll, rr, k);</span><br><span class="line">        PushTag(lc(root), l, mid);</span><br><span class="line">        PushTag(rc(root), mid + <span class="number">1</span>, r);</span><br><span class="line">        sum[root] = (sum[lc(root)] + sum[rc(root)]) % CH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); CH = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) a[i] = getint();</span><br><span class="line">    Tree.buildTree(<span class="number">1</span>, <span class="number">1</span>, n, a);</span><br><span class="line">    m = getint();</span><br><span class="line">    countdown (m) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = getint();</span><br><span class="line">        <span class="keyword">int</span> l = getint();</span><br><span class="line">        <span class="keyword">int</span> r = getint();</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k = getll();</span><br><span class="line">                Tree.Modify(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, n, l, r, k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k = getll();</span><br><span class="line">                Tree.Modify(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, n, l, r, k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Tree.Query(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  多操作线段树标记下方是有顺序的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="https://blog.handwer-std.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2016《战略游戏》</title>
    <link href="https://blog.handwer-std.top/2019-05-11/Luogu-P2016/"/>
    <id>https://blog.handwer-std.top/2019-05-11/Luogu-P2016/</id>
    <published>2019-05-11T06:58:24.000Z</published>
    <updated>2019-08-04T04:38:31.789Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最典型的树形DP</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Bob喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。</p><p>他要建立一个古城堡，城堡中的路形成一棵树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。</p><p>注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被了望到。</p><p>请你编一程序，给定一树，帮Bob计算出他需要放置最少的士兵.</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行 N，表示树中结点的数目。</p><p>第二行至第N+1行，每行描述每个结点信息，依次为：该结点标号i，k(后面有k条边与结点I相连)。</p><p>接下来k个数，分别是每条边的另一个结点标号r1，r2，…，rk。</p><p>对于一个n(0&lt;n&lt;=1500)个结点的树，结点标号在0到n-1之间，在输入数据中每条边只出现一次。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件仅包含一个数，为所求的最少的士兵数目。</p><p>例如，对于如下图所示的树：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">3</span></span><br></pre></td></tr></table></figure><p>答案为1（只要一个士兵在结点1上）。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">0</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题，就是这种树形DP最标准的形态<br>「选点DP」</p><hr><p>设 <code>dp[i][0/1]</code> 表示选/不选以i为根的子树时的最大值</p><p>转移方程很显然<br><code>dp[root][0] += dp[child][1]</code><br><code>dp[root][1] += std::min(dp[child][0], dp[child][1])</code></p><p>也就是</p><ul><li><p>如果我不选当前点，那么就必须选我儿子，不然我和我儿子之间这条路没人看</p></li><li><p>如果我选了当前点，我儿子干啥我是不管的，选一个最小的加上</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, dp[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    G[prev].push_back(next);</span><br><span class="line">    G[next].push_back(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    dp[root][<span class="number">1</span>] = <span class="number">1</span>; dp[root][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[root]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(v, root);</span><br><span class="line">        dp[root][<span class="number">1</span>] += <span class="built_in">std</span>::min(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]);</span><br><span class="line">        dp[root][<span class="number">0</span>] += dp[v][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; k;</span><br><span class="line">        ++id;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; qwq;</span><br><span class="line">            ++qwq;</span><br><span class="line">            addEdge(id, qwq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::min(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最典型的树形DP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2014《选课》</title>
    <link href="https://blog.handwer-std.top/2019-05-11/Luogu-P2014/"/>
    <id>https://blog.handwer-std.top/2019-05-11/Luogu-P2014/</id>
    <published>2019-05-11T06:39:08.000Z</published>
    <updated>2019-08-04T04:38:45.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>森林上的DP</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数N,M用空格隔开。(1&lt;=N&lt;=300,1&lt;=M&lt;=300)</p><p>接下来的N行,第I+1行包含两个整数ki和si, ki表示第I门课的直接先修课，si表示第I门课的学分。若ki=0表示没有直接先修课（1&lt;=ki&lt;=N, 1&lt;=si&lt;=20）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一行，选M门课程的最大得分。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">7 </span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span> <span class="number">2</span></span><br><span class="line"><span class="symbol">0 </span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span> <span class="number">1</span></span><br><span class="line"><span class="symbol">7 </span> <span class="number">1</span></span><br><span class="line"><span class="symbol">7 </span> <span class="number">6</span></span><br><span class="line"><span class="symbol">2 </span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>注意到题目中的「每门课有一门或没有直接先修课」<br>所以这是一个森林</p><p>我们用一个虚拟点0把所有的树根连起来，构成一棵大树<br>接下来这个题目就从一个DAG上DP转化为了一个树形DP<br>但是！它事一个树形背包</p><hr><p>设<code>dp[i][j]</code>表示选以i为根的树j个节点</p><p>初始化方程：<br><code>dp[child][i] = dp[root][i] + weight[root]</code><br><code>(0 &lt;= i &lt; 还能选择的节点数)</code><br>至于为什么从零开始……因为可以选择的节点是root的子树的节点数减一，毕竟root占掉了一个节点</p><p>转移方程：<br><code>dp[root][i] = std::max(dp[root][k], dp[child][k-1]);</code><br><code>(1 &lt;= i &lt;= 还能选择的节点数)</code></p><p>答案：<br><code>dp[0][m]</code></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首先这是一个森林</span></span><br><span class="line"><span class="comment"> * 令 f[i][j] 表示以 i 为根的子树选择前 j 个点的最大价值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> weight[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        head[prev].push_back(next);</span><br><span class="line">        weight[next] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 没得选了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> now : head[root]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                dp[now][i] = dp[root][i] + weight[now];</span><br><span class="line">            &#125;</span><br><span class="line">            DFS(now, k - <span class="number">1</span>); <span class="comment">// 对子树进行选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">                dp[root][i] = <span class="built_in">std</span>::max(dp[root][i], dp[now][i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev, weight;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; prev &gt;&gt; weight;</span><br><span class="line">        G.addEdge(prev, i, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    G.DFS(<span class="number">0</span>, m);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">0</span>][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;森林上的DP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="背包问题" scheme="https://blog.handwer-std.top/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1967「NOIP2013」《货车运输》</title>
    <link href="https://blog.handwer-std.top/2019-03-30/Luogu-P1967/"/>
    <id>https://blog.handwer-std.top/2019-03-30/Luogu-P1967/</id>
    <published>2019-03-30T13:46:53.000Z</published>
    <updated>2019-07-30T12:40:02.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>A国有n座城市，编号从  1到n，城市之间有  m  条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有  q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><a id="more"></a><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有两个用一个空格隔开的整数n,m，表示  A  国有n  座城市和  m  条道路。</p><p>接下来  m行每行3个整数  x, y, z，每两个整数之间用一个空格隔开，表示从  x号城市到y号城市有一条限重为  z  的道路。注意： <strong>  x  不等于  y，两座城市之间可能有多条道路 </strong> 。</p><p>接下来一行有一个整数 q，表示有 q 辆货车需要运货。</p><p>接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： <strong> x 不等于 y </strong> 。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>共有  q  行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出−1。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>题目让我们求对于每个司机，最多能运多少货物，也就是在给定的两点间必经路线中求最大边权，显然我们要最大化这个边权，才能使答案更优。</p><p>注意到一些边是无论如何都不会被经过的，这些边通常较小，经过它们会劣化答案。那么一个很显然的贪心就是，排个序，依次选择最大的边加入新图，尽量不选较小的边，直到新图联通且无环，两点间有唯一的不重复经过同一条边的路径</p><p>等等……这个是最大生成树？<strong>是的。</strong></p><hr><p>想一想答案怎么求。<br>既然新图有一个性质「两点间有唯一的不重复经过同一条边的路径」，那么走一遍这条路径不就求出答案了吗！</p><p>为什么不再往上走一走？能运载的最大货物量是由这条路径决定的，往上走只可能有两种结果：上面边权比最小值大，上面边权比最小值小。第一种情况对答案没有什么贡献（因为最大值影响不了最小值），第二种情况则会<strong>劣化答案</strong>！</p><p>显然这条路径被这两个点的 LCA 分成两段，从一个点向上到 LCA 再向下到另一个点，那么在求 LCA 往上蹦的过程中求一下最小值就行了。可以倍增。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>#include <algorithm></algorithm></p><p>#include <iostream></iostream></p><p>#include <cstring></cstring></p><p>#include <cstdio></cstdio></p><p>#define FILE_IN(<strong>fname) freopen(</strong>fname, “r”, stdin)</p><p>#define FILE_OUT(<strong>fname) freopen(</strong>fname, “w”, stdout)</p><p>#define IMPROVE_IO() std::ios::sync_with_stdio(false)</p><p>using std::cin;<br>using std::cout;<br>using std::endl;</p><p>const int MAXN = 100000 + 10;<br>const int MAXM = MAXN * 5;<br>const int LOG = 21;</p><p>int n, m, q;</p><p>namespace Graph{<br>    struct RawEdge {<br>        int prev, next, weight;</p><pre><code>    bool operator &lt; (const RawEdge &amp;that) const {        return weight &gt; that.weight;    }} redge[MAXM];struct Edge {    int now, next, weight;} edge[MAXM];int head[MAXN], cnt;bool vis[MAXN];void addEdge(int prev, int next, int weight) {    edge[++cnt].now = next;    edge[cnt].weight = weight;    edge[cnt].next = head[prev];    head[prev] = cnt;}struct UnionFind{    int seq[MAXN];    UnionFind() { memset(seq, 0, sizeof seq); }    int Find(int x) {        if (seq[x] == 0) return x;        return seq[x] = Find(seq[x]);    }    bool Union(int x, int y) {        x = Find(x); y = Find(y);        if (x == y) return false;        seq[x] = y;        return true;    }} U;void Kruskal() {    std::sort(redge + 1, redge + 1 + m);    for(int i = 1; i &lt;= m; ++i) {        if (U.Union(redge[i].prev, redge[i].next)) {            addEdge(redge[i].prev, redge[i].next, redge[i].weight);            addEdge(redge[i].next, redge[i].prev, redge[i].weight);        }    }}</code></pre><p>}</p><p>namespace LCAs {<br>    using namespace Graph;<br>    int depth[MAXN], fa[MAXN][LOG], w[MAXN][LOG];</p><pre><code>void Search(int root) {    vis[root] = true;    for(int e = head[root]; e; e = edge[e].next) {        int now = edge[e].now;        if (vis[now]) continue;        depth[now] = depth[root] + 1;        fa[now][0] = root;        w[now][0] = edge[e].weight;        Search(now);    }}int GetAnswer(int x, int y) {    if (U.Find(x) != U.Find(y)) return -1;    int ans = 0x7f7f7f7f;    if (depth[x] &gt; depth[y]) std::swap(x,y);    for (int i = LOG - 1; i &gt;= 0; --i) {        if (depth[fa[y][i]] &gt;= depth[x]) {            ans = std::min(ans, w[y][i]);            y = fa[y][i];        }    }    if (x == y) return ans;    for (int i = LOG - 1; i &gt;= 0; --i) {        if (fa[x][i] != fa[y][i]) {            ans = std::min(ans, std::min(w[x][i], w[y][i]));            x = fa[x][i];            y = fa[y][i];        }    }    ans = std::min(ans, std::min(w[x][0], w[y][0]));    return ans;}</code></pre><p>}</p><p>int main() {<br>    using namespace LCAs;<br>    using namespace Graph;</p><pre><code>scanf(&quot;%d %d&quot;, &amp;n, &amp;m);for (int i = 1; i &lt;= m; ++i) {    int x, y, z;    scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);    redge[i].prev = x;    redge[i].next = y;    redge[i].weight = z;}Kruskal();for (int i = 1; i &lt;= n; ++i){    if (!vis[i]) {        depth[i] = 1;        Search(i);        fa[i][0] = i;        w[i][0] = 0x7f7f7f7f;    }}for (int i = 1; i &lt;= LOG - 1; ++i) {    for (int j = 1; j &lt;= n; ++j) {        fa[j][i] = fa[fa[j][i-1]][i-1];        w[j][i] = std::min(w[j][i-1], w[fa[j][i-1]][i-1]);    }}scanf(&quot;%d&quot;, &amp;q);for (int i = 1; i &lt;= q; ++i) {    int prev, next;    cin &gt;&gt; prev &gt;&gt; next;    printf(&quot;%d\n&quot;, GetAnswer(prev, next));}return 0;</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;A国有n座城市，编号从  1到n，城市之间有  m  条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有  q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="生成树" scheme="https://blog.handwer-std.top/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="LCA" scheme="https://blog.handwer-std.top/tags/LCA/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P5018「NOIP2018普及组」《对称二叉树》</title>
    <link href="https://blog.handwer-std.top/2019-03-30/NOIP2018-PJ-Tree-Luogu-P5018/"/>
    <id>https://blog.handwer-std.top/2019-03-30/NOIP2018-PJ-Tree-Luogu-P5018/</id>
    <published>2019-03-30T07:49:29.000Z</published>
    <updated>2019-07-12T13:40:45.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个长得像暴力的正解</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树：</p><ol><li>二叉树；</li><li>将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。</li></ol><p>下图中节点内的数字为权值，节点外的 id 表示节点编号。</p><p><img src="https://cdn.luogu.org/upload/pic/43192.png" alt="1"></p><p>现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。</p><p>注意：只有树根的树也是对称二叉树。本题中约定，以节点T 为子树根的一棵“子 树”指的是：节点 T 和它的全部后代节点构成的二叉树。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 $1 \sim n$，其中节点 1 是树根。</p><p>第二行 n 个正整数，用一个空格分隔，第 i 个正整数 $v_i$​ 代表节点 i 的权值。</p><p>接下来 n 行，每行两个正整数 $l_i, r_i$，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 -1 表示。两个数之间用一个空格隔开。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span> </span><br><span class="line"><span class="number">2</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">4</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">9</span> <span class="number">10</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">5</span> <span class="number">6</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模与约定】<br>共 25 个测试点。<br>$v_i ≤ 1000$。<br>测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。<br>测试点 $4 \sim 8, n ≤ 10$。<br>测试点 $9 \sim 12, n ≤ 10^5$ ，保证输入是一棵“满二叉树” 。<br>测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。<br>测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 1。<br>测试点 $21 \sim 25, n ≤ 10^6$ 。</p><p>本题约定：</p><p>层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 1。</p><p>树的深度：树中节点的最大层次称为树的深度。</p><p>满二叉树：设二叉树的深度为 h，且二叉树有 $2h−1$ 个节点，这就是满二叉树。</p><p>完全二叉树：设二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大 个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>场上没写这道题真是<big>血亏</big><br><del>被T3折磨得心态爆炸&nbsp;也没心情写这题了。。。</del></p><hr><p>首先它求的是满足要求的最大子树的<strong>大小</strong><br>那就先 DFS 一遍求出所有子树的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// nodes[root].treeSize 已经被赋值为1了</span></span><br><span class="line">    <span class="keyword">if</span> (nodes[root].leftChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].leftChild);</span><br><span class="line">        nodes[root].treeSize += nodes[LC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].rightChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].rightChild);</span><br><span class="line">        nodes[root].treeSize += nodes[RC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后呢？</p><p>一个很暴力的想法，就是暴力枚举根节点，判断一下这棵子树是否对称，对称就更新答案</p><p>判断对称是很好写的，递归即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckSymmetric</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">-1</span> &amp;&amp; n2 == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (n1 != <span class="number">-1</span> &amp;&amp; n2 != <span class="number">-1</span>) <span class="comment">/* 判断是否有完整的节点 */</span></span><br><span class="line">        &amp;&amp; nodes[n1].data == nodes[n2].data <span class="comment">/* 判断节点信息是否相同 */</span></span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n1), RC(n2)) <span class="comment">/* 递归判断两边的节点 */</span></span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n2), RC(n1)) <span class="comment">/* 递归判断中间的节点 */</span></span><br><span class="line">    ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 判断失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>「递归判断两边 / 中间的节点」，是这么回事</p><p><img src="https://cdn.luogu.org/upload/pic/43189.png" alt="2"></p><p>先假装节点<code>id = 2</code>不存在<br><!--好现在枚举到了`id = 10`的节点来写一下伪代码调用函数 CheckSymmetric((id = 10) -> LeftChild, (id = 10) -> RightChild).... n1 = 7, n2 = 8.... n1 != -1, n2 != -1, 判断失败.... n1 != -1, n2 != -1，判断成功，继续判断|... nodes[n1].data == nodes[n2].data，判断成功，继续判断|... 调用函数 CheckSymmetric--></p><p>在进行递归的时候，判断的是<code>(id = 3, id = 6)</code>和<code>(id = 4, id = 5)</code><br>很明显判断对称的时候，要判断的就是这两个节点（和它们的子树）</p><hr><p>代码分析完了，来算算这份暴力的复杂度</p><ul><li><code>DFS</code> 不用说</li><li><code>CheckSymmetric</code> 的最坏情况是原树为完全二叉树，递归次数为树高（即 $\log_2n$），又因为要暴力枚举一共$n$个点，所以复杂度为$O(n\log_2 n)$</li></ul><p>综上，程序复杂度为$O(n\log_2n)$，是能过的</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) ((nodes[x].leftChild))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((nodes[x].rightChild))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> leftChild;</span><br><span class="line">    <span class="keyword">int</span> rightChild;</span><br><span class="line">    <span class="keyword">int</span> treeSize;</span><br><span class="line">    </span><br><span class="line">    Node() : data(<span class="number">0</span>), leftChild(<span class="number">0</span>), rightChild(<span class="number">0</span>), treeSize(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].leftChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].leftChild);</span><br><span class="line">        nodes[root].treeSize += nodes[LC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].rightChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].rightChild);</span><br><span class="line">        nodes[root].treeSize += nodes[RC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckSymmetric</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">-1</span> &amp;&amp; n2 == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (n1 != <span class="number">-1</span> &amp;&amp; n2 != <span class="number">-1</span>)</span><br><span class="line">        &amp;&amp; nodes[n1].data == nodes[n2].data</span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n1), RC(n2))</span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n2), RC(n1))</span><br><span class="line">    ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nodes[i].data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nodes[i].leftChild &gt;&gt; nodes[i].rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// enumerate every subtree</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (CheckSymmetric(LC(i), RC(i))) &#123;</span><br><span class="line">            ans = <span class="built_in">std</span>::max(ans, nodes[i].treeSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个长得像暴力的正解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
      <category term="暴力" scheme="https://blog.handwer-std.top/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1092「NOIP2004」《虫食算》</title>
    <link href="https://blog.handwer-std.top/2019-03-30/Luogu-P1092/"/>
    <id>https://blog.handwer-std.top/2019-03-30/Luogu-P1092/</id>
    <published>2019-03-30T06:47:17.000Z</published>
    <updated>2019-08-04T04:47:20.103Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>调换搜索顺序以获得更快时间</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的例子：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">43</span>#<span class="number">9865</span>#<span class="number">045</span></span><br><span class="line">+  <span class="number">8468</span>#<span class="number">6633</span></span><br><span class="line"> <span class="number">44445509678</span></span><br></pre></td></tr></table></figure><p>其中$#$号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。</p><p>现在，我们对问题做两个限制：</p><p>首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。</p><p>其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表午的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字：但是这N个字母并不一定顺序地代表0到N−1。输入数据保证N个字母分别至少出现一次。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">BADC</span></span><br><span class="line"><span class="keyword">+CBDA</span></span><br><span class="line"><span class="keyword"> </span>DCCC</span><br></pre></td></tr></table></figure><p>上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>包含四行。<br>第一行有一个正整数$N(N \le 26)$。</p><p>后面的三行，每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有NN位。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，即唯一的那组解。</p><p>解是这样表示的：输出N个数字，分别表示A,B,C,…所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">ABCED</span></span><br><span class="line"><span class="keyword">BDACE</span></span><br><span class="line"><span class="keyword">EBBAA</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>对于30％的数据，保证有$N \le 10$；</p><p>对于50％的数据，保证有$N \le 15$；</p><p>对于全部的数据，保证有$N \le 26$。</p><p>noip2004提高组第4题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑暴力枚举每一个数字</p><p>肯定是过不去的</p><hr><p>考虑枚举算式中的每一个数</p><p>用时大大减小</p><p>但是可能会填出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code"> 1111</span></span><br><span class="line">+1221</span><br><span class="line">-----</span><br><span class="line"><span class="code"> 2333</span></span><br></pre></td></tr></table></figure><p>这样的情况</p><p>显然这样的情况是无用的</p><p>就需要一个判断</p><p>耗时依然较高</p><hr><p>换一下搜索顺序，每列每列地填</p><p>在填完一列之后判断一下等式是否成立</p><p>就差不多了</p><p>虽然可能会耗点时间<br>但是省出来的时间是多得多的</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDBUG(x,y) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; y;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MDBUG(comment) std::cerr &lt;&lt; comment;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getNum(x) ((ans[x]))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> giveNum(x,y) ((ans[x] = y))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">26</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans[MAXN], col[<span class="number">3</span> + <span class="number">2</span>][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ol[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// convert the letters to numbers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            col[i + <span class="number">1</span>][j + <span class="number">1</span>] = ol[i][j] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Checks &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Check for unfilled letters</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (ans[i] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Check that the equation is correct</span></span><br><span class="line">        <span class="keyword">int</span> nextBit = <span class="number">0</span>; <span class="comment">// addition carry</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// from right to left</span></span><br><span class="line">            <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> C = getNum(col[<span class="number">3</span>][i]);</span><br><span class="line">            <span class="keyword">if</span> ((A + B + nextBit) % n != C) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            nextBit = (<span class="keyword">bool</span>) ((A + B + nextBit) &gt;= n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Other equation correction checking</span></span><br><span class="line">        <span class="keyword">if</span> (getNum(col[<span class="number">1</span>][<span class="number">1</span>]) + getNum(col[<span class="number">2</span>][<span class="number">1</span>]) &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// The first one needs to be carried</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> C = getNum(col[<span class="number">3</span>][i]);</span><br><span class="line">            <span class="keyword">if</span> (A == <span class="number">-1</span> || B == <span class="number">-1</span> || C == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((A + B) % n != C &amp;&amp; (A + B + <span class="number">1</span>) % n != C) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> column = n, <span class="keyword">int</span> line = <span class="number">1</span>, <span class="keyword">int</span> nextBit = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// from right to left</span></span><br><span class="line">    <span class="keyword">if</span> (Checks::check3()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Checks::check1()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Checks::check2()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getNum(col[line][column]) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// unfilled letter, fill it</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (line == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][column]);</span><br><span class="line">                <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][column]);</span><br><span class="line">                <span class="keyword">int</span> C = A + B + nextBit;</span><br><span class="line">                <span class="keyword">if</span> (C % n != i) <span class="keyword">continue</span>;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                giveNum(col[line][column], i);</span><br><span class="line">                DFS(column - <span class="number">1</span>, <span class="number">1</span>, (<span class="keyword">bool</span>) (C &gt;= n));</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">                giveNum(col[line][column], <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                giveNum(col[line][column], i);</span><br><span class="line">                DFS(column, line + <span class="number">1</span>, nextBit);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">                giveNum(col[line][column], <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// filled letter</span></span><br><span class="line">        <span class="keyword">if</span> (line != <span class="number">3</span>) DFS(column, line + <span class="number">1</span>, nextBit);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][column]);</span><br><span class="line">            <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][column]);</span><br><span class="line">            <span class="keyword">int</span> C = A + B + nextBit;</span><br><span class="line">            DFS(column - <span class="number">1</span>, <span class="number">1</span>, (<span class="keyword">bool</span>) (C &gt;= n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ol[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ol[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ol[<span class="number">2</span>];</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;调换搜索顺序以获得更快时间&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="搜索" scheme="https://blog.handwer-std.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 735D《Taxes》</title>
    <link href="https://blog.handwer-std.top/2019-03-23/CF735D/"/>
    <id>https://blog.handwer-std.top/2019-03-23/CF735D/</id>
    <published>2019-03-23T11:13:22.000Z</published>
    <updated>2019-07-12T13:30:18.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><del>这™什么破题</del></p></blockquote><a id="more"></a><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>大概就是规定一个数的花费为它的最大真因子（除了本身以外的最大因数，如果这个数是质数，花费为1）</p><p>现在给你一个数 $n$，要求把它拆成几个数相加的形式（也可以不拆），使得拆完后每一个数的花费的和最小</p><p>输出这个最小的和</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>别告诉我你脑子里装的都是暴力</p><p>我现在来说几个有趣的性质</p><p>说完这道题就做完了</p><ol><li>哥德巴赫猜想（即任意大于2的偶数都可以被拆成两个质数的和）</li><li>对于任意大于5的非质奇数（即不是质数的奇数），都可以被拆成3和两个质数的和（哥德巴赫猜想的一个推论）</li></ol><p>好 现在假设哥德巴赫猜想成立 请读者自行证明第二条</p><hr><p>依据这两个性质，我们可以对这道题进行如下的分类讨论</p><ul><li>当给定的为质数时，花费为1</li><li>当给定的为偶数时，根据哥德巴赫猜想可以拆成两个质数，花费为2</li><li>当<code>给定的数-2</code>为质数时，这个数可以拆成2和<code>给定的数-2</code>两个质数，花费为2</li><li>否则这个数可以拆成3和<code>给定的数-3</code>，因为给定的数是奇数，显然<code>给定的数-3</code>是偶数，可以拆成两个质数，花费为3</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span> || x == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这什么破题啊</span></span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(n)) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 根据哥德巴赫猜想，一个偶数可以被拆成两个质数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isPrime(n - <span class="number">2</span>)) <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这个数字可以被拆成 2 和另一个质数的和</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这个数字可以被拆成 3 和另一个偶数的和，这个偶数又可以被拆成两个质数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;del&gt;这™什么破题&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://blog.handwer-std.top/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Codeforces" scheme="https://blog.handwer-std.top/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2922《[USACO08DEC]秘密消息Secret Message》</title>
    <link href="https://blog.handwer-std.top/2019-03-23/Luogu-P2922/"/>
    <id>https://blog.handwer-std.top/2019-03-23/Luogu-P2922/</id>
    <published>2019-03-23T11:13:07.000Z</published>
    <updated>2019-08-04T04:35:50.812Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Trie 中储存两个信息</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Bessie is leading the cows in an attempt to escape! To do this, the cows are sending secret binary messages to each other.</p><p>Ever the clever counterspy, Farmer John has intercepted the first b_i (1 &lt;= b_i &lt;= 10,000) bits of each of M (1 &lt;= M &lt;= 50,000) of these secret binary messages.</p><p>He has compiled a list of N (1 &lt;= N &lt;= 50,000) partial codewords that he thinks the cows are using. Sadly, he only knows the first c_j (1 &lt;= c_j &lt;= 10,000) bits of codeword j.</p><p>For each codeword j, he wants to know how many of the intercepted messages match that codeword (i.e., for codeword j, how many times does a message and the codeword have the same initial bits). Your job is to compute this number.</p><p>The total number of bits in the input (i.e., the sum of the b_i and the c_j) will not exceed 500,000.</p><p>Memory Limit: 32MB</p><p>POINTS: 270</p><p>贝茜正在领导奶牛们逃跑．为了联络，奶牛们互相发送秘密信息．</p><p>信息是二进制的，共有M(1≤M≤50000)条．反间谍能力很强的约翰已经部分拦截了这些信息，知道了第i条二进制信息的前bi(l《bi≤10000)位．他同时知道，奶牛使用N(1≤N≤50000)条密码．但是，他仅仅了解第J条密码的前cj(1≤cj≤10000)位．</p><p>对于每条密码J，他想知道有多少截得的信息能够和它匹配．也就是说，有多少信息和这条密码有着相同的前缀．当然，这个前缀长度必须等于密码和那条信息长度的较小者．</p><p>在输入文件中，位的总数（即∑Bi+∑Ci）不会超过500000.</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><ul><li><p>Line 1: Two integers: M and N</p></li><li><p>Lines 2..M+1: Line i+1 describes intercepted code i with an integer b_i followed by b_i space-separated 0’s and 1’s</p></li><li><p>Lines M+2..M+N+1: Line M+j+1 describes codeword j with an integer c_j followed by c_j space-separated 0’s and 1’s</p></li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><ul><li>Lines 1..M: Line j: The number of messages that the jth codeword could match.</li></ul><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">5</span> </span><br><span class="line"><span class="symbol">3 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> </span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> </span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> </span><br><span class="line"><span class="symbol">2 </span><span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="symbol">5 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span></span><br><span class="line"><span class="symbol">3 </span></span><br><span class="line"><span class="symbol">1 </span></span><br><span class="line"><span class="symbol">1 </span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Four messages; five codewords.</p><p>The intercepted messages start with 010, 1, 100, and 110.</p><p>The possible codewords start with 0, 1, 01, 01001, and 11.</p><p>0 matches only 010: 1 match</p><p>1 matches 1, 100, and 110: 3 matches</p><p>01 matches only 010: 1 match</p><p>01001 matches 010: 1 match</p><p>11 matches 1 and 110: 2 matches</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>查询前缀的题很容易想到 Trie</p><hr><p>维护两个信息 <code>pass</code> 和 <code>lasts</code><br><code>pass</code> 表示当前节点有多少条信息经过， <code>lasts</code> 表示有多少以当前节点结尾的信息（不一定没有相同的串）</p><p>插入就不说了，说说查询</p><hr><p>查询的时候，记一下路径上<code>lasts</code>的和（也就是拿原信息去匹配查询信息）</p><p>首先对于每一条查询信息，都分两种情况</p><ol><li>这条信息被完美的查询完了</li><li>这条信息查到一半断开了</li></ol><p>对于第二种情况，什么都不用管，输出统计的<code>lasts</code>的和就行<br>对于第一种情况，则需要减去<strong>查询信息</strong>的最后一个节点的<code>lasts</code>值，加上<code>pass</code>值再输出</p><p>为什么呢？</p><hr><p><strong><em>这里建议画图理解</em></strong></p><p>首先，如果查到一半断开了，那么答案就是<strong>用原信息去匹配查询信息</strong>的匹配数，也就是<code>lasts</code>的和</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">比如下面的例子</span><br><span class="line">查询信息：</span><br><span class="line">rain_air_txdy</span><br><span class="line">原始信息：</span><br><span class="line">rain</span><br><span class="line">rain_air</span><br><span class="line">rain_air_tql（这个也是没法匹配的，后几个字符不同）</span><br><span class="line">那么匹配数就是<span class="number">2</span>，即为答案</span><br></pre></td></tr></table></figure><p>如果查询完了，那么说明<strong>存在能匹配查询信息的原信息</strong>，所以「用原信息去匹配查询信息的匹配数」还不够，要再加上「用查询信息去匹配原信息的匹配数」，也就是<code>lasts的总和 + pass</code></p><p>有这么一种情况，就是<strong>原信息与查询信息相同</strong>，那么它在当前节点的<code>lasts</code>里面算了一次，在当前节点的<code>pass</code>又算了一次！所以要减去当前节点的<code>lasts</code></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">比如下面的例子</span><br><span class="line">查询信息：</span><br><span class="line">rain_air_txdy</span><br><span class="line">原始信息：</span><br><span class="line">rain_air_txdy_tql</span><br><span class="line">rain_air_txdy</span><br><span class="line">答案是啥？<span class="number">2</span></span><br><span class="line"></span><br><span class="line">注意到y这里的 pass 是<span class="number">2</span>，把两条信息都算上了</span><br><span class="line">但同时y这里的 lasts 也是<span class="number">1</span>啊！！！</span><br><span class="line">这不就重了吗，所以要减去 lasts</span><br></pre></td></tr></table></figure><p><del>我觉得我说的已经够通俗易懂了吧<img src="https://s2.ax1x.com/2019/03/23/AJ3jc8.png" alt="AJ3jc8.png" border="0"></del></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> pass, lasts;</span><br><span class="line">        <span class="keyword">int</span> next[<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        Node() &#123;</span><br><span class="line">            pass = lasts = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span> next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; node[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    Trie() &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SwitchTo</span><span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">bool</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node[now].next[data] == <span class="number">0</span>) &#123;</span><br><span class="line">            node[now].next[data] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = node[now].next[data];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">switchTo</span><span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">bool</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node[now].next[data] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        now = node[now].next[data];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= f; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> nf = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nf;</span><br><span class="line">            t.SwitchTo(pos, nf);</span><br><span class="line">            ++t.node[pos].pass;</span><br><span class="line">        &#125;</span><br><span class="line">        ++t.node[pos].lasts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, pos = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        <span class="keyword">bool</span> cont = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nf = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nf;</span><br><span class="line">            <span class="keyword">if</span> (cont &amp;&amp; t.switchTo(pos, nf)) &#123;</span><br><span class="line">                ans += t.node[pos].lasts;</span><br><span class="line">            &#125; <span class="keyword">else</span> cont = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cont) ans = ans - t.node[pos].lasts + t.node[pos].pass;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Trie 中储存两个信息&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="USACO" scheme="https://blog.handwer-std.top/tags/USACO/"/>
    
      <category term="字符串" scheme="https://blog.handwer-std.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Trie" scheme="https://blog.handwer-std.top/tags/Trie/"/>
    
  </entry>
  
</feed>
