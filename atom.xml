<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Handwer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.handwer-std.top/"/>
  <updated>2019-01-20T14:11:43.197Z</updated>
  <id>https://blog.handwer-std.top/</id>
  
  <author>
    <name>Handwer STD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公告栏</title>
    <link href="https://blog.handwer-std.top/2019-10-31/BulletinBoard/"/>
    <id>https://blog.handwer-std.top/2019-10-31/BulletinBoard/</id>
    <published>2019-10-31T12:30:10.000Z</published>
    <updated>2019-01-20T14:11:43.197Z</updated>
    
    <content type="html"><![CDATA[<p><font style="color:#66ccff"></font></p><p><center>这里可能会挂些什么东西。 <br>There may be something here.<br></center><br><br><img src="https://v2.jinrishici.com/one.svg" alt="今日诗词"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font style=&quot;color:#66ccff&quot;&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;这里可能会挂些什么东西。 &lt;br&gt;There may be something here.&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://v2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>洛谷P1434《[SHOI2010]滑雪》</title>
    <link href="https://blog.handwer-std.top/2019-01-27/Luogu-P1434/"/>
    <id>https://blog.handwer-std.top/2019-01-27/Luogu-P1434/</id>
    <published>2019-01-27T12:23:55.000Z</published>
    <updated>2019-01-27T12:57:50.534Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记忆化搜索好题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Michael喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>  <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"><span class="symbol">16 </span> <span class="number">17</span>  <span class="number">18</span>  <span class="number">19</span>  <span class="number">6</span></span><br><span class="line"><span class="symbol">15 </span> <span class="number">24</span>  <span class="number">25</span>  <span class="number">20</span>  <span class="number">7</span></span><br><span class="line"><span class="symbol">14 </span> <span class="number">23</span>  <span class="number">22</span>  <span class="number">21</span>  <span class="number">8</span></span><br><span class="line"><span class="symbol">13 </span> <span class="number">12</span>  <span class="number">11</span>  <span class="number">10</span>  <span class="number">9</span></span><br></pre></td></tr></table></figure><p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可行的滑坡为24－17－16－1（从24开始，在1结束）。当然25－24－23－…－3－2－1更长。事实上，这是最长的一条。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为表示区域的二维数组的行数R和列数C（1≤R，C≤100）。下面是R行，每行有C个数，代表高度(两个数字之间用1个空格间隔)。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出区域中最长滑坡的长度。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">16 </span><span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">15 </span><span class="number">24</span> <span class="number">25</span> <span class="number">20</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">14 </span><span class="number">23</span> <span class="number">22</span> <span class="number">21</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">13 </span><span class="number">12</span> <span class="number">11</span> <span class="number">10</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一眼就能看出这是搜索题</p><p>方法很显然，枚举所有的点，从当前点开始 DFS，每次往四个方向搜索，直到不能搜为止，这时候答案就出来了一个，更新一下。</p><hr><p>考虑一下优化。<br>在每次搜索的过程中，我们有很多点是重复走过的，那么就可以把暴搜升级为记忆化搜索。<br>用 $ \text{mem}(x,y) $ 表示从点 $ (x,y) $ 出发的最长路径，在每一次搜索完成之后更新一下当前的答案，记录到 $ \text{mem}(x,y) $ 中即可。等到下一次搜到这个点（记为 $ (x’,y’) $ ），如果 $ \text{mem}(x’,y’) \geq 0 $ （也就是被更新过了），直接返回 $ \text{mem}(x’,y’) $ 就行。</p><hr><p>我们也可以把记忆化搜索升级为 DP <del>不过据说比记忆化搜索还慢</del><br>DP 做法题解已提上日程。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>,  <span class="number">0</span>, <span class="number">-1</span>,  <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXRC = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> snow[MAXRC][MAXRC];</span><br><span class="line"><span class="keyword">int</span> r, c, ans;</span><br><span class="line"><span class="keyword">int</span> mem[MAXRC][MAXRC];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mem[x][y]) t = mem[x][y];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (nx &gt; <span class="number">0</span> &amp;&amp; ny &gt; <span class="number">0</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &lt;= c &amp;&amp; snow[x][y] &lt; snow[nx][ny]) &#123;</span><br><span class="line">                t = <span class="built_in">std</span>::max(t, Search(nx, ny) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mem[x][y] = t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; snow[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = Search(i, j);</span><br><span class="line">            mem[i][j] = now;</span><br><span class="line">            ans = <span class="built_in">std</span>::max(ans, mem[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记忆化搜索好题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="省选" scheme="https://blog.handwer-std.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="记忆化搜索" scheme="https://blog.handwer-std.top/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Luogu-P2320</title>
    <link href="https://blog.handwer-std.top/2019-01-27/Luogu-P2320/"/>
    <id>https://blog.handwer-std.top/2019-01-27/Luogu-P2320/</id>
    <published>2019-01-26T23:35:48.000Z</published>
    <updated>2019-01-26T23:35:48.232Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>洛谷P1541「NOIP2010」《乌龟棋》</title>
    <link href="https://blog.handwer-std.top/2019-01-26/Luogu-P1541/"/>
    <id>https://blog.handwer-std.top/2019-01-26/Luogu-P1541/</id>
    <published>2019-01-26T00:38:28.000Z</published>
    <updated>2019-01-26T14:37:08.346Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ProjectDP - 3</p></blockquote><blockquote><p>枚举转移</p></blockquote><a id="more"></a><h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>乌龟棋的棋盘是一行$N$个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第$N$格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</p><p>乌龟棋中$M$张爬行卡片，分成4种不同的类型（$M$张卡片中不一定包含所有4种类型的卡片，见样例），每种类型的卡片上分别标有$1,2,3,4$四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</p><p>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</p><p>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。</p><p>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>每行中两个数之间用一个空格隔开。</p><p>第1行2个正整数$N,M$，分别表示棋盘格子数和爬行卡片数。</p><p>第2行$N$个非负整数，$a_1,a_2,…,a_N$，其中$a_i$表示棋盘第$i$个格子上的分数。</p><p>第3行$M$个整数，$b_1,b_2,…,b_M$，表示M张爬行卡片上的数字。</p><p>输入数据保证到达终点时刚好用光$M$张爬行卡片。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>11个整数，表示小明最多能得到的分数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">9 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">10</span> <span class="number">14</span> <span class="number">2</span> <span class="number">8</span> <span class="number">8</span> <span class="number">18</span> <span class="number">5</span> <span class="number">17</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">73</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先来想想五维的 DP</p><p>我们设 $ f(i,j,k,l,m) $ 表示当前用了 $i$ 个卡片1， $j$ 个卡片2， $k$ 个卡片3， $l$ 个卡片4，走了 $m$ 步时的最大得分</p><p>分别对四种卡片进行转移</p><p>$$ Max = f[i-1][j][k][l][m - 1] (i \geq 1) $$</p><p>$$ Max = max(Max,f[i][j-1][k][l][m - 2]) (j \geq 1, m \geq 3) $$</p><p>$$ Max = max(Max,f[i][j][k-1][l][m - 3]) (k \geq 1, m \geq 4) $$</p><p>$$ Max = max(Max,f[i][j][k][l-1][m - 4]) (l \geq 1, m \geq 5) $$</p><p>$$ f[i][j][k][l][m] = Max + Score[m] $$</p><hr><p>考虑一下优化。<br>显然 $m$ 是可以通过计算得出的，$ m = i + 2j + 3k + 4l + 1 $ （注意后面的+1，因为是从第一个格开始的），那么就能省去一维</p><p>转移方程就变为了</p><p>$$ m = i + 2j + 3k + 4l + 1 $$</p><p>$$ Max = f[i-1][j][k][l] (i \geq 1) $$</p><p>$$ Max = max(Max,f[i][j-1][k][l]) (j \geq 1) $$</p><p>$$ Max = max(Max,f[i][j][k-1][l]) (k \geq 1) $$</p><p>$$ Max = max(Max,f[i][j][k][l-1]) (l \geq 1) $$</p><p>$$ f[i][j][k][l] = Max + Score[m] $$</p><p>最终答案<del>留做习题</del>见代码</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  3.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/1/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CARD1 means the card that can make the turtle go 1 block.</span></span><br><span class="line"><span class="comment"> * CARD2, CARD3 and CARD4 too.</span></span><br><span class="line"><span class="comment"> * dp[i][j][k][l] records the max score when there are i CARD1(s), j CARD2(s), k CARD3(s) and l CARD4(s) have been used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Formula:</span></span><br><span class="line"><span class="comment"> *     Step = i * 1 + j * 2 + k * 3 + l * 4 + 1</span></span><br><span class="line"><span class="comment"> *     Max = dp[i][j][k][k]</span></span><br><span class="line"><span class="comment"> *     Max = max(Max, dp[i-1][j][k][l]) (i &gt;= 1)</span></span><br><span class="line"><span class="comment"> *     Max = max(Max, dp[i][j-1][k][l]) (j &gt;= 1)</span></span><br><span class="line"><span class="comment"> *     Max = max(Max, dp[i][j][k-1][l]) (k &gt;= 1)</span></span><br><span class="line"><span class="comment"> *     Max = max(Max, dp[i][j][k][l-1]) (l &gt;= 1)</span></span><br><span class="line"><span class="comment"> *     dp[i][j][k][l] = Max + score[Step]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Answer:</span></span><br><span class="line"><span class="comment"> *     dp[a][b][c][d],</span></span><br><span class="line"><span class="comment"> *     a -&gt; the amount of CARD1, b, c, and d too.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">350</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">120</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXCARD = <span class="number">40</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sc[MAXN], cds[MAXM];</span><br><span class="line"><span class="keyword">int</span> a, b, c, d;</span><br><span class="line"><span class="keyword">int</span> dp[MAXCARD][MAXCARD][MAXCARD][MAXCARD];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; sc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cds[i];</span><br><span class="line">        <span class="keyword">if</span> (cds[i] == <span class="number">1</span>) ++a;</span><br><span class="line">        <span class="keyword">if</span> (cds[i] == <span class="number">2</span>) ++b;</span><br><span class="line">        <span class="keyword">if</span> (cds[i] == <span class="number">3</span>) ++c;</span><br><span class="line">        <span class="keyword">if</span> (cds[i] == <span class="number">4</span>) ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= c; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= d; ++l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> walked = <span class="number">1</span> + i * <span class="number">1</span> + j * <span class="number">2</span> + k * <span class="number">3</span> + l * <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (walked &gt; n) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">int</span> Max = dp[i][j][k][l];</span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) Max = max(Max, dp[i<span class="number">-1</span>][j][k][l]);</span><br><span class="line">                    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) Max = max(Max, dp[i][j<span class="number">-1</span>][k][l]);</span><br><span class="line">                    <span class="keyword">if</span> (k - <span class="number">1</span> &gt;= <span class="number">0</span>) Max = max(Max, dp[i][j][k<span class="number">-1</span>][l]);</span><br><span class="line">                    <span class="keyword">if</span> (l - <span class="number">1</span> &gt;= <span class="number">0</span>) Max = max(Max, dp[i][j][k][l<span class="number">-1</span>]);</span><br><span class="line">                    dp[i][j][k][l] = Max + sc[walked];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[a][b][c][d] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ProjectDP - 3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;枚举转移&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="DP" scheme="https://blog.handwer-std.top/tags/DP/"/>
    
      <category term="ProjectDP" scheme="https://blog.handwer-std.top/tags/ProjectDP/"/>
    
  </entry>
  
  <entry>
    <title>ProjectDP</title>
    <link href="https://blog.handwer-std.top/2019-01-24/ProjectDP/"/>
    <id>https://blog.handwer-std.top/2019-01-24/ProjectDP/</id>
    <published>2019-01-24T10:21:55.000Z</published>
    <updated>2019-01-26T14:38:44.753Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DP计划</p></blockquote><p>为提高自己的DP水平，我创建了一个名为「DP计划」的工程，用它来记录自己的题目完成情况，同时编程、调试、代码储存也使用此工程。</p><p>项目地址：<a href="https://github.com/HandwerSTD/ProjectDP" target="_blank" rel="noopener">View ProjectDP on GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;DP计划&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为提高自己的DP水平，我创建了一个名为「DP计划」的工程，用它来记录自己的题目完成情况，同时编程、调试、代码储存也使用此工程。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://githu
      
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="DP" scheme="https://blog.handwer-std.top/tags/DP/"/>
    
      <category term="ProjectDP" scheme="https://blog.handwer-std.top/tags/ProjectDP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1083《借教室》</title>
    <link href="https://blog.handwer-std.top/2019-01-24/Luogu-P1083/"/>
    <id>https://blog.handwer-std.top/2019-01-24/Luogu-P1083/</id>
    <published>2019-01-24T06:54:42.000Z</published>
    <updated>2019-01-25T05:49:25.937Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前缀和 + 二分答案</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p><p>面对海量租借教室的信息，我们自然希望编程解决这个问题。</p><p>我们需要处理接下来$n$天的借教室信息，其中第$i$天学校有$r_i$个教室可供租借。共有$m$份订单，每份订单用三个正整数描述，分别为$d_j,s_j,t_j$，表示某租借者需要从第$s_j$天到第$t_j$天租借教室（包括第$s_j$天和第$t_j$天），每天需要租借$d_j$个教室。</p><p>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$d_j$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p><p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$s_j$天到第$t_j$天中有至少一天剩余的教室数量不足$d_j$个。</p><p>现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p><p>输入输出格式<br>输入格式：<br>第一行包含两个正整数$n,m$，表示天数和订单的数量。</p><p>第二行包含$n$个正整数，其中第$i$个数为$r_i$，表示第$i$天可用于租借的教室数量。</p><p>接下来有$m$行，每行包含三个正整数$d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。</p><p>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从$1$开始的整数编号。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果所有订单均可满足，则输出只有一行，包含一个整数 $0$。否则（订单无法完全满足）</p><p>输出两行，第一行输出一个负整数$−1$，第二行输出需要修改订单的申请人编号。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">3</span> </span><br><span class="line"><span class="symbol">2 </span><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> </span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">3</span> </span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">4</span> </span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="number">1</span> </span></span><br><span class="line"><span class="ruby"><span class="number">2</span></span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【输入输出样例说明】</p><p>第 $1$份订单满足后，$4$天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2$天到第 $4$ 天每天提供 $3$个教室，而第 $3$ 天剩余的教室数为 $2$，因此无法满足。分配停止，通知第$2$ 个申请人修改订单。</p><p>【数据范围】</p><p>对于10%的数据，有$1≤ n,m≤ 10$；</p><p>对于30%的数据，有$1≤ n,m≤1000$；</p><p>对于 70%的数据，有$1 ≤ n,m ≤ 10^5$；</p><p>对于 100%的数据，有 $ 1 ≤ n,m ≤ 10^6,0 ≤ r_i,d_j≤ 10^9,1 ≤ s_j≤ t_j≤ n​ $。</p><p>NOIP 2012 提高组 第二天 第二题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑二分答案</p><p>首先我们知道，对于一个订单 $i$，如果它能被批准，那么 $[1,i]$ 都能被批准；如果它不能被批准，那么 $[i,m]$ 都不能被批准（单调性）</p><p>那么我们二分订单的编号 $\text{mid}$，每次判一下$[1,\text{mid}]$是否全都能满足，最后如果右边界不是 $m$ 了，说明有订单不能满足，输出右边界即可</p><hr><p>如何判断是否能满足？<br>首先我们要$O(1)$实现区间修改（？？？）<br>用前缀和就可以实现！</p><p>想想下面的过程$\downarrow$</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">原数列:  <span class="number"> 0 </span><span class="number"> 0 </span><span class="number"> 0 </span><span class="number"> 0 </span><span class="number"> 0 </span> 0</span><br><span class="line">       [<span class="number"> 1 </span><span class="number"> 2 </span><span class="number"> 3 </span><span class="number"> 4 </span><span class="number"> 5 </span><span class="number"> 6 </span>]</span><br><span class="line">前缀和： <span class="number"> 0 </span><span class="number"> 0 </span><span class="number"> 0 </span><span class="number"> 0 </span><span class="number"> 0 </span> 0</span><br><span class="line">       [<span class="number"> 1 </span><span class="number"> 2 </span><span class="number"> 3 </span><span class="number"> 4 </span><span class="number"> 5 </span><span class="number"> 6 </span>]</span><br><span class="line">       </span><br><span class="line">我们让[1,3]都增加2</span><br><span class="line">于是我们选择让[1]增加2，让[4]（即[3+1]）减去2</span><br><span class="line">那么上面的数列就变成了：</span><br><span class="line"></span><br><span class="line">原数列:  <span class="number"> 2 </span><span class="number"> 0 </span><span class="number"> 0 </span>-2 <span class="number"> 0 </span> 0</span><br><span class="line">       [<span class="number"> 1 </span><span class="number"> 2 </span><span class="number"> 3 </span><span class="number"> 4 </span><span class="number"> 5 </span><span class="number"> 6 </span>]</span><br><span class="line">前缀和： <span class="number"> 2 </span><span class="number"> 2 </span><span class="number"> 2 </span><span class="number"> 0 </span><span class="number"> 0 </span> 0</span><br><span class="line">       [<span class="number"> 1 </span><span class="number"> 2 </span><span class="number"> 3 </span><span class="number"> 4 </span><span class="number"> 5 </span><span class="number"> 6 </span>]</span><br><span class="line"></span><br><span class="line">这个时候前缀和数组就实现了区间加！</span><br></pre></td></tr></table></figure><p>那么依照上面的思想，我们就能写出<code>Check(int mid)</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Order</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> amount, l, r;</span><br><span class="line">    </span><br><span class="line">    Order() &#123; amount = l = r = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; order[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], sum[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> __i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __i; ++i) &#123;</span><br><span class="line">        <span class="comment">// 像上面一样处理前缀和</span></span><br><span class="line">        sum[order[i].l] += order[i].amount;</span><br><span class="line">        sum[order[i].r] -= order[i].amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将前缀和处理一遍</span></span><br><span class="line">        <span class="comment">// 判一下是否有超过当天可用教室的值</span></span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[i] &gt; a[i]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不合法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXNM = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Order</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        </span><br><span class="line">        Order() &#123; num = l = r = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125; order[MAXNM];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m, seq[MAXNM];</span><br><span class="line">    <span class="keyword">int</span> sum[MAXNM];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">            sum[order[i].l] += order[i].num;</span><br><span class="line">            sum[order[i].r + <span class="number">1</span>] -= order[i].num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (sum[i] &gt; seq[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, n) seq[i] = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        order[i].num = getint();</span><br><span class="line">        order[i].l = getint();</span><br><span class="line">        order[i].r = getint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, R = m;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid)) L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (R != m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n%d\n"</span>, R);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前缀和 + 二分答案&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="二分答案" scheme="https://blog.handwer-std.top/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>二分图匹配学习笔记 &amp; HDU2063 题解</title>
    <link href="https://blog.handwer-std.top/2019-01-24/BipartiteGraph/"/>
    <id>https://blog.handwer-std.top/2019-01-24/BipartiteGraph/</id>
    <published>2019-01-24T01:36:23.000Z</published>
    <updated>2019-01-24T03:27:08.223Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二分图真是个奇怪又好玩的东西</p></blockquote><p>原创建时间：2018-07-06 21:36:45</p><!--本文包含[《HDU2063 过山车》](https://acm.hdu.edu.cn/showproblem.php?pid=2063)题解--><!--**本文部分内容有误（因为作者太弱），等待修正**--><!--已修正完毕--><a id="more"></a><h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>设图$G=(V,E)$是一个无向图，若顶点集合$V$可分割为两个互不相交的子集$X$和$Y$，且图中每条边连接的顶点一个在$X$中，一个在$Y$中，则称$G$是一个二分图。</p><h2 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h2><p>若某一图是联通的，</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 任选一个点V作为顶点，定义距离标号为<span class="number">0</span></span><br><span class="line"><span class="number">2.</span> 将V的邻接点标号设为<span class="number">1</span>，接着将它的未标号的邻接点的标号设为<span class="number">2</span>，以此类推 </span><br><span class="line"><span class="number">3.</span> 将所有标号为奇数的点归为X，标号为偶数的点归为Y</span><br></pre></td></tr></table></figure><p>以上内容可以采用BFS完成</p><p>依次检查每一条边，看看是否满足顶点一个在$X$中，一个在$Y$中</p><hr><p>若某一图不连通，就在每个联通块里进行判定</p><h1 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定一个二分图$G$，在$G$的子图$M$中，$M$的边集${E}$中的任意两条边都不依附于同一个顶点，则称$M$是一个匹配。</p><p>图中蓝色的边是数量为2的匹配</p><p><img src="https://s1.ax2x.com/2018/07/06/oQPHl.png" alt="oQPHl.png"></p><h2 id="最大匹配-amp-完全匹配"><a href="#最大匹配-amp-完全匹配" class="headerlink" title="最大匹配 &amp; 完全匹配"></a>最大匹配 &amp; 完全匹配</h2><p>选择边数最大的子图称为「二分图的最大匹配问题」</p><p>如果一个匹配中图的每一个顶点都和某条边相关联，则称此匹配为「完全匹配」（或「完备匹配」）</p><p>图中为一个完全匹配</p><p><img src="https://s1.ax2x.com/2018/07/06/oQa4J.png" alt="oQa4J.png"></p><h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>设$M$为二分图$G$已匹配边的集合，若$P$是$G$上其中一条联通两个未匹配顶点的路径（起点在$X$部，终点在$Y$部），且属$M$的边和不属$M$的边在$P$上交替出现，则称$P$为相对于$M$的一条增广路径</p><h3 id="寻找增广路"><a href="#寻找增广路" class="headerlink" title="寻找增广路"></a>寻找增广路</h3><p>设$M$为二分图$G$所有已匹配边的集合，</p><p>如图，蓝色为在$M$里的边，黄色为不在$M$里的边</p><p><img src="https://s1.ax2x.com/2018/07/06/oW9gr.png" alt="oW9gr.png"></p><p>从$x_4$到$y_2$找一条路径：</p><p>$<br>x_4 \rightarrow y_3 \rightarrow x_2 \rightarrow y1 \rightarrow x1 \rightarrow y2<br>$</p><p>这条路径就是<strong>「增广路径」</strong></p><p>其中属于$M$的边有：<br>${x2,y3}, {x1,y1}$</p><p>不属于$M$的边有：<br>${x4,y3}, {x2,y1},{x1,y2}$</p><p>显然，<i><b>不属于$M$的边比属于$M$的边要多一条</b></i></p><hr><p>将这条增广路上的边全都「反色」，如图</p><p><img src="https://s1.ax2x.com/2018/07/06/oWBQY.png" alt="oWBQY.png"></p><p>可以发现，匹配仍然合法，但是匹配数多了一对</p><pre><code>另外，单独的一条连接两个未匹配点的边显然也是增广路   </code></pre><p>那么可知，当不能再找到增广轨时，就得到了一个「最大匹配」，这就是匈牙利算法的基本思路</p><h3 id="增广路径性质"><a href="#增广路径性质" class="headerlink" title="增广路径性质"></a>增广路径性质</h3><p>由增广路的定义可以推出下述三个结论：</p><ol><li>P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。</li><li>P经过取反操作可以得到一个更大的匹配M’。</li><li>M为G的最大匹配当且仅当不存在相对于M的增广路径。</li></ol><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>用增广路求最大匹配（称作匈牙利算法，匈牙利数学家Edmonds于1965年提出）</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>置$M$为空</li><li>找出一条增广路$P$，通过取反操作获得更大的匹配$M‘$代替$M$</li><li>重复2直到找不出增广路</li></ol><h3 id="找增广路径的算法"><a href="#找增广路径的算法" class="headerlink" title="找增广路径的算法"></a>找增广路径的算法</h3><p>我们采用DFS的办法找一条增广路径： </p><p>从X部一个未匹配的顶点u开始，找一个未访问的邻接点v（v一定是Y部顶点）。</p><p>对于$v$，分两种情况：</p><ol><li>如果$v$未匹配，则已经找到一条增广路</li><li>如果$v$已经匹配，则取出$v$的匹配顶点$w$($w$一定是$X$部顶点)，边$(w,v)$目前是匹配的，根据“取反”的想法，要将$(w,v)$改为未匹配，$(u,v)$设为匹配，能实现这一点的条件是看从$w$为起点能否新找到一条增广路径$P’$。如果行，则$u \rightarrow v \rightarrow P’$就是一条以$u$为起点的增广路径。</li></ol><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ \text{Algorithm 1: } $ 寻找从 $ u $ 出发的增广路径 $ DFS(u) $<br>返回 $ \text{True} $ 表示成功匹配，$ \text{False} $ 反之<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>&nbsp;&nbsp;$ 1: \text{For each } v \in u$的邻接点<br>&nbsp;&nbsp;$ 2: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{If } v $ 未访问过<br>&nbsp;&nbsp;$ 3: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 标记 $ v $ 被访问过<br>&nbsp;&nbsp;$ 4: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{If } v $ 未被匹配 或者 $ \text{DFS(}v$的匹配点$\text{)}$<br>&nbsp;&nbsp;$ 5: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 标记 $v$ 的匹配点为 $u$，$u$ 的匹配点为 $v$<br>&nbsp;&nbsp;$ 6: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{Return True} $<br>&nbsp;&nbsp;$ 7: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{End If}$<br>&nbsp;&nbsp;$ 8: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{End If}$<br>&nbsp;&nbsp;$ 9: \text{End For} $<br>$ 10: \text{Return False} $<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="comment">// ans 表示 Y 集合中每个顶点的匹配点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(px, <span class="number">-1</span>, <span class="keyword">sizeof</span> px);</span><br><span class="line"><span class="comment">// 用 -1 表示没有匹配</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = edge[e].now;</span><br><span class="line">        <span class="keyword">if</span> (!vis[now]) &#123;</span><br><span class="line">            vis[now] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (px[now] == <span class="number">-1</span> || DFS(px[now])) &#123;</span><br><span class="line">                px[u] = now;</span><br><span class="line">                <span class="comment">// 为了方便，可以只标记 Y 到 X</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="《HDU2063-过山车》题解"><a href="#《HDU2063-过山车》题解" class="headerlink" title="《HDU2063 过山车》题解"></a>《HDU2063 过山车》题解</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p><h2 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h2><p><strong>Input</strong></p><p>输入数据的第一行是三个整数$K , M , N$，分别表示可能的组合数目，女生的人数，男生的人数。$0&lt;K&lt;=1000,<br>1&lt;=N,M&lt;=500$.接下来的$K$行，每行有两个数，分别表示女生$A_i$愿意和男生$B_j$做partner。最后一个$0$结束输入。</p><p><strong>Output</strong></p><p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p><p><strong>Sample Input</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">6 </span><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>「每个女生必须找个个男生做partner和她同坐」</p><p>好了，可以看出这是匹配问题，问你如何匹配</p><p>「Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner」</p><p>这句话告诉了我们如何建边：</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">把所有女生的顶点放到集合<span class="keyword">X</span>中，所有男生的顶点放到集合<span class="keyword">Y</span>中，</span><br><span class="line">从Rabbit分别建一条到XHD的边和一条到PQK的边，</span><br><span class="line">从Grass分别建一条到linle的边和一条到LL的边……</span><br></pre></td></tr></table></figure><p>那么显然这就是一个二分图，而本题要求的就是这个二分图的最大匹配</p><p>又是一道模板题</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t[MAXN][MAXN], <span class="built_in">map</span>[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[u][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>[i] || dfs(<span class="built_in">map</span>[i])) &#123;</span><br><span class="line">                <span class="built_in">map</span>[i] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;k, &amp;m, &amp;n), k != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            t[x][y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span> (dfs(i)) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;二分图真是个奇怪又好玩的东西&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原创建时间：2018-07-06 21:36:45&lt;/p&gt;
&lt;!--本文包含[《HDU2063 过山车》](https://acm.hdu.edu.cn/showproblem.php?pid=2063)题解--&gt;
&lt;!--**本文部分内容有误（因为作者太弱），等待修正**--&gt;
&lt;!--已修正完毕--&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="BFS" scheme="https://blog.handwer-std.top/tags/BFS/"/>
    
      <category term="二分图" scheme="https://blog.handwer-std.top/tags/%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P5019「NOIP 2013 / 2018」《铺设道路》</title>
    <link href="https://blog.handwer-std.top/2019-01-23/Luogu-P5019/"/>
    <id>https://blog.handwer-std.top/2019-01-23/Luogu-P5019/</id>
    <published>2019-01-23T05:05:49.000Z</published>
    <updated>2019-01-23T05:44:47.138Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CCF：<strong>我&nbsp;抄&nbsp;我&nbsp;自&nbsp;己</strong></p></blockquote><a id="more"></a><center>本题与<a href="https://www.luogu.org/problemnew/show/P1969" target="_blank" rel="noopener">洛谷P1969</a>重复</center><br><center>代码通用</center><br><center>题解<a href="/2019-01-22/Luogu-P1969">传送门</a></center>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;CCF：&lt;strong&gt;我&amp;nbsp;抄&amp;nbsp;我&amp;nbsp;自&amp;nbsp;己&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Luogu-P5020</title>
    <link href="https://blog.handwer-std.top/2019-01-23/Luogu-P5020/"/>
    <id>https://blog.handwer-std.top/2019-01-23/Luogu-P5020/</id>
    <published>2019-01-23T05:05:40.000Z</published>
    <updated>2019-01-23T05:05:40.553Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>洛谷P1330《封锁阳光大学》</title>
    <link href="https://blog.handwer-std.top/2019-01-23/Luogu-P1330/"/>
    <id>https://blog.handwer-std.top/2019-01-23/Luogu-P1330/</id>
    <published>2019-01-23T02:22:04.000Z</published>
    <updated>2019-01-23T03:38:48.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对子连通图的染色</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。</p><p>阳光大学的校园是一张由N个点构成的无向图，N个点之间由M条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在与这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。</p><p>询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：两个整数N，M</p><p>接下来M行：每行两个整数A，B，表示点A到点B之间有道路相连。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行：如果河蟹无法封锁所有道路，则输出“Impossible”，否则输出一个整数，表示最少需要多少只河蟹。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Impossible</span></span><br></pre></td></tr></table></figure><h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模】</p><p>1&lt;=N&lt;=10000，1&lt;=M&lt;=100000，任意两点之间最多有一条道路。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><big>本题的图可能不为连通图（注意这个坑）</big><p>阅读题目，我们得到了这样几条信息：<br>「当某个点被封锁后，与这个点相连的道路就被封锁了」<br>「当两只河蟹封锁了相邻的两个点时，他们会发生冲突」<br>「封锁所有道路并且不发生冲突」</p><p>总结一下就是：<br>「要求每一条边有且仅有一个点被选择，求最少能选择多少点」</p><p>然后我们就可以考虑用染色的方法做这一题</p><p>我们枚举每一个点，以当前枚举到的起点为根对这个子连通图进行 DFS 染色（因为图可能不联通），答案累加每次染色的最小数量（黑色点数量和白色点数量中最小的）</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> head(a) Head[a].id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nowcolor(a) Head[a].color</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> visited(a) Head[a].used</span></span><br><span class="line"><span class="comment">// 这样 define 有助于简化代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, ans;</span><br><span class="line">    <span class="keyword">int</span> sum0, sum1;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> color, used, id;</span><br><span class="line">            <span class="comment">// 在一个数组中存储三个数量</span></span><br><span class="line">            </span><br><span class="line">            Node() &#123; color = used = id = <span class="number">0</span>; &#125;</span><br><span class="line">        &#125; Head[MAXN];</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> now, next;</span><br><span class="line">        &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">bool</span> isR = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isR) &#123; addEdge(next, prev, <span class="literal">false</span>); &#125;</span><br><span class="line">            edge[++cnt].now = next;</span><br><span class="line">            edge[cnt].next = head(prev);</span><br><span class="line">            head(prev) = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Color</span><span class="params">(<span class="keyword">int</span> __id, <span class="keyword">int</span> nowColor)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 返回 true 为成功染色， false 反之</span></span><br><span class="line">            <span class="keyword">if</span> (visited(__id)) &#123;</span><br><span class="line">                <span class="keyword">return</span> nowcolor(__id) == nowColor;</span><br><span class="line">                <span class="comment">// 如果当前被染过不同的颜色，就失败</span></span><br><span class="line">            &#125;</span><br><span class="line">            visited(__id) = <span class="literal">true</span>;</span><br><span class="line">            nowcolor(__id) = nowColor;</span><br><span class="line">            <span class="keyword">if</span> (nowColor) ++sum1;</span><br><span class="line">            <span class="keyword">else</span> ++sum0;</span><br><span class="line">            <span class="keyword">bool</span> __ans = <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = head(__id); e &amp;&amp; __ans; e = edge[e].next) &#123;</span><br><span class="line">                <span class="keyword">int</span> now = edge[e].now;</span><br><span class="line">                __ans = __ans &amp; Color(now, nowColor ^ <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 遍历与当前点相连的每一条边并 DFS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> __ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> __EXIT() &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        g1.addEdge(prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g1.visited(i)) <span class="keyword">continue</span>;</span><br><span class="line">        sum0 = sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!g1.Color(i, <span class="number">0</span>)) __EXIT();</span><br><span class="line">        ans += <span class="built_in">std</span>::min(sum0, sum1);</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO::putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对子连通图的染色&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1969「NOIP 2013 / 2018」《积木大赛》</title>
    <link href="https://blog.handwer-std.top/2019-01-22/Luogu-P1969/"/>
    <id>https://blog.handwer-std.top/2019-01-22/Luogu-P1969/</id>
    <published>2019-01-22T07:33:30.000Z</published>
    <updated>2019-01-23T02:06:05.923Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>原&nbsp;题&nbsp;警&nbsp;告</strong></p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，大厦可以看成由$n$块宽度为1的积木组成，第$i$块积木的最终高度需要是$h_i$。</p><p>在搭建开始之前，没有任何积木（可以看成$n$块高度为$0$的积木）。接下来每次操作，小朋友们可以选择一段连续区间$[l, r]$，然后将第 $L$块到第 $R$ 块之间（含第 $L$ 块和第 $R$块）所有积木的高度分别增加$1$。</p><p>小 $M$是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>包含两行，第一行包含一个整数nn，表示大厦的宽度。</p><p>第二行包含$n$个整数，第i个整数为$h_i$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>建造所需的最少操作数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【样例解释】</p><p>其中一种可行的最佳方案，依次选择</p><p>$[1,5]$ $[1,3]$ $[2,3]$ $[3,3]$ $[5,5]$</p><p>【数据范围】</p><p>对于 30\%30%的数据，有$1 ≤ n ≤ 10$；</p><p>对于 70\%70%的数据，有$1 ≤ n ≤ 1000$；</p><p>对于 100\%100%的数据，有$1 ≤ n ≤ 100000,0 ≤ h_i≤ 10000$。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>真不敢相信 CCF 居然用了原题</p><hr><p>单独把 $h_1$ 读进来，存在 $ans$ 里。</p><p>在读剩下的 $n - 1$ 个数的时候，每次判一下当前数与上一个数的关系：</p><ul><li>如果比上一个数大，就说明我们还需要再放积木，答案累加当前数与上一个数的差；</li><li>如果没有上个数大，就说明我们之前搭积木已经能够把这摞积木放好了，自然就不需要更新了。</li></ul><p>然后把「上一个数」更新为当前数即可</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> lastOne = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; now;</span><br><span class="line">        <span class="keyword">if</span> (now &gt; lastOne) ans += (now - lastOne);</span><br><span class="line">        lastOne = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;原&amp;nbsp;题&amp;nbsp;警&amp;nbsp;告&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1119《灾后重建》</title>
    <link href="https://blog.handwer-std.top/2019-01-22/Luogu-P1119/"/>
    <id>https://blog.handwer-std.top/2019-01-22/Luogu-P1119/</id>
    <published>2019-01-22T07:32:53.000Z</published>
    <updated>2019-01-22T09:04:30.223Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>让人加深对 Floyd 的理解</p></blockquote><a id="more"></a><h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>B地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出B地区的村庄数$N$，村庄编号从$0$到$N−1$，和所有$M$条公路的长度，公路是双向的。并给出第$i$个村庄重建完成的时间$t_i$，你可以认为是同时开始重建并在第$t_i$​    天重建完成，并且在当天即可通车。若$t_i$​为$0$则说明地震未对此地区造成损坏，一开始就可以通车。之后有$Q$个询问$(x, y, t)$，对于每个询问你要回答在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄$x$或村庄$y$在第$t$天仍未重建完成 ，则需要返回$-1$。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数$N,M$，表示了村庄的数目与公路的数量。</p><p>第二行包含$N$个非负整数$t_0, t_1,…, t_{N-1}$，表示了每个村庄重建完成的时间，数据保证了$t_0 ≤ t_1 ≤ … ≤ t_{N-1}$。</p><p>接下来$M$行，每行$3$个非负整数$i, j, w$，$w$为不超过$10000$的正整数，表示了有一条连接村庄$i$与村庄$j$的道路，长度为$w$，保证$i≠j$，且对于任意一对村庄只会存在一条道路。</p><p>接下来一行也就是$M+3$行包含一个正整数$Q$，表示$Q$个询问。</p><p>接下来$Q$行，每行$3$个非负整数$x, y, t$，询问在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少，数据保证了$t$是不下降的。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共$Q$行，对每一个询问$(x, y, t)$输出对应的答案，即在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果在第$t$天无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄$x$或村庄$y$在第$t$天仍未修复完成，则输出$-1$。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="number">1</span></span></span><br><span class="line"><span class="ruby">-<span class="number">1</span></span></span><br><span class="line"><span class="ruby"><span class="number">5</span></span></span><br><span class="line"><span class="ruby"><span class="number">4</span></span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>对于$30\%$的数据，有$N≤50$；</p><p>对于$30\%$的数据，有$t_i= 0$​，其中有$20\%$的数据有$t_i = 0$且$N&gt;50$；</p><p>对于$50\%$的数据，有$Q≤100$；</p><p>对于$100\%$的数据，有 $N≤200$，$M≤N \times (N-1)/2$，$Q≤50000$，所有输入数据涉及整数均不超过$100000$。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先 $ N \leq 200 $，那么肯定是用 Floyd</p><p>Floyd 算法的本质是 DP，转移方程为 </p><p>$$ f_{i,j} = min(f_{i,j},\ f_{i,k} + f_{k,j}) $$</p><p>其中的这个 $k$ 就是「中转点」，表示当前最大能经过编号为 $k$ 的点。</p><p>明确了这些，我们再来看题。</p><hr><p>给出每一个点状态转为「可用」的时间和所有的边，让你求任意点到点的距离。<br>我们跑 Floyd 时，$k$ 限制了我们当前能走的点，就相当于是题目中点的「不可用」状态！再加上所有的询问都是按照时间顺序给出的，所以我们就可以利用 Floyd 的性质来做这题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- 全局变量 -- */</span></span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>; <span class="comment">// 当前最多能走第 now 个点，也就是 Floyd 中的 k</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- 在函数 main() 里 -- */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; start &gt;&gt; end &gt;&gt; ti<span class="comment">// 读入起止点 start end 和当前时间 ti</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (Time[now] &lt;= ti) &#123;</span><br><span class="line"><span class="comment">// 当前的点转为「可用」的时间没有超过当前时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = now; <span class="comment">// 方便理解</span></span><br><span class="line"><span class="comment">// 以下为标准的 Floyd</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">dis[x][y] = <span class="built_in">std</span>::min(dis[x][y], dis[x][k] + dis[k][y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++now; <span class="comment">// 这个点更新完了，往后继续更新，直到超过当前时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">dis[start][end] == __INF <span class="comment">/* 无法到达 */</span> </span><br><span class="line">|| Time[start] &gt; ti </span><br><span class="line">|| Time[end] &gt; ti <span class="comment">/* 没有转为「可用」 */</span></span><br><span class="line">) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[start][end]); <span class="comment">// 输出答案</span></span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> dis[MAXN][MAXN], k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    <span class="keyword">int</span> ttime[MAXN];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    <span class="built_in">memset</span>(ttime, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> ttime);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ttime[i] = getint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        <span class="keyword">int</span> weight = getint();</span><br><span class="line">        dis[prev][next] = dis[next][prev] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    q = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = getint();</span><br><span class="line">        <span class="keyword">int</span> t = getint();</span><br><span class="line">        <span class="keyword">int</span> timee = getint();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ttime[k] &lt;= timee) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; n; ++a) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; n; ++b) &#123;</span><br><span class="line">                    dis[a][b] = <span class="built_in">std</span>::min(dis[a][b], dis[a][k] + dis[k][b]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dis[s][t] == <span class="number">0x3f3f3f3f</span> || ttime[s] &gt; timee || ttime[t] &gt; timee) ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans = dis[s][t];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;让人加深对 Floyd 的理解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Floyd" scheme="https://blog.handwer-std.top/tags/Floyd/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1341《无序字母对》</title>
    <link href="https://blog.handwer-std.top/2019-01-21/Luogu-P1341/"/>
    <id>https://blog.handwer-std.top/2019-01-21/Luogu-P1341/</id>
    <published>2019-01-21T09:11:55.000Z</published>
    <updated>2019-01-21T11:02:32.522Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欧拉图板子题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定n个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有n+1个字母的字符串使得每个字母对都在这个字符串中出现。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数n。</p><p>以下n行每行两个字母，表示这两个字母需要相邻。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出满足要求的字符串。</p><p>如果没有满足要求的字符串，请输出“No Solution”。</p><p>如果有多种方案，请输出前面的字母的ASCII编码尽可能小的（字典序最小）的方案</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line">aZ</span><br><span class="line">tZ</span><br><span class="line">Xt</span><br><span class="line">aX</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">XaZtX</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模与约定】</p><p>不同的无序字母对个数有限，n的规模可以通过计算得到。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们考虑把每一对字母视为一条边<br>那么这个图就是无向的（因为字母对是无序的）</p><p>题目让你求一个串，使得这个串里出现了所有的字母对，实际上就是让你求一条路径，使得所有的边都出现过</p><p><b><big><big><big><big>那这不就是求欧拉路吗！</big></big></big></big></b></p><p>所以这道题就完美地被转换为了欧拉路板子题</p><p>没学过欧拉路的看<a href="/2019-01-18/EulerPath-EulerCircuit/">这里</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">256</span> + <span class="number">233</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> G[MAXN][MAXN], deg[MAXN];</span><br><span class="line">    <span class="keyword">char</span> __MIN_NODE = <span class="number">127</span>, __MAX_NODE = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">char</span> prev, <span class="keyword">char</span> next, <span class="keyword">bool</span> Undirected = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">        ++G[prev][next];</span><br><span class="line">        <span class="keyword">if</span> (Undirected) addEdge(next, prev, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deleteEdge</span><span class="params">(<span class="keyword">char</span> prev, <span class="keyword">char</span> next, <span class="keyword">bool</span> Undirected = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">        --G[prev][next];</span><br><span class="line">        <span class="keyword">if</span> (Undirected) deleteEdge(next, prev, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Hierholzer</span><span class="params">(<span class="keyword">char</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i = __MIN_NODE; i &lt;= __MAX_NODE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G[s][i]) &#123;</span><br><span class="line">                deleteEdge(s, i);</span><br><span class="line">                Hierholzer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">char</span> prev, next;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; prev;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; next;</span><br><span class="line">        addEdge(prev, next);</span><br><span class="line">        ++deg[prev];</span><br><span class="line">        ++deg[next];</span><br><span class="line">        __MIN_NODE = <span class="built_in">std</span>::min(__MIN_NODE, <span class="built_in">std</span>::min(prev, next));</span><br><span class="line">        __MAX_NODE = <span class="built_in">std</span>::max(__MAX_NODE, <span class="built_in">std</span>::max(prev, next));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i = __MIN_NODE; i &lt;= __MAX_NODE; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deg[i] != <span class="number">0</span> &amp;&amp; deg[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) start = i;</span><br><span class="line">            ++odd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!start) start = __MIN_NODE;</span><br><span class="line">    <span class="keyword">if</span> (odd &amp;&amp; odd != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意不要忘了判无解</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Hierholzer(start);</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;欧拉图板子题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="欧拉图" scheme="https://blog.handwer-std.top/tags/%E6%AC%A7%E6%8B%89%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2731《骑马修栅栏 Riding the Fences》</title>
    <link href="https://blog.handwer-std.top/2019-01-20/Luogu-P2731/"/>
    <id>https://blog.handwer-std.top/2019-01-20/Luogu-P2731/</id>
    <published>2019-01-20T15:46:46.000Z</published>
    <updated>2019-01-21T11:14:18.536Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欧拉图板子题</p></blockquote><a id="more"></a><h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>Farmer John每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>John是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。你必须编一个程序，读入栅栏网络的描述，并计算出一条修栅栏的路径，使每个栅栏都恰好被经过一次。John能从任何一个顶点(即两个栅栏的交点)开始骑马，在任意一个顶点结束。</p><p>每一个栅栏连接两个顶点，顶点用1到500标号(虽然有的农场并没有500个顶点)。一个顶点上可连接任意多(&gt;=1)个栅栏。两顶点间可能有多个栅栏。所有栅栏都是连通的(也就是你可以从任意一个栅栏到达另外的所有栅栏)。</p><p>你的程序必须输出骑马的路径(用路上依次经过的顶点号码表示)。我们如果把输出的路径看成是一个500进制的数，那么当存在多组解的情况下，输出500进制表示法中最小的一个 (也就是输出第一位较小的，如果还有多组解，输出第二位较小的，等等)。</p><p>输入数据保证至少有一个解。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1行: 一个整数F(1 &lt;= F &lt;= 1024)，表示栅栏的数目</p><p>第2到F+1行: 每行两个整数i, j(1 &lt;= i,j &lt;= 500)表示这条栅栏连接i与j号顶点。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出应当有F+1行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">6</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">7</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>题目翻译来自NOCOW。</p><p>USACO Training Section 3.3</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>「使每个栅栏都恰好被经过一次」</p><p>妥妥的欧拉路板子题啊</p><p>没学过的看<a href="/2019-01-18/EulerPath-EulerCircuit/">这里</a></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">500</span> + <span class="number">10</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> G[MAXN][MAXN], n, degree[MAXN];</span><br><span class="line">    <span class="keyword">int</span> __MAX_NODE = <span class="number">-1</span>, __MIN_NODE = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        ++G[from][to];</span><br><span class="line">        ++G[to][from];</span><br><span class="line">        ++degree[from];</span><br><span class="line">        ++degree[to];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Hierholzer</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = __MIN_NODE; t &lt;= __MAX_NODE; ++t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G[s][t]) &#123;</span><br><span class="line">                --G[s][t];</span><br><span class="line">                --G[t][s];</span><br><span class="line">                Hierholzer(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    n = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        addEdge(prev, next);</span><br><span class="line">        __MAX_NODE = <span class="built_in">std</span>::max(__MAX_NODE, <span class="built_in">std</span>::max(prev, next));</span><br><span class="line">        __MIN_NODE = <span class="built_in">std</span>::min(__MIN_NODE, <span class="built_in">std</span>::min(prev, next));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __MAX_NODE; ++i, ++start) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degree[i] != <span class="number">0</span> &amp;&amp; degree[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) Hierholzer(start);</span><br><span class="line">    <span class="keyword">else</span> Hierholzer(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!ans.empty()) &#123;</span><br><span class="line">        putint(ans.top(), <span class="string">'\n'</span>);</span><br><span class="line">        ans.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;欧拉图板子题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="欧拉图" scheme="https://blog.handwer-std.top/tags/%E6%AC%A7%E6%8B%89%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>欧拉图学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-01-18/EulerPath-EulerCircuit/"/>
    <id>https://blog.handwer-std.top/2019-01-18/EulerPath-EulerCircuit/</id>
    <published>2019-01-18T09:27:03.000Z</published>
    <updated>2019-01-20T14:09:06.566Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从一个点出发走一走</p></blockquote><a id="more"></a><h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><ol><li>定义 $ (A,B) $ 表示从 $ A \rightarrow B $ 的一条边（若无特别说明，即为无向边）</li><li>定义 $ (A,B) \rightarrow (C,D) $ 表示从 $ A \rightarrow D $ ，经过 $ (A,B), (C,D) $ 两条边的路径</li><li>定义「孤立点」表示一个度为 0 的点</li><li>定义「奇顶点」表示一个度数为奇数的点</li><li>定义对于有向图 G ，将所有的有向边替换为无向边得到图 G 的基图，若图 G 的基图是连通的，则称图 G 是「弱连通图」。</li><li>$ Stack_a $ 表示标号为 $ a $ 的栈。</li><li>用 $ Stack_x = a]b]c] $ 表示 $ Stack_x $ 的层级结构，其中 $ a $ 为栈顶， $ c $ 为栈底。</li><li>$ \text{Foo} \rightarrow \text{Bar} $ 表示 $ \text{Foo} $ 里的元素 $ \text{Bar} $ （表特指）</li></ol><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>如果图G中的一个路径包括每个边恰好一次，则该路径称为欧拉路径(Euler path)。<br>如果一个回路是欧拉路径，则称为欧拉回路(Euler circuit)。<br>具有欧拉回路的图称为欧拉图（简称E图）。具有欧拉路径但不具有欧拉回路的图称为半欧拉图。</p><p style="text-align: right">——百度百科</p><hr><p>通俗地说，</p><p>对于一个图的某条路径，如果能从一个点出发将这个图的所有边都不重复地走一遍，那么这条路径就被称为欧拉路；对于一个图的某条路径，如果能从一个点出发将这个图的所有边都不重复地走一遍并回到起点，那么这条路径就被称为欧拉回路。</p><p>比如下图中的<br>$$ (A,B) \rightarrow (B,C) \rightarrow (C,D) \rightarrow (D,B) $$<br>就是一条欧拉路。<br><img src="/images/EulerPath-EulerCircuit/0.png" alt="0"></p><p>比如下图中的<br>$$ (A,B) \rightarrow (B,C) \rightarrow (D,C) \rightarrow (C,A) $$<br>就是一条欧拉回路。<br><img src="/images/EulerPath-EulerCircuit/1.png" alt="1"></p><h1 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h1><h2 id="无向图判定"><a href="#无向图判定" class="headerlink" title="无向图判定"></a>无向图判定</h2><ol><li><p>无孤立点的无向图 G 为欧拉图，当且仅当图 G 连通且所有顶点的度都是偶数。</p></li><li><p>如果无向连通图有 2k 个奇顶点，则图 G 可以用 k 条路径将图 G 的每一条边经过 一次，且至少要使用 k 条路径。</p></li><li><p>无孤立点的无向图 G 为半欧拉图，当且仅当图 G 连通且 G 的奇顶点个数为 2 。 此时两个奇顶点分别为欧拉路径的起点和终点。 </p></li></ol><h2 id="有向图判定"><a href="#有向图判定" class="headerlink" title="有向图判定"></a>有向图判定</h2><ol><li><p>无孤立点的有向图 G 为欧拉图，当且仅当图 G 弱连通且所有顶点的入度等于出度。</p></li><li><p>对于连通有向图，所有顶点入度与出度差的绝对值之和为 2k ，则图 G 可以用 k 条路径将图 G 的每一条边经过一次，且至少要使用 k 条路径。</p></li><li><p>无孤立点的有向图 G 为半欧拉图，当且仅当图 G 弱连通，且恰有一个顶点 u 入度比出度小 1 ，一个顶点 v 入度比出度大 1 ，其余顶点入度等于出度。此时存在 u 作为起点， v 作为终点的欧拉路径。</p></li></ol><h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><h2 id="Hierholzier-算法"><a href="#Hierholzier-算法" class="headerlink" title="Hierholzier 算法"></a>Hierholzier 算法</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>任选一起点，沿任意未访问的边走到相邻节点，直至无路可走。此时必然回到起点形成了一个回路，此时图中仍有部分边未被访问。在退栈的时候找到仍有未访问边的点，从该点为起点求出另一个回路，将该回路与之前求出的回路拼接。如此反复，直至所有的边都被访问。</p><hr><p>比如说我们有这样一张图：</p><p><img src="/images/EulerPath-EulerCircuit/2.png" alt="2"></p><p>我们随便取一个点，比如说 $ 1 $，把它加入一个<strong>栈</strong>。</p><p>$$ Stack_1 = 1] $$</p><p>$$ Path_1 = [\ ] $$</p><p>我们用 $ u $ 表示 $ Stack_1 \rightarrow Top $<br>如果当前的 $ u $ 点已没有未访问的出边，就将 $ u $ 从 $ Stack_1 $ 里弹出来，加入到 $ Path_1 $ 的<strong>前端</strong></p><p>重复上面的过程，直到 $ Stack_1 $ 为空。</p><p><img src="/images/EulerPath-EulerCircuit/3.png" alt="3"><br>在这个过程中，<br>$$ Stack_1 = 2]1],\ Path_1 = [\ ] $$</p><p>$$ Stack_1 = 4]2]1],\ Path_1 = [\ ] $$</p><p>$$ Stack_1 = 1]4]2]1],\ Path_1 = [\ ] $$</p><p>$$ Stack_1 = 5]4]2]1],\ Path_1 = [1] $$</p><p>$$ Stack_1 = 6]5]4]2]1],\ Path_1 = [1] $$</p><p>$$ Stack_1 = 4]6]5]4]2]1],\ Path_1 = [1] $$</p><p>$$ Stack_1 = 2]5]4]2]1],\ Path_1 = [6,4,1] $$</p><p>$$ Stack_1 = 3]2]5]4]2]1],\ Path_1 = [6,4,1] $$</p><p>$$ Stack_1 = 5]3]2]5]4]2]1],\ Path_1 = [6,4,1] $$</p><hr><p>所有的边都访问了，开始回溯存路径</p><p>$$ Stack_1 = \ ],\ Path_1 = [1,2,4,5,2,3,6,4,1] $$</p><p>最终答案即为 $ Path_1 $</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>假装自己写的是真正的 $ \LaTeX $</p><hr><p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p><p>$ \text{Algorithm 1: Hierholzer(s)} $<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ 1: \text{while s} $ 存在未被删除的无向边 $ (s,t)\  \text{do} $<br>$ 2: $ &nbsp;&nbsp;&nbsp;&nbsp;删除无向边 $ (s,t) $<br>$ 3: $ &nbsp;&nbsp;&nbsp;&nbsp;$ \text{Hierholzer(t)} $<br>$ 4: \text{End while} $<br>$ 5: cnt \leftarrow cnt + 1$<br>$ 6: Path[cnt] \leftarrow s$<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>真正的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN_M = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[MAXN_M][MAXN_M], ans[MAXN_M], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hierholzer</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = __MIN_NODE; t &lt;= __MAX_NODE; ++t) &#123;</span><br><span class="line">        <span class="comment">// 预防数据中不出现标号为 1 的节点的情况</span></span><br><span class="line">        <span class="comment">// __MIN_NODE 指数据中标号最小的节点的标号</span></span><br><span class="line">        <span class="comment">// __MAX_NODE 同上</span></span><br><span class="line">        <span class="keyword">if</span> (G[s][t]) &#123;</span><br><span class="line">            <span class="comment">// 使用邻接矩阵存图，更加易懂</span></span><br><span class="line">            --G[s][t];</span><br><span class="line">            --G[t][s];</span><br><span class="line">            Hierholzer(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[++cnt] = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fluery-算法"><a href="#Fluery-算法" class="headerlink" title="Fluery 算法"></a>Fluery 算法</h2><p><del>挖坑待填</del></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problemnew/show/P2731" target="_blank" rel="noopener">洛谷 P2731</a> 模板题</p><p>题解将会在不久后上传</p><h1 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>IOI2018 中国国家候选队论文集</li><li>洛谷 P2731 题解</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;从一个点出发走一走&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="图论算法" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="欧拉图" scheme="https://blog.handwer-std.top/tags/%E6%AC%A7%E6%8B%89%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1601《[Usaco2008 Oct]灌水》</title>
    <link href="https://blog.handwer-std.top/2019-01-12/BZOJ1601/"/>
    <id>https://blog.handwer-std.top/2019-01-12/BZOJ1601/</id>
    <published>2019-01-12T03:08:33.000Z</published>
    <updated>2019-01-12T03:32:50.899Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最小生成树板子</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Farmer John已经决定把水灌到他的n(1&lt;=n&lt;=300)块农田，农田被数字1到n标记。把一块土地进行灌水有两种方法，从其他农田饮水，或者这块土地建造水库。 建造一个水库需要花费wi(1&lt;=wi&lt;=100000),连接两块土地需要花费Pij(1&lt;=pij&lt;=100000,pij=pji,pii=0). 计算Farmer John所需的最少代价。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>*第一行：一个数n</p><p>*第二行到第n+1行：第i+1行含有一个数wi</p><p>*第n+2行到第2n+1行：第n+1+i行有n个被空格分开的数，第j个数代表pij。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>*第一行：一个单独的数代表最小代价.</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">4</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>输出详解：</p><p>Farmer John在第四块土地上建立水库，然后把其他的都连向那一个，这样就要花费3+2+2+2=9</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>很显然这道题需要最小生成树</p><p>那么是不是我们生成树之后加上根节点的$w$值就可以了？</p><big><big>显然不！</big></big><p>很容易就能举出反例：<br>最小生成树的根节点$w_1=99999$，次小生成树的根节点$w_2=1$，两个生成树答案之差$ans_1 - ans_2 = 1$</p><p>那么我们就可以考虑建一个虚拟的编号为$n + 1$的点，对于所有的点$i$以$w_i$为边权进行连接<br>最后直接跑最小生成树即可。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZ = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> U[MAX_SIZ];</span><br><span class="line">        </span><br><span class="line">        UnionFind() &#123;</span><br><span class="line">            For (i, <span class="number">1</span>, MAX_SIZ) U[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> U[x];</span><br><span class="line">            <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> xx = Find(x);</span><br><span class="line">            <span class="keyword">int</span> yy =  Find(y);</span><br><span class="line">            <span class="keyword">if</span> (xx == yy) <span class="keyword">return</span>;</span><br><span class="line">            U[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> nweight, now;</span><br><span class="line">            </span><br><span class="line">            Node() &#123; nweight = now = <span class="number">0</span>; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nweight &gt; that.nweight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> now, weight, next;</span><br><span class="line">            <span class="keyword">int</span> raw_now, raw_next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> weight &lt; that.weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head[MAXN], dis[MAXN], cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight, <span class="keyword">bool</span> isR = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isR) &#123; addEdge(next, prev, weight, <span class="literal">false</span>); &#125;</span><br><span class="line">            edge[++cnt].now = next;</span><br><span class="line">            edge[cnt].weight = weight;</span><br><span class="line">            edge[cnt].next = head[prev];</span><br><span class="line">            head[prev] = cnt;</span><br><span class="line">            </span><br><span class="line">            edge[cnt].raw_next = next;</span><br><span class="line">            edge[cnt].raw_now = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> Node <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> nowWeight, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">            Node tmp;</span><br><span class="line">            tmp.nweight = nowWeight;</span><br><span class="line">            tmp.now = now;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">            <span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line">            q.push(NewNode(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                Node NowNode = q.top();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> now = NowNode.now;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">                    <span class="keyword">if</span> (dis[to] &gt; dis[now] + edge[e].weight) &#123;</span><br><span class="line">                        dis[to] = dis[now] + edge[e].weight;</span><br><span class="line">                        q.push(NewNode(dis[to], to));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">            UnionFind u;</span><br><span class="line">            <span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + cnt);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> eu = u.Find(edge[i].raw_now);</span><br><span class="line">                <span class="keyword">int</span> ev = u.Find(edge[i].raw_next);</span><br><span class="line">                <span class="keyword">if</span> (eu == ev) <span class="keyword">continue</span>;</span><br><span class="line">                u.Union(eu, ev);</span><br><span class="line">                ans += edge[i].weight;</span><br><span class="line">                </span><br><span class="line">                ++tot;</span><br><span class="line">                <span class="keyword">if</span> (tot == cnt - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, n) g1.addEdge(i, n + <span class="number">1</span>, getint());</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        For (j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = getint();</span><br><span class="line">            g1.addEdge(i, j, p, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO::putint(g1.Kruskal(), <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最小生成树板子&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://blog.handwer-std.top/tags/BZOJ/"/>
    
      <category term="USACO" scheme="https://blog.handwer-std.top/tags/USACO/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最小生成树" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1144《最短路计数》</title>
    <link href="https://blog.handwer-std.top/2019-01-12/Luogu-P1144/"/>
    <id>https://blog.handwer-std.top/2019-01-12/Luogu-P1144/</id>
    <published>2019-01-12T01:57:14.000Z</published>
    <updated>2019-01-12T02:57:25.997Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最短路“板子”</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个$N$个顶点$M$条边的无向无权图，顶点编号为$1-N$。问从顶点$1$开始，到其他每个点的最短路有几条。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含$2$个正整数$N,M$，为图的顶点数与边数。</p><p>接下来$M$行，每行$2$个正整数$x,y$，表示有一条顶点$x$连向顶点$y$的边，请注意可能有自环与重边。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共$N$行，每行一个非负整数，第$i$行输出从顶点$1$到顶点$i$有多少条不同的最短路，由于答案有可能会很大，你只需要输出 $ans \bmod 100003$后的结果即可。如果无法到达顶点$i$则输出$0$。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">7</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>$1$到$5$的最短路有$4$条，分别为$2$条$1-2-4-5$和$2$条$1-3-4-5$（由于$4−5$的边有$2$条）。</p><p>对于$20\%$的数据，$N ≤ 100$；</p><p>对于$60\%$的数据，$N ≤ 1000$；</p><p>对于$100\%$的数据，$N&lt;=1000000,M&lt;=2000000$。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>稍微改一下最短路板子即可</p><p>具体就是用 <code>ans[i]</code> 数组记录一下到<code>i</code>点的最短路个数，在更新路径长度的时候判一下两条路径长度的关系即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">100006</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">    <span class="keyword">if</span> (dis[to] &gt; dis[now] + edge[e].weight) &#123;</span><br><span class="line">    <span class="comment">// 两条路径长度不等，更新答案</span></span><br><span class="line">        dis[to] = dis[now] + edge[e].weight;</span><br><span class="line">        ans[to] = ans[now];</span><br><span class="line">        q.push(NewNode(dis[to], to));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis[to] == dis[now] + edge[e].weight) &#123;</span><br><span class="line">    <span class="comment">// 两条路径长度相等，将答案相加</span></span><br><span class="line">        ans[to] += ans[now];</span><br><span class="line">        ans[to] %= HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">100003</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2000000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> nweight, now;</span><br><span class="line">            </span><br><span class="line">            Node() &#123; nweight = now = <span class="number">0</span>; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nweight &gt; that.nweight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> now, weight, next;</span><br><span class="line">        &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head[MAXN], dis[MAXN], ans[MAXN], cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight, <span class="keyword">bool</span> isR = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isR) &#123; addEdge(next, prev, weight, <span class="literal">false</span>); &#125;</span><br><span class="line">            edge[++cnt].now = next;</span><br><span class="line">            edge[cnt].weight = weight;</span><br><span class="line">            edge[cnt].next = head[prev];</span><br><span class="line">            head[prev] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> Node <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> nowWeight, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">            Node tmp;</span><br><span class="line">            tmp.nweight = nowWeight;</span><br><span class="line">            tmp.now = now;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">            <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">            <span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line">            q.push(NewNode(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                Node NowNode = q.top();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> now = NowNode.now;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">                    <span class="keyword">if</span> (dis[to] &gt; dis[now] + edge[e].weight) &#123;</span><br><span class="line">                        dis[to] = dis[now] + edge[e].weight;</span><br><span class="line">                        ans[to] = ans[now];</span><br><span class="line">                        q.push(NewNode(dis[to], to));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis[to] == dis[now] + edge[e].weight) &#123;</span><br><span class="line">                        ans[to] += ans[now];</span><br><span class="line">                        ans[to] %= HA;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        g1.addEdge(prev, next, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g1.SPFA();</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        FastIO::putint(g1.ans[i], <span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最短路“板子”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="BFS" scheme="https://blog.handwer-std.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1126《机器人搬重物》</title>
    <link href="https://blog.handwer-std.top/2019-01-10/Luogu-P1126/"/>
    <id>https://blog.handwer-std.top/2019-01-10/Luogu-P1126/</id>
    <published>2019-01-10T14:06:16.000Z</published>
    <updated>2019-01-12T00:40:14.413Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>有直径</strong>还写个锤</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径$1.6$米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个$N \times M$的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：向前移动$1$步（Creep）；向前移动$2$步（Walk）；向前移动$3$步（Run）；向左转（Left）；向右转（Right）。每个指令所需要的时间为$1$秒。请你计算一下机器人完成任务所需的最少时间。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为两个正整数$N,M(N,M \le 50)$，下面$N$行是储藏室的构造，$0$表示无障碍，$1$表示有障碍，数字之间用一个空格隔开。接着一行有$4$个整数和$1$个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东$E$，南$S$，西$W$，北$N$），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。</p><p>输出格式：<br>一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出$−1$。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">9 </span><span class="number">10</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">2</span> <span class="number">2</span> <span class="number">7</span> S</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>1.&nbsp;将格子图转为点图 &amp; 障碍物判断<br><br>要注意这个机器人是<strong>有直径</strong>的，所以边界和障碍物的四周都不能走</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> ttt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ttt);</span><br><span class="line">        <span class="keyword">if</span> (ttt) &#123;</span><br><span class="line">            <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][j - <span class="number">1</span>] = <span class="built_in">map</span>[i - <span class="number">1</span>][j] = <span class="built_in">map</span>[i - <span class="number">1</span>][j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.单向 BFS<br>枚举所有的步数和方向</p><p>3.三维数组判重<br>要注意本题是<strong>有方向</strong>的，所以vis数组需要开三维（<code>vis[N][M][方向]</code>）</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN_M = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Robot</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">int</span> dir;</span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Robot&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN_M][MAXN_M][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">map</span>[MAXN_M][MAXN_M];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> startx, starty, endx, endy, sd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> startdir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> ttt;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ttt);</span><br><span class="line">            <span class="keyword">if</span> (ttt) &#123;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][j - <span class="number">1</span>] = <span class="built_in">map</span>[i - <span class="number">1</span>][j] = <span class="built_in">map</span>[i - <span class="number">1</span>][j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %c"</span>, &amp;startx, &amp;starty, &amp;endx, &amp;endy, &amp;startdir);</span><br><span class="line">    <span class="keyword">switch</span>(startdir) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'E'</span>: &#123;</span><br><span class="line">            sd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'S'</span>: &#123;</span><br><span class="line">            sd = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'W'</span>: &#123;</span><br><span class="line">            sd = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            sd = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 对方向进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (startx &gt;= n || startx &lt; <span class="number">1</span> || starty &gt;= m || starty &lt; <span class="number">1</span> || <span class="built_in">map</span>[startx][starty]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Robot rb;</span><br><span class="line">    rb.x = startx;</span><br><span class="line">    rb.y = starty;</span><br><span class="line">    rb.dir = sd;</span><br><span class="line">    rb.step = <span class="number">0</span>;</span><br><span class="line">    vis[startx][starty][sd] = <span class="literal">true</span>;</span><br><span class="line">    q.push(rb);</span><br><span class="line">    <span class="comment">// 开始 BFS</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        rb = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> newx = rb.x;</span><br><span class="line">        <span class="keyword">int</span> newy = rb.y;</span><br><span class="line">        <span class="keyword">if</span> (newx == endx &amp;&amp; newy == endy) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rb.step);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举步数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> steps = <span class="number">1</span>; steps &lt;= <span class="number">3</span>; ++steps) &#123;</span><br><span class="line">            newx += dx[rb.dir];</span><br><span class="line">            newy += dy[rb.dir];</span><br><span class="line">            <span class="keyword">if</span> (newx &lt; <span class="number">1</span> || newx &gt;= n || newy &lt; <span class="number">1</span> || newy &gt;= m || <span class="built_in">map</span>[newx][newy]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!vis[newx][newy][rb.dir]) &#123;</span><br><span class="line">                vis[newx][newy][rb.dir] = <span class="literal">true</span>;</span><br><span class="line">                Robot nown;</span><br><span class="line">                nown.x = newx;</span><br><span class="line">                nown.y = newy;</span><br><span class="line">                nown.dir = rb.dir;</span><br><span class="line">                nown.step = rb.step + <span class="number">1</span>;</span><br><span class="line">                q.push(nown);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新步数</span></span><br><span class="line">        Robot nown = rb;</span><br><span class="line">        ++nown.step;</span><br><span class="line">        --nown.dir;</span><br><span class="line">        <span class="keyword">if</span> (nown.dir == <span class="number">-1</span>) nown.dir = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nown.x][nown.y][nown.dir]) &#123;</span><br><span class="line">            vis[nown.x][nown.y][nown.dir] = <span class="literal">true</span>;</span><br><span class="line">            q.push(nown);</span><br><span class="line">        &#125;</span><br><span class="line">        nown.dir = rb.dir + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nown.dir == <span class="number">4</span>) nown.dir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nown.x][nown.y][nown.dir]) &#123;</span><br><span class="line">            vis[nown.x][nown.y][nown.dir] = <span class="literal">true</span>;</span><br><span class="line">            q.push(nown);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;有直径&lt;/strong&gt;还写个锤&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="搜索" scheme="https://blog.handwer-std.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="BFS" scheme="https://blog.handwer-std.top/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1141《01迷宫》</title>
    <link href="https://blog.handwer-std.top/2019-01-10/Luogu-P1141/"/>
    <id>https://blog.handwer-std.top/2019-01-10/Luogu-P1141/</id>
    <published>2019-01-10T14:06:15.000Z</published>
    <updated>2019-01-11T15:50:40.952Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DFS 联通块</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有一个仅由数字$0$与$1$组成的$n \times n$格迷宫。若你位于一格$0$上，那么你可以移动到相邻$4$格中的某一格$1$上，同样若你位于一格$1$上，那么你可以移动到相邻$4$格中的某一格$0$上。</p><p>你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第11行为两个正整数$n,m$。</p><p>下面$n$行，每行$n$个字符，字符只可能是$0$或者$1$，字符之间没有空格。</p><p>接下来$m$行，每行$2$个用空格分隔的正整数$i,j$，对应了迷宫中第$i$行第$j$列的一个格子，询问从这一格开始能移动到多少格。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>$m$行，对于每个询问输出相应答案。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="number">01</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>所有格子互相可达。</p><p>对于$20\%20$的数据，$n≤10$；</p><p>对于$40\%$的数据，$n≤50$；</p><p>对于$50\%$的数据，$m≤5$；</p><p>对于$60\%$的数据，$n≤100,m≤100$；</p><p>对于$100\%$的数据，$n≤1000,m≤100000$。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先我们可以知道一个联通块内的所有格子的答案相同</p><p>那么我们就直接找联通块，这个联通块内的所有格子的答案都是这个联通块的格子个数</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> mp[MAXN][MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN][MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m, nowans;</span><br><span class="line">    <span class="keyword">int</span> xans[MAXN * MAXN], yans[MAXN * MAXN];</span><br><span class="line">    <span class="keyword">int</span> ans[MAXN][MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        ++nowans;</span><br><span class="line">        xans[nowans] = x;</span><br><span class="line">        yans[nowans] = y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (!(nx &lt;= <span class="number">0</span> || nx &gt; n || ny &lt;= <span class="number">0</span> || ny &gt; n) &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] != mp[x][y]) &#123;</span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                Search(nx, ny);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        For (j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i][j]) &#123;</span><br><span class="line">                vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">                nowans = <span class="number">0</span>;</span><br><span class="line">                Search(i, j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> no = <span class="number">1</span>; no &lt;= nowans; ++no) &#123;</span><br><span class="line">                    ans[xans[no]][yans[no]] = nowans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;DFS 联通块&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="搜索" scheme="https://blog.handwer-std.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1629《邮递员送信》</title>
    <link href="https://blog.handwer-std.top/2019-01-10/Luogu-P1629/"/>
    <id>https://blog.handwer-std.top/2019-01-10/Luogu-P1629/</id>
    <published>2019-01-10T14:06:14.000Z</published>
    <updated>2019-01-11T14:39:19.922Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个正向图，一个反向图</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有一个邮递员要送东西，邮局在节点1.他总共要送N-1样东西，其目的地分别是2~N。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有M条道路，通过每条道路需要一定的时间。这个邮递员每次只能带一样东西。求送完这N-1样东西并且最终回到邮局最少需要多少时间。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包括两个整数N和M。</p><p>第2到第M+1行，每行三个数字U、V、W，表示从A到B有一条需要W时间的道路。 满足1&lt;=U,V&lt;=N,1&lt;=W&lt;=10000,输入保证任意两点都能互相到达。</p><p>【数据规模】</p><p>对于30%的数据，有1≤N≤200;</p><p>对于100%的数据，有1≤N≤1000,1≤M≤100000。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅一行，包含一个整数，为最少需要的时间。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">10</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">1</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">83</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>类似题目：<a href="https://www.luogu.org/problemnew/show/P1821" target="_blank" rel="noopener">洛谷P1821《[USACO07FEB]银牛派对Sliver Cow Party》</a><br>题解：<a href="https://blog.handwer-std.top/2018-07-20/Luogu-P1821/">洛谷P1821 《[USACO07FEB]银牛派对Silver Cow Party》</a></p><p>对于这类题目，我们考虑建一个反向（所有边的方向都相反）的图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> nweight, now;</span><br><span class="line">            </span><br><span class="line">            Node() &#123; nweight = now = <span class="number">0</span>; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nweight &gt; that.nweight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> now, weight, next;</span><br><span class="line">        &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head[MAXN], dis[MAXN], cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            edge[++cnt].now = next;</span><br><span class="line">            edge[cnt].weight = weight;</span><br><span class="line">            edge[cnt].next = head[prev];</span><br><span class="line">            head[prev] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> Node <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> nowWeight, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">            Node tmp;</span><br><span class="line">            tmp.nweight = nowWeight;</span><br><span class="line">            tmp.now = now;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最短路</span></span><br><span class="line">        <span class="comment">// 一块写进去更方便</span></span><br><span class="line">            <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">            <span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line">            q.push(NewNode(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                Node NowNode = q.top();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> now = NowNode.now;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">                    <span class="keyword">if</span> (dis[to] &gt; dis[now] + edge[e].weight) &#123;</span><br><span class="line">                        dis[to] = dis[now] + edge[e].weight;</span><br><span class="line">                        q.push(NewNode(dis[to], to));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>这里我选择一个稍微懒一点的方法，将图存到一个结构体里面，创建的时候只要 <code>Graph g1, g2;</code> 即可。</p><p>最后答案即为</p><p>$$ \sum_{i = 1}^{n} \text{g1.dis}[i] + \text{g2.dis}[i] $$</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> nweight, now;</span><br><span class="line">            </span><br><span class="line">            Node() &#123; nweight = now = <span class="number">0</span>; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nweight &gt; that.nweight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> now, weight, next;</span><br><span class="line">        &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head[MAXN], dis[MAXN], cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            edge[++cnt].now = next;</span><br><span class="line">            edge[cnt].weight = weight;</span><br><span class="line">            edge[cnt].next = head[prev];</span><br><span class="line">            head[prev] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> Node <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> nowWeight, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">            Node tmp;</span><br><span class="line">            tmp.nweight = nowWeight;</span><br><span class="line">            tmp.now = now;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">            <span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line">            q.push(NewNode(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                Node NowNode = q.top();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> now = NowNode.now;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">                    <span class="keyword">if</span> (dis[to] &gt; dis[now] + edge[e].weight) &#123;</span><br><span class="line">                        dis[to] = dis[now] + edge[e].weight;</span><br><span class="line">                        q.push(NewNode(dis[to], to));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1, g2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        <span class="keyword">int</span> weight = getint();</span><br><span class="line">        g1.addEdge(prev, next, weight);</span><br><span class="line">        g2.addEdge(next, prev, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    g1.SPFA();</span><br><span class="line">    g2.SPFA();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ans += g1.dis[i] + g2.dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO::putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个正向图，一个反向图&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
</feed>
