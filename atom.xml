<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Handwer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.handwer-std.top/"/>
  <updated>2020-01-19T12:17:10.188Z</updated>
  <id>https://blog.handwer-std.top/</id>
  
  <author>
    <name>Handwer STD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>POJ2001《Shortest Prefixes》</title>
    <link href="https://blog.handwer-std.top/2020-01-18/POJ2001/"/>
    <id>https://blog.handwer-std.top/2020-01-18/POJ2001/</id>
    <published>2020-01-18T10:00:26.000Z</published>
    <updated>2020-01-19T12:17:10.188Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这题在纸上手玩一遍找找规律就出来了</p></blockquote><a id="more"></a><p>传送门：<a href="http://poj.org/problem?id=2001" target="_blank" rel="noopener">http://poj.org/problem…</a></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先看到这是个字符串题</p><p>再然后一想，这个要处理前缀相等问题</p><p>好，就是你了，Trie</p><hr><p>先把给定的字符串插进 Trie 里</p><p>在纸上画出样例的 Trie 树，手玩一下，找找规律</p><p>应该可以发现这样一句废话：<br>一个字符串的「最短无歧义缩写」是该字符串到「它的『最长有歧义缩写』的最后一位」的下一位所构成的前缀</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">字符串“wyhaksx”和“wyhaknoi”</span><br><span class="line">w y h a k s x</span><br><span class="line">w y h a k n o i</span><br><span class="line">此时 wyhak 这个缩写是有歧义的，因为它两句话都能表示，而且它还是最长有歧义缩写；</span><br><span class="line">但是再加一个字母，wyhaks 就没有歧义了，是最短无歧义缩写，</span><br><span class="line">因为它只能表示 wyhaksx 不能表示 wyhaknoi，而你找不到比它更短的了</span><br></pre></td></tr></table></figure><p>同时对照着 Trie 树看看（再添加一个“wyhac”加强例子的一般性）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">w → y → h↘</span><br><span class="line">         a → c</span><br><span class="line">         ↓</span><br><span class="line">         k</span><br><span class="line">        ↙ ↘</span><br><span class="line">      s     n</span><br><span class="line">      ↓     ↓</span><br><span class="line">      x     o</span><br><span class="line">            ↓</span><br><span class="line">            i</span><br></pre></td></tr></table></figure><p>你发现了什么？<br>最长有歧义缩写的结尾正好在深度最大的分支处！<br>最短无歧义缩写的结尾正好是深度最大的分支的子节点！</p><blockquote><p>两个字符串，一个字符串是另一个字符串的子串（“wyh”和“wyhak”）这种情况先不考虑。</p></blockquote><hr><p>那么现在问题转化成了如何找深度最高的分支的位置。</p><p>这个比较简单，在插入字符串的时候，对于每一个节点，记一下这个点有几条向下连的边，连边数超过 2 的话就是分支；再记一下这个节点的父亲是谁；插完之后记一下这个字符串对应结尾在 Trie 中的位置（也就是动态开点后的节点编号）。</p><p>查找的时候，从刚刚记的结尾位置开始向上查找，直到找到第一个分支，返回它的子节点编号即可</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNode</span><span class="params">(<span class="keyword">int</span> down)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 沿着叶子节点往上走，找到第一个分叉节点，返回它的儿子</span></span><br><span class="line"><span class="comment">// 分叉节点即为向下连的边超过两条的点</span></span><br><span class="line"><span class="keyword">int</span> now = location[down]; <span class="comment">// 获取这个字符串对应的结尾节点</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (now == <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// 居然滚回根节点了</span></span><br><span class="line"><span class="keyword">int</span> father = node[now].from; <span class="comment">// 父亲节点</span></span><br><span class="line"><span class="keyword">if</span> (node[father].edges &gt;= <span class="number">2</span>) <span class="keyword">break</span>; <span class="comment">// 找到了 orz</span></span><br><span class="line">now = father; <span class="comment">// 往上跳</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>接下来只需要顺着下去溜一遍，把字符串复制一下输出就好了，需要注意的是到了刚刚找到的节点要 <code>break</code> 掉</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> down)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> endNode = findNode(down); <span class="comment">// 调用上面的函数获取最终节点</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> res = <span class="string">""</span>; <span class="built_in">std</span>::<span class="built_in">string</span> &amp;ds = originalStrings[down];</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = (<span class="keyword">int</span>) ds.length(); i &lt; len; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> next = node[now].next[toNum(ds[i])]; <span class="comment">// 获取当前节点的子节点</span></span><br><span class="line">res += ds[i]; now = next; <span class="comment">// 复制字符串，更新位置</span></span><br><span class="line"><span class="keyword">if</span> (next == endNode) <span class="keyword">break</span>; <span class="comment">// 如果下一个节点是终点，那就停掉</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res; <span class="comment">// 返回这个输出的结果就好了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>One more thing.</p><p>「两个字符串，一个字符串是另一个字符串的子串的情况」？<br>答案：简单粗暴地在字符串尾加一个特殊字符，强行搞出一个分支来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如“wyh”和“wyhak”</span><br><span class="line">可以修改成“wyh#”和“wyhak#”</span><br><span class="line"></span><br><span class="line">w → y → h → #</span><br><span class="line">        ↘ a → k → #</span><br></pre></td></tr></table></figure><p>这样不就有分支了吗</p><p>那是不是还要修改一下 <code>std::string find(int)</code> 函数？<br>不用！</p><p>注意到这种情况下，调用 <code>findNode(int)</code> 函数获得的实际上是 <code>#</code> 所在的节点编号，而 <code>find(int)</code> 函数在找的时候，循环 <strong>至多</strong> 会循环到 <strong>原字符串的长度</strong>，复制字符串 <strong>至多</strong> 会复制 <strong>完整的原字符串</strong>，所以压根不需要特判。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSTRS = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> originalStrings[MAXSTRS];</span><br><span class="line"><span class="keyword">int</span> location[MAXSTRS];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXNODES = <span class="number">30000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">bool</span> str; <span class="keyword">int</span> from, siz, edges;</span><br><span class="line"><span class="keyword">int</span> next[<span class="number">30</span>];</span><br><span class="line">Node() &#123; </span><br><span class="line">str = <span class="number">0</span>; from = siz = edges = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span> next); </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node node[MAXNODES];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">toNum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;s)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (s == <span class="string">'#'</span>) <span class="keyword">return</span> <span class="number">27</span>;</span><br><span class="line"><span class="keyword">return</span> s - <span class="string">'a'</span> + <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Trie() &#123; cnt = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="keyword">int</span> down)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1</span>, strLen = (<span class="keyword">int</span>) s.length();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> &amp;next = node[now].next[toNum(s[i])];</span><br><span class="line"><span class="keyword">if</span> (next == <span class="number">0</span>) &#123; </span><br><span class="line">next = ++cnt; node[next].from = now; </span><br><span class="line">++node[now].edges;</span><br><span class="line">&#125;</span><br><span class="line">now = next;</span><br><span class="line">&#125;</span><br><span class="line">node[now].str = <span class="literal">true</span>;</span><br><span class="line">location[down] = now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNode</span><span class="params">(<span class="keyword">int</span> down)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 沿着叶子节点往上走，找到第一个分叉节点，返回它的儿子</span></span><br><span class="line"><span class="comment">// 分叉节点即为向下连的边超过两条的点</span></span><br><span class="line"><span class="keyword">int</span> now = location[down];</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (now == <span class="number">1</span>) <span class="keyword">break</span>; <span class="comment">// md 居然滚回根节点了</span></span><br><span class="line"><span class="keyword">int</span> father = node[now].from; <span class="comment">// 父亲节点</span></span><br><span class="line"><span class="comment">// printf("\tNow on node [%d], its father is [%d], \n\tits father's out-edges amount is %d;\n", now, father, node[father].edges);</span></span><br><span class="line"><span class="keyword">if</span> (node[father].edges &gt;= <span class="number">2</span>) <span class="keyword">break</span>; <span class="comment">// 找到了 orz</span></span><br><span class="line">now = father; <span class="comment">// 往上跳</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> down)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 获得答案</span></span><br><span class="line"><span class="comment">// printf("[DEBUG] Now processing [%d] -&gt; %s:\n", down, originalStrings[down].c_str());</span></span><br><span class="line"><span class="keyword">int</span> endNode = findNode(down);</span><br><span class="line"><span class="comment">// printf("\tendNode = %d\n", endNode);</span></span><br><span class="line"><span class="comment">// printf("\tCopying string...\n");</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> res = <span class="string">""</span>; <span class="built_in">std</span>::<span class="built_in">string</span> &amp;ds = originalStrings[down];</span><br><span class="line"><span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, len = (<span class="keyword">int</span>) ds.length(); i &lt; len; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> next = node[now].next[toNum(ds[i])];</span><br><span class="line"><span class="comment">// printf("\tnow = %d, next = %d, now char = %c\n", now, next, ds[i]);</span></span><br><span class="line">res += ds[i]; now = next;</span><br><span class="line"><span class="keyword">if</span> (next == endNode) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125; trie;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; originalStrings[++n]); </span><br><span class="line">--n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) </span><br><span class="line">trie.insert(originalStrings[i] + <span class="string">"#"</span>, i);</span><br><span class="line"><span class="comment">// trie.initSize();</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s %s\n"</span>, originalStrings[i].c_str(), trie.find(i).c_str());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这题在纸上手玩一遍找找规律就出来了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="字符串" scheme="https://blog.handwer-std.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Trie" scheme="https://blog.handwer-std.top/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2761《软件补丁问题》</title>
    <link href="https://blog.handwer-std.top/2020-01-17/Luogu-P2761/"/>
    <id>https://blog.handwer-std.top/2020-01-17/Luogu-P2761/</id>
    <published>2020-01-17T07:47:46.000Z</published>
    <updated>2020-01-19T10:57:29.732Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>或 CTSC99《补丁 VS 错误》</p><p>说的那么麻烦，其实就一最短路。。</p></blockquote><a id="more"></a><p>题目传送门：<a href="https://www.luogu.com.cn/problem/P2761" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P2761</a></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一个，这题是状压，反正错误不超过 20 个；</p><p>第二个，这题要在一个一个状态之间转移，因为补丁包修复错误的同时还带来了错误；</p><p>第三个，这题有起始状态（全是错误）和最终状态（没有错误），状态转移还有额外代价。</p><p>所以！这题用<del>动态规划</del>最短路肯定没错！</p><hr><p>把 20 个错误的拥有情况压成 20 位的 int，0 表示无此错误，1 表示有此错误</p><p>把这些状态抽象成点，在一个一个状态之间转移的补丁包抽象成有向边，补丁包的安装时间抽象成边权，跑最短路就完了</p><hr><p>问题是，边的数量未免有点太多了吧，可以构造出一个全 0 的补丁包，这样所有的点都要连边啊 qaq</p><p>那就索性不连边了……反正就 100 个补丁包，每次 <code>for</code> 一遍检查哪些补丁包能用的也没大问题</p><hr><p>检查补丁包能不能用这个我不用再讲了吧……基本二进制操作</p><p>有一个小 trick：在修复软件包的时候不能直接把错误状态和修复状态异或（因为有些错误可能并不存在，这时候异或就不对了），例子是 <code>1011 ^ 0111 = 1100 != 1000</code>。这时候可以先让它强制获得这个错误，然后再修复掉这些错误，也就是先 <code>1011 | 0111</code> 再 <code>1111 ^ 0111</code></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_NODE = (<span class="number">1</span> &lt;&lt; <span class="number">22</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Patch</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> usage;</span><br><span class="line"><span class="keyword">int</span> required, requiredNot;</span><br><span class="line"><span class="keyword">int</span> fixedBugs, newBugs;</span><br><span class="line"></span><br><span class="line">Patch(<span class="keyword">int</span> _us = <span class="number">0</span>, <span class="keyword">int</span> _r = <span class="number">0</span>, <span class="keyword">int</span> _rn = <span class="number">0</span>, <span class="keyword">int</span> _f = <span class="number">0</span>, <span class="keyword">int</span> _n = <span class="number">0</span>) : usage(_us), required(_r), requiredNot(_rn), fixedBugs(_f), newBugs(_n) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> requireStr, effectStr;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; usage &gt;&gt; requireStr &gt;&gt; effectStr;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (requireStr[i] == <span class="string">'+'</span>) required += (<span class="number">1</span> &lt;&lt; (i));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (requireStr[i] == <span class="string">'-'</span>) requiredNot += (<span class="number">1</span> &lt;&lt; (i));</span><br><span class="line"><span class="keyword">if</span> (effectStr[i] == <span class="string">'-'</span>) fixedBugs += (<span class="number">1</span> &lt;&lt; (i));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (effectStr[i] == <span class="string">'+'</span>) newBugs += (<span class="number">1</span> &lt;&lt; (i)); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; patches[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> id, wt;</span><br><span class="line">Node(<span class="keyword">int</span> _i = <span class="number">0</span>, <span class="keyword">int</span> _w = <span class="number">0</span>) : id(_i), wt(_w) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> wt &gt; that.wt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dist[MAX_NODE];</span><br><span class="line"><span class="keyword">bool</span> vis[MAX_NODE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInstallResult</span><span class="params">(<span class="keyword">int</span> id, Patch p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((id | p.required) != id) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ((id &amp; p.requiredNot) != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> res = (((id | p.fixedBugs) ^ p.fixedBugs) | p.newBugs);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shortestPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">int</span> init = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) q.pop();</span><br><span class="line">q.push(Node(init, <span class="number">0</span>));</span><br><span class="line"><span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">dist[init] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">Node nownode = q.top(); q.pop();</span><br><span class="line"><span class="keyword">int</span> u = nownode.id;</span><br><span class="line"><span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> res = getInstallResult(u, patches[i]);</span><br><span class="line"><span class="keyword">if</span> (res == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (dist[res] &gt; dist[u] + patches[i].usage) &#123;</span><br><span class="line">dist[res] = dist[u] + patches[i].usage;</span><br><span class="line">q.push(Node(res, dist[res]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">patches[i].read();</span><br><span class="line">&#125;</span><br><span class="line">shortestPath();</span><br><span class="line"><span class="keyword">if</span> (dist[<span class="number">0</span>] != <span class="number">0x3f3f3f3f</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dist[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;或 CTSC99《补丁 VS 错误》&lt;/p&gt;
&lt;p&gt;说的那么麻烦，其实就一最短路。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>对「共青团中央」微信公众号转发关于“华为 251 事件”文章的一些看法</title>
    <link href="https://blog.handwer-std.top/2019-12-07/Some-Thinking-About-Article-of-Huawei-251/"/>
    <id>https://blog.handwer-std.top/2019-12-07/Some-Thinking-About-Article-of-Huawei-251/</id>
    <published>2019-12-07T14:58:20.000Z</published>
    <updated>2019-12-07T15:30:03.764Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我把 Wikipedia 上的“251 事件”经过看了一遍、整篇文章读了三遍，目的就是让自己的观点尽量的客观、准确。</p><p>原文链接：<a href="https://mp.weixin.qq.com/s/ulrfQFNFdVGepT7tHNWUuQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ulrfQFNFdVGepT7tHNWUuQ</a><br>Handwer 的 Evernote 备份：<a href="https://app.yinxiang.com/shard/s62/nl/21474206/ed6c5aa4-6ebd-49c3-a8ef-b19c5d49f1df" target="_blank" rel="noopener">https://app.yinxiang.com/shard/s62/nl/21474206/ed6c5aa4-6ebd-49c3-a8ef-b19c5d49f1df</a></p><p>本文记录的是一个<em>心智不成熟</em>的初中生的主观感受</p></blockquote><a id="more"></a><p>原来以为是洗地文章，看完发现不是。</p><p>首先，个人觉得，华为这家公司的风评、做事底线与它的最近国际上的处境是两码事。我认为这篇文章的观点没大问题，就算 251 事件出了更大的事也没有问题——因为它讲的根本就不是 251 事件本身及其影响，而是 251 事件之后外媒和网络上一些人的反应。这和其他大部分文章的角度是不同的。</p><p>也正因如此，没有谈及 251 事件性质的该文章被网络上的大部分人当做了“不该出现的洗地文”，再经过一些人的断章取义，加上这还是「共青团中央」转发的所谓“维护资产阶级企业家及其企业形象”的文章，就导致大量攻击官媒的高赞评论出现——而我觉得他们大部分可能都没有读完文章，也可能是只看了我所说的图片就直接去评论了，因为你只要完整地看完了这篇文章，就直接能明白：这篇文章是在借民众对“251 事件”及一些报道的反应谈这种愤怒情绪对整个社会的影响，而并非是为华为洗地。</p><p>文章中有一句话我很喜欢，就是含有讽刺意的这句：</p><blockquote><p>什么最重要？保持愤怒情绪最重要。</p></blockquote><p>被情绪冲昏了头脑的人没有办法理性思考，只会跟着舆论方向乱起哄，而一些不怀好意的人——包括国内的所谓“恨国党”、境外媒体、还有据传不是李洪元写的“李洪元写给任正非的公开信”的真正作者、和那些可能并无恶意的普通自媒体，他们提供的海量的信息就是头脑被冲昏的重要因素之一。包括现在正在写这篇文章的作者我，在多方了解事件进展时，脑袋也差点被搅糊涂了。文章论证了“251 事件”的炒作与“反送中”别无二致，都是通过煽动不明真相也没法独立思考的群众来做到混淆视听或者引起社会的波澜以放缓中国的发展，这很值得我们（包括作者我）来进行反思：我们思考的时候到底有没有被外界影响？此时还能否做到理性思考？这些没有一点理性的愤怒会给整个社会带来多少影响？而那整篇文章就是在说：「不要失去理性，失去理性的愤怒会“搞垮整个社会”！」这恰恰就是“境外势力”和“精神境外势力”（指恨国党）的目的：搞垮整个社会，阻碍中国发展。对于他们，让群众「保持愤怒」自然是最重要的了。还需要说明的一点是，达成目标所需要的一切力量并不来自境外，而是来自那些被煽动的境内群众。</p><p>「共青团中央」之所以会转发这篇文章，就是因为这篇文章并不是从微观角度谈“251 事件”，而是从宏观角度谈“Fake News”对整个社会的影响。假设「共青团中央」只是一个普通的自媒体的话，带来流量最多的华为新闻肯定早就被它转遍了，但是啊，它是一个官媒，它关心的是整个国家、整个社会，而不仅仅是一个比较大的企业或者一个行业中发生的事情。提到官媒转发华为事件，很多人应该都能想到人民网转发文章被删的事吧。文章被删可能确实是“黑恶势力”在作祟，也可能只是内部觉得不妥而删除而已。抛开这些不管，假如文章还活着的话，我依然会赞同这篇文章的观点，更有可能两篇都会支持——这个观点我已经明确表示过了，两篇文章谈的是同一件事的两个角度，说的也都是我认为正确的，我当然都会赞同，这其中没有任何自相矛盾，华为这个公司的品行是一回事，这件事引发的舆论影响又是一回事。我支持运用法律的武器打击流氓企业，抨击华为的这种钻法律空子的行为，同时痛恨肆意扩大这件事的影响来给自己赚流量而不顾当事人感受的部分自媒体，和那些见不得中国好的外媒及“中国人”。</p><p>另外，文章中提到的“公知大 V”我找不到相关信息，故不对此做出评论，还是建议原作者随便附几个例子，这样应该可以堵住一小部分人的嘴。</p><p>最后，以原作者的一句话结尾，祝华为早日挺过公关危机，也希望华为这个公司的品行能越来越好。</p><blockquote><p>我们不要被人利用了，不要被人当枪使，美国舆论轰炸机《纽约时报》，CNN都立刻带着”251炸弹“起飞了，还看不明白吗？</p></blockquote><hr><p>另附一份 PDF 版本，包含完整的脚注、格式，<a href="/files/对「共青团中央」微信公众号转发关于“华为 251 事件”文章的一些看法.pdf">链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我把 Wikipedia 上的“251 事件”经过看了一遍、整篇文章读了三遍，目的就是让自己的观点尽量的客观、准确。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://mp.weixin.qq.com/s/ulrfQFNFdVGepT7tHNWUuQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/s/ulrfQFNFdVGepT7tHNWUuQ&lt;/a&gt;&lt;br&gt;Handwer 的 Evernote 备份：&lt;a href=&quot;https://app.yinxiang.com/shard/s62/nl/21474206/ed6c5aa4-6ebd-49c3-a8ef-b19c5d49f1df&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://app.yinxiang.com/shard/s62/nl/21474206/ed6c5aa4-6ebd-49c3-a8ef-b19c5d49f1df&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文记录的是一个&lt;em&gt;心智不成熟&lt;/em&gt;的初中生的主观感受&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="记录" scheme="https://blog.handwer-std.top/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="文章" scheme="https://blog.handwer-std.top/tags/%E6%96%87%E7%AB%A0/"/>
    
      <category term="华为" scheme="https://blog.handwer-std.top/tags/%E5%8D%8E%E4%B8%BA/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2449《[SDOI2005]矩形》</title>
    <link href="https://blog.handwer-std.top/2019-11-05/Luogu-P2449/"/>
    <id>https://blog.handwer-std.top/2019-11-05/Luogu-P2449/</id>
    <published>2019-11-05T07:22:48.000Z</published>
    <updated>2019-11-05T07:42:31.318Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>真就正解是暴力呗</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>现在我们在一个平面上画了n个矩形。每一个矩形的两边都与坐标轴相平行，且矩形定点的坐标均为整数。现我们定义满足如下性质的图形为一个块：</p><p>1.每一个矩形都是一个块；</p><p>2.如果两个块有一段公共的部分，那么这两个块就会形成一个新的块，否则这两个块就是不同的。</p><p>示例：</p><p>图1中的矩形形成了两个不同的块。图2中的矩形形成了一个块。</p><p><img src="https://cdn.luogu.com.cn/upload/pic/1579.png" alt></p><p>任务：</p><p>请写一个程序：</p><p>1.从文本文件PRO.IN中读入各个矩形的顶点坐标；</p><p>2.找出这些矩形中不同的块的数目；</p><p>3.把结果输出到文本文件PRO.OUT中。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>文本文件PRO.IN的第一行包括一个整数n，1 &lt;= n &lt;= 7000，为矩形的数目。以下的n行为矩形顶点的坐标。每一个矩形都是用四个整数来描述的：左下角的x坐标、左下角的y坐标、右上角的x坐标和右上角的y坐标。所有的坐标都是不大于10000的非负整数。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>在文本文件PRO.OUT中输出唯一的一个整数——这些矩形所形成的不同的块的数目。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>考试题</p><p>当时看到这题发现自己只会 $O(n^2\log n)$，最后拿了 54pts<br>考试结束看了一眼洛谷题解，发现这玩意真就是个暴力。。。自己写丑了才少拿了分</p><p>具体就是 $O(n^2)$ 枚举所有的矩形，判断是否是一个联通块，是就用并查集把编号连起来，时间复杂度 $O(n^2\log n)$</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>这里不给出代码，原因是洛谷数据过水导致我的 AC 代码可以被 Hack 掉。。找个时间再放上来吧</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;真就正解是暴力呗&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="并查集" scheme="https://blog.handwer-std.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3200《[HNOI2009]有趣的数列》</title>
    <link href="https://blog.handwer-std.top/2019-11-04/Luogu-P3200/"/>
    <id>https://blog.handwer-std.top/2019-11-04/Luogu-P3200/</id>
    <published>2019-11-04T08:40:56.000Z</published>
    <updated>2019-11-04T13:27:00.437Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>卡特兰数 + 质因数分解</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们称一个长度为2n的数列是有趣的，当且仅当该数列满足以下三个条件：</p><p>(1)它是从1到2n共2n个整数的一个排列{ai}；</p><p>(2)所有的奇数项满足a1&lt;a3&lt;…&lt;a2n-1，所有的偶数项满足a2&lt;a4&lt;…&lt;a2n；</p><p>(3)任意相邻的两项a2i-1与a2i(1&lt;=i&lt;=n)满足奇数项小于偶数项，即：a2i-1&lt;a2i。</p><p>现在的任务是：对于给定的n，请求出有多少个不同的长度为2n的有趣的数列。因为最后的答案可能很大，所以只要求输出答案 mod P的值。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入文件只包含用空格隔开的两个整数n和P。输入数据保证，50%的数据满足n&lt;=1000，100%的数据满足n&lt;=1000000且P&lt;=1000000000。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>仅含一个整数，表示不同的长度为2n的有趣的数列个数mod P的值。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先给出结论：卡特兰数。</p><hr><p>注意到偶数位的数字必须大于前面偶数位、偶数位必须大于奇数位两个性质，可以得出这个结论：</p><blockquote><p>对于任意偶数位的数字，都满足该数字大于前面的所有数字</p></blockquote><p>考虑把偶数位、奇数位拆出来看，即拆成一个两行 n 列的矩阵，第一行表示奇数位，第二行表示偶数位。<br>上面的式子可以写成：</p><blockquote><p>对于任意在第二行的数字，都满足它大于它左边、左上边（不含正上方）的所有数字</p></blockquote><p>把第一排的数字都记为 0，第二排的数字都记为 1，放回到原序列，再联系前面的结论，可以得出：</p><blockquote><p>在（更新为 0 或 1 的）原序列中，对于任意一位 0，都满足前面的所有 0 的个数不小于前面所有 1 的个数；对于任意一位 1，都满足前面的所有 0 的个数大于前面所有 1 的个数</p></blockquote><p>如果把 0 看作栈的入栈操作，1 看作栈的出栈操作，那么上面的式子可以写成：</p><blockquote><p>在一个栈操作序列中，对于任意一个入栈操作，都满足前面的入栈操作数不小于前面的出栈操作数；对于任意一个出栈操作，都满足前面的入栈操作数大于前面的出栈操作数</p></blockquote><p>也就是求 <strong>长度为 n 的合法栈操作序列个数 / 出栈序列个数</strong></p><p>这个怎么求我不用再多说了吧</p><hr><p>接下来是另一个问题：取模</p><p>题目的 $p$ 是读入的，样例就明明白白的说了不一定是质数，甚至还可能很小</p><p>怎么办？</p><p>分解质因数。</p><p>注意到</p><script type="math/tex; mode=display">\begin{aligned}\text{ans} &= {C_{2n}^n \over n + 1}\\ &= { { { (2n)! } \over { n! \times n! } } \over { n + 1 } }\\ &= { { (2n)! } \over { (n!)^2(n + 1) } }\\ &= { { 1\times 2\times\dots \times (n - 1)\times n\times (n + 1)\times\dots\times (2n - 1)\times 2n } \over { [1\times 2\times\dots \times (n - 1)\times n] \times [1\times 2\times\dots \times (n - 1)\times n] \times (n + 1) } }\end{aligned}</script><p>分数上下消一消</p><script type="math/tex; mode=display">\begin{aligned}\text{ans} &= { {(n + 2) \times (n + 3) \times \dots \times (2n - 1) \times 2n} \over {1\times 2\times\dots \times (n - 1)\times n} }\end{aligned}</script><p>然后记 $f_i(i \in \text{Primes})$ 表示在答案中，编号为 $i$ 的质数被乘了几次，<br>也就是把 $ans$ 进行唯一分解放到一个数组里</p><p>怎么求 $f$ ？</p><p>直接上代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在线性筛中，如果 i 这个数是被第 k 个质数筛掉的，那么 sieveBy[i] = k</span></span><br><span class="line"><span class="comment">// prs[i] 表示第 i 个质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line"><span class="comment">// 加上分子 n + 2 到 2n 的乘积的分解</span></span><br><span class="line"><span class="keyword">int</span> x = i;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 分解质因数</span></span><br><span class="line">++f[sieveBy[x]];</span><br><span class="line">x = x / prs[sieveBy[x]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="comment">// 消去分母中 1 到 n 的乘积的分解</span></span><br><span class="line"><span class="keyword">int</span> x = i;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">--f[sieveBy[x]];</span><br><span class="line">x = x / prs[sieveBy[x]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后 for 一遍所有的质数，快速幂乘一下就好了</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notprime[<span class="number">2000000</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> prs[<span class="number">2000000</span> + <span class="number">10</span>], cnt;</span><br><span class="line"><span class="keyword">int</span> sieveBy[<span class="number">2000000</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"><span class="keyword">int</span> calcs[<span class="number">2000000</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * <span class="number">1l</span>l * a % p;</span><br><span class="line">a = <span class="number">1l</span>l * a * <span class="number">1l</span>l * a % p;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">notprime[<span class="number">0</span>] = notprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!notprime[i]) &#123;</span><br><span class="line">prs[++cnt] = i;</span><br><span class="line">sieveBy[i] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prs[j] &lt;= <span class="number">2</span> * n; ++j) &#123;</span><br><span class="line">notprime[i * prs[j]] = <span class="literal">true</span>;</span><br><span class="line">sieveBy[i * prs[j]] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;p);</span><br><span class="line">sieve();</span><br><span class="line"><span class="comment">// ans = ((2n)! / (n! * n!) * (n + 1))</span></span><br><span class="line"><span class="comment">// = ((1 * 2 * ... * (n - 1) * n * (n + 1) * (n + 2) * (n + 3) * ... * 2n) /</span></span><br><span class="line"><span class="comment">//(1 * 2 * ... * (n - 1) * n) * (1 * 2 * ... * (n - 1) * n) * (n + 1))</span></span><br><span class="line"><span class="comment">// = ((n + 1) * (n + 2) * (n + 3) * ... * 2n) /</span></span><br><span class="line"><span class="comment">//  ((1 * 2 * ... * (n - 1) * n) * (n + 1))</span></span><br><span class="line"><span class="comment">// = ((n + 2) * (n + 3) * ... * 2n) / ((1 * 2 * ... * (n - 1) * n)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x = i;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// printf("Now exting: %d\n", x);</span></span><br><span class="line">++calcs[sieveBy[x]];</span><br><span class="line">x = x / prs[sieveBy[x]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// printf("Calc 1.\n");</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x = i;</span><br><span class="line"><span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">--calcs[sieveBy[x]];</span><br><span class="line">x = x / prs[sieveBy[x]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">ans = <span class="number">1l</span>l * ans * <span class="number">1l</span>l * fastPow(prs[i], calcs[i], p) % p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;卡特兰数 + 质因数分解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="筛法" scheme="https://blog.handwer-std.top/tags/%E7%AD%9B%E6%B3%95/"/>
    
      <category term="质数" scheme="https://blog.handwer-std.top/tags/%E8%B4%A8%E6%95%B0/"/>
    
      <category term="卡特兰数" scheme="https://blog.handwer-std.top/tags/%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3331《[BeiJing2013]压力》</title>
    <link href="https://blog.handwer-std.top/2019-11-03/BZOJ3331/"/>
    <id>https://blog.handwer-std.top/2019-11-03/BZOJ3331/</id>
    <published>2019-11-03T11:47:56.000Z</published>
    <updated>2019-11-03T12:16:34.591Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一张 n 个点 m 条边的无向图，再给你 q 个点对，让你计算对于每一个点，有多少个点对间的路径必定经过这个点。N≤100000,M,Q≤200000。</p><a id="more"></a><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先可以发现这样一个东西：</p><blockquote><p>在原图对应的圆方树上，一个点对之间的所有圆点都会被经过</p></blockquote><p>那就好做了</p><p>首先建出圆方树，然后问题转化为了一个树上链修改，单点查询的题目</p><p>直接树上差分一下就行了</p><hr><p>我还是讲一下这个差分吧</p><p>具体就是对于点对<code>(u,v)</code>，<code>diff[u]++, diff[v]++, diff[LCA(u,v)]--, diff[father[LCA(u,v)]]--</code></p><p>最后一遍 dfs 还原一下树上前缀和即可</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/11/2.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: [BeiJing2013]压力</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NEWN = MAXN &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next; <span class="keyword">bool</span> typ;</span><br><span class="line">    Node(<span class="keyword">int</span> _next = <span class="number">0</span>, <span class="keyword">bool</span> _typ = <span class="literal">false</span>) &#123; next = _next; typ = _typ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qu</span> &#123;</span> <span class="keyword">int</span> u, v; qu(<span class="keyword">int</span> _u = <span class="number">0</span>, <span class="keyword">int</span> _v = <span class="number">0</span>) &#123; u = _u; v = _v; &#125; &#125; qs[MAXQ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, tn, m, q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[NEWN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tarjan &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> dfn[MAXN], low[MAXN], timestamp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stk[MAXN], top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tn = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tn; ++i) <span class="keyword">if</span> (!dfn[i]) work(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++timestamp;</span><br><span class="line">        stk[++top] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                work(v, u);</span><br><span class="line">                low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span> (low[v] &gt;= dfn[u]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = <span class="number">-1</span>; ++tn; <span class="comment">// 直接在这里建圆方树，++tn 是给圆方树的方点分配编号</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        x = stk[top--];</span><br><span class="line">                        tree[tn].push_back(x);</span><br><span class="line">                        tree[x].push_back(tn);</span><br><span class="line"><span class="comment">//                        printf("Edge connected: &lt;%d, %d&gt;\n", tn, x);</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> (x != v);</span><br><span class="line">                    tree[u].push_back(tn); tree[tn].push_back(u);</span><br><span class="line"><span class="comment">//                    printf("Edge connected: &lt;%d, %d&gt;\n", tn, u);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v != fa) low[u] = <span class="built_in">std</span>::min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCA &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> father[NEWN][<span class="number">30</span>], depth[NEWN];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lg[NEWN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tn; ++i) &#123;</span><br><span class="line">            lg[i] = lg[i - <span class="number">1</span>] + (<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>] == i);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        father[u][<span class="number">0</span>] = fa; depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= depth[u]; ++i) &#123;</span><br><span class="line">            father[u][i] = father[father[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) tree[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = tree[u][i];</span><br><span class="line">            <span class="keyword">if</span> (v != fa) dfs(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth[u] &lt; depth[v]) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">        <span class="keyword">while</span> (depth[u] &gt; depth[v]) &#123;</span><br><span class="line">            u = father[u][lg[depth[u] - depth[v]] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lg[depth[u]]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (father[u][i] != father[v][i]) &#123;</span><br><span class="line">                u = father[u][i]; v = father[v][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Difference &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> diff[NEWN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = LCA::get(u, v);</span><br><span class="line"><span class="comment">//        printf("u = %d, v = %d, LCA&lt;%d, %d&gt; = %d, LCA's father = %d\n", u, v, u, v, l, LCA::father[l][0]);</span></span><br><span class="line">        ++diff[u]; ++diff[v];</span><br><span class="line">        --diff[l]; --diff[LCA::father[l][<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        printf("[dfs(u)] u = %d\n", u);</span></span><br><span class="line">        <span class="keyword">using</span> LCA::father;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) tree[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = tree[u][i]; <span class="keyword">if</span> (v == father[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(v);</span><br><span class="line">            diff[u] += diff[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        head[u].push_back(v); head[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        qs[i] = qu(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    Tarjan::tarjan();</span><br><span class="line">    LCA::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qs[i].u, v = qs[i].v;</span><br><span class="line"><span class="comment">//        printf("Query #%d: u = %d, v = %d\n", i, u, v);</span></span><br><span class="line">        Difference::modify(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    Difference::dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Difference::diff[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h1&gt;&lt;p&gt;给你一张 n 个点 m 条边的无向图，再给你 q 个点对，让你计算对于每一个点，有多少个点对间的路径必定经过这个点。N≤100000,M,Q≤200000。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="差分" scheme="https://blog.handwer-std.top/tags/%E5%B7%AE%E5%88%86/"/>
    
      <category term="Tarjan" scheme="https://blog.handwer-std.top/tags/Tarjan/"/>
    
      <category term="圆方树" scheme="https://blog.handwer-std.top/tags/%E5%9C%86%E6%96%B9%E6%A0%91/"/>
    
      <category term="LCA" scheme="https://blog.handwer-std.top/tags/LCA/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>可持久化线段树学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-11-03/Persistent-Segment-Tree/"/>
    <id>https://blog.handwer-std.top/2019-11-03/Persistent-Segment-Tree/</id>
    <published>2019-11-03T09:12:29.000Z</published>
    <updated>2019-11-03T09:26:19.261Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>可持久化数据结构初探</p></blockquote><a id="more"></a><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>请设计一个支持如下操作的数据结构：</p><ol><li>扩大这个数据结构的范围（如从 $[1,n]$ 扩大到 $[1,n + k]$，保证最终的大小不会超过 $10^5$）</li><li>在最新版本基础上修改某个位置上的值</li><li>查询最新版本某个位置上的值</li><li>回滚到某一个版本</li><li>在某一个版本基础上修改某个位置的值</li><li>查询某一个版本某个位置上的值</li></ol><p>为了方便，初始时数据结构范围为 $[1,1]$；输入数据均为正整数；每次修改时，都要新建一个版本（基于哪一个版本取决于操作的编号）；每次查询时，新建一个与最新版本相同的版本</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>前置条件：</p><ol><li>数组下标从 1 开始</li><li>一开始就直接开到最大数据结构大小</li></ol><h2 id="朴素算法-1"><a href="#朴素算法-1" class="headerlink" title="朴素算法 1"></a>朴素算法 1</h2><p>将版本视为一个时间轴，建立一个二维数组，第一维表示版本，第二维存对应版本的数据，每一次操作时把基于的版本复制一遍，然后修改、查询。</p><p>时空复杂度 $\mathcal{O}(nm)$，其中 $n$ 为数据结构最大大小，$m$ 为数据结构最大版本数</p><h2 id="朴素算法-2"><a href="#朴素算法-2" class="headerlink" title="朴素算法 2"></a>朴素算法 2</h2><p>依然将版本视为一个时间轴，建立意义与朴素算法 1 相同的二维数组，不同的是，这次不再复制整个数组，取而代之的是在没有用到的下标 0 处记录这个版本是基于哪个版本的，修改只需修改对应的元素即可。查询时，先看这个元素是不是 0（意味着未被修改），是则跳到下标 0 记录的版本，重复这个过程，直到元素非 0，输出即可</p><p>空间复杂度 $\mathcal{O}(nm)$；<br>修改时间复杂度 $\mathcal{O}(1)$，查询时间复杂度最坏为 $\mathcal{O}(m)$；<br>$n,m$ 意义同朴素算法 1。</p><h2 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h2><p>为什么要说算法 2 呢？<br>我个人认为，算法 2 <strong>只修改有用的点</strong>的特性正符合可持久化线段树的特点。</p><p>顺着算法 2 想下去。发现算法 2 有大量无用的空间，怎么办？</p><p>搬出树形结构，再加动态开点。</p><h3 id="树的结构及修改操作"><a href="#树的结构及修改操作" class="headerlink" title="树的结构及修改操作"></a>树的结构及修改操作</h3><p>一棵线段树长这样：</p><p><img src="https://s2.ax1x.com/2019/11/03/KX0NHU.md.png" alt="KX0NHU.md.png"></p><p>然后发现修改第二个元素需要经历这些节点：<br><img src="https://s2.ax1x.com/2019/11/03/KX0gHO.md.png" alt="KX0gHO.md.png"></p><p>依据算法 2，开一些新的点作为这个版本的点<br><img src="https://s2.ax1x.com/2019/11/03/KXDUfJ.md.png" alt="KXDUfJ.md.png"><br>蓝点为原来的点，橙点为这个版本经过的点</p><p>可以发现它不再是一棵树。但是如果不看那些“被修改”的蓝点，它仍然是一棵二叉树……怎么办？</p><p>不妨把它视为多棵线段树，每一棵树都是一个版本，最顶上的依然是树根，只不过<strong>这些线段树共享了一些相同的节点</strong>。</p><p>具体实现的话，就把线段树的根节点<strong>们</strong>存在一个数组<code>root[]</code>中，这样，<code>root[i]</code>就表示第 i 棵（第 i 个版本的）线段树的根节点编号。</p><p>看一眼代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建树，把原始数列建到树的 0 版本上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> roots[]; <span class="comment">// 根节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs, val;</span><br><span class="line">    <span class="comment">// ls 表示左儿子编号，rs 表示右儿子编号，val 表示节点信息</span></span><br><span class="line">&#125; tree[];</span><br><span class="line"><span class="keyword">int</span> cnt; <span class="comment">// 节点编号计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// root 要引用的原因是操作过程中</span></span><br><span class="line">    <span class="comment">// 要对存放根节点、左儿子（左子树的根节点）、右儿子（右子树的根节点）编号的变量进行更新</span></span><br><span class="line">    <span class="comment">// 直接引用变量的话可以省一步赋值，写起来也方便</span></span><br><span class="line">    root = ++cnt; <span class="comment">// 给新的节点——当前子树的根节点分配编号</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ((<span class="keyword">void</span>) (tree[root].val = seq[l]));</span><br><span class="line">    <span class="comment">// 经典的线段树赋值  </span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    buildTree(tree[root].ls, l, mid);  </span><br><span class="line">    buildTree(tree[root].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 左右子树建树  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    buildTree(roots[<span class="number">0</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// 把 0 版本的根节点编号传进去</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改操作，root 表示当前子树根节点编号，引用也是因为更新方便</span></span><br><span class="line"><span class="comment">// base 表示当前修改的是基于哪个版本的，存的是那个版本「对应深度」子树的根节点编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> base, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> k)</span> </span>&#123;  </span><br><span class="line">    root = ++cnt; tree[root] = tree[base];  </span><br><span class="line">    <span class="comment">// 分配根节点编号，把节点信息原份复制下来，后面再修改</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; tree[root].val = k; <span class="keyword">return</span>; &#125;  </span><br><span class="line">    <span class="comment">// 经典的单点赋值</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) modify(tree[root].ls, tree[base].ls, l, mid, pos, k);  </span><br><span class="line">    <span class="keyword">else</span> modify(tree[root].rs, tree[base].rs, mid + <span class="number">1</span>, r, pos, k);  </span><br><span class="line">    <span class="comment">// 对左右子树修改，顺便可以直接更新这个节点的左右儿子信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    modify(roots[新的版本], roots[基于哪个版本], <span class="number">1</span>, n, 修改的位置, 值);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>明白了 <code>root[]</code> 数组的意义，查询就很简单了</p><hr><p><img src="https://s2.ax1x.com/2019/11/03/KX258O.md.png" alt="KX258O.md.png"></p><p>比如说查询版本 1（初始版本为 0），就是顺着版本 1 的根节点往下找对应位置，查到底部返回。图中灰色的节点是查版本 1 永远碰不到的节点——因为它们在版本 1 中被修改了，而剩下的点依然形成了一棵线段树，顺着这棵树查下去就完事了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询操作，root 不加引用是因为查询操作没必要对线段树进行修改</span></span><br><span class="line"><span class="comment">// 经典的单点查询，不讲了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[root].val;  </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) <span class="keyword">return</span> query(tree[root].ls, l, mid, pos);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(tree[root].rs, mid + <span class="number">1</span>, r, pos);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    query(roots[查询的版本], <span class="number">1</span>, n, 查询的位置);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><h4 id="扩大数据结构范围"><a href="#扩大数据结构范围" class="headerlink" title="扩大数据结构范围"></a>扩大数据结构范围</h4><p>这个其实不用管。。。毕竟一开始就已经把范围开好了</p><h4 id="回滚到某个版本"><a href="#回滚到某个版本" class="headerlink" title="回滚到某个版本"></a>回滚到某个版本</h4><p>对线段树的具体内容没有一点操作，直接把新版本的根节点编号设为回滚到的版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    roots[新的版本] = roots[回滚到的版本];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于数据范围"><a href="#关于数据范围" class="headerlink" title="关于数据范围"></a>关于数据范围</h4><p>由于线段树的空间开销本身就很大，再加上可持久化的节点，一般开到原数据范围的 32 倍（即<code>MAXN &lt;&lt; 5</code>）</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>题目：洛谷P3919《【模板】可持久化数组》<br>支持的操作：操作 2、3、5、6</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/11/2.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: 可持久化数组</span></span><br><span class="line"><span class="comment">// Used data structure: 可持久化线段树</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs, val;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> _ls = <span class="number">0</span>, <span class="keyword">int</span> _rs = <span class="number">0</span>, <span class="keyword">int</span> _val = <span class="number">0</span>) &#123; ls = _ls; rs = _rs; val = _val; &#125;</span><br><span class="line">&#125; tree[MAXN &lt;&lt; <span class="number">5</span>]; <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, seq[MAXN], roots[MAXN], versions;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    root = ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ((<span class="keyword">void</span>) (tree[root].val = seq[l]));</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    buildTree(tree[root].ls, l, mid);</span><br><span class="line">    buildTree(tree[root].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> base, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    root = ++cnt; tree[root] = tree[base];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; tree[root].val = k; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) modify(tree[root].ls, tree[base].ls, l, mid, pos, k);</span><br><span class="line">    <span class="keyword">else</span> modify(tree[root].rs, tree[base].rs, mid + <span class="number">1</span>, r, pos, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[root].val;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) <span class="keyword">return</span> query(tree[root].ls, l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(tree[root].rs, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, seq + i);</span><br><span class="line">    buildTree(roots[<span class="number">0</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ver, cmd, loc;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;ver, &amp;cmd, &amp;loc);</span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            modify(roots[++versions], roots[ver], <span class="number">1</span>, n, loc, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(roots[ver], <span class="number">1</span>, n, loc));</span><br><span class="line">            roots[++versions] = roots[ver];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;可持久化数据结构初探&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://blog.handwer-std.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="可持久化线段树" scheme="https://blog.handwer-std.top/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1383「IOI 2012」《高级打字机》</title>
    <link href="https://blog.handwer-std.top/2019-11-02/Luogu-P1383/"/>
    <id>https://blog.handwer-std.top/2019-11-02/Luogu-P1383/</id>
    <published>2019-11-02T13:56:53.000Z</published>
    <updated>2019-11-02T14:18:54.295Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>IOI 也出板子题？</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>早苗入手了最新的高级打字机。最新款自然有着与以往不同的功能，那就是它具备撤销功能，厉害吧。</p><p>请为这种高级打字机设计一个程序，支持如下3种操作：</p><p>1.T x：在文章末尾打下一个小写字母x。(type操作)</p><p>2.U x：撤销最后的x次修改操作。（Undo操作）</p><p>（注意Query操作并不算修改操作）</p><p>3.Q x：询问当前文章中第x个字母并输出。（Query操作）</p><p>文章一开始可以视为空串。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第1行：一个整数n，表示操作数量。</p><p>以下n行，每行一个命令。保证输入的命令合法。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>每行输出一个字母，表示Query操作的答案。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">T a</span><br><span class="line">T b</span><br><span class="line">T c</span><br><span class="line">Q 2</span><br><span class="line">U 2</span><br><span class="line">T c</span><br><span class="line">Q 2</span><br></pre></td></tr></table></figure></p><p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure></p><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>【数据范围】</p><p>对于40%的数据 n&lt;=200;</p><p>对于100%的数据 n&lt;=100000；保证Undo操作不会撤销Undo操作。</p><p>&lt;高级挑战&gt;</p><p>对于200%的数据 n&lt;=100000；Undo操作可以撤销Undo操作。</p><ioi挑战><p>必须使用在线算法完成该题。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="普通数据"><a href="#普通数据" class="headerlink" title="普通数据"></a>普通数据</h2><p>就是个模拟。。。没啥好讲的</p><p>代码之后会给</p><h2 id="IOI-挑战"><a href="#IOI-挑战" class="headerlink" title="IOI 挑战"></a>IOI 挑战</h2><p>原题为 IOI2012 Scrivener <a href="http://www.ioi2012.org/wp-content/uploads/2011/12/Scrivener.pdf" target="_blank" rel="noopener">PDF 链接</a></p><p>这不就是个可持久化数组板子吗。。。<br><del> 就这还 IOI 题？</del></p><hr><p>算了还是好好说一下三种操作吧</p><ol><li>插入操作<br>提前开好一个大小为 n 的可持久化数组，每次插入的时候建一个新的版本，把上个版本的长度 + 1 处字符修改了就好</li><li>撤销操作<br>直接新开一个版本，把版本信息（根节点和长度）修改成撤销到的那个版本就行了</li><li>查询操作<br>这个就是模板操作了，不再赘述</li></ol><hr><p>什么？听说你不会可持久化数据结构？<br><del>不久之后</del>我会专门开一篇讲的</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="普通数据-1"><a href="#普通数据-1" class="headerlink" title="普通数据"></a>普通数据</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ptr;</span><br><span class="line"><span class="keyword">char</span> ss[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">3</span>], a[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'T'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br><span class="line">            ss[++ptr] = a[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'U'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            ptr -= x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, ss[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IOI-挑战-1"><a href="#IOI-挑战-1" class="headerlink" title="IOI 挑战"></a>IOI 挑战</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs; <span class="keyword">char</span> val;</span><br><span class="line">    Node(<span class="keyword">int</span> _ls = <span class="number">0</span>, <span class="keyword">int</span> _rs = <span class="number">0</span>, <span class="keyword">char</span> _val = <span class="number">0</span>) &#123; ls = _ls; rs = _rs; val = _val; &#125;</span><br><span class="line">&#125; tree[MAXN &lt;&lt; <span class="number">5</span>]; <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, roots[MAXN &lt;&lt; <span class="number">5</span>], lens[MAXN &lt;&lt; <span class="number">5</span>], version;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> base, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">    root = ++cnt; tree[root] = tree[base];</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="keyword">void</span>) (tree[root].val = val);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) modify(tree[root].ls, tree[base].ls, l, mid, pos, val);</span><br><span class="line">    <span class="keyword">else</span> modify(tree[root].rs, tree[base].rs, mid + <span class="number">1</span>, r, pos, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[root].val;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) <span class="keyword">return</span> query(tree[root].ls, l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(tree[root].rs, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> cmd[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'T'</span>) &#123;</span><br><span class="line">            ++version; lens[version] = lens[version - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> sss[<span class="number">3</span>]; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, sss);</span><br><span class="line">            modify(roots[version], roots[version - <span class="number">1</span>], <span class="number">1</span>, n, lens[version], sss[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'U'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ver; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ver);</span><br><span class="line">            ++version; roots[version] = roots[version - ver - <span class="number">1</span>];</span><br><span class="line">            lens[version] = lens[version - ver - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, query(roots[version], <span class="number">1</span>, n, pos));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></ioi挑战>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;IOI 也出板子题？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="可持久化数据结构" scheme="https://blog.handwer-std.top/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="https://blog.handwer-std.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="IOI" scheme="https://blog.handwer-std.top/tags/IOI/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2090《数字对》</title>
    <link href="https://blog.handwer-std.top/2019-11-01/Luogu-P2090/"/>
    <id>https://blog.handwer-std.top/2019-11-01/Luogu-P2090/</id>
    <published>2019-11-01T13:29:42.000Z</published>
    <updated>2019-11-01T14:00:00.349Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更相减损术</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>对于一个数字对(a, b)，我们可以通过一次操作将其变为新数字对(a+b, b)或(a, a+b)。</p><p>给定一正整数n，问最少需要多少次操作可将数字对(1, 1)变为一个数字对，该数字对至少有一个数字为n。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行一个正整数 n</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个整数表示答案。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>样例解释：</p><p>(1,1)  →  (1,2)  →  (3,2)  →  (5,2)</p><p>对于30%的数据， 1 &lt;= n &lt;= 1000</p><p>对于60%的数据， 1 &lt;= n &lt;= 20000</p><p>对于100%的数据，1 &lt;= n &lt;= 10^6</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>先手玩一下样例，发现式子是这样的：</p><blockquote><p>$(a,b) \leftarrow (a’ + b, b)$</p></blockquote><p>反过来写</p><blockquote><p>$(a’,b) \rightarrow (a - b, b)$</p></blockquote><p>这个不是。。。更相减损术？</p><hr><p>所以题目就转化成了：找到一个数字对 $(n,a)$ 使得 <code>gcd(n, a)</code> 进行更相减损的次数最小。</p><p>考虑枚举 $a$，上界怎么确定？</p><p>手玩的时候顺便发现从 $(1,1)$ 分出的两条分支是对称的，那么超出 $n$ 的枚举是没有必要的，所以 $1\leq a \leq n$</p><hr><p>每一次 <code>gcd</code> 传下去的参数都是 <code>b,a mod b</code>，更相减损了 $\lfloor {a \over b} \rfloor$ 次， 每次步数要加上这个数；<br>最后如果 $b = 1$，那么步数要另加上 $a - 1$ （从 $(1,1)$ 转移到 $(a,1)$ 需要 $a - 1$ 步）；<br>最后如果 $b = 0$ 那就无解，直接 <code>return inf</code> 别让答案更新就好</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/11/1.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: 数字对</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">    <span class="keyword">return</span> a / b + gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans, gcd(n, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更相减损术&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2062《分队问题》</title>
    <link href="https://blog.handwer-std.top/2019-11-01/Luogu-P2062/"/>
    <id>https://blog.handwer-std.top/2019-11-01/Luogu-P2062/</id>
    <published>2019-11-01T11:28:30.000Z</published>
    <updated>2019-11-01T13:28:26.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定n个选手，将他们分成若干只队伍。其中第i个选手要求自己所属的队伍的人数大等于a[i]人。</p><p>在满足所有选手的要求的前提下，最大化队伍的总数。</p><p>注：每个选手属于且仅属于一支队伍。</p><a id="more"></a><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行一个整数n，表示人数。</p><p>以下n行，每行一个整数表示a[i]。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出队伍总数的最大值。数据保证有解。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p><p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于20%的数据，n &lt;= 10</p><p>对于40%的数据，n &lt;= 1000</p><p>对于60%的数据，n &lt;= 10000</p><p>对于100%的数据，1 &lt;= n &lt;= 10^6</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应是个贪心</p><p>就是从大往小排序，然后从前往后扫，每碰到一个人就把它后面的人都拉进队</p><p>每个元素只会访问一次，时间复杂度$\mathcal{O}(n)$</p><hr><p>但是这个是错的</p><p>考虑这组数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">4</span>, a[] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure><p>贪心跑出来是 2，答案应该是 3<br>原因在于贪心无法判断当前的人是另开一队更优还是加入已有队伍更优，赛后我看了一眼洛谷题解，有人判了这个之后贪心过了<del>但我没看懂</del></p><hr><p>考虑 dp</p><p>首先把 <code>a[]</code>  从小到大排个序</p><p>然后设 <code>f[i]</code> 表示当前安排了前 i 个人所能获得的最大队伍数<br>转移方程：</p><script type="math/tex; mode=display">f_i=\left\{\begin{array}{ll}{f_{i - 1}} & {\left(i < a_i)\right.} \\ {f_{i - a_{i}} + 1} & {\left(i \geq a_i\right)}\end{array}\right.</script><p>就是，对于一个人，可以把他塞进旧队伍里，也可以接着前面的 $a_i$ 个人开一个新队伍</p><p>时间复杂度 $\mathcal{O}(n)$</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/11/1.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: 分队问题</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, arr[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, arr + i);</span><br><span class="line">    <span class="built_in">std</span>::sort(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; arr[i]) f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> f[i] = <span class="built_in">std</span>::max(f[i - <span class="number">1</span>], f[i - arr[i]] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定n个选手，将他们分成若干只队伍。其中第i个选手要求自己所属的队伍的人数大等于a[i]人。&lt;/p&gt;
&lt;p&gt;在满足所有选手的要求的前提下，最大化队伍的总数。&lt;/p&gt;
&lt;p&gt;注：每个选手属于且仅属于一支队伍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
  </entry>
  
  <entry>
    <title>公告栏</title>
    <link href="https://blog.handwer-std.top/2019-10-31/BulletinBoard/"/>
    <id>https://blog.handwer-std.top/2019-10-31/BulletinBoard/</id>
    <published>2019-10-31T12:30:00.000Z</published>
    <updated>2019-12-07T23:54:30.893Z</updated>
    
    <content type="html"><![CDATA[<font style="color:#66ccff"><center>这里可能会挂些什么东西。 <br>There may be something here.</center></font><p><img src="https://v2.jinrishici.com/one.svg" alt="今日诗词"></p><!--博客累计已突破 100 篇文章--><!--New！[《「文章」百名学生参训 礼堂“变身”教室》](/2019-02-16/SDWC-Article/)--><center><a href="/2019-08-14/Articles-Moving-To-cnblogs/">《关于新开的&nbsp;cnblogs&nbsp;博客的一些说明》</a></center><center><a href="2019-12-07/Some-Thinking-About-Article-of-Huawei-251/">《对「共青团中央」微信公众号转发关于“华为&nbsp;251&nbsp;事件”文章的一些看法》</a></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font style=&quot;color:#66ccff&quot;&gt;
&lt;center&gt;这里可能会挂些什么东西。 &lt;br&gt;There may be something here.
&lt;/center&gt;
&lt;/font&gt;

&lt;p&gt;&lt;img src=&quot;https://v2.jinrishici.com
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Codeforces 1244D《Paint the Tree》</title>
    <link href="https://blog.handwer-std.top/2019-10-28/CF1244D/"/>
    <id>https://blog.handwer-std.top/2019-10-28/CF1244D/</id>
    <published>2019-10-28T12:40:47.000Z</published>
    <updated>2019-10-28T12:45:06.093Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为细节问题没过 pretest 导致我掉分的题目</p></blockquote><a id="more"></a><h1 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h1><p>有一棵树，有3种颜色，第i个节点染成第j种颜色的代价是$c_{j,i}$，现在要你求出一种染色方案，使得总代价最小，且对于任意三个相邻的节点，颜色不能相同。输出最小代价与其中一种方案。无解输出$-1$。</p><p>$3\le n\le 10^5$</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3 2 3</span><br><span class="line">4 3 2</span><br><span class="line">3 1 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure></p><p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1 3 2</span><br></pre></td></tr></table></figure></p><p><strong>输入 #2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 1 2</span><br><span class="line">4 2 1 5 4</span><br><span class="line">5 3 2 1 1</span><br><span class="line">1 2</span><br><span class="line">3 2</span><br><span class="line">4 3</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure></p><p><strong>输出 #2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure></p><p><strong>输入 #3</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 1 2</span><br><span class="line">4 2 1 5 4</span><br><span class="line">5 3 2 1 1</span><br><span class="line">1 2</span><br><span class="line">3 2</span><br><span class="line">4 3</span><br><span class="line">5 4</span><br></pre></td></tr></table></figure></p><p><strong>输出 #3</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">1 3 2 1 3</span><br></pre></td></tr></table></figure></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>拿到样例之后就<del>随便</del>手玩一下，然后再<del>随便</del>举几个例子<br>发现这样一个奇怪的事情：</p><blockquote><p>好像任意的$k(k \geq 2)$叉树都没法染色。。。</p></blockquote><p>这里直接用二叉树的情况解释一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A --&gt; B</span><br><span class="line">A --&gt; C</span><br><span class="line">B --&gt; D</span><br><span class="line">B --&gt; E</span><br></pre></td></tr></table></figure><p>发现在无论怎么染色，对 A、B、D、E 进行染色总会冲突</p><p>所以分析了半天可以发现这样一个有趣的性质：</p><blockquote><p>一棵树能被正确进行染色当且仅当这棵树为一条链。</p></blockquote><hr><p>判完 -1 再来想一想怎么搞一条链的情况</p><p><del>不会了啊。。。完了今晚要掉分了</del></p><p>想一下暴力是怎么做的：$3^n$枚举所有的点怎么填颜色，然后扫一遍判断。继续手玩一条链的情况，发现一个事情：</p><blockquote><p>两个点确定了，整条链的染色方案就唯一确定了。</p></blockquote><hr><p>做法就出来了。</p><blockquote><p>首先判断树是否为一条链（判断每个点的度），不为链则 Failed；<br>然后两重循环大力枚举前两个点的颜色，之后扫一遍确定其他点的颜色，顺便算出花费，更新答案<br>输出最终答案</p></blockquote><hr><p>实现的时候要注意细节很多。。。我比赛的时候因为时间不太够写的很急，结果没过 pretest。。。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/10/27.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: Paint the Tree</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, linkTop;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">10000000000000000</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> cost[MAXN][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> degree[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="keyword">int</span> next[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> col[MAXN], fcol[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : head[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        next[now] = v;</span><br><span class="line">        DFS(v, now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre, <span class="keyword">int</span> ppre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; now; now = next[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[ppre] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[pre] == <span class="number">2</span>) col[now] = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> col[now] = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col[ppre] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[pre] == <span class="number">1</span>) col[now] = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> col[now] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[pre] == <span class="number">1</span>) col[now] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> col[now] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ppre = pre; pre = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> fcost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fcost += cost[i][col[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &gt;= fcost) &#123;</span><br><span class="line">        ans = fcost;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            fcol[i] = col[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">3</span>; ++c) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; cost[i][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        head[u].push_back(v); ++degree[u];</span><br><span class="line">        head[v].push_back(u); ++degree[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degree[i] &gt; <span class="number">2</span>) <span class="keyword">return</span> (<span class="number">0</span> &amp; <span class="built_in">puts</span>(<span class="string">"-1"</span>));</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">1</span> &amp;&amp; !linkTop) linkTop = i;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(linkTop, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        col[linkTop] = i;</span><br><span class="line">        <span class="keyword">int</span> linkNext = next[linkTop];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            col[linkNext] = j;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            Search(next[linkNext], linkNext, linkTop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fcol[i] &lt;&lt; (i == n ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为细节问题没过 pretest 导致我掉分的题目&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="暴力" scheme="https://blog.handwer-std.top/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P5142《区间方差》</title>
    <link href="https://blog.handwer-std.top/2019-10-26/Luogu-P5142/"/>
    <id>https://blog.handwer-std.top/2019-10-26/Luogu-P5142/</id>
    <published>2019-10-26T08:31:42.000Z</published>
    <updated>2019-10-26T10:33:28.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单的数据结构题目以及无处不在的取模</p></blockquote><a id="more"></a><h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>出题人并没有能力写有趣的题面……</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>对于一个长度为n的序列$a_1,a_2,a_3\cdots a_n$​，我们定义它的平均数a为:</p><p>$a=\frac{1}{n}\sum_{i=1}^{n}a_i$</p><p>并定义它的方差d为:</p><p>$d=\frac{1}{n}\sum_{i=1}^{n}(a_i-a)^2$</p><p>现在给定一个长度为n的序列$b_1,b_2\cdots b_n$​。你需要支持两种操作。每种操作的格式为c x y。</p><p>若c=1，为修改操作，代表将$b_x$​赋值为y。</p><p>若c=2，为查询操作，代表查询$b_x$​到$b_y$的方差。</p><p>为了避免浮点数误差，请以分数取模形式输出结果（对1000000007（$10^9+7$）取模）。如果不知道什么是分数取模，请看下文。</p><blockquote><p>作者注：原文这里是对乘法逆元对介绍，在此省略</p></blockquote><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行两个数n,m，代表序列b的长度为n，有m个操作。</p><p>第二行n个整数$b_i$​，表示序列b的初始值。</p><p>下面有m行整数，每行格式为c a b，含义如上文所示。保证所有操作合法。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>对于每个操作2，输出一行。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">4 8</span><br><span class="line">0 0 0 0</span><br><span class="line">1 1 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 3</span><br><span class="line">1 4 4</span><br><span class="line">2 1 1</span><br><span class="line">2 1 2</span><br><span class="line">2 1 3</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure></p><p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">250000002</span><br><span class="line">666666672</span><br><span class="line">250000003</span><br></pre></td></tr></table></figure></p><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>四次修改后，序列b为：1,2,3,4。</p><p>区间[1,1]的方差为0.</p><p>区间[1,2]的方差为1/4。4的逆元为250000002。</p><p>区间[1,3]的方差为2/3。3的逆元为333333336，2*333333336%M=666666672。</p><p>对于50%的数据，n≤1000，m≤1000.</p><p>对于100%的数据，n≤100000，m≤100000，1≤b_i≤1000000000，1≤x≤n。对于操作1，1≤y≤1000000000。对于操作2，x≤y≤n。</p><p>保证逆元一定存在。注意M=1000000007（10^9+7）。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>没啥可解析的……推推式子就完了</p><p>查询 $[l,r]$ 的方差：<br>首先令 $N = r - l + 1$，有</p><script type="math/tex; mode=display">a = {1 \over N} \sum_{i = l}^{r} a_i</script><p>而且</p><script type="math/tex; mode=display">d = {1 \over N} \sum_{i = l}^{r} (a_i - a)^2</script><p>对下面的式子作一番变形：</p><script type="math/tex; mode=display">\begin{align*}d &= {1 \over N} \sum_{i = l}^{r} (a_i - a)^2\\&= {1 \over N} \sum_{i = l}^{r} (a_i^2 + a^2 - 2 a \cdot a_i)\\&= {1 \over N} \big( \sum_{i = l}^{r} a_i^2 + \sum_{i = l}^{r} a^2 - \sum_{i = l}^{r} 2 a \cdot a_i \big)\\&= {1\over N} \big(\sum_{i = l}^{r} a_i^2 + N \times a^2 - 2a \sum_{i = l}^{r} a_i\big)\\&={1\over N}\sum_{i = l}^{r} a_i^2 + {1\over N} \times N \times a^2 - {1\over N} \times2a \sum_{i = l}^{r} a_i\\&={1\over N}\sum_{i = l}^{r} a_i^2 + a^2 - {1\over N} \times2a \sum_{i = l}^{r} a_i\end{align*}</script><p>这个式子复杂的令人自闭。。<br>这时设 </p><script type="math/tex; mode=display">F = \sum_{i = l}^{r} a_i, G = \sum_{i = l}^{r} a_i^2</script><p>这样到后面式子会好看许多，把 $a$ 代入继续变形</p><script type="math/tex; mode=display">\begin{align*}d &= {1\over N}\sum_{i = l}^{r} a_i^2 + a^2 - {1\over N} \times2a \sum_{i = l}^{r} a_i\\&= {1\over N}\cdot G + {\big({1 \over N} \sum_{i = l}^{r} a_i\big)}^2 - 2 \times {1 \over N} \times {1 \over N} \sum_{i = l}^{r} a_i \times \sum_{i = l}^{r} a_i\\&= {1\over N} \cdot G + {1\over N^2} \cdot F^2-2\times {1\over N^2}\cdot F^2\\&= {1\over N} \cdot G -{1\over N^2}\cdot F^2\end{align*}</script><p>这个就是最后的方差式子。。。终于推出来了</p><p>注意到之前设的 $F$ 和 $G$ 是</p><script type="math/tex; mode=display">F = \sum_{i = l}^{r} a_i, G = \sum_{i = l}^{r} a_i^2</script><p>发现这个东西似乎可以用数据结构维护</p><hr><p>然后就是一道树状数组模板题了</p><p>维护两个树状数组，一个记录区间和，一个记录区间平方和</p><p>这个很好做吧，下面放代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀和</span></span><br><span class="line"><span class="function">lli <span class="title">qu</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;  </span><br><span class="line">    lli r = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        (r += bit[p]) %= HA;  </span><br><span class="line">        lb(p, <span class="number">-1l</span>l);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> r;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 前缀平方和</span></span><br><span class="line"><span class="function">lli <span class="title">qux</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;  </span><br><span class="line">    lli r = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        (r += bitt[p]) %= HA;  </span><br><span class="line">        lb(p, <span class="number">-1l</span>l);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> r;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 修改，注意操作是单点覆盖而不是单点加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> p, lli x)</span> </span>&#123;  </span><br><span class="line">    lli d = x - (qu(p) - qu(p - <span class="number">1</span>)),  </span><br><span class="line">            dx = x * x - (qux(p) - qux(p - <span class="number">1</span>));  </span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123;  </span><br><span class="line">        bit[p] = (bit[p] + d) % HA;  </span><br><span class="line">        bitt[p] = (bitt[p] + dx) % HA;  </span><br><span class="line">        lb(p, <span class="number">1l</span>l);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这道<code>省选/NOI-</code>的题目就做完了<br>真就评分虚高嗷</p><hr><p>注意几个坑点</p><ol><li>题目的操作是单点覆盖，但是树状数组只能区间加，要先查询一下当前点的值然后加上差值，这个见代码吧</li><li><big><big>取模！取模！取模</big> 修改和查询都要取模！还要注意负数取模的问题！</big></li></ol><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/10/23.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: 区间方差</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x,y) ((x = x + y * (x &amp; (-x))))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> lli HA = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">lli bit[MAXN], bitt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">lli <span class="title">qu</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; lli r = <span class="number">0</span>; <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) &#123; (r += bit[p]) %= HA; lb(p, <span class="number">-1l</span>l); &#125; <span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="function">lli <span class="title">qux</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; lli r = <span class="number">0</span>; <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) &#123; (r += bitt[p]) %= HA; lb(p, <span class="number">-1l</span>l); &#125; <span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> p, lli x)</span> </span>&#123;</span><br><span class="line">    lli d = x - (qu(p) - qu(p - <span class="number">1</span>)), dx = x * x - (qux(p) - qux(p - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123; bit[p] = (bit[p] + d) % HA; bitt[p] = (bitt[p] + dx) % HA; lb(p, <span class="number">1l</span>l); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lli <span class="title">pw</span><span class="params">(lli a, lli b)</span> </span>&#123; lli r = <span class="number">1</span>; <span class="keyword">while</span> (b) &#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>) r = r * a % HA; a = a * a % HA; b &gt;&gt;= <span class="number">1</span>; &#125; <span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="function">lli <span class="title">inv</span><span class="params">(lli a)</span> </span>&#123; <span class="keyword">return</span> pw(a, HA - <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); m = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) mo(i, getint());</span><br><span class="line">    rap (i, <span class="number">1</span>, m, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getint(); <span class="keyword">int</span> x = getint(); <span class="keyword">int</span> y = getint();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) mo(x, y);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lli N = (y - x + <span class="number">1</span>); lli iN = inv(N);</span><br><span class="line">            lli fx = (qu(y) - qu(x - <span class="number">1</span>) + HA) % HA, gx = (qux(y) - qux(x - <span class="number">1</span>) + HA) % HA;</span><br><span class="line">            lli tx = (iN * gx % HA - iN * iN % HA * fx % HA * fx % HA); <span class="keyword">while</span> (tx &lt;= <span class="number">0</span>) tx += HA; tx %= HA;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, tx % HA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>代码也不长啊，不就50行吗</del></p><h1 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h1><p>强化版：<a href="https://www.luogu.org/problem/P1471" target="_blank" rel="noopener">洛谷P1471《方差》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简单的数据结构题目以及无处不在的取模&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://blog.handwer-std.top/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 453A《Little Pony and Expected Maximum》</title>
    <link href="https://blog.handwer-std.top/2019-10-25/CF453A/"/>
    <id>https://blog.handwer-std.top/2019-10-25/CF453A/</id>
    <published>2019-10-25T13:01:46.000Z</published>
    <updated>2019-10-25T13:59:19.035Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单期望题目</p></blockquote><a id="more"></a><h1 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h1><blockquote><p>翻译来自洛谷</p></blockquote><p>暮暮刚刚在和她的朋友——AJ（苹果杰克）、FS（小蝶）、RD（云宝黛西）玩Ludo游戏。但是她马品没攒够总是输。回到城堡过后，她对游戏用的骰子产生了兴趣。</p><p>题目描述</p><p>这个骰子有M面：骰子的第一面有一个点，第二面有两个点，以此类推，第m面含有M点。暮暮确信的是，当掷骰子时，每一面都有1/m的可能性出现，并且每次投掷的概率都是都是独立的。请你帮助她计算掷N次骰子后每次得到的点数中最大值的期望。</p><p>输入输出格式</p><p>输入格式：</p><p>一行两个整数 m 和 n (1 ≤ m, n ≤ 10^5).</p><p>输出格式：</p><p>输出一行一个实数，与答案误差不大于10^-4</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 1</span><br></pre></td></tr></table></figure></p><p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.500000000000</span><br></pre></td></tr></table></figure></p><p><strong>输入 #2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 3</span><br></pre></td></tr></table></figure></p><p><strong>输出 #2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.958333333333</span><br></pre></td></tr></table></figure></p><p><strong>输入 #3</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure></p><p><strong>输出 #3</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.750000000000</span><br></pre></td></tr></table></figure></p><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>Consider the third test example. If you’ve made two tosses:</p><ol><li>You can get 1 in the first toss, and 2 in the second. Maximum equals to 2.</li><li>You can get 1 in the first toss, and 1 in the second. Maximum equals to 1.</li><li>You can get 2 in the first toss, and 1 in the second. Maximum equals to 2.</li><li>You can get 2 in the first toss, and 2 in the second. Maximum equals to 2.</li></ol><p>The probability of each outcome is 0.25, that is expectation equals to:<br>$(2+1+2+2) \cdot 0.25=\frac{7}{4}$<br>You can read about expectation using the following link: <a href="http://en.wikipedia.org/wiki/Expected_value" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Expected_value</a></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>代码里什么都有</p><p>期望的公式是 $E(x) = \sum P(x = i) \times i$</p><p>顺便把注释里的两个式子渲染一下：</p><script type="math/tex; mode=display">ans = {\sum_{i = 1}^{m} i \times [i^n - (i - 1)^n] \over m^n}</script><script type="math/tex; mode=display">ans = \sum_{i = 1}^{m} i \times \big[\big({i \over m}\big)^n - \big({i - 1 \over m}\big)^n\big]</script><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">fp</span><span class="params">(db a, <span class="keyword">int</span> b)</span> </span>&#123; db r = <span class="number">1</span>; <span class="keyword">while</span> (b) &#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>) r = r * a; a = a * a; b &gt;&gt;= <span class="number">1</span>; &#125; <span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 掷 n 次骰子，最大点数不超过 k 的方案数为 k^n</span></span><br><span class="line"><span class="comment"> * 掷 n 次骰子，最大点数不超过 k - 1 的方案数为 (k - 1)^n</span></span><br><span class="line"><span class="comment"> * 减一下就可以知道最大点数为 k 的方案数</span></span><br><span class="line"><span class="comment"> * 然后套一下期望的公式就可以知道</span></span><br><span class="line"><span class="comment"> * ans = &#123;\sum_&#123;i = 1&#125;^&#123;m&#125; i \times [i^n - (i - 1)^n] \over m^n&#125;</span></span><br><span class="line"><span class="comment"> * 整理一下得到</span></span><br><span class="line"><span class="comment"> * ans = \sum_&#123;i = 1&#125;^&#123;m&#125; i \times \big[\big(&#123;i \over m&#125;\big)^n - \big(&#123;i - 1 \over m&#125;\big)^n\big]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">double</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        db d = fp(((<span class="keyword">double</span>) i * <span class="number">1.0</span>) / ((<span class="keyword">double</span>) m * <span class="number">1.0</span>), n);</span><br><span class="line">        ans = ans + ((<span class="keyword">double</span>) i * <span class="number">1.0</span>) * (d - last);</span><br><span class="line">        last = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%0.12lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;简单期望题目&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Codeforces" scheme="https://blog.handwer-std.top/tags/Codeforces/"/>
    
      <category term="概率与期望" scheme="https://blog.handwer-std.top/tags/%E6%A6%82%E7%8E%87%E4%B8%8E%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1074《靶型数独》</title>
    <link href="https://blog.handwer-std.top/2019-10-20/LuoguP1074/"/>
    <id>https://blog.handwer-std.top/2019-10-20/LuoguP1074/</id>
    <published>2019-10-20T11:01:13.000Z</published>
    <updated>2019-10-20T11:17:19.673Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于常识的搜索顺序优化</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。</p><p>靶形数独的方格同普通数独一样，在  99  格宽×99  格高的大九宫格中有99  个  33  格宽×33  格高的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入  11  到  99的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）</p><p><img src="https://cdn.luogu.com.cn/upload/pic/28.png" alt></p><p>上图具体的分值分布是：最里面一格（黄色区域）为  1010  分，黄色区域外面的一圈（红色区域）每个格子为99分，再外面一圈（蓝色区域）每个格子为88  分，蓝色区域外面一圈（棕色区域）每个格子为77分，最外面一圈（白色区域）每个格子为66分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和</p><p>总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。</p><p><img src="https://cdn.luogu.com.cn/upload/pic/29.png" alt></p><p>由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一共  99  行。每行99个整数（每个数都在  0-90−9  的范围内），表示一个尚未填满的数独方格，未填的空格用“00”表示。每两个数字之间用一个空格隔开。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出共  11  行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数-1−1。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">7 0 0 9 0 0 0 0 1 </span><br><span class="line">1 0 0 0 0 5 9 0 0 </span><br><span class="line">0 0 0 2 0 0 0 8 0 </span><br><span class="line">0 0 5 0 2 0 0 0 3 </span><br><span class="line">0 0 0 0 0 0 6 4 8 </span><br><span class="line">4 1 3 0 0 0 0 0 0 </span><br><span class="line">0 0 7 0 0 2 0 9 0 </span><br><span class="line">2 0 1 0 6 0 8 0 4 </span><br><span class="line">0 8 0 5 0 4 0 1 2</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong>复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2829</span><br></pre></td></tr></table></figure></p><p><strong>输入 #2</strong>复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 7 0 2 4 5 3 </span><br><span class="line">9 0 0 0 0 8 0 0 0 </span><br><span class="line">7 4 0 0 0 5 0 1 0 </span><br><span class="line">1 9 5 0 8 0 0 0 0 </span><br><span class="line">0 7 0 0 0 0 0 2 5 </span><br><span class="line">0 3 0 5 7 9 1 0 8 </span><br><span class="line">0 0 0 6 0 1 0 0 0 </span><br><span class="line">0 6 0 9 0 0 0 0 1 </span><br><span class="line">0 0 0 0 0 0 0 0 6</span><br></pre></td></tr></table></figure></p><p><strong>输出 #2</strong>复制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2852</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>拿到题目：<br>这啥啊。。。不是很会啊。。。暴搜估计搜不过去啊。。。</p><p>无奈之下看了一眼题解，忽然就想起来了自己以前填数独的技巧。</p><hr><p>填数独有一个技巧，就是提前填工作量最小的地方，也就是<strong>优先填数最满的地方</strong></p><p>确定这个搜索顺序之后这个题就差不多做完了</p><hr><p>分别开三个数组记录这一行某一个数字是否被填过，这一列某一个数字是否被填过，这一个宫是否被填过</p><p>每次搜索记录当前搜到了哪个点，枚举当前格子是填 1-9 中哪个数字，搜一搜就好了</p><hr><p>搜索顺序如何求出？<br>再开俩数组分别记录每一行填了多少数字，每一列填了多少数字，转移时先枚举填的数字最多的行，然后在这一行中确定<strong>没填过的</strong>格子对应的填的数字最多的列，下一次搜索的时候就搜行列相交处的格子</p><p>建议配合代码理解</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><del>我写完代码之后才发觉 line 和 row 都是「行」的意思。。</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">9</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> weight[<span class="number">11</span>][<span class="number">11</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> area[<span class="number">11</span>][<span class="number">11</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Order</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, siz;</span><br><span class="line">    Order(<span class="keyword">int</span> _id = <span class="number">0</span>, <span class="keyword">int</span> _siz = <span class="number">0</span>) : id(_id), siz(_siz) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Order &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> siz &gt; that.siz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; order[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">9</span>, sd[MAXN][MAXN], linesiz[MAXN], rowsiz[MAXN];</span><br><span class="line"><span class="keyword">bool</span> lineUsed[MAXN][<span class="number">10</span>], rowUsed[MAXN][<span class="number">10</span>], areaUsed[MAXN][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, vis = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, sd[i][j], j == n ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">placeNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    sd[x][y] = num;</span><br><span class="line">    ++linesiz[x]; ++rowsiz[y];</span><br><span class="line">    lineUsed[x][num] = rowUsed[y][num] = <span class="literal">true</span>;</span><br><span class="line">    areaUsed[area[x][y]][num] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displaceNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    sd[x][y] = <span class="number">0</span>;</span><br><span class="line">    --linesiz[x]; --rowsiz[y];</span><br><span class="line">    lineUsed[x][num] = rowUsed[y][num] = <span class="literal">false</span>;</span><br><span class="line">    areaUsed[area[x][y]][num] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> line = <span class="number">0</span>, <span class="keyword">int</span> row = <span class="number">0</span>, <span class="keyword">int</span> totalPlaced = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (totalPlaced == <span class="number">81</span>) &#123;</span><br><span class="line">        vis = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                fans += sd[i][j] * weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        print();</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; fans &lt;&lt; endl;</span></span><br><span class="line">        ans = <span class="built_in">std</span>::max(ans, fans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; ++num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lineUsed[line][num]</span><br><span class="line">        || rowUsed[row][num]</span><br><span class="line">        || areaUsed[area[line][row]][num]) <span class="keyword">continue</span>;</span><br><span class="line">        placeNum(line, row, num);</span><br><span class="line">        <span class="keyword">int</span> nextLine = <span class="number">0</span>, maxSize = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxSize &lt; linesiz[i] &amp;&amp; linesiz[i] != <span class="number">9</span>) &#123;</span><br><span class="line">                maxSize = linesiz[i]; nextLine = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextRow = <span class="number">0</span>; maxSize = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxSize &lt; rowsiz[i] &amp;&amp; !sd[nextLine][i]) &#123;</span><br><span class="line">                maxSize = rowsiz[i]; nextRow = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        printf("\nModified &lt;%d,%d&gt;: %d\n", line, row, sd[line][row]);</span></span><br><span class="line"><span class="comment">//        print();</span></span><br><span class="line">        DFS(nextLine, nextRow, totalPlaced + <span class="number">1</span>);</span><br><span class="line">        displaceNum(line, row, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSiz1 = <span class="number">-1</span>, lc = <span class="number">0</span>, maxSiz2 = <span class="number">-1</span>, rc = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            sd[i][j] = getint();</span><br><span class="line">            <span class="keyword">if</span> (sd[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cnt += (sd[i][j] &gt; <span class="number">0</span>);</span><br><span class="line">            linesiz[i] += (sd[i][j] &gt; <span class="number">0</span>);</span><br><span class="line">            rowsiz[j] += (sd[i][j] &gt; <span class="number">0</span>);</span><br><span class="line">            lineUsed[i][sd[i][j]]</span><br><span class="line">            = rowUsed[j][sd[i][j]] = <span class="literal">true</span>;</span><br><span class="line">            areaUsed[area[i][j]][sd[i][j]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxSiz1 &lt; linesiz[i] &amp;&amp; linesiz[i] != <span class="number">9</span>) &#123;</span><br><span class="line">            lc = i; maxSiz1 = linesiz[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSiz2 &lt; rowsiz[i] &amp;&amp; !sd[lc][i]) &#123;</span><br><span class="line">            rc = i; maxSiz2 = rowsiz[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(lc, rc, cnt);</span><br><span class="line">    <span class="keyword">if</span> (!vis) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;基于常识的搜索顺序优化&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="搜索" scheme="https://blog.handwer-std.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P4514《上帝造题的七分钟》</title>
    <link href="https://blog.handwer-std.top/2019-10-20/LuoguP4514/"/>
    <id>https://blog.handwer-std.top/2019-10-20/LuoguP4514/</id>
    <published>2019-10-20T10:55:29.000Z</published>
    <updated>2019-10-20T11:15:30.474Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二维树状数组</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>“第一分钟，X说，要有矩阵，于是便有了一个里面写满了0的n×m矩阵。<br>第二分钟，L说，要能修改，于是便有了将左上角为(a,b)，右下角为(c,d)的一个矩形区域内的全部数字加上一个值的操作。<br>第三分钟，k说，要能查询，于是便有了求给定矩形区域内的全部数字和的操作。<br>第四分钟，彩虹喵说，要基于二叉树的数据结构，于是便有了数据范围。<br>第五分钟，和雪说，要有耐心，于是便有了时间限制。<br>第六分钟，吃钢琴男说，要省点事，于是便有了保证运算过程中及最终结果均不超过32位有符号整数类型的表示范围的限制。<br>第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”<br>——《上帝造裸题的七分钟》<br>所以这个神圣的任务就交给你了。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入数据的第一行为<code>X n m</code>，代表矩阵大小为n×m。<br>从输入数据的第二行开始到文件尾的每一行会出现以下两种操作：</p><ul><li><code>L a b c d delta</code>  —— 代表将(a,b),(c,d)为顶点的矩形区域内的所有数字加上delta。</li><li><code>k a b c d</code>  —— 代表求(a,b),(c,d)为顶点的矩形区域内所有数字的和。</li></ul><p>请注意，kk为小写。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>针对每个k操作，在单独的一行输出答案。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X 4 4</span><br><span class="line">L 1 1 3 3 2</span><br><span class="line">L 2 2 4 4 1</span><br><span class="line">k 2 2 3 3</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>不多说了。。。</p><p>就是一个支持矩阵的子矩阵加减、子矩阵和查询的树状数组模板题</p><p>讲解见<a href="https://blog.handwer-std.top/2019-10-17/BinaryIndexedTree/#子矩阵加减、子矩阵和查询">这里</a>吧</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>代码也不放了。。上面的链接给的代码就是这题的 AC 代码</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;二维树状数组&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P4145《上帝造题的七分钟2 / 花神游历各国》</title>
    <link href="https://blog.handwer-std.top/2019-10-20/LuoguP4145/"/>
    <id>https://blog.handwer-std.top/2019-10-20/LuoguP4145/</id>
    <published>2019-10-20T10:43:50.000Z</published>
    <updated>2019-10-20T11:19:01.367Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你会支持区间开平方的数据结构吗？</p></blockquote><a id="more"></a><h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>XLk觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>“第一分钟，X说，要有数列，于是便给定了一个正整数数列。</p><p>第二分钟，L说，要能修改，于是便有了对一段数中每个数都开平方(下取整)的操作。</p><p>第三分钟，k说，要能查询，于是便有了求一段数的和的操作。</p><p>第四分钟，彩虹喵说，要是noip难度，于是便有了数据范围。</p><p>第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。</p><p>第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过64位有符号整数类型的表示范围的限制。</p><p>第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”</p><p>——《上帝造题的七分钟·第二部》</p><p>所以这个神圣的任务就交给你了。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行一个整数n，代表数列中数的个数。</p><p>第二行n个正整数，表示初始状态下数列中的数。</p><p>第三行一个整数m，表示有m次操作。</p><p>接下来m行每行三个整数<code>k,l,r</code>，</p><ul><li><code>k=0</code>表示给[l,r]中的每个数开平方(下取整)</li><li><code>k=1</code>表示询问[l,r]中各个数的和。</li></ul><p><strong>数据中有可能l&gt;r，所以遇到这种情况请交换l和r</strong>。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>对于询问操作，每行输出一个回答。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong>复制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">5</span><br><span class="line">0 1 10</span><br><span class="line">1 1 10</span><br><span class="line">1 1 5</span><br><span class="line">0 5 8</span><br><span class="line">1 4 8</span><br></pre></td></tr></table></figure></p><p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">19</span><br><span class="line">7</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我不会支持区间开方的数据结构。怎么办呢？</p><p>一个<del>很容易发现的</del>事实是题目给的所有数最多被开方6次（原题数据范围1e12）。为什么呢？</p><p><img src="https://s2.ax1x.com/2019/10/20/KMPKDH.png" alt="KMPKDH.png"></p><p>懂了吧</p><hr><p>所以开方操作直接暴力修改就好。每次修改之前查询一下这个块的最大值是不是1，是的话就不去开方这个区间了，这样跑的飞快</p><p>查询操作就是正常的不带 lazy tag 的查询函数</p><p>还有一个坑点就是 l 和 r 的大小关系，这个注意一下就好了</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: 上帝造题的七分钟2 / 花神游历各国</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> down(a,t,s,i) for (int a = t; a &gt;= s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">lli osq[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SegmentTree &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (root &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (root &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line">    lli sum[MAXN &lt;&lt; <span class="number">2</span>], max[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function">    </span>&#123; sum[root] = sum[lson] + sum[rson]; max[root] = <span class="built_in">std</span>::max(max[lson], max[rson]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="keyword">void</span>) (sum[root] = max[root] = osq[l]);</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        buildTree(lson, l, mid); buildTree(rson, mid + <span class="number">1</span>, r);</span><br><span class="line">        update(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            sum[root] = max[root] = <span class="built_in">sqrt</span>(sum[root]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= mid &amp;&amp; max[lson] &gt; <span class="number">1</span>)</span><br><span class="line">            modify(ll, rr, lson, l, mid);</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= rr &amp;&amp; max[rson] &gt; <span class="number">1</span>)</span><br><span class="line">            modify(ll, rr, rson, mid + <span class="number">1</span>, r);</span><br><span class="line">        update(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">lli <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> sum[root];</span><br><span class="line">        lli rt = <span class="number">0</span>; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= mid) rt += querySum(ll, rr, lson, l, mid);</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= rr) rt += querySum(ll, rr, rson, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) osq[i] = getll();</span><br><span class="line">    SegmentTree::buildTree();</span><br><span class="line">    m = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, m, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmd = getint();</span><br><span class="line">        <span class="keyword">int</span> l = getint(); <span class="keyword">int</span> r = getint();</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="built_in">std</span>::swap(l, r);</span><br><span class="line">        <span class="keyword">if</span> (!cmd) SegmentTree::modify(l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, SegmentTree::querySum(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;你会支持区间开平方的数据结构吗？&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="暴力" scheme="https://blog.handwer-std.top/tags/%E6%9A%B4%E5%8A%9B/"/>
    
      <category term="线段树" scheme="https://blog.handwer-std.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「初赛」康托展开学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-10-17/Cantor-Expansion/"/>
    <id>https://blog.handwer-std.top/2019-10-17/Cantor-Expansion/</id>
    <published>2019-10-17T08:56:54.000Z</published>
    <updated>2019-11-03T09:33:39.409Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>康托展开</strong>是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</p><p style="text-align: right">——Wikipedia</p><a id="more"></a><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>直接给式子吧</p><p>对于一个长度为 $n$ 的排列，它在全排列中的排名为</p><script type="math/tex; mode=display">x=1+a_{n}(n-1) !+a_{n-1}(n-2) !+\cdots+a_{1} \cdot 0 !</script><p>其中$a_i$为给定排列前 $i - 1$个数中 <strong>小于 $a_i$ 的</strong> <em>没有出现的</em> 数的数量</p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t = &#123;1, 6, 4, 5, 3, 2&#125;</span><br><span class="line">那么</span><br><span class="line">a = &#123;0, 4&lt;2,3,4,5&gt;, 2&lt;2,3&gt;, 2&lt;2,3&gt;, 1&lt;2&gt;, 0&#125;</span><br><span class="line">其中&lt;&gt;里具体说明了是哪几个数</span><br><span class="line">此时 x = 114</span><br></pre></td></tr></table></figure></p><p>另外，$x-1$就是有多少个排列比给定排列要小。这个很显然。</p><h1 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h1><p>前面说了是可逆的，那么说一说怎么逆回去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">如n=5,x=96时：</span><br><span class="line"></span><br><span class="line">首先用96-1得到95，说明x之前有95个排列.(将此数本身减去1)</span><br><span class="line">用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.</span><br><span class="line">用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.</span><br><span class="line">用5去除2!得到2余1，类似地，这一位是3.</span><br><span class="line">用1去除1!得到1余0，这一位是2.</span><br><span class="line">最后一位只能是1.</span><br><span class="line">所以这个排列是&#123;4, 5, 3, 2, 1&#125;.</span><br><span class="line"></span><br><span class="line">再给一个例子：</span><br><span class="line">n = 6, x = 123</span><br><span class="line">123 / (5!) = 1...3</span><br><span class="line">3 / (4!) = 0...3</span><br><span class="line">...（结果都是0...3）</span><br><span class="line">3 / (2!) = 1...1</span><br><span class="line">1 / (1!) = 1...0</span><br><span class="line">0 / (0!) = 0...0</span><br><span class="line"></span><br><span class="line">所以最终排列为&#123;2, 1, 3, 5, 6, 4&#125;</span><br></pre></td></tr></table></figure><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>写这玩意有什么用？打开NOIP2018提高组初赛第21题看程序写输出，他要求的就是给定排列往后数t个得到的排列</p><p>使用这个方法就可以将给定排列转化为排名，加t之后再转化回排列，进而得到结果</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;康托展开&lt;/strong&gt;是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。&lt;/p&gt;
&lt;p style=&quot;text-align: right&quot;&gt;——Wikipedia&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="学习笔记" scheme="https://blog.handwer-std.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="初赛" scheme="https://blog.handwer-std.top/tags/%E5%88%9D%E8%B5%9B/"/>
    
      <category term="排列" scheme="https://blog.handwer-std.top/tags/%E6%8E%92%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>树状数组学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-10-17/BinaryIndexedTree/"/>
    <id>https://blog.handwer-std.top/2019-10-17/BinaryIndexedTree/</id>
    <published>2019-10-17T07:38:38.000Z</published>
    <updated>2020-01-18T06:26:17.146Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>高效又好写的数据结构</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>树状数组</strong>或<strong>二叉索引树</strong>（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以${\displaystyle O(\log n)}$的时间得到任意前缀和${\displaystyle \sum _{i=1}^{j}A[i],1\le j\le N}$!，并同时支持在${\displaystyle O(\log n)}$时间内支持动态单点值的修改。空间复杂度${\displaystyle O(n)}$。</p><p style="text-align: right">——Wikipedia</p><p>简单的说，树状数组就是一个便于在 $O(\log n)$ 时间内维护一个数列 / 矩阵的前缀和，可以支持单点修改、查询，区间修改、查询的数据结构。</p><p>依据支持操作的不同（包含关系），我这里把它分为六类：</p><ul><li>支持序列单点加减、区间和查询的树状数组</li><li>支持序列区间加减、单点查询的树状数组</li><li>支持序列区间加减、区间和查询的树状数组</li><li>支持矩阵单点加减、子矩阵和查询的树状数组</li><li>支持矩阵的子矩阵加减、单点查询的树状数组</li><li>支持矩阵的子矩阵加减、子矩阵和查询的树状数组</li></ul><p>这些会一个一个的讲。</p><h1 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h1><h2 id="单点加减、区间和查询"><a href="#单点加减、区间和查询" class="headerlink" title="单点加减、区间和查询"></a>单点加减、区间和查询</h2><p>这个是最基础的树状数组，应该没有人不会吧……</p><p>原理就是通过维护前缀和，修改的时候像暴力维护前缀和一样一个一个往后加，不过每次增长的值不是1而是lowbit，其中“一个数取lowbit能跳到哪”这个关系连边后就形成了一个二叉搜索树。</p><blockquote><p>按照Peter M. Fenwick的说法，正如所有的整数都可以表示成2的幂和，我们也可以把一串序列表示成一系列子序列的和。采用这个想法，我们可将一个前缀和划分成多个子序列的和，而划分的方法与数的2的幂和具有极其相似的方式。一方面，子序列的个数是其二进制表示中1的个数，另一方面，子序列代表的f[i]的个数也是2的幂。</p><p style="text-align: right">——Wikipedia</p></blockquote><p><img src="https://s2.ax1x.com/2019/10/17/KAb2Se.png" alt="KAb2Se.png"></p><p>比如说这一棵就是八个元素的树状数组，对照下面的表可以发现上面的连边规律（点下面的是编号，请自动忽略根节点 9 以及那条边）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1&apos;s lowbit = 1, 1 + lowbit = 2</span><br><span class="line">2&apos;s lowbit = 2, 2 + lowbit = 4</span><br><span class="line">3&apos;s lowbit = 1, 3 + lowbit = 4</span><br><span class="line">4&apos;s lowbit = 4, 4 + lowbit = 8</span><br><span class="line">5&apos;s lowbit = 1, 5 + lowbit = 6</span><br><span class="line">6&apos;s lowbit = 2, 6 + lowbit = 8</span><br><span class="line">7&apos;s lowbit = 1, 7 + lowbit = 8</span><br><span class="line">8&apos;s lowbit = 8, 8 + lowbit = 16</span><br><span class="line">9&apos;s lowbit = 1, 9 + lowbit = 10</span><br><span class="line">10&apos;s lowbit = 2, 10 + lowbit = 12</span><br></pre></td></tr></table></figure><p>那么代码就很容易写出来了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, tree[MAX_SIZE];</span><br><span class="line"><span class="comment">// n 为元素个数，tree[] 为树状数组维护的前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x) &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 pos 位置的数加上 x</span></span><br><span class="line">    <span class="keyword">for</span> (; pos &lt;= n; pos += lowbit(pos)) tree[pos] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询 [1,pos] 之间的数的和</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; pos &gt;= <span class="number">1</span>; pos -= lowbit(pos)) ret += tree[pos];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeQuery</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询 [l,r] 之间的数的和</span></span><br><span class="line">    <span class="keyword">return</span> Query(r) - Query(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间加减、单点查询"><a href="#区间加减、单点查询" class="headerlink" title="区间加减、单点查询"></a>区间加减、单点查询</h2><p>不知道你们有没有听说过一个东西叫做「差分」</p><p>定义差分数组 <code>d[i] = a[i] - a[i - 1]</code>，其中 <code>a[]</code> 表示原数列<br>那么对 <code>d[i]</code> 求一个前缀和就可以得出 <code>a[i]</code>的值了<br>举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组下标从 0 开始，元素存储从 1 开始，a[0] = d[0] = 0</span><br><span class="line">a[] = &#123;0, 1, 3, 4, 2&#125;</span><br><span class="line">d[] = &#123;/, 1, 2, 2, -2&#125;</span><br></pre></td></tr></table></figure></p><p>发现了什么？</p><script type="math/tex; mode=display">\sum_{i = 1}^{n} d_i = a_i</script><p>如何修改$\text{[L,R]}+x$？<br>先给结论：在$\text{L}$处$+x$，在$\text{R+1}$处$-x$<br>直观理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">下标从 1 开始。</span><br><span class="line">原数列：0 0 0 0 0 0</span><br><span class="line">按照上面的方法 [2,4]+x</span><br><span class="line">0 x 0 0 -x 0</span><br><span class="line">看看前缀和之后会发生什么……</span><br><span class="line">0 x x x 0 0</span><br><span class="line">！！！！！</span><br></pre></td></tr></table></figure></p><hr><p>而维护前缀和这种事情，树状数组最在行了</p><p>可以写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, a[MAXN], bit[MAXN];  </span><br><span class="line"><span class="comment">// n 为元素个数，a 为原数组，bit 为差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (; pos &lt;= n; pos += lowbit(pos)) bit[pos] += x;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rangeModify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Modify(l, x); Modify(r + <span class="number">1</span>, -x);</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (; pos &gt;= <span class="number">1</span>; pos -= lowbit(pos)) ret += bit[pos];  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> to n increase <span class="number">1</span>) &#123;  </span><br><span class="line">        read a[i]</span><br><span class="line">        rangeModify(i, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    read x, read y, read k </span><br><span class="line">    rangeModify(x, y, k);</span><br><span class="line">    <span class="comment">// 将 [x,y] 区间内的数加上 k  </span></span><br><span class="line">    ...</span><br><span class="line">    read k</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(k));  </span><br><span class="line">    <span class="comment">// 查询 k 位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间加减、区间和查询"><a href="#区间加减、区间和查询" class="headerlink" title="区间加减、区间和查询"></a>区间加减、区间和查询</h2><p><del>线段树天下第一</del><br>但是线段树难写、难调，常数还大，占空间还多。。。</p><p>如果你只需要区间加减、区间和查询，树状数组无疑是你最好的选择</p><hr><p>区间加减维护一下差分数组就行了</p><p>考虑区间和本质是</p><script type="math/tex; mode=display">\sum_{a = 1}^{p}\sum_{i = 1}^{a}d_i</script><p>计算一下每个 $d_i$ 被算的次数，顺便把式子变换一下</p><script type="math/tex; mode=display">\sum_{a = 1}^{p}d_a \times (p - a + 1)</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">举个例子</span><br><span class="line">比如说 p = 5 时，可以发现 </span><br><span class="line">ans = </span><br><span class="line">d[1] + </span><br><span class="line">d[1] + d[2] +</span><br><span class="line">d[1] + d[2] + d[3] + </span><br><span class="line">d[1] + d[2] + d[3] + d[4] + </span><br><span class="line">d[1] + d[2] + d[3] + d[4] + d[5]</span><br><span class="line">找一找规律就可以搞出上面的式子了</span><br></pre></td></tr></table></figure><p>拆一下 $\sum$，可以变换成</p><script type="math/tex; mode=display">(p + 1)\sum_{a = 1}^{p}d_a - \sum_{a = 1}^{p}d_a \times a</script><p>这样的话，只需要分别维护两个差分数组，一个记 $d_a$，一个记 $d_a \times a$ 就行</p><p>修改$\text{[L,R] + }x$的时候，像上面<a href="#区间加减、单点查询">区间加减、单点查询</a>一样，把 $\text{[L]} + x,\text{[R+1]} - x$（对两个数组进行的修改可以合并到 <code>Modify()</code> 函数中，具体见代码）<br>查询的时候像上面<a href="#单点加减、区间和查询">单点加减、区间和查询</a>一样，是前缀和作差</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码没有经过提交，仅进行了一些小样例测试！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;  </span><br><span class="line">lli ss[MAXN];  </span><br><span class="line">lli biti[MAXN], bitpi[MAXN];</span><br><span class="line"><span class="comment">// ss 表示原数组，biti 表示维护 d[a] 的数组， bitpi 表示维护 d[a] * a 的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> pos, lli x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> dx = pos;  </span><br><span class="line">    <span class="keyword">for</span> (; pos &lt;= n; pos += lowbit(pos)) &#123;  </span><br><span class="line">        <span class="comment">// 为了方便，可以把 rangeModify() 里的乘法挪到 Modify() 里面</span></span><br><span class="line">        biti[pos] += x; bitpi[pos] += x * <span class="number">1l</span>l * dx;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rangeModify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, lli x)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 这是把括号里的乘法挪到 Modify() 里面的写法</span></span><br><span class="line">    Modify(l, x); Modify(r + <span class="number">1</span>, -x);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function">lli <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;  </span><br><span class="line">    lli ret = <span class="number">0</span>, dx = pos;  </span><br><span class="line">    <span class="keyword">while</span> (pos &gt;= <span class="number">1</span>) &#123; ret += (dx + <span class="number">1</span>) * <span class="number">1l</span>l * biti[pos] - bitpi[pos]; pos -= lowbit(pos); &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function">lli <span class="title">rangeQuery</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> Query(r) - Query(l - <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h1><p>一维的操作都讲完了，那能不能把它推广到二维上面呢？答案是肯定的。<br>提前说一句，以下操作从访问$n$个元素变成了$nm$个元素，时间复杂度变为$O(\log(nm))$</p><h2 id="单点加减、子矩阵和查询"><a href="#单点加减、子矩阵和查询" class="headerlink" title="单点加减、子矩阵和查询"></a>单点加减、子矩阵和查询</h2><p>前面说过，树状数组是利用前缀和的思想进行实现的，既然二维也有前缀和，何不照葫芦画瓢把而为树状数组搞出来呢？</p><hr><p>先来复习一下。</p><script type="math/tex; mode=display">\sum_{i = l}^{r} a_i = \sum_{i = 1}^{r} a_i - \sum_{i = 1}^{l - 1} a_i</script><p>为了方便，定义 <script type="math/tex">f(x,y)=\sum_{i = 1}^{x} \sum_{j = 1}^{y} a_{i,j}</script></p><script type="math/tex; mode=display">\sum_{i = x_1}^{x_2}\sum_{j = y_1}^{y_2}a_{i,j}=f(x_2,y_2)-f(x_1 - 1,y_2)-f(x_2,y_1-1)+f(x_1-1,y_1-1)</script><p>直观来看，</p><p><img src="https://s2.ax1x.com/2019/10/17/KE3Zkj.png" alt="KE3Zkj.png"></p><p>定义$\text{Sum}(a,b,c,d)$为以$(a,b)$为左下角，$(c,d)$为右上角（对于矩阵是反着的）的矩阵元素之和，那么很显然能看出 $\text{Sum}(5,4,7,5)=\text{Sum}(1,1,7,5)-\text{Sum}(1,1,7,3)-\text{Sum}(1,1,4,5)+\text{Sum}(1,1,4,3)$，也就是四边形$\text{ABCD}-\text{ABGI}-\text{AHFD}+\text{AHEI}$元素的值</p><p>二维树状数组和一位的除了多了一维之外没多大区别，手法从一维前缀和换到了二维前缀和</p><p>看代码就知道了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码没有经过提交，仅进行了一些小样例测试！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, bit[MAXN][MAXN];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 是不是和一维的手法差不多（逃</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += lowbit(x)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fy = y; fy &lt;= m; fy += lowbit(fy)) &#123;  </span><br><span class="line">            <span class="comment">// 说一个坑：这里不要对 y 进行直接修改</span></span><br><span class="line">            <span class="comment">// 因为下一次循环 x 的时候需要用 y</span></span><br><span class="line">            <span class="comment">// 我当初在这里栽坑调了快 10min。。。</span></span><br><span class="line">            bit[x][fy] += w;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (; x &gt;= <span class="number">1</span>; x -= lowbit(x)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fy = y; fy &gt;= <span class="number">1</span>; fy -= lowbit((fy))) &#123;  </span><br><span class="line">            ans += bit[x][fy];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matrixQuery</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// x1 &lt;= x2, y1 &lt;= y2  </span></span><br><span class="line">    <span class="keyword">int</span> a = Query(x2, y2);  </span><br><span class="line">    <span class="keyword">int</span> b = Query(x1 - <span class="number">1</span>, y2);  </span><br><span class="line">    <span class="keyword">int</span> c = Query(x2, y1 - <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">int</span> d = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> a - b - c + d;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子矩阵加减、单点查询"><a href="#子矩阵加减、单点查询" class="headerlink" title="子矩阵加减、单点查询"></a>子矩阵加减、单点查询</h2><p>还记得<a href="#区间加减、单点查询">区间加减、单点查询</a>吗？<br>接下来把它推广到二维！</p><hr><p>查询手法一样的，二维前缀和</p><p>如何修改$(x_1,y_1)\text{ to }(x_2,y_2)$？<br>先说结论：<br>$d[x_1][y_1] + x,d[x_1][y_2+1]-x,d[x_2+1][y_1]-x,d[x_2+1][y_2+1]+x$<br>直观理解：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">下标从 1 开始</span><br><span class="line">  1 2 3 4 5</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">2 0 0 0 0 0</span><br><span class="line">3 0 0 0 0 0</span><br><span class="line">4 0 0 0 0 0</span><br><span class="line">修改(1,2)-&gt;(4,3) + x</span><br><span class="line">  1  2  3  4  5</span><br><span class="line">1 0  0  0  0  0</span><br><span class="line">2 x  0  0  0 -x</span><br><span class="line">3 0  0  0  0  0</span><br><span class="line">4 -x 0  0  0  x</span><br><span class="line">前缀和：</span><br><span class="line">  1 2 3 4 5</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">2 x x x x 0</span><br><span class="line">3 x x x x 0</span><br><span class="line">4 0 0 0 0 0</span><br></pre></td></tr></table></figure></p><p>放代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码没有经过提交，仅进行了一些小样例测试！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, bit[MAXN][MAXN];  </span><br><span class="line"><span class="comment">// n,m 为矩阵大小，bit 为差分数组</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += lowbit(j)) &#123;  </span><br><span class="line">            bit[i][j] += w;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrixModify</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// x1 &lt;= x2  </span></span><br><span class="line">    Modify(x1, y1, w); Modify(x1, y2 + <span class="number">1</span>, -w);  </span><br><span class="line">    Modify(x2 + <span class="number">1</span>, y1, -w); Modify(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>, w);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i -= lowbit(i)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &gt;= <span class="number">1</span>; j -= lowbit(j)) &#123;  </span><br><span class="line">            ret += bit[i][j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子矩阵加减、子矩阵和查询"><a href="#子矩阵加减、子矩阵和查询" class="headerlink" title="子矩阵加减、子矩阵和查询"></a>子矩阵加减、子矩阵和查询</h2><p>最后一种操作，也是最难的操作</p><p>……其实并不难，如果你把前面都学懂了。</p><p>和<a href="#区间加减、区间和查询">区间加减、区间和查询</a>一样，先看看查询操作的本质</p><script type="math/tex; mode=display">\sum_{i=1}^{x} \sum_{j=1}^{y} \sum_{k=1}^{i} \sum_{h=1}^{j} d[h][k]</script><p>先统计一下 $d[i][j]$ 被访问了多少次，然后<big>稍微</big>整理一下式子，变成</p><script type="math/tex; mode=display">{\sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times(x+1-i) \times(y+1-j)} \\= {(x+1)(y+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j]} \\ {-(y+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times i} \\ {-(x+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times j} \\ {\quad+\sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times i \times j}</script><!--![KEdzbq.png](https://s2.ax1x.com/2019/10/17/KEdzbq.png)--><p>所以，实现区修区查需要维护四个差分数组！</p><ul><li>第一个：维护$d[i][j]$</li><li>第二个：维护$d[i][j]\times i$</li><li>第三个：维护$d[i][j]\times j$</li><li>第四个：维护$d[i][j]\times i\times j$</li></ul><p>接下来是<strong>完整</strong>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/10/17.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 洛谷 P4514 《上帝造题的七分钟》</span></span><br><span class="line"><span class="comment">// 常数略大。。开O2过的  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x &amp; (-x)))  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;  </span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2048</span> + <span class="number">10</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> n, m, q;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;  </span><br><span class="line">    <span class="keyword">int</span> d[MAXN][MAXN], di[MAXN][MAXN];  </span><br><span class="line">    <span class="keyword">int</span> dj[MAXN][MAXN], dij[MAXN][MAXN];  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += lowbit(j)) &#123;  </span><br><span class="line">                d[i][j] += w; di[i][j] += w * x;  </span><br><span class="line">                dj[i][j] += w * y; dij[i][j] += w * x * y;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">matrixModify</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">        Modify(x1, y1, w); Modify(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>, w);  </span><br><span class="line">        Modify(x1, y2 + <span class="number">1</span>, -w); Modify(x2 + <span class="number">1</span>, y1, -w);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i -= lowbit(i)) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &gt;= <span class="number">1</span>; j -= lowbit(j)) &#123;  </span><br><span class="line">                ret += d[i][j] * (x + <span class="number">1</span>) * (y + <span class="number">1</span>)  </span><br><span class="line">                       - (y + <span class="number">1</span>) * di[i][j]  </span><br><span class="line">                       - (x + <span class="number">1</span>) * dj[i][j]  </span><br><span class="line">                       + dij[i][j];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">matrixQuery</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = Query(x2, y2);  </span><br><span class="line">        <span class="keyword">int</span> b = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">int</span> c = Query(x1 - <span class="number">1</span>, y2);  </span><br><span class="line">        <span class="keyword">int</span> d = Query(x2, y1 - <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">return</span> a - c - d + b;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _s; <span class="built_in">cin</span> &gt;&gt; _s;  </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;  </span><br><span class="line"><span class="comment">//    rap (i, 1, n, 1) &#123;  </span></span><br><span class="line"><span class="comment">//        rap (j, 1, m, 1) &#123;  </span></span><br><span class="line"><span class="comment">//            int fx = 0;  </span></span><br><span class="line"><span class="comment">//            scanf("%d", &amp;fx);  </span></span><br><span class="line"><span class="comment">//            BIT::matrixModify(i, j, i, j, fx);  </span></span><br><span class="line"><span class="comment">//        &#125;  </span></span><br><span class="line"><span class="comment">//    &#125;  </span></span><br><span class="line">  <span class="keyword">char</span> ch = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch) &#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, d = <span class="number">0</span>;  </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;  </span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'L'</span>) &#123;  </span><br><span class="line">            <span class="keyword">int</span> delta = <span class="number">0</span>;  </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; delta;  </span><br><span class="line">            BIT::matrixModify(a, b, c, d, delta);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line"><span class="comment">//            scanf("\n");  </span></span><br><span class="line"><span class="comment">//            printf("%d\n", BIT::matrixQuery(a, b, c, d));  </span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; BIT::matrixQuery(a, b, c, d) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"><span class="comment">//        getchar();  </span></span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;高效又好写的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://blog.handwer-std.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="树" scheme="https://blog.handwer-std.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>HDU6108《小C的倍数问题》</title>
    <link href="https://blog.handwer-std.top/2019-10-13/HDU6108/"/>
    <id>https://blog.handwer-std.top/2019-10-13/HDU6108/</id>
    <published>2019-10-13T00:08:09.000Z</published>
    <updated>2019-10-16T05:25:23.035Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>真·小学数学</p></blockquote><a id="more"></a><h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>根据小学数学的知识，我们知道一个正整数x是3的倍数的条件是x每一位加起来的和是3的倍数。反之，如果一个数每一位加起来是3的倍数，则这个数肯定是3的倍数。  </p><p>现在给定进制P，求有多少个B满足P进制下，一个正整数是B的倍数的充分必要条件是每一位加起来的和是B的倍数。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数T表示数据组数(1&lt;=T&lt;=20)。  </p><p>接下来T行，每行一个正整数P(2 &lt; P &lt; 1e9)，表示一组询问。</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>对于每组数据输出一行，每一行一个数表示答案。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>小 学 数 学</p><hr><p>考虑$p$进制表示的实质是<br>$x = a<em>1p^n+a_2p^{(n - 1)} + a_3p^{(n - 2)} + \dots + a</em>{n+1}$<br>稍微变形一下</p><script type="math/tex; mode=display">x=a_1(p^n-1)+a_2(p^{n-1}-1)+a_3(p^{n - 3} - 1) + \dots + \sum_{i = 1}^{n + 1}a_i</script><p>然后注意到$p^n - 1=(p - 1)(p^{n - 1} + p^{n - 2} + \dots + 1)$<br>把它代入进去</p><script type="math/tex; mode=display">\begin{aligned}x&=a_1(p - 1)(p^{n - 1} + p^{n - 2} + \dots + 1)\\&+a_2(p - 1)(p^{n - 2} + p^{n - 3} + \dots + 1)\\&+a_3(p - 1)(p^{n - 3} + p^{n - 4} + \dots + 1) + \dots \\&+ \sum_{i = 1}^{n + 1}a_i\end{aligned}</script><p>发现前面几项都有一个 $p - 1$<br>那么，当且仅当$\sum_{i = 1}^{n + 1}a_i$，即 x 各位数字之和 $\equiv 0(\bmod (p - 1))$ 时，$x \equiv 0 (\bmod (p - 1))$</p><p>one more thing<br>对于任意的自然数$a,p$，如果 $a \mod p = 0$，那么有$a \mod x = 0(x \mid p)$</p><p>所以这题的思路已经很明显了，求的就是$p - 1$的因子个数</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fx = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fx); --fx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, fs = <span class="built_in">sqrt</span>(fx); i &lt;= fs; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fx % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ++ans; <span class="keyword">if</span> ((fx / i) != i) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;真·小学数学&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="进制" scheme="https://blog.handwer-std.top/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
</feed>
