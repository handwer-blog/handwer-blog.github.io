<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Handwer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.handwer-std.top/"/>
  <updated>2019-07-12T13:28:29.982Z</updated>
  <id>https://blog.handwer-std.top/</id>
  
  <author>
    <name>Handwer STD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公告栏</title>
    <link href="https://blog.handwer-std.top/2019-10-31/BulletinBoard/"/>
    <id>https://blog.handwer-std.top/2019-10-31/BulletinBoard/</id>
    <published>2019-10-31T12:30:10.000Z</published>
    <updated>2019-07-12T13:28:29.982Z</updated>
    
    <content type="html"><![CDATA[<p><font style="color:#66ccff"></font></p><p><center>这里可能会挂些什么东西。 <br>There may be something here.<br></center><br><br><img src="https://v2.jinrishici.com/one.svg" alt="今日诗词"></p><!--博客累计已突破 100 篇文章--><!--New！[《「文章」百名学生参训 礼堂“变身”教室》](/2019-02-16/SDWC-Article/)-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font style=&quot;color:#66ccff&quot;&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;这里可能会挂些什么东西。 &lt;br&gt;There may be something here.&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://v2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ZROI 918《「良心普及组」黄队的宫殿》</title>
    <link href="https://blog.handwer-std.top/2019-08-13/ZROI918/"/>
    <id>https://blog.handwer-std.top/2019-08-13/ZROI918/</id>
    <published>2019-08-13T13:26:09.000Z</published>
    <updated>2019-08-13T14:20:16.698Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）" />    <label for="pass">密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      本题为权限题目，请输入密码访问。密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）
    
    </summary>
    
    
      <category term="只有经历过的人才知道的世界" scheme="https://blog.handwer-std.top/tags/%E5%8F%AA%E6%9C%89%E7%BB%8F%E5%8E%86%E8%BF%87%E7%9A%84%E4%BA%BA%E6%89%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="https://blog.handwer-std.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>HDU1483《Automatic Correction of Misspellings》</title>
    <link href="https://blog.handwer-std.top/2019-08-08/HDU1483/"/>
    <id>https://blog.handwer-std.top/2019-08-08/HDU1483/</id>
    <published>2019-08-08T15:56:55.000Z</published>
    <updated>2019-08-08T16:00:04.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Some text editors offer a feature to correct words which seem to be written incorrectly. In this problem you are asked to implement a simple Automatic Correction of Misspellings (ACM).  </p><a id="more"></a><p>ACM takes care of the following misspellings of words:  </p><p>1.One letter is missing (e.g., letter is written leter) or too much (e.g., letter is written lettter).<br>2.One letter is wrong (e.g., letter is written ketter)<br>3.The order of two adjacent letters is wrong (e.g., letter is written lettre)  </p><p>ACM is based on a dictionary of known words. When a text contains a word which is not in the dictionary, ACM will try to replace it by a similar word of the dictionary. Two words are similar if we can transform one word into the other by doing exactly one of the misspellings listed above. An unknown word is left unchanged if there is no similar word in the dictionary.  </p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>The first line of the input file will give the number n of words in the dictionary (n ≤ 10000). The next n lines contain the dictionary words. The following line contains an integer q ≤ 1000, the number of query words. The next q lines contain the query words. You may assume that each word in the input consists of 1 to 25 lower case letters (‘a’ to ‘z’).  </p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each query word, print one line with the query word followed by one of the following possibilities:  </p><ol><li>is correct, if the word occurs in the dictionary.  </li><li>is a misspelling of <x>, where <x> is a word of the dictionary similar to the query word, and the query word is not in the dictionary. In the case that there are several possibilities, select the word from the dictionary which appeared earlier in the input.  </x></x></li><li>is unknown, if cases 1 and 2 do not apply.  </li></ol><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">this</span><br><span class="line">is</span><br><span class="line">a</span><br><span class="line">dictionary</span><br><span class="line">that</span><br><span class="line">we</span><br><span class="line">will</span><br><span class="line">use</span><br><span class="line">for</span><br><span class="line">us</span><br><span class="line">6</span><br><span class="line">su</span><br><span class="line">as</span><br><span class="line">the</span><br><span class="line">dictonary</span><br><span class="line">us</span><br><span class="line">willl</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">su is a misspelling of us</span><br><span class="line">as is a misspelling of is</span><br><span class="line">the is unknown</span><br><span class="line">dictonary is a misspelling of dictionary</span><br><span class="line">us is correct</span><br><span class="line">willl is a misspelling of will</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><del>还是从代码里复制过来的（</del></p><p>场上写一个 Trie 写到自闭。。。<br>赛后来补一下</p><p>道理我都懂，但是这题为什么暴力能过。。。</p><p>以下，将字典中的串称作「字典串」，将询问的串称作「匹配串」</p><p>首先扫一遍字典，有相同的直接输出 correct</p><p>然后如果没有相同的，再扫一遍字典，对于每一个字典串，做这样几件事：</p><ol><li>如果字典串和匹配串长度相等，就说明这个匹配串可能是当前字典串的一个错误拼写<br>逐位扫一遍两个串，记一下错误的次数，以及最后一次错误的下标<br>如果错误次数是 1 就直接输出 misspelling，此时匹配串相对于字典串只错了一个字符<br>如果错误次数是 2 就判断一下是否是顺序弄反了，这个用最后一次错误下标很好写，如果是就输出 misspelling<br>否则就凉凉</li><li>如果字典串比匹配串长 1，就说明这个匹配串可能是当前字典串漏了一个字<br>逐位扫一遍字典串，用一个变量 k 记录当前字典串这一位对应的是匹配串的哪一位<br>如果当前的两个串对应字符相等，就让 k 正常加一，否则就不让 k 加一<br>显然如果真的是只漏了一个字，那么最后 k 一定等于匹配串长度，输出 misspelling<br>否则 k 一定不等于匹配串长度（具体会变成什么值我也不大清楚，反正模拟一下就好了）</li><li>如果字典串比匹配串短 1，就说明这个匹配串可能是当前字典串添了一个字<br>仿照着情况 2 做就完事了</li></ol><p>最后如果三种情况都没有，输出 unknown</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU1483.cpp</span></span><br><span class="line"><span class="comment">//  Title: Automatic Correction of Misspellings</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/8.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dict[MAXN];</span><br><span class="line"><span class="keyword">int</span> dictlen[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoCorrectionMachine</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMisspelling</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wrong = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] != m[i]) &#123; ++wrong; pos = i; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wrong == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (wrong == <span class="number">2</span> &amp;&amp; (d[pos] == m[pos - <span class="number">1</span>] &amp;&amp; d[pos - <span class="number">1</span>] == m[pos])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCharacterDeletion</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> lend, <span class="keyword">int</span> lenm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lend; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] != m[k++]) --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == lenm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCharacterAddition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> lend, <span class="keyword">int</span> lenm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenm; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i] != d[k++]) --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == lend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; acm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; dict[i];</span><br><span class="line">        dictlen[i] = (<span class="keyword">int</span>) dict[i].length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> env;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; env;</span><br><span class="line">        <span class="keyword">int</span> lenenv = (<span class="keyword">int</span>) env.length();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; env;</span><br><span class="line">        <span class="keyword">bool</span> cor = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dict[i] == env) &#123; cor = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cor) <span class="built_in">cout</span> &lt;&lt; <span class="string">" is correct\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dictlen[i] == lenenv) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isMisspelling(dict[i], env, lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dictlen[i] == lenenv + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isCharacterDeletion(dict[i], env, dictlen[i], lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dictlen[i] == lenenv - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isCharacterAddition(dict[i], env, dictlen[i], lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n + <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" is unknown\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Description&quot;&gt;&lt;a href=&quot;#Problem-Description&quot; class=&quot;headerlink&quot; title=&quot;Problem Description&quot;&gt;&lt;/a&gt;Problem Description&lt;/h1&gt;&lt;p&gt;Some text editors offer a feature to correct words which seem to be written incorrectly. In this problem you are asked to implement a simple Automatic Correction of Misspellings (ACM).  &lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="暴力" scheme="https://blog.handwer-std.top/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>HDU3183《A Magic Lamp》</title>
    <link href="https://blog.handwer-std.top/2019-08-08/HDU3183/"/>
    <id>https://blog.handwer-std.top/2019-08-08/HDU3183/</id>
    <published>2019-08-08T15:44:15.000Z</published>
    <updated>2019-08-08T15:47:14.778Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Kiki likes traveling. One day she finds a magic lamp, unfortunately the genie in the lamp is not so kind. Kiki must answer a question, and then the genie will realize one of her dreams.  </p><a id="more"></a> <p>The question is: give you an integer, you are allowed to delete exactly m digits. The left digits will form a new integer. You should make it minimum.<br>You are not allowed to change the order of the digits. Now can you help Kiki to realize her dream?  </p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>There are several test cases.<br>Each test case will contain an integer you are given (which may at most contains 1000 digits.) and the integer m (if the integer contains n digits, m will not bigger then n). The given integer will not contain leading zero.  </p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, output the minimum result you can get in one line.<br>If the result contains leading zero, ignore it.  </p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">178543 4 </span><br><span class="line">1000001 1</span><br><span class="line">100001 2</span><br><span class="line">12345 2</span><br><span class="line">54321 2</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">123</span><br><span class="line">321</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然删除从左向右遇到的第一个比下一个数大的数，也就是让最高位最小的过程。那么按这样的策略做 m 次即可获得正确答案，删除后的序列可使用双向链表（STL 里有<code>std::list&lt;int&gt;</code>）来维护。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU3183.cpp</span></span><br><span class="line"><span class="comment">//  Title: A Magic Lamp</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/8.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> charat(x) ((x - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除从左向右遇到的第一个比下一个数大的数</span></span><br><span class="line"><span class="comment"> * 用一个双向链表维护</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) s.length();</span><br><span class="line">        lst.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            lst.insert(lst.end(), s[charat(i)] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.begin(); i != lst.end(); i++) &#123;</span><br><span class="line">                i++; <span class="keyword">if</span> (i == lst.end()) &#123; --i; lst.erase(i); <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">int</span> next = (*i);</span><br><span class="line">                --i;</span><br><span class="line">                <span class="keyword">if</span> (*i &gt; next) &#123; lst.erase(i); <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> fz = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : lst) &#123; <span class="keyword">if</span> (fz &amp;&amp; i == <span class="number">0</span>) <span class="keyword">continue</span>; fz = <span class="literal">false</span>; <span class="built_in">printf</span>(<span class="string">"%d"</span>, i); &#125;</span><br><span class="line">        <span class="keyword">if</span> (fz) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;Kiki likes traveling. One day she finds a magic lamp, unfortunately the genie in the lamp is not so kind. Kiki must answer a question, and then the genie will realize one of her dreams.  &lt;/p&gt;
    
    </summary>
    
    
      <category term="贪心" scheme="https://blog.handwer-std.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 402B《Trees in a Row》</title>
    <link href="https://blog.handwer-std.top/2019-08-07/CF402B/"/>
    <id>https://blog.handwer-std.top/2019-08-07/CF402B/</id>
    <published>2019-08-07T11:59:04.000Z</published>
    <updated>2019-08-07T12:59:17.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h1><p>有n个正整数，可以对一个数进行修改(修改后也是正整数)，要求修改之后满足$a_i+k=a{i+1}$，求最少的修改次数以及具体的修改方案</p><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The Queen of England has n trees growing in a row in her garden. At that, the i-th (1 ≤ i ≤ n) tree from the left has height ai meters. Today the Queen decided to update the scenery of her garden. She wants the trees’ heights to meet the condition: for all i (1 ≤ i &lt; n), ai + 1 - ai = k, where k is the number the Queen chose.</p><p>Unfortunately, the royal gardener is not a machine and he cannot fulfill the desire of the Queen instantly! In one minute, the gardener can either decrease the height of a tree to any positive integer height or increase the height of a tree to any positive integer height. How should the royal gardener act to fulfill a whim of Her Majesty in the minimum number of minutes?</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>The first line contains two space-separated integers: n, k (1 ≤ n, k ≤ 1000). The second line contains n space-separated integers a1, a2, …, an (1 ≤ ai ≤ 1000) — the heights of the trees in the row.</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>In the first line print a single integer p — the minimum number of minutes the gardener needs. In the next p lines print the description of his actions.</p><p>If the gardener needs to increase the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, then print in the corresponding line “+ j x”. If the gardener needs to decrease the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, print on the corresponding line “- j x”.</p><p>If there are multiple ways to make a row of trees beautiful in the minimum number of actions, you are allowed to print any of them.</p><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>input<br>4 1<br>1 2 1 5</p><p>output<br>2</p><ul><li>3 2</li></ul><ul><li>4 1</li></ul><p>input<br>4 1<br>1 2 3 4</p><p>output<br>0</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本文同步发布于<a href="[https://www.luogu.org/blog/handwer-blog/](https://www.luogu.org/blog/handwer-blog/">洛谷博客</a>)</p><hr><p><del>先说点题外话</del></p><p>这道题是我今天（发题解的那一天，2019.08.07）打 ACM 的时候做的，当时看到这题口胡了一下做法，没敢写，交给队友去写了，然后一遍AC</p><p>感谢队友把我带飞</p><hr><p>言归正传。</p><p>考虑枚举第一棵树的高度，因为这样就能直接确定后面的树的高度了 </p><p>然后假设当前枚举第一棵树高度为 $l$，那么第 $i$ 棵树的高度 $h_i$ 就应该是 $l + k(i - 1)$，这个应该很好理解吧，如果不懂可以评论区留个言，我找个时间写一下</p><p>那么再套一层循环，枚举所有的树，如果当前枚举到的第 $i$ 棵树的高度不是 $l + k(i - 1)$，就意味着这棵树需要被修改，需要增高 / 降低的高度是 $\text{abs}(l - k(i - 1))$，需要增高还是降低取决于 $l - k(i - 1)$ 的符号</p><p>统计一下修改了多少次，作为一个方案，最后取一个最优方案的输出就行了</p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXNKH = <span class="number">1000</span> + <span class="number">10</span>; <span class="comment">// the max of n, k, height</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOC = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MODIFY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, ans = <span class="number">0x7f7f7f7f</span>, ansf[MAXNKH][<span class="number">2</span>], p, f[MAXNKH][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> height[MAXNKH];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); k = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) height[i] = getint();</span><br><span class="line">    rap (h1, <span class="number">1</span>, <span class="number">1000</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 枚举第一棵树的高度，可以直接确定后面树的高度</span></span><br><span class="line">        p = <span class="number">0</span>; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] - (i - <span class="number">1</span>) * k != h1) &#123;</span><br><span class="line">            <span class="comment">// 记一下要修改的树的下标和要增加 / 减少的值</span></span><br><span class="line">                f[++p][LOC] = i;</span><br><span class="line">                f[p][MODIFY] = (h1 + (i - <span class="number">1</span>) * k) - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; ans) &#123;</span><br><span class="line">            <span class="comment">// 更优的方案，更新一下</span></span><br><span class="line">            ans = p;</span><br><span class="line">            <span class="built_in">memcpy</span>(ansf, f, <span class="keyword">sizeof</span> f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    rap (i, <span class="number">1</span>, ans, <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%c %d %d\n"</span>, (ansf[i][MODIFY] &lt; <span class="number">0</span> ? <span class="string">'-'</span> : <span class="string">'+'</span>), ansf[i][LOC], <span class="built_in">std</span>::<span class="built_in">abs</span>(ansf[i][MODIFY]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code by Handwer</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Translate&quot;&gt;&lt;a href=&quot;#Translate&quot; class=&quot;headerlink&quot; title=&quot;Translate&quot;&gt;&lt;/a&gt;Translate&lt;/h1&gt;&lt;p&gt;有n个正整数，可以对一个数进行修改(修改后也是正整数)，要求修改之后满足$a_i+k=a{i+1}$，求最少的修改次数以及具体的修改方案&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3177《[HAOI2015]树上染色》</title>
    <link href="https://blog.handwer-std.top/2019-07-31/Luogu-P3177-BZOJ4033/"/>
    <id>https://blog.handwer-std.top/2019-07-31/Luogu-P3177-BZOJ4033/</id>
    <published>2019-07-31T15:30:50.000Z</published>
    <updated>2019-07-31T15:33:23.916Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我推式子推了半个小时。。。</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一棵点数为N的树，树边有边权。给你一个在0~N之内的正整数K，你要在这棵树中选择K个点，将其染成黑色，并</p><p>将其他的N-K个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间距离的和的收益。</p><p>问收益最大值是多少。</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个整数N,K。</p><p>接下来N-1行每行三个正整数fr,to,dis，表示该树中存在一条长度为dis的边(fr,to)。</p><p>输入保证所有点之间是联通的。</p><p>N&lt;=2000,0&lt;=K&lt;=N</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一个正整数，表示收益的最大值。</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 2  </span><br><span class="line">1 2 3  </span><br><span class="line">1 5 1  </span><br><span class="line">2 3 1  </span><br><span class="line">2 4 2</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure><p>【样例解释】<br>将点1,2染黑就能获得最大收益。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应设 $\text{dp[i][j]}$ 表示以 i 为根的子树选 j 个黑点的最大收益<br>但是是错的</p><p>康了一眼<a href="https://www.luogu.org/blog/ahaha254/solution-p3177" target="_blank" rel="noopener">这个</a>我就瞬间明白了<br>关于式子的推导，组成部分的意义，还有循环顺序的选择，这篇文章都讲得很清楚</p><p>老规矩，题解都在代码里</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  BZOJ4033.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2015]树上染色</span></span><br><span class="line"><span class="comment">//  Alternatives: Luogu-P3177</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参考资料：https://www.luogu.org/blog/ahaha254/solution-p3177</span></span><br><span class="line"><span class="comment"> * 关于 val(x,y) 和枚举顺序的解释可以康一康这篇文章</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设 f[i][j] 表示以 i 为根的子树中取了 j 个黑点「对答案的贡献」</span></span><br><span class="line"><span class="comment"> * 转移方程：</span></span><br><span class="line"><span class="comment"> * f[u][j] = max(</span></span><br><span class="line"><span class="comment"> *     f[u][j],</span></span><br><span class="line"><span class="comment"> *     f[u][j - k] + f[v][k] + val(u,v)</span></span><br><span class="line"><span class="comment"> * )</span></span><br><span class="line"><span class="comment"> * 其中 v 是 u 的儿子，k 是枚举出来的</span></span><br><span class="line"><span class="comment"> * j = min(m,size(x)) -&gt; 0, k = 0 -&gt; min(j,size(y))</span></span><br><span class="line"><span class="comment"> * 其中 val(x,y) 表示边 (x,y) 对答案的贡献，它等于</span></span><br><span class="line"><span class="comment"> * 「该边两边黑点数量的乘积 乘以 边长 加上 该边两边白点数量的乘积 乘以 边长」</span></span><br><span class="line"><span class="comment"> * 也就是 val(x,y) = k * (m - k) * weight(x,y) + (size(y) - k) * ((n - m) - (size(y) - k)) * weight(x,y)</span></span><br><span class="line"><span class="comment"> * 其中 m 是总的黑点数，k 是边 (x,y) 另一边的黑点数，那么 (m - k) 就是这一边的黑点数</span></span><br><span class="line"><span class="comment"> * size(y) 是以 y 为根的子树的大小，也就意味着 (size(y) - k) 是另一边的白点数（另一边的肯定不是黑点就是白点）</span></span><br><span class="line"><span class="comment"> * (n - m) 是总的白点数，(size(y) - k) 是另一边的白点数，也就意味着 ((n - m) - (size(y) - k)) 是边 (x,y) 这一边的白点数（白点肯定不在那边就在这边）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    lli w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> v = <span class="number">0</span>, lli w = <span class="number">0</span>) : v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, size[MAXN];</span><br><span class="line">lli dp[MAXN][MAXK];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXK];</span><br><span class="line"><span class="comment">// dp 数组大概 31 MB</span></span><br><span class="line"><span class="comment">// size 数组大概 8 KB</span></span><br><span class="line"><span class="comment">// vis 数组大概 4 MB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    size[root] = <span class="number">1</span>;</span><br><span class="line">    vis[root][<span class="number">0</span>] = vis[root][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i].v;</span><br><span class="line">        <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(next, root);</span><br><span class="line">        size[root] += size[next];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i].v;</span><br><span class="line">        <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">        lli weight = head[root][i].w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">std</span>::min(m, size[root]); j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="built_in">std</span>::min(j, size[next]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= up; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[root][j - k]) <span class="keyword">continue</span>;</span><br><span class="line">                lli val = k * (m - k) * weight + (size[next] - k) * ((n - m) - (size[next] - k)) * weight;</span><br><span class="line">                dp[root][j] = <span class="built_in">std</span>::max(dp[root][j], dp[root][j - k] + dp[next][k] + val);</span><br><span class="line">                vis[root][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); m = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n - <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint(), next = getint(), weight = getint();</span><br><span class="line">        head[prev].push_back(Edge(next, weight));</span><br><span class="line">        head[next].push_back(Edge(prev, weight));</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;我推式子推了半个小时。。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>TopCoder 13955《WalkOverATree》</title>
    <link href="https://blog.handwer-std.top/2019-07-31/TopCoder13955/"/>
    <id>https://blog.handwer-std.top/2019-07-31/TopCoder13955/</id>
    <published>2019-07-31T14:58:03.000Z</published>
    <updated>2019-08-07T13:12:09.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h1><p>Given is a tree on n nodes. The nodes are numbered 0 through n-1. You are given the description of the tree as a int[]  <strong>parent</strong>  with n-1 elements. For each valid i, there is an edge between vertices (i+1) and  <strong>parent</strong>[i].</p><a id="more"></a><p>A person is currently standing in node 0. In a single step, the person can move from its current node to any adjacent node. You are given an int  <strong>L</strong>. The person is allowed to make at most  <strong>L</strong>  steps.</p><p>Return the maximum number of nodes the person can visit during the walk. Node 0 (where the walk starts) and the node where the walk ends count as visited. Each visited node is only counted once, even if it is visited multiple times.</p><h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><p>Class: WalkOverATree<br>Method: maxNodesVisited<br>Parameters: int[], int<br>Returns: int<br>Method signature: int maxNodesVisited(int[] parent, int L)<br>(be sure your method is public)</p><h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><ul><li><p><strong>parent</strong>  will contain between 0 and 49 elements, inclusive.</p></li><li><p>For each i,  <strong>parent</strong>[i] will be between 0 and i, inclusive.</p></li><li><p><strong>L</strong>  will be between 1 and 100, inclusive.</p></li></ul><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>请自行到 vjudge 上寻找</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>英文很好懂，只需人教初二水平（反正我准初三选手看懂了）</p><p>题目大意：<br>给定一棵 n 个点的树，编号 0~n-1。连边方式以输入每个点的父亲给出，对于每个 i，有一条边连接点 (i+1) 和点 father[i]，而且 father[i] 是 (i+1) 的父亲。<br>有一个人站在点 0，可以向四周走不超过 L 步，求出这个人能经过多少不同的点</p><p>这题和 dp 有什么关系吗。。。</p><p>这题的难点大概就是 class 的使用和答案统计了吧</p><p>class 的使用可以参考<a href="https://blog.csdn.net/qq_31908675/article/details/81198751" target="_blank" rel="noopener">这里</a></p><p>答案统计和基本的思路见代码吧</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  TopCoder13955.cpp</span></span><br><span class="line"><span class="comment">//  Title: WalkOverATree</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt;= s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WalkOverATree</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 直接暴力就好了。。。</span></span><br><span class="line"><span class="comment">     * 一遍 DFS 预处理出所有的点的深度（根节点深度为 0）</span></span><br><span class="line"><span class="comment">     * 答案的输出见下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> depthWalk[MAXL];</span><br><span class="line">    <span class="keyword">int</span> maxstep = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>, <span class="keyword">int</span> step = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        depthWalk[root] = step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = head[root][i];</span><br><span class="line">            <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">            DFS(next, root, step + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNodesVisited</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        maxstep = L;</span><br><span class="line">        <span class="keyword">int</span> N = (<span class="keyword">int</span>) father.size() + <span class="number">1</span>; <span class="comment">// 把根节点算上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = N - <span class="number">1</span>; i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = (i + <span class="number">1</span>) + <span class="number">1</span>, next = father[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 编号整体加一</span></span><br><span class="line">            head[prev].push_back(next);</span><br><span class="line">            head[next].push_back(prev);</span><br><span class="line">        &#125;</span><br><span class="line">        DFS();</span><br><span class="line">        ans = *<span class="built_in">std</span>::max_element(depthWalk + <span class="number">1</span>, depthWalk + <span class="number">1</span> + N);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; L) <span class="keyword">return</span> L + <span class="number">1</span>; <span class="comment">// 能走的最长的路径已经超过了 L，直接返回 L + 1（把根节点算上）</span></span><br><span class="line">        ans = <span class="built_in">std</span>::min(N, ans + <span class="number">1</span> + (L - ans) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// ans + 1：走过的最长路径加上根节点</span></span><br><span class="line">        <span class="comment">// L - ans：剩下能走的路径，不能浪费</span></span><br><span class="line">        <span class="comment">// (L - ans) / 2：需要一半的路径来折返</span></span><br><span class="line">        <span class="comment">// 注意：剩下的 L - ans 这些路径可以在任何地方用来走，不只是用来在最深的点折返</span></span><br><span class="line">        <span class="comment">// 还有一种情况：所有的点都走完了，还有步数</span></span><br><span class="line">        <span class="comment">// 这时候答案就不会再继续累加了</span></span><br><span class="line">        <span class="comment">// 这种情况下 ans 就要对 N 取个 min</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得最后提交的时候不要带 main 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> int main() &#123;</span></span><br><span class="line"><span class="comment"> std::vector&lt;int&gt; fa;</span></span><br><span class="line"><span class="comment"> fa.clear();</span></span><br><span class="line"><span class="comment"> int x = 0;</span></span><br><span class="line"><span class="comment"> while (true) &#123;</span></span><br><span class="line"><span class="comment"> cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment"> if (x == -1) break;</span></span><br><span class="line"><span class="comment"> fa.push_back(x);</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> int l = 0;</span></span><br><span class="line"><span class="comment"> cin &gt;&gt; l;</span></span><br><span class="line"><span class="comment"> WalkOverATree wk;</span></span><br><span class="line"><span class="comment"> cout &lt;&lt; wk.maxNodesVisited(fa, l) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"> return 0;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem-Statement&quot;&gt;&lt;a href=&quot;#Problem-Statement&quot; class=&quot;headerlink&quot; title=&quot;Problem Statement&quot;&gt;&lt;/a&gt;Problem Statement&lt;/h1&gt;&lt;p&gt;Given is a tree on n nodes. The nodes are numbered 0 through n-1. You are given the description of the tree as a int[]  &lt;strong&gt;parent&lt;/strong&gt;  with n-1 elements. For each valid i, there is an edge between vertices (i+1) and  &lt;strong&gt;parent&lt;/strong&gt;[i].&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="TopCoder" scheme="https://blog.handwer-std.top/tags/TopCoder/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2519《[HAOI2011]problem a》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/Luogu-P2519-BZOJ2298/"/>
    <id>https://blog.handwer-std.top/2019-07-30/Luogu-P2519-BZOJ2298/</id>
    <published>2019-07-30T14:38:23.000Z</published>
    <updated>2019-07-30T15:27:14.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>人类智慧题</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>一次考试共有n个人参加，第i个人说：“有ai个人分数比我高，bi个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个整数n，接下来n行每行两个整数，第i+1行的两个整数分别代表ai、bi</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>一个整数，表示最少有几个人说谎</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3  </span><br><span class="line">2 0  </span><br><span class="line">0 2    </span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我个人对「人类智慧题」的定义是「运用人脑求特殊解也想不出来的问题」</p><p>第一眼看到这题的时候，我一脸问号<br>直到老师开始讲题……</p><hr><p>首先，把题目转化一下<br>对于每个学生，给定了有多少人成绩比他好，成绩比他差，那就把它转化为一个成绩区间，表示这个区间内的人（可能只有 1 个）成绩相同</p><p>然后考虑一下「假话」的判断方式</p><ol><li>成绩比他好的 + 成绩比他差的 + 他 &gt; 总人数<br>这个请自行理解</li><li>两个有交集的区间没有完全相同，那么两个区间必有一个是假话<br>这个很显然吧，就是两个区间有交集的话说明它们是一个成绩，然而小于这个成绩的人或大于这个成绩的人却不相同</li><li>对于一堆完全相同的区间，它们之间是真话的个数至多是[区间长度]个，超出的部分全都是假话<br>想一想区间长度的现实意义是什么：有[区间长度]个学生成绩相同。那么，一个成绩是有[区间长度]个人的，也就是说，至多有[区间长度]个属于这个区间对应的成绩的学生在说真话（可以看作他们的成绩属于这个区间对应的成绩），剩下的学生都在说假话。<br>这样说应该会好理解一些吧……实在不行我举个例子：[2,4]，意味着这个区间对应的成绩有 3 个人获得了，那么如果有 4 个人说“我获得了这个成绩”，那么肯定有 1 个人在说假话。</li></ol><p>经过筛选，区间数量减少了一些，再去个重，把相同的区间个数用权值的形式表示出来（对每种区间分配唯一 id），比如说我有三个[2,4]和一个[7,8]，我就可以对[2,4]这个区间加一个权值 3，对[7,8]这个区间加一个权值 1。</p><hr><p>那么问题现在变成了：带权值的线段覆盖，求最大权值和</p><p>这个就是一个 dp 问题了</p><p>下面这一段也是从我代码里复制过来的（</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 设 F[i] 表示选择右端点不超过 i 的最大权值</span><br><span class="line">// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话</span><br><span class="line">// 初始：F[i] = F[i - 1]</span><br><span class="line">// 转移：当 i 点为某一线段的右端点时，</span><br><span class="line">// F[i] = max(F[i], F[j - 1] + Weight)</span><br><span class="line">// 其中 j 为该线段的左端点，Weight 为该线段的权值</span><br><span class="line">// (j - 1) 是因为线段不能重叠</span><br></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>代码里有很多注释，应该会很好理解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2519.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2011]problem a</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ2298</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, w;</span><br><span class="line">    </span><br><span class="line">    Segment(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : l(l), r(r), w(w) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Segment &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == that.r) <span class="keyword">return</span> l &lt; that.l;</span><br><span class="line">        <span class="keyword">return</span> r &lt; that.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; segt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Ls[MAXN], Rs[MAXN], Ws[MAXN];</span><br><span class="line"><span class="comment">// segt 记录读入后经过处理的线段，Ls, Rs, Ws 记录去重后的线段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt, cntnew;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="comment">// 将给定的数据转化为学生 i 的排名</span></span><br><span class="line">        <span class="comment">// 用区间[l,r]的形式表示（按成绩排名）第 l 个人到第 r 个人成绩相同</span></span><br><span class="line">        <span class="comment">// 考虑把所有完全相同的线段记为单个带权值的线段</span></span><br><span class="line">        <span class="comment">// 那么问题就变为了一个带权线段覆盖问题</span></span><br><span class="line">        <span class="keyword">if</span> (l + r &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 学生数量不合法，显然是错的</span></span><br><span class="line">        ++l; r = (n - ((r + <span class="number">1</span>) - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 避免出现左端点为 0 的情况，因为读入的 l 有可能是 0</span></span><br><span class="line">        segt[++cnt] = Segment(l, r); <span class="comment">// 记一下目前合法的线段数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(segt + <span class="number">1</span>, segt + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(segt[i].l == segt[i - <span class="number">1</span>].l &amp;&amp; segt[i].r == segt[i - <span class="number">1</span>].r)) ++cntnew;</span><br><span class="line">        <span class="comment">// 两条线段如果重合，就增加该线段的权值</span></span><br><span class="line">        <span class="comment">// 两条线段如果不重合，就新开一条线段</span></span><br><span class="line">        <span class="comment">// 本质是一个去重并合并权值的过程</span></span><br><span class="line">        Ws[cntnew] = <span class="built_in">std</span>::min((segt[i].r - segt[i].l + <span class="number">1</span>), Ws[cntnew] + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 重合的线段表示有(线段长度)个人是相同成绩的</span></span><br><span class="line">        <span class="comment">// 所以每组重合线段（按线段长度分组）的个数如果超过了它的长度</span></span><br><span class="line">        <span class="comment">// 则超出去的那部分必定是假话</span></span><br><span class="line">        Ls[cntnew] = segt[i].l; Rs[cntnew] = segt[i].r;</span><br><span class="line">        <span class="comment">// 记一下去重后的线段</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 设 F[i] 表示选择右端点不超过 i 的最大权值</span></span><br><span class="line">        <span class="comment">// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话</span></span><br><span class="line">        <span class="comment">// 初始：F[i] = F[i - 1]</span></span><br><span class="line">        <span class="comment">// 转移：当 i 点为某一线段的右端点时，</span></span><br><span class="line">        <span class="comment">// F[i] = max(F[i], F[j - 1] + Weight)</span></span><br><span class="line">        <span class="comment">// 其中 j 为该线段的左端点，Weight 为该线段的权值</span></span><br><span class="line">        <span class="comment">// (j - 1) 是因为线段不能重叠</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= cntnew &amp;&amp; Rs[j] == i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">std</span>::max(dp[i], dp[Ls[j] - <span class="number">1</span>] + Ws[j]);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于 F[i] 表示说真话的数量，所以答案为学生的数量 - 说真话的数量</span></span><br><span class="line">    <span class="comment">// 也就是 n - dp[n]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;人类智慧题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://blog.handwer-std.top/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
  </entry>
  
  <entry>
    <title>CF816E / CF815C《Karen and Supermarket》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/CF816E-CF815C/"/>
    <id>https://blog.handwer-std.top/2019-07-30/CF816E-CF815C/</id>
    <published>2019-07-30T11:45:09.000Z</published>
    <updated>2019-07-30T12:09:15.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>On the way home, Karen decided to stop by the supermarket to buy some groceries.</p><a id="more"></a><p><img src="https://vj.ti12z.cn/7bda7944615fd91edd669116f72aa574?v=1564372682" alt=""></p><p>She needs to buy a lot of goods, but since she is a student her budget is still quite limited. In fact, she can only spend up to  $b$  dollars.</p><p>The supermarket sells  $n$  goods. The  $i$-th good can be bought for  $c_i$  dollars. Of course, each good can only be bought once.</p><p>Lately, the supermarket has been trying to increase its business. Karen, being a loyal customer, was given  $n$  coupons. If Karen purchases the  $i$-th good, she can use the  $i$-th coupon to decrease its price by  $d_i$. Of course, a coupon cannot be used without buying the corresponding good.</p><p>There is, however, a constraint with the coupons. For all  $i≥ 2$, in order to use the  $i$-th coupon, Karen must also use the  $x_i$ -th coupon (which may mean using even more coupons to satisfy the requirement for that coupon).</p><p>Karen wants to know the following. What is the maximum number of goods she can buy, without exceeding her budget  $b$?</p><h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>The first line of input contains two integers  nn  and  bb  (  1&lt;=n&lt;=50001&lt;=n&lt;=5000  ,  1&lt;=b&lt;=10^{9}1&lt;=b&lt;=109  ), the number of goods in the store and the amount of money Karen has, respectively.</p><p>The next  nn  lines describe the items. Specifically:</p><ul><li>The  ii  -th line among these starts with two integers,  c_{i}ci​  and  d_{i}di​  (  1&lt;=d_{i}&lt;c_{i}&lt;=10^{9}1&lt;=di​&lt;ci​&lt;=109  ), the price of the  ii  -th good and the discount when using the coupon for the  ii  -th good, respectively.</li><li>If  i&gt;=2i&gt;=2  , this is followed by another integer,  x_{i}xi​  (  1&lt;=x_{i}&lt;i1&lt;=xi​&lt;i  ), denoting that the  x_{i}xi​  -th coupon must also be used before this coupon can be used.</li></ul><h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>Output a single integer on a line by itself, the number of different goods Karen can buy, without exceeding her budget.</p><h3 id="Input-Output-Samples"><a href="#Input-Output-Samples" class="headerlink" title="Input / Output Samples"></a>Input / Output Samples</h3><p><strong>Input #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 16</span><br><span class="line">10 9</span><br><span class="line">10 5 1</span><br><span class="line">12 2 1</span><br><span class="line">20 18 3</span><br><span class="line">10 2 3</span><br><span class="line">2 1 5</span><br></pre></td></tr></table></figure><p><strong>Output #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>Input #2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 10</span><br><span class="line">3 1</span><br><span class="line">3 1 1</span><br><span class="line">3 1 2</span><br><span class="line">3 1 3</span><br><span class="line">3 1 4</span><br></pre></td></tr></table></figure><p><strong>Output #2</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>从代码里复制过来的（</p><p>一道树形 DP</p><p>显然优惠券的使用逻辑可以构成一棵树<br>设 $\text{f[i][j][0/1]}$ 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费<br>初始状态：</p><p>$\text{f[][][] = INF}$<br>$\text{f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read}$</p><p>转移方程：<br>$\text{f[root][i + j][0] = min{ f[root][i + j][0], f[root][i][0] + f[u][j][0] | u} \in subtree(root) \ }$<br>$\text{f[root][i + j][1] = min{ f[root][i + j][1], f[root][i][1] + min{ f[u][j][0], f[u][j][1] } | u}  \in subtree(root)\ }$</p><p>其中 $i \leq \text{size[root]}, j \leq \text{size[u]}$，i 需要倒序枚举来避免重复选商品</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CF816E.cpp</span></span><br><span class="line"><span class="comment">//  Title: Karen and Supermarket</span></span><br><span class="line"><span class="comment">//  Alternatives: CF815C</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/30.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="comment">// CodeForces 中请使用 %I64d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 显然优惠券的使用逻辑可以构成一棵树</span></span><br><span class="line"><span class="comment"> * 设 f[i][j][0/1] 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费</span></span><br><span class="line"><span class="comment"> * 初始状态：</span></span><br><span class="line"><span class="comment"> * f[][][] = INF</span></span><br><span class="line"><span class="comment"> * f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read</span></span><br><span class="line"><span class="comment"> * 转移方程：</span></span><br><span class="line"><span class="comment"> * f[root][i + j][0] = min&#123; f[root][i + j][0], f[root][i][0] + f[u][j][0] | u 为 root 的孩子 &#125;</span></span><br><span class="line"><span class="comment"> * f[root][i + j][1] = min&#123; f[root][i + j][1], f[root][i][1] + min&#123; f[u][j][0], f[u][j][1] &#125; | u 为 root 的孩子 &#125;</span></span><br><span class="line"><span class="comment"> * 其中 i &lt;= size[root], j &lt;= size[u]，i 需要倒序枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">lli dp[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> size[MAXN];</span><br><span class="line"><span class="comment">// dp 数组耗空间约 383MB</span></span><br><span class="line"><span class="comment">// size 数组耗空间约 20KB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : head[u]) &#123;</span><br><span class="line">        DFS(v, u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size[u]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= size[v]; ++j) &#123;</span><br><span class="line">                dp[u][i + j][<span class="number">0</span>] = <span class="built_in">std</span>::min(</span><br><span class="line">                    dp[u][i + j][<span class="number">0</span>],</span><br><span class="line">                    dp[u][i][<span class="number">0</span>] + dp[v][j][<span class="number">0</span>]</span><br><span class="line">                );</span><br><span class="line">                dp[u][i + j][<span class="number">1</span>] = <span class="built_in">std</span>::min(</span><br><span class="line">                    dp[u][i + j][<span class="number">1</span>],</span><br><span class="line">                    dp[u][i][<span class="number">1</span>] + <span class="built_in">std</span>::min(</span><br><span class="line">                        dp[v][j][<span class="number">0</span>],</span><br><span class="line">                        dp[v][j][<span class="number">1</span>]</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); b = getint();</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">0</span>] = getll();</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>][<span class="number">0</span>] - getll();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = getint();</span><br><span class="line">            head[next].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="keyword">int</span> i = n;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][i][<span class="number">0</span>] &lt;= b || dp[<span class="number">1</span>][i][<span class="number">1</span>] &lt;= b) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h1&gt;&lt;p&gt;On the way home, Karen decided to stop by the supermarket to buy some groceries.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Codeforces" scheme="https://blog.handwer-std.top/tags/Codeforces/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2218《[HAOI2007]覆盖问题》</title>
    <link href="https://blog.handwer-std.top/2019-07-30/Luogu-P2218-BZOJ1052/"/>
    <id>https://blog.handwer-std.top/2019-07-30/Luogu-P2218-BZOJ1052/</id>
    <published>2019-07-30T00:14:10.000Z</published>
    <updated>2019-07-30T00:34:54.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>某人在山上种了N棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用3个L*L的正方形塑料薄膜将小树遮起来。</p><a id="more"></a><p>我们不妨将山建立一个平面直角坐标系，设第i棵小树的坐标为（Xi,Yi），3个L*L的正方形的边要求平行 与坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求L最小值。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有一个正整数N，表示有多少棵树。</p><p>接下来有N行，第i+1行有2个整数Xi,Yi，表示第i棵树的坐标，保证不会有2个树的坐标相同。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一行，输出最小的L值。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 1</span><br><span class="line">0 -1</span><br><span class="line">1 0</span><br><span class="line">-1 0</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>数据范围</p><p>100%的数据，-1,000,000,000&lt;=Xi,Yi&lt;=1,000,000,000</p><p>30%的数据，N&lt;=100</p><p>50%的数据，N&lt;=2000</p><p>100%的数据，N&lt;=20000</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然答案具有单调性，因为边长为 k 的正方形能覆盖的话，边长为 k + 1 的正方形一定能覆盖<br>考虑二分答案</p><hr><p>首先用一个最小的矩形覆盖所有的点</p><p>很容易想到一个做法：先把矩形的左上角、右下角用正方形覆盖，再把中间的用正方形覆盖<br>然而这样是不行的，反例很多，这里就不写了<br>但是换个思路，矩形的四个角一定会有贴着边放的正方形</p><p>所以换一个做法：枚举矩形的四个角，放正方形；此时还剩下一些点，再找一个最小的矩形覆盖所有点，递归进去做即可，深度只有 3 层</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2218.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2007]覆盖问题</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ1052</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">lli n, maxx = -(<span class="number">0x3f3f3f3f</span>), minx = (<span class="number">0x3f3f3f3f</span>), maxy = -(<span class="number">0x3f3f3f3f</span>), miny = (<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">lli x[MAXN], y[MAXN];</span><br><span class="line"><span class="keyword">int</span> cov[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 确定一个最小的矩形使得这个矩形可以覆盖所有点。</span></span><br><span class="line"><span class="comment"> * 枚举这个矩形的四个角，把一个正方形放到这个角上，</span></span><br><span class="line"><span class="comment"> * 有一些点会被覆盖，此时递归进去确定剩下未被覆盖的点即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Cover(<span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> ly, <span class="keyword">int</span> ry, <span class="keyword">int</span> ts) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!cov[i]</span><br><span class="line">            &amp;&amp; lx &lt;= x[i] &amp;&amp; x[i] &lt;= rx</span><br><span class="line">            &amp;&amp; ly &lt;= y[i] &amp;&amp; y[i] &lt;= ry)</span><br><span class="line">            cov[i] = ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Uncover</span><span class="params">(<span class="keyword">int</span> ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cov[i] == ts)</span><br><span class="line">            cov[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _CHECK(<span class="keyword">int</span> mid, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">    lli minx = INF, maxx = -INF, miny = INF, maxy = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!cov[i]) &#123;</span><br><span class="line">            minx = min(minx, x[i]); maxx = max(maxx, x[i]);</span><br><span class="line">            miny = min(miny, y[i]); maxy = max(maxy, y[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (max(maxx - minx, maxy - miny) &lt;= mid) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    _Cover(minx, minx + mid, miny, miny + mid, depth); <span class="comment">// ld</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(minx, minx + mid, maxy - mid, maxy, depth); <span class="comment">// lu</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(maxx - mid, maxx, miny, miny + mid, depth); <span class="comment">// rd</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(maxx - mid, maxx, maxy - mid, maxy, depth); <span class="comment">// ru</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cov, <span class="number">0</span>, <span class="keyword">sizeof</span> cov);</span><br><span class="line">    <span class="keyword">return</span> _CHECK(mid, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; x[i] = getint(); y[i] = getint(); &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;某人在山上种了N棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用3个L*L的正方形塑料薄膜将小树遮起来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="贪心" scheme="https://blog.handwer-std.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="递归" scheme="https://blog.handwer-std.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2341《[HAOI2006]受欢迎的牛》</title>
    <link href="https://blog.handwer-std.top/2019-07-29/Luogu-P2341-BZOJ1051-LOJ10091/"/>
    <id>https://blog.handwer-std.top/2019-07-29/Luogu-P2341-BZOJ1051-LOJ10091/</id>
    <published>2019-07-29T14:40:15.000Z</published>
    <updated>2019-07-30T00:38:00.628Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Tarjan 缩点板子题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶</p><p>牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜</p><p>欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你</p><p>算出有多少头奶牛可以当明星。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行：两个用空格分开的整数：N和M</p><p>第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>第一行：单独一个整数，表示明星奶牛的数量</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>只有 3 号奶牛可以做明星</p><p>【数据范围】</p><p>10%的数据N&lt;=20, M&lt;=50</p><p>30%的数据N&lt;=1000,M&lt;=20000</p><p>70%的数据N&lt;=5000,M&lt;=50000</p><p>100%的数据N&lt;=10000,M&lt;=50000 </p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先把题目转化一下</p><p>显然能成为明星的奶牛<strong>们</strong>一定是互相喜欢的<br>那么可以这样想：能成为明星的奶牛们都是在一个强连通分量中的，这样意味着互相喜欢<br>所以问题转化为了求图中强连通分量大小，这个用 Tarjan 来完成</p><p>值得注意的是，把强连通分量缩点之后，所得的图一定是一个DAG（这是一个性质）（实际写代码的时候不需要重新建图）<br>回到题目，缩完点之后，强连通分量对应的点的出度一定为0，而且有且仅有强连通分量对应的点出度为 0，因为如果强连通分量对应的点出度大于 0，则连出去的边与其他的点连到强连通分量的边就构成了一个环，与上面的性质相矛盾</p><p>注意到强连通分量对应的点出度为 0，那么该图合法必须要保证只有一个强连通分量（想一想，为什么）</p><p>所以写代码的思路就大体形成了：<br>Tarjan求强连通分量大小➡️缩点求出度➡️判断强连通分量个数➡️输出0或者强连通分量大小</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2341.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2006]受欢迎的牛</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ1051-LOJ10091</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/28.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inStack[MAXN];</span><br><span class="line"><span class="keyword">int</span> rep[MAXM], ren[MAXM];</span><br><span class="line"><span class="comment">// 把输入数据存一下</span></span><br><span class="line"><span class="keyword">int</span> sizSC[MAXN], ode[MAXN];</span><br><span class="line"><span class="keyword">int</span> ftot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top, Stack[MAXN];</span><br><span class="line"><span class="keyword">int</span> col, timestamp, SC[MAXN];</span><br><span class="line"><span class="comment">// dfn：dfs的时间戳</span></span><br><span class="line"><span class="comment">// low：在点u的子树能到达的节点中dfn的最小值</span></span><br><span class="line"><span class="comment">// SC：点u属于哪一个强连通分量</span></span><br><span class="line"><span class="comment">// inStack：是否在栈中</span></span><br><span class="line"><span class="comment">// sizSC：该强连通分量的大小</span></span><br><span class="line"><span class="comment">// ode：该“点”的出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; head[x].push_back(y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    low[u] = dfn[u] = ++timestamp;</span><br><span class="line">    Stack[++top] = u;</span><br><span class="line">    inStack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            <span class="comment">// 没被访问过</span></span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inStack[v]) low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">        <span class="comment">// 意味着u的子树中没有能到达u的祖先的边，也就是找到了一个强连通分量</span></span><br><span class="line">        SC[u] = ++col;</span><br><span class="line">        inStack[u] = <span class="literal">false</span>;</span><br><span class="line">        ++sizSC[col];</span><br><span class="line">        <span class="keyword">while</span> (Stack[top] != u) &#123;</span><br><span class="line">            SC[Stack[top]] = col;</span><br><span class="line">            ++sizSC[col];</span><br><span class="line">            inStack[Stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        addEdge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="comment">// 对所有联通块进行tarjan</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[i].size(); j &lt; siz; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = head[i][j];</span><br><span class="line">            <span class="keyword">if</span> (SC[i] != SC[v]) ++ode[SC[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= col; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!ode[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans) &#123; <span class="built_in">printf</span>(<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">            ans = sizSC[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tm这题我调了2h</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Tarjan 缩点板子题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="各省省选" scheme="https://blog.handwer-std.top/tags/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
      <category term="Tarjan" scheme="https://blog.handwer-std.top/tags/Tarjan/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2606《排列计数》</title>
    <link href="https://blog.handwer-std.top/2019-07-21/Luogu-P2606/"/>
    <id>https://blog.handwer-std.top/2019-07-21/Luogu-P2606/</id>
    <published>2019-07-21T12:14:10.000Z</published>
    <updated>2019-07-24T00:06:24.698Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>披着数论皮的图论</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>称一个1,2,…,N的排列P1,P2…,Pn是Magic的，当且仅当2&lt;=i&lt;=N时，Pi&gt;Pi/2. 计算1，2，…N的排列中有多少是Magic的，答案可能很大，只能输出模P以后的值</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第一行包含两个整数 n和p，含义如上所述。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件中仅包含一个整数，表示计算1,2,⋯, N的排列中， Magic排列的个数模 p的值。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p>输入样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 23</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>100%的数据中，1 ≤N ≤ 10^6, P≤ 10^9，p是一个质数。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>考虑这么一个事情：<br><br>$P_i &gt; P_{i / 2}$放到一棵树上是什么？<br>把$P_i$看作第$i$个点的权值，那么…… <br>第$i$个点的权值比第$i/2$个点的权值要大，也就是第$i$个点的权值要比第$i \times 2$个点的权值要小……<br>想一想二叉树的表示方法……这好像是一个小根堆？</p><p>问题转化为了：求1-n的所有排列中，可以构成一个小根堆的排列的个数</p><p>考虑dp<br>设<code>dp[u]</code>表示以u为根结点分配1~size(u)的小根堆的方案数<br>转移：$$d p(x)=\left(\begin{array}{c}{\operatorname{sz}(x)-1} \ {\operatorname{sz}\left(u_{1}\right), s z\left(u_{2}\right), \ldots, s z\left(u_{r}\right)}\end{array}\right) \prod d p\left(u_{i}\right)$$</p><p>最终答案就是$dp(1)$</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>我开了O2才过。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n, HA, fac[MAXN], inv[MAXN], siz[MAXN], dp[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">long long int getll() &#123; </span></span><br><span class="line"><span class="comment">    long long int s = 0, x = 1; </span></span><br><span class="line"><span class="comment">    char ch = getchar(); </span></span><br><span class="line"><span class="comment">    while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; </span></span><br><span class="line"><span class="comment">    while (isdigit(ch)) &#123; s = s * x + 1ll * ch - 1ll * '0'; ch = getchar(); &#125; </span></span><br><span class="line"><span class="comment">    return 1ll * s * x; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void putll(long long int x) &#123; </span></span><br><span class="line"><span class="comment">    if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; </span></span><br><span class="line"><span class="comment">    putll(x / 10); putchar(x % 10 + '0'); </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a % HA;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % HA;</span><br><span class="line">        a = a * a % HA;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> m, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 洛谷上数据水不用 Lucas 定理</span></span><br><span class="line">    <span class="comment">// n! / (m!(n - m)!)</span></span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % HA * inv[n - m] % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    head[prev].push_back(next);</span><br><span class="line">    head[next].push_back(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> father = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    siz[root] = <span class="number">1</span>;</span><br><span class="line">    dp[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, ss = head[root].size(); i &lt; ss; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i];</span><br><span class="line">        <span class="keyword">if</span> (father == next) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(root, next);</span><br><span class="line">        siz[root] += siz[next];</span><br><span class="line">        dp[root] = <span class="number">1l</span>l * dp[root] * C(siz[next], siz[root] - <span class="number">1</span>) % HA * dp[next] % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n = getll(); HA = getll();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;n, &amp;HA);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % HA;</span><br><span class="line">        inv[i] = fastPow(fac[i], HA - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> lson = (i &lt;&lt; <span class="number">1</span>), rson = (i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (lson &lt;= n) addEdge(i, lson);</span><br><span class="line">        <span class="keyword">if</span> (rson &lt;= n) addEdge(i, rson);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="comment">//putll(dp[1] % HA);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>] % HA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;披着数论皮的图论&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>单调栈专项练习</title>
    <link href="https://blog.handwer-std.top/2019-07-21/MonotoneStack-Luogu-P1901-Luogu-P1823-Luogu-P2947/"/>
    <id>https://blog.handwer-std.top/2019-07-21/MonotoneStack-Luogu-P1901-Luogu-P1823-Luogu-P2947/</id>
    <published>2019-07-21T12:11:00.000Z</published>
    <updated>2019-07-22T10:21:25.756Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>单调数据结构</p></blockquote><a id="more"></a><h1 id="练习：洛谷P2947《Look-Up》"><a href="#练习：洛谷P2947《Look-Up》" class="headerlink" title="练习：洛谷P2947《Look Up》"></a>练习：洛谷P2947《Look Up》</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Farmer John’s N (1 &lt;= N &lt;= 100,000) cows, conveniently numbered 1..N, are once again standing in a row. Cow i has height H_i (1 &lt;= H_i &lt;= 1,000,000).</p><p>Each cow is looking to her left toward those with higher index numbers. We say that cow i ‘looks up’ to cow j if i &lt; j and H_i &lt; H_j. For each cow i, FJ would like to know the index of the first cow in line looked up to by cow i.</p><p>Note: about 50% of the test data will have N &lt;= 1,000.</p><p>约翰的N(1≤N≤10^5)头奶牛站成一排，奶牛i的身高是Hi(l≤Hi≤1,000,000)．现在，每只奶牛都在向右看齐．对于奶牛i，如果奶牛j满足i&lt;j且Hi&lt;Hj，我们可以说奶牛i可以仰望奶牛j． 求出每只奶牛离她最近的仰望对象．</p><p>Input</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><ul><li><p>Line 1: A single integer: N</p></li><li><p>Lines 2..N+1: Line i+1 contains the single integer: H_i</p></li></ul><p>第 1 行输入 N，之后每行输入一个身高 H_i。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><ul><li>Lines 1..N: Line i contains a single integer representing the smallest index of a cow up to which cow i looks. If no such cow exists, print 0.</li></ul><p>共 N 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 0。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">3 </span><br><span class="line">2 </span><br><span class="line">6 </span><br><span class="line">1 </span><br><span class="line">1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>输出样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">3 </span><br><span class="line">0 </span><br><span class="line">6 </span><br><span class="line">6 </span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>FJ has six cows of heights 3, 2, 6, 1, 1, and 2.</p><p>Cows 1 and 2 both look up to cow 3; cows 4 and 5 both look up to cow 6; and cows 3 and 6 do not look up to any cow.</p><p>【输入说明】6 头奶牛的身高分别为 3, 2, 6, 1, 1, 2.</p><p>【输出说明】奶牛#1,#2 仰望奶牛#3，奶牛#4,#5 仰望奶牛#6，奶牛#3 和#6 没有仰望对象。</p><p>【数据规模】</p><p>对于 20%的数据： 1≤N≤10；</p><p>对于 50%的数据： 1≤N≤1,000；</p><p>对于 100%的数据：1≤N≤100,000；1≤H_i≤1,000,000；</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目就是说，依次给出一堆线段，求对于每条线段，第一个在它右面，长度大于它的线段的下标是多少<br>我们先来模拟一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1[===] 歪着看体验更佳（逃</span><br><span class="line">2[==]</span><br><span class="line">3[======]</span><br><span class="line">4[=]</span><br><span class="line">5[=]</span><br><span class="line">6[==]</span><br></pre></td></tr></table></figure><p>第一次，1号进来了，没有比它高的，让它等一会<br>第二次，2号进来了，它甚至比1号还低，对1号的答案没有什么影响，也让它等一会<br>第三次，3号进来了，它比1、2号都高！此时1、2号的答案都是3号，而且1、2号<strong>对于以后的线段答案是没有影响的</strong>，呆在队伍里已经没有什么用了，让它们出去即可<br>第四次、第五次，4号和5号依次进来，对3号的答案并没有什么影响<br>第六次，6号进来了，4号和5号的答案更新为6号，而且对以后的线段答案也是没有什么影响的（如果以后还有线段的话），出去即可<br>队伍里还有俩线段3和6，它们的答案没有被更新过，也就是没有答案</p><hr><p>这就是一个单调栈的工作流程，通过清除栈里的元素来维护单调性，而本题中第三次循环和第六次循环则是对于单调数据结构进行具体问题具体分析的关键点</p><p>可以看出，实质上是维护了一个单调不增的栈，在维护栈的单调性过程中求出了答案</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cow</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> height, id;</span><br><span class="line">    </span><br><span class="line">    Cow() : height(<span class="number">0</span>), id(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Cow(<span class="keyword">int</span> height, <span class="keyword">int</span> id) : height(height), id(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Cow&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = getint();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt; height) &#123;</span><br><span class="line">            <span class="comment">// stk.top().height &lt; height 维护栈内元素单调不增性</span></span><br><span class="line">            <span class="comment">// 如果 stk.top().height &gt; height 则单调性仍存在，不必维护</span></span><br><span class="line">            ans[stk.top().id] = i;</span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push((Cow) &#123; height, i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="巩固：洛谷P1901《发射站》"><a href="#巩固：洛谷P1901《发射站》" class="headerlink" title="巩固：洛谷P1901《发射站》"></a>巩固：洛谷P1901《发射站》</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>某地有 N 个能量发射站排成一行，每个发射站 i 都有不相同的高度 Hi，并能向两边（当 然两端的只能向一边）同时发射能量值为 Vi 的能量，并且发出的能量只被两边最近的且比 它高的发射站接收。</p><p>显然，每个发射站发来的能量有可能被 0 或 1 或 2 个其他发射站所接受，特别是为了安 全，每个发射站接收到的能量总和是我们很关心的问题。由于数据很多，现只需要你帮忙计 算出接收最多能量的发射站接收的能量是多少。</p><h2 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行：一个整数 N;</p><p>第 2 到 N+1 行：第 i+1 行有两个整数 Hi 和 Vi，表示第 i 个人发射站的高度和发射的能量值。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅一行，表示接收最多能量的发射站接收到的能量值，答案不超过 longint。</p><h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 </span><br><span class="line">3 5 </span><br><span class="line">6 10</span><br></pre></td></tr></table></figure><p>输出样例#1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>对于 40%的数据，1&lt;=N&lt;=5000；1&lt;=Hi&lt;=100000；1&lt;=Vi&lt;=10000;</p><p>对于 70%的数据，1&lt;=N&lt;=100000；1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000;</p><p>对于 100%的数据，1&lt;=N&lt;=1000000;1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000。</p><h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>同样的，先来模拟一下这个过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1[====](2)</span><br><span class="line">2[===](5)</span><br><span class="line">3[======](10)</span><br></pre></td></tr></table></figure><p>第一次，1号发射站进来，它莫得其他发射站来传输能量<br>第二次，2号发射站进来，它可以给1号传输能量<br>第三次，3号发射站进来：<br>2号发射站可以给3号发射站传输能量，1号发射站亦可。由于这两个发射站对于其他发射站的答案已经没有贡献，自己的答案也确定了，让它们出去即可</p><hr><p>本质上也是维护了一个单调递减的栈，在维护单调性的同时确定答案</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Launcher</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> height; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> energy;</span><br><span class="line">    <span class="comment">// height: 该发射站的高度</span></span><br><span class="line">    <span class="comment">// energy: 该发射站的能量强度</span></span><br><span class="line">    Launcher() &#123; id = height = energy = <span class="number">0</span>; &#125;</span><br><span class="line">    Launcher(<span class="keyword">int</span> id, <span class="keyword">int</span> height, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> energy) : id(id), height(height), energy(energy) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans[MAXN]; <span class="comment">// 答案不超过 long int</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Launcher&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = getint();</span><br><span class="line">        <span class="keyword">int</span> energy = getint();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt; h) &#123;</span><br><span class="line">            ans[i] += stk.top().energy; <span class="comment">// 栈顶对应的发射站能「向右」发射能量到当前的发射站</span></span><br><span class="line">            stk.pop(); <span class="comment">// 维护栈的单调递减性</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stk.empty()) ans[stk.top().id] += energy; <span class="comment">// 当前发射站能「向左」发射能量到栈顶对应的发射站</span></span><br><span class="line">        stk.push((Launcher) &#123; i, h, energy &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>) *<span class="built_in">std</span>::max_element(ans + <span class="number">1</span>, ans + <span class="number">1</span> + n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="提高：洛谷P1823《Patrik-音乐会的等待》"><a href="#提高：洛谷P1823《Patrik-音乐会的等待》" class="headerlink" title="提高：洛谷P1823《Patrik 音乐会的等待》"></a>提高：洛谷P1823《Patrik 音乐会的等待》</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>N个人正在排队进入一个音乐会。人们等得很无聊，于是他们开始转来转去，想在队伍里寻找自己的熟人。队列中任意两个人A和B，如果他们是相邻或他们之间没有人比A或B高，那么他们是可以互相看得见的。</p><p>写一个程序计算出有多少对人可以互相看见。</p><h2 id="输入输出格式-2"><a href="#输入输出格式-2" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个整数N (1 ≤ N ≤ 500 000), 表示队伍中共有N个人。</p><p>接下来的N行中，每行包含一个整数，表示人的高度，以毫微米(等于10的-9次方米)为单位，每个人的调度都小于2^31毫微米。这些高度分别表示队伍中人的身高。</p><h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅有一行，包含一个数S，表示队伍中共有S对人可以互相看见。</p><h2 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 </span><br><span class="line">2 </span><br><span class="line">4 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">2 </span><br><span class="line">5 </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>输出样例#1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>依然来模拟一下：，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1[==]</span><br><span class="line">2[====]</span><br><span class="line">3[=]</span><br><span class="line">4[==]</span><br><span class="line">5[==]</span><br><span class="line">6[=====]</span><br><span class="line">7[=]</span><br></pre></td></tr></table></figure><p>第一次，1号进入，它谁都望不到<br>第二次，2号进入，1、2号能互相看见，此时1号对答案已经没有贡献，出去即可<br>第三次，3号进入，2、3号能互相看见<br>第四次，4号进入，3、4号能互相看见，同时2、4号也可以互相看见，此时3号对答案已经没有贡献，出去即可<br>第五次……第六次……第七次……</p><hr><p>已经很明显了，依然是维护一个单调不增的栈，在维护元素单调性的同时更新答案<br>但是这里的代码实现有一定的技巧</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Height</span> &#123;</span></span><br><span class="line">    <span class="comment">// 按照顺序把相邻等高的人视为一组</span></span><br><span class="line">    <span class="keyword">int</span> height; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> amount;</span><br><span class="line">    <span class="comment">// height: 该组的高度</span></span><br><span class="line">    <span class="comment">// amount: 该组的人数</span></span><br><span class="line">    Height() &#123; height = amount = <span class="number">0</span>; &#125;</span><br><span class="line">    Height(<span class="keyword">int</span> height, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> amount) : height(height), amount(amount) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Height&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = getint();</span><br><span class="line">        Height hh = (Height) &#123; h, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt;= h) &#123;</span><br><span class="line">            ans += stk.top().amount; <span class="comment">// 当前人能够看见上一组整组的人</span></span><br><span class="line">            <span class="keyword">if</span> (stk.top().height == h) hh.amount += stk.top().amount; <span class="comment">// 如果两组人等高，就把两组人归到一组去</span></span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stk.empty()) ++ans;</span><br><span class="line">        <span class="comment">// 在放当前的人进栈之前，如果栈非空，说明栈顶这个人是能看见当前的人的</span></span><br><span class="line">        stk.push(hh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="comment">// C(100000, 2) &gt; (1 &lt;&lt; 31)</span></span><br><span class="line">    <span class="comment">// 答案超过 int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;单调数据结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="专项练习" scheme="https://blog.handwer-std.top/tags/%E4%B8%93%E9%A1%B9%E7%BB%83%E4%B9%A0/"/>
    
      <category term="单调栈" scheme="https://blog.handwer-std.top/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3884 洛谷P4139《上帝与集合的正确用法》</title>
    <link href="https://blog.handwer-std.top/2019-07-18/BZOJ3884-Luogu-P4139/"/>
    <id>https://blog.handwer-std.top/2019-07-18/BZOJ3884-Luogu-P4139/</id>
    <published>2019-07-18T12:49:05.000Z</published>
    <updated>2019-07-21T02:33:37.607Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  $2^{2^{2^{2^{2^{…}}}}}$</p></blockquote><a id="more"></a><h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>根据一些书上的记载，上帝的一次失败的创世经历是这样的：<br>第一天，    上帝创造了一个世界的基本元素，称做“元”。<br>第二天，    上帝创造了一个新的元素，称作“α”。“α”被定义为“元”构成的集合。容易发现，一共有两种不同的“α”。<br>第三天，    上帝又创造了一个新的元素，称作“β”。“β”被定义为“α”构成的集合。容易发现，一共有四种不同的“β”。<br>第四天，    上帝创造了新的元素“γ”，“γ”被定义为“β”的集合。显然，一共会有16种不同的“γ”。<br>如果按照这样下去，上帝创造的第四种元素将会有65536种，第五种元素将会有2^65536种。这将会是一个天文数字。<br>然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……<br>然而不久，当上帝创造出最后一种元素“θ”时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。<br>至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素“θ”一共有多少种？<br>上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对p取模后的值即可。<br>你可以认为上帝从“α”到“θ”一共创造了10^9次元素，或10^18次，或者干脆∞次。<br>一句话题意：<br>求 $2^{2^{2^{2^{2^{…}}}}}\bmod p$的值</p><h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>接下来T行，每行一个正整数p，代表你需要取模的值</p><h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>T行，每行一个正整数，为答案对p取模后的值</p><h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h1 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h1><p>对于100%的数据，T&lt;=1000,p&lt;=10^7</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>一开始看到这个题目，我是懵逼的</p><p>这题让我们求$2^\infty\bmod p$的值，考虑把它转化一下</p><p>根据扩展欧拉定理可知<br>$$<br>a ^ b= \begin{cases} a ^ {b \bmod \varphi(p)} \quad &amp; \gcd(a,p)=1 \ a ^ b \quad &amp; \gcd(a,p) \not=1, b &lt; \varphi(p)\ a ^ {b \bmod \varphi(p) + \varphi (p)} \quad &amp; \gcd(a,p) \not=1, b \ge \varphi(p)\ \end{cases}<br>$$<br>所以把它变成第三条的形式<br>$$<br>2^{2^{2^{2^{2^{…}}}}}\bmod p=2^{2^{2^{2^{2^{…}}}} \bmod \varphi(p) + \varphi(p)}<br>$$<br>把第一个2的指数摘出来单独康一康<br>$$<br>2^{2^{2^{2^{…}}}} \bmod \varphi(p) + \varphi(p)<br>$$<br>设$\varphi(p) + \varphi(p) = a$，上式变为<br>$$<br>2^{2^{2^{2^{…}}}} \bmod a<br>$$<br>好像在哪见过……那就再来一遍<br>$$<br>2^{2^{2^{2^{2^{…}}}}}\bmod a=2^{2^{2^{2^{2^{…}}}} \bmod \varphi(a) + \varphi(a)}<br>$$<br>这是个递归式！</p><p>那么解法就很显然了：<br>根据扩展欧拉定理，把指数部分变形，然后递归进去继续变形指数部分的指数部分……</p><hr><p>找一找递归出口<br>在模$p$的意义下，一个数的取值范围是$[0,p-1]$<br>考虑让这个数变成定值，显然$p=1$时，这个数为$0$<br>这个就是递归出口，当模数为1时，返回0</p><p>求$\varphi(i)$建议使用根号算法，更快一些</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &amp; <span class="number">1</span>) ret = ret * x % p;</span><br><span class="line">        x = x * x % p;</span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = x, a = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123; <span class="comment">// 如果i是a的质因子</span></span><br><span class="line">            ret = ret / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i; <span class="comment">// 筛去所有的i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) ret = ret / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> pp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> pf = phi(pp);</span><br><span class="line">    <span class="keyword">return</span> fastPower(<span class="number">2</span>, solve(pf) + pf, pp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = getint();</span><br><span class="line">    countdown (T) &#123;</span><br><span class="line">        p = getll();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  $2^{2^{2^{2^{2^{…}}}}}$&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="EXGCD" scheme="https://blog.handwer-std.top/tags/EXGCD/"/>
    
  </entry>
  
  <entry>
    <title>关于近期对博客大部分文章进行整理的说明</title>
    <link href="https://blog.handwer-std.top/2019-07-12/Articles-Reform/"/>
    <id>https://blog.handwer-std.top/2019-07-12/Articles-Reform/</id>
    <published>2019-07-12T13:47:01.000Z</published>
    <updated>2019-07-12T13:49:57.679Z</updated>
    
    <content type="html"><![CDATA[<p>利用这几天时间对博客文章的排版、一句话说明、标签等内容进行修改和更新</p><p>博客主题也有大幅度变动的可能</p><p>特此说明</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;利用这几天时间对博客文章的排版、一句话说明、标签等内容进行修改和更新&lt;/p&gt;
&lt;p&gt;博客主题也有大幅度变动的可能&lt;/p&gt;
&lt;p&gt;特此说明&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="博客相关" scheme="https://blog.handwer-std.top/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3907《圈的异或》</title>
    <link href="https://blog.handwer-std.top/2019-07-12/Luogu-P3907/"/>
    <id>https://blog.handwer-std.top/2019-07-12/Luogu-P3907/</id>
    <published>2019-07-12T12:12:00.000Z</published>
    <updated>2019-07-12T13:24:44.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  暴力 DFS 即可<small>(???)</small></p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出无向图G，边(A_i,B_i) 的权是C_i，判断下列性质是否成立：</p><p>对于任意圈C，其边权的异或和是0</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第1 行，1 个整数T，表示数据的组数。</p><p>每组数据第1 行，2 个整数N,M，表示图G 点和边的数量。</p><p>M 行，每行3 个整数A_i,B_i,C_i</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>对每个数据输出一行，“Yes” 或者“No”</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p>输入 #1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">3 1 3</span><br><span class="line">1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure><p>输出 #1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应搜索</p><p>其他的都没的说，如何判断异或和？</p><p>维护一个 $\text{prefix[x]}​$ 数组表示 dfs 序中从起点到点$\text{x}​$的边权异或和，可以理解为一个类似于前缀和的东西 <br>它工作是这样一个过程：</p><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1g4xcci5vtrj30mg0jijsh.jpg" alt="image-20190712204439157"></p><p>比如说这么一个图，我从 6 开始搜索</p><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4xcltwnf5j30mg0jh0vn.jpg" alt="image-20190712205341779"></p><p>当前搜到了 5，检测出来返祖边了，在这停下不知所措<br>黑色部分是$\text{prefix[5]}$，青色部分是$\text{prefix[1]}$</p><p>那么答案就是从 1 走到 5 的异或和（设为$X$） $\text{xor}$ $\text{weight}(1,5)$ <br>$X$怎么求？来想一想 $\text{xor}$ 的性质吧：$a \text{ xor } a=0, a\text{ xor }0=a $  <br>那么……<br>$$<br>\text{sum[5]}=X\text{ xor sum[1]}\<br>\text{sum[5] xor sum[1]}<br>\=X \text{ xor sum[1] xor sum[1]}<br>\=X\text{ xor 0}<br>$$<br>$\text{prefix[5]}=X \text{ xor prefix[1]}$  <br>所以 $\text{prefix[5] xor prefix[1]}$ <br>$=X \text{ xor prefix[1] xor prefix[1]}\=X \text{ xor } 0 \ = X$</p><p>！！！<br>那么求 $X$ 就直接把上面那俩 xor 一下就行了</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> next, weight;</span><br><span class="line">        </span><br><span class="line">        Edge() &#123; next = weight = <span class="number">0</span>; &#125;</span><br><span class="line">        Edge(<span class="keyword">int</span> next, <span class="keyword">int</span> weight) : next(next), weight(weight) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> prefix[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN], exitNeeded;</span><br><span class="line"></span><br><span class="line">    Graph() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(prefix, <span class="number">0</span>, <span class="keyword">sizeof</span> prefix);</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        exitNeeded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        head[prev].push_back((Edge) &#123; next, weight &#125;);</span><br><span class="line">        head[next].push_back((Edge) &#123; prev, weight &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> last, <span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exitNeeded) <span class="keyword">return</span>;</span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line">        prefix[now] = ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[now].size(); i &lt; siz &amp;&amp; !exitNeeded; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = head[now][i].next;</span><br><span class="line">            <span class="keyword">if</span> (!vis[next]) DFS(next, now, ans ^ head[now][i].weight);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 前面的点被搜过了，返祖边！</span></span><br><span class="line">                <span class="keyword">if</span> (now != last) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (head[now][i].weight ^ prefix[now] ^ prefix[next]) &#123;</span><br><span class="line">                        <span class="comment">// 对应解析中 X 的求法</span></span><br><span class="line">                        exitNeeded = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T = getint();</span><br><span class="line">    countdown (T) &#123;</span><br><span class="line">        Graph G;</span><br><span class="line">        n = getint(); m = getint();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = getint();</span><br><span class="line">            <span class="keyword">int</span> next = getint();</span><br><span class="line">            <span class="keyword">int</span> weight = getint();</span><br><span class="line">            G.addEdge(prev, next, weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!G.vis[i]) G.DFS(i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (G.exitNeeded) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(G.exitNeeded ? <span class="string">"No"</span> : <span class="string">"Yes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  暴力 DFS 即可&lt;small&gt;(???)&lt;/small&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="搜索" scheme="https://blog.handwer-std.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2023《维护序列》</title>
    <link href="https://blog.handwer-std.top/2019-07-06/Luogu-P2023/"/>
    <id>https://blog.handwer-std.top/2019-07-06/Luogu-P2023/</id>
    <published>2019-07-06T14:10:46.000Z</published>
    <updated>2019-07-08T02:43:54.878Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>  多操作线段树标记下方是有顺序的</p></blockquote><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。 有长为N的数列，不妨设为a1,a2,…,aN 。有如下三种操作形式：<br>(1)把数列中的一段数全部乘一个值;<br>(2)把数列中的一段数全部加一个值;<br>(3)询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模P的值。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p><p>第一行两个整数N和P(1≤P≤1000000000）。<br>第二行含有N个非负整数,从左到右依次为a1,a2,…,aN, (0≤ai≤1000000000,1≤i≤N)。<br>第三行有一个整数M，表示操作总数。<br>从第四行开始每行描述一个操作，输入的操作有以下三种形式：<br>操作1：“1 t g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai×c(1≤t≤g≤N,0≤c≤1000000000)。<br>操作2：“2 t g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai+c (1≤t≤g≤N,0≤c≤1000000000)。<br>操作3：“3 t g”(不含双引号)。询问所有满足t≤i≤g的ai的和模P的值 (1≤t≤g≤N)。<br>同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。</p><p>输出格式：</p><p>对每个操作3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 43</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">5</span><br><span class="line">1 2 5 5</span><br><span class="line">3 2 4</span><br><span class="line">2 3 7 9</span><br><span class="line">3 1 3</span><br><span class="line">3 4 7</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">35</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>多操作线段树模板题，同《线段树 2》</p><h3 id="大致方向"><a href="#大致方向" class="headerlink" title="大致方向"></a>大致方向</h3><p>首先我们来康一康只有区间加的时候怎么做 <br>维护一个标记<code>add[i]</code>表示节点<code>i</code>对应的区间<code>[l,r]</code>被加了多少 <br>在下放标记时，<code>sum[i]</code>会被更新为<code>sum[i] + add[i] * (r - l + 1)</code> <br>我们把它看作 $x + b$ 的形式，其中<code>sum[i]</code>对应$x$， <code>add[i]</code> 对应$b$，后面的看作常数就好啦 <br>那么区间加乘的形式就应该是 $ax+b$，也就意味着要多维护一个标记<code>mul[i]</code>表示节点<code>i</code>对应的区间<code>[l,r]</code>被乘了多少，<code>sum[i]</code>会被更新为<code>sum[i] * mul[i] + add[i] * (r - l + 1)</code> <br></p><hr><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>先看乘法，比如<code>i</code>节点对应区间<code>[l,r]</code>被乘了一个$k$，本质上就是$k(ax+b)$，拆出来就是$kax + kb$，也就是把<code>mul[i]</code>和<code>add[i]</code>都乘上一个$k$ <br>加法本质上就是 $ax + b + k$，整理得 $ax + (b + k)$，那么把<code>add[i]</code>加上$k$就行了</p><h3 id="标记下放"><a href="#标记下放" class="headerlink" title="标记下放"></a>标记下放</h3><p>同样地，把每个节点看作 $ax+b$  的关系，在这里<code>i</code>节点对应的区间和<code>[l,r]</code>为$ax+b$，左子树<code>lc(i)</code>对应的区间和<code>[l, mid]</code>为$a’y+b’$ <br>遵循先乘后加的原则，对左子树乘上一个$a$得 <br>$$aa’y+ab’$$ <br>然后加上 $b$ <br>$$aa’y+ab’+b$$ <br>整理得 <br>$$(aa’)y + (ab’ + b)$$ <br>观察下这个式子，把它写成$ax+b$的形式 <br>$$Ay+B\ (A=aa’,B=ab’ + b)$$ <br>发现了什么？</p><p>本质上就是，<br>左子树的乘法标记 乘上 当前点的乘法标记 <br>左子树的加法标记 先乘上 当前点的乘法标记 再加上 当前点的加法标记</p><p><code>mul[lc(i)] *= mul[i], add[lc(i)] = add[lc(i)] * mul[i] + add[i]</code></p><p>对右子树进行一遍同样的操作，清空标记即可（稍有常识的人都知道<code>mul[i]</code>要初始化为1）</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, CH, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a[MAXN / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> mul[MAXN &lt;&lt; <span class="number">2</span>], add[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) ((x &lt;&lt; 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) ((x &lt;&lt; 1 | 1))</span></span><br><span class="line">    </span><br><span class="line">    SegmentTree() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="built_in">memset</span>(mul, <span class="number">1</span>, <span class="keyword">sizeof</span> mul);</span><br><span class="line">        <span class="built_in">memset</span>(add, <span class="number">0</span>, <span class="keyword">sizeof</span> add);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PushTag</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mul[root] == <span class="number">1</span> &amp;&amp; add[root] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 该处标记不存在或已被下放</span></span><br><span class="line">        <span class="keyword">if</span> (l != r) &#123;</span><br><span class="line">            mul[lc(root)] = mul[lc(root)] * mul[root] % CH;</span><br><span class="line">            mul[rc(root)] = mul[rc(root)] * mul[root] % CH;</span><br><span class="line">            add[lc(root)] = (add[lc(root)] * mul[root] % CH + add[root]) % CH;</span><br><span class="line">            add[rc(root)] = (add[rc(root)] * mul[root] % CH + add[root]) % CH;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[root] = (sum[root] * mul[root] % CH + add[root] * (r - l + <span class="number">1</span>) % CH) % CH;</span><br><span class="line">        mul[root] = <span class="number">1</span>; add[root] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *seq)</span> </span>&#123;</span><br><span class="line">        mul[root] = <span class="number">1</span>; add[root] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; sum[root] = seq[l]; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        buildTree(lc(root), l, mid, seq);</span><br><span class="line">        buildTree(rc(root), mid + <span class="number">1</span>, r, seq);</span><br><span class="line">        sum[root] = (sum[lc(root)] + sum[rc(root)]) % CH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">        PushTag(root, l, r);</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> sum[root];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= mid) ret = (ret + Query(lc(root), l, mid, ll, rr)) % CH;</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= rr) ret = (ret + Query(rc(root), mid + <span class="number">1</span>, r, ll, rr)) % CH;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> method, <span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PushTag(root, l, r);</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method == <span class="number">1</span>) &#123;</span><br><span class="line">                mul[root] = mul[root] * k % CH;</span><br><span class="line">                add[root] = add[root] * k % CH;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add[root] = (add[root] + k) % CH;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= mid) Modify(method, lc(root), l, mid, ll, rr, k);</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= rr) Modify(method, rc(root), mid + <span class="number">1</span>, r, ll, rr, k);</span><br><span class="line">        PushTag(lc(root), l, mid);</span><br><span class="line">        PushTag(rc(root), mid + <span class="number">1</span>, r);</span><br><span class="line">        sum[root] = (sum[lc(root)] + sum[rc(root)]) % CH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); CH = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) a[i] = getint();</span><br><span class="line">    Tree.buildTree(<span class="number">1</span>, <span class="number">1</span>, n, a);</span><br><span class="line">    m = getint();</span><br><span class="line">    countdown (m) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = getint();</span><br><span class="line">        <span class="keyword">int</span> l = getint();</span><br><span class="line">        <span class="keyword">int</span> r = getint();</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k = getll();</span><br><span class="line">                Tree.Modify(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, n, l, r, k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k = getll();</span><br><span class="line">                Tree.Modify(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, n, l, r, k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Tree.Query(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;  多操作线段树标记下方是有顺序的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="https://blog.handwer-std.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2016《战略游戏》</title>
    <link href="https://blog.handwer-std.top/2019-05-11/Luogu-P2016/"/>
    <id>https://blog.handwer-std.top/2019-05-11/Luogu-P2016/</id>
    <published>2019-05-11T06:58:24.000Z</published>
    <updated>2019-08-04T04:38:31.789Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最典型的树形DP</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Bob喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。</p><p>他要建立一个古城堡，城堡中的路形成一棵树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。</p><p>注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被了望到。</p><p>请你编一程序，给定一树，帮Bob计算出他需要放置最少的士兵.</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行 N，表示树中结点的数目。</p><p>第二行至第N+1行，每行描述每个结点信息，依次为：该结点标号i，k(后面有k条边与结点I相连)。</p><p>接下来k个数，分别是每条边的另一个结点标号r1，r2，…，rk。</p><p>对于一个n(0&lt;n&lt;=1500)个结点的树，结点标号在0到n-1之间，在输入数据中每条边只出现一次。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件仅包含一个数，为所求的最少的士兵数目。</p><p>例如，对于如下图所示的树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       0</span><br><span class="line">1</span><br><span class="line">2      3</span><br></pre></td></tr></table></figure><p>答案为1（只要一个士兵在结点1上）。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 1</span><br><span class="line">1 2 2 3</span><br><span class="line">2 0</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题，就是这种树形DP最标准的形态<br>「选点DP」</p><hr><p>设 <code>dp[i][0/1]</code> 表示选/不选以i为根的子树时的最大值</p><p>转移方程很显然<br><code>dp[root][0] += dp[child][1]</code><br><code>dp[root][1] += std::min(dp[child][0], dp[child][1])</code></p><p>也就是</p><ul><li><p>如果我不选当前点，那么就必须选我儿子，不然我和我儿子之间这条路没人看</p></li><li><p>如果我选了当前点，我儿子干啥我是不管的，选一个最小的加上</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, dp[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    G[prev].push_back(next);</span><br><span class="line">    G[next].push_back(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    dp[root][<span class="number">1</span>] = <span class="number">1</span>; dp[root][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[root]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(v, root);</span><br><span class="line">        dp[root][<span class="number">1</span>] += <span class="built_in">std</span>::min(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]);</span><br><span class="line">        dp[root][<span class="number">0</span>] += dp[v][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; k;</span><br><span class="line">        ++id;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; qwq;</span><br><span class="line">            ++qwq;</span><br><span class="line">            addEdge(id, qwq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::min(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最典型的树形DP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2014《选课》</title>
    <link href="https://blog.handwer-std.top/2019-05-11/Luogu-P2014/"/>
    <id>https://blog.handwer-std.top/2019-05-11/Luogu-P2014/</id>
    <published>2019-05-11T06:39:08.000Z</published>
    <updated>2019-08-04T04:38:45.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>森林上的DP</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数N,M用空格隔开。(1&lt;=N&lt;=300,1&lt;=M&lt;=300)</p><p>接下来的N行,第I+1行包含两个整数ki和si, ki表示第I门课的直接先修课，si表示第I门课的学分。若ki=0表示没有直接先修课（1&lt;=ki&lt;=N, 1&lt;=si&lt;=20）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一行，选M门课程的最大得分。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7  4</span><br><span class="line">2  2</span><br><span class="line">0  1</span><br><span class="line">0  4</span><br><span class="line">2  1</span><br><span class="line">7  1</span><br><span class="line">7  6</span><br><span class="line">2  2</span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>注意到题目中的「每门课有一门或没有直接先修课」<br>所以这是一个森林</p><p>我们用一个虚拟点0把所有的树根连起来，构成一棵大树<br>接下来这个题目就从一个DAG上DP转化为了一个树形DP<br>但是！它事一个树形背包</p><hr><p>设<code>dp[i][j]</code>表示选以i为根的树j个节点</p><p>初始化方程：<br><code>dp[child][i] = dp[root][i] + weight[root]</code><br><code>(0 &lt;= i &lt; 还能选择的节点数)</code><br>至于为什么从零开始……因为可以选择的节点是root的子树的节点数减一，毕竟root占掉了一个节点</p><p>转移方程：<br><code>dp[root][i] = std::max(dp[root][k], dp[child][k-1]);</code><br><code>(1 &lt;= i &lt;= 还能选择的节点数)</code></p><p>答案：<br><code>dp[0][m]</code></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首先这是一个森林</span></span><br><span class="line"><span class="comment"> * 令 f[i][j] 表示以 i 为根的子树选择前 j 个点的最大价值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> weight[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        head[prev].push_back(next);</span><br><span class="line">        weight[next] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 没得选了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> now : head[root]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                dp[now][i] = dp[root][i] + weight[now];</span><br><span class="line">            &#125;</span><br><span class="line">            DFS(now, k - <span class="number">1</span>); <span class="comment">// 对子树进行选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">                dp[root][i] = <span class="built_in">std</span>::max(dp[root][i], dp[now][i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev, weight;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; prev &gt;&gt; weight;</span><br><span class="line">        G.addEdge(prev, i, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    G.DFS(<span class="number">0</span>, m);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">0</span>][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;森林上的DP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="背包问题" scheme="https://blog.handwer-std.top/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1967「NOIP2013」《货车运输》</title>
    <link href="https://blog.handwer-std.top/2019-03-30/Luogu-P1967/"/>
    <id>https://blog.handwer-std.top/2019-03-30/Luogu-P1967/</id>
    <published>2019-03-30T13:46:53.000Z</published>
    <updated>2019-07-30T12:40:02.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>A国有n座城市，编号从  1到n，城市之间有  m  条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有  q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p><a id="more"></a><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有两个用一个空格隔开的整数n,m，表示  A  国有n  座城市和  m  条道路。</p><p>接下来  m行每行3个整数  x, y, z，每两个整数之间用一个空格隔开，表示从  x号城市到y号城市有一条限重为  z  的道路。注意： <strong>  x  不等于  y，两座城市之间可能有多条道路 </strong> 。</p><p>接下来一行有一个整数 q，表示有 q 辆货车需要运货。</p><p>接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： <strong> x 不等于 y </strong> 。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>共有  q  行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出−1。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2 4</span><br><span class="line">2 3 3</span><br><span class="line">3 1 1</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><p><strong>输出 #1</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>题目让我们求对于每个司机，最多能运多少货物，也就是在给定的两点间必经路线中求最大边权，显然我们要最大化这个边权，才能使答案更优。</p><p>注意到一些边是无论如何都不会被经过的，这些边通常较小，经过它们会劣化答案。那么一个很显然的贪心就是，排个序，依次选择最大的边加入新图，尽量不选较小的边，直到新图联通且无环，两点间有唯一的不重复经过同一条边的路径</p><p>等等……这个是最大生成树？<strong>是的。</strong></p><hr><p>想一想答案怎么求。<br>既然新图有一个性质「两点间有唯一的不重复经过同一条边的路径」，那么走一遍这条路径不就求出答案了吗！</p><p>为什么不再往上走一走？能运载的最大货物量是由这条路径决定的，往上走只可能有两种结果：上面边权比最小值大，上面边权比最小值小。第一种情况对答案没有什么贡献（因为最大值影响不了最小值），第二种情况则会<strong>劣化答案</strong>！</p><p>显然这条路径被这两个点的 LCA 分成两段，从一个点向上到 LCA 再向下到另一个点，那么在求 LCA 往上蹦的过程中求一下最小值就行了。可以倍增。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>#include <algorithm></algorithm></p><p>#include <iostream></iostream></p><p>#include <cstring></cstring></p><p>#include <cstdio></cstdio></p><p>#define FILE_IN(<strong>fname) freopen(</strong>fname, “r”, stdin)</p><p>#define FILE_OUT(<strong>fname) freopen(</strong>fname, “w”, stdout)</p><p>#define IMPROVE_IO() std::ios::sync_with_stdio(false)</p><p>using std::cin;<br>using std::cout;<br>using std::endl;</p><p>const int MAXN = 100000 + 10;<br>const int MAXM = MAXN * 5;<br>const int LOG = 21;</p><p>int n, m, q;</p><p>namespace Graph{<br>    struct RawEdge {<br>        int prev, next, weight;</p><pre><code>    bool operator &lt; (const RawEdge &amp;that) const {        return weight &gt; that.weight;    }} redge[MAXM];struct Edge {    int now, next, weight;} edge[MAXM];int head[MAXN], cnt;bool vis[MAXN];void addEdge(int prev, int next, int weight) {    edge[++cnt].now = next;    edge[cnt].weight = weight;    edge[cnt].next = head[prev];    head[prev] = cnt;}struct UnionFind{    int seq[MAXN];    UnionFind() { memset(seq, 0, sizeof seq); }    int Find(int x) {        if (seq[x] == 0) return x;        return seq[x] = Find(seq[x]);    }    bool Union(int x, int y) {        x = Find(x); y = Find(y);        if (x == y) return false;        seq[x] = y;        return true;    }} U;void Kruskal() {    std::sort(redge + 1, redge + 1 + m);    for(int i = 1; i &lt;= m; ++i) {        if (U.Union(redge[i].prev, redge[i].next)) {            addEdge(redge[i].prev, redge[i].next, redge[i].weight);            addEdge(redge[i].next, redge[i].prev, redge[i].weight);        }    }}</code></pre><p>}</p><p>namespace LCAs {<br>    using namespace Graph;<br>    int depth[MAXN], fa[MAXN][LOG], w[MAXN][LOG];</p><pre><code>void Search(int root) {    vis[root] = true;    for(int e = head[root]; e; e = edge[e].next) {        int now = edge[e].now;        if (vis[now]) continue;        depth[now] = depth[root] + 1;        fa[now][0] = root;        w[now][0] = edge[e].weight;        Search(now);    }}int GetAnswer(int x, int y) {    if (U.Find(x) != U.Find(y)) return -1;    int ans = 0x7f7f7f7f;    if (depth[x] &gt; depth[y]) std::swap(x,y);    for (int i = LOG - 1; i &gt;= 0; --i) {        if (depth[fa[y][i]] &gt;= depth[x]) {            ans = std::min(ans, w[y][i]);            y = fa[y][i];        }    }    if (x == y) return ans;    for (int i = LOG - 1; i &gt;= 0; --i) {        if (fa[x][i] != fa[y][i]) {            ans = std::min(ans, std::min(w[x][i], w[y][i]));            x = fa[x][i];            y = fa[y][i];        }    }    ans = std::min(ans, std::min(w[x][0], w[y][0]));    return ans;}</code></pre><p>}</p><p>int main() {<br>    using namespace LCAs;<br>    using namespace Graph;</p><pre><code>scanf(&quot;%d %d&quot;, &amp;n, &amp;m);for (int i = 1; i &lt;= m; ++i) {    int x, y, z;    scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);    redge[i].prev = x;    redge[i].next = y;    redge[i].weight = z;}Kruskal();for (int i = 1; i &lt;= n; ++i){    if (!vis[i]) {        depth[i] = 1;        Search(i);        fa[i][0] = i;        w[i][0] = 0x7f7f7f7f;    }}for (int i = 1; i &lt;= LOG - 1; ++i) {    for (int j = 1; j &lt;= n; ++j) {        fa[j][i] = fa[fa[j][i-1]][i-1];        w[j][i] = std::min(w[j][i-1], w[fa[j][i-1]][i-1]);    }}scanf(&quot;%d&quot;, &amp;q);for (int i = 1; i &lt;= q; ++i) {    int prev, next;    cin &gt;&gt; prev &gt;&gt; next;    printf(&quot;%d\n&quot;, GetAnswer(prev, next));}return 0;</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;A国有n座城市，编号从  1到n，城市之间有  m  条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有  q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="生成树" scheme="https://blog.handwer-std.top/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="LCA" scheme="https://blog.handwer-std.top/tags/LCA/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
  </entry>
  
</feed>
