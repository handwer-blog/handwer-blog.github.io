<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Handwer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.handwer-std.top/"/>
  <updated>2018-11-24T04:20:32.080Z</updated>
  <id>https://blog.handwer-std.top/</id>
  
  <author>
    <name>Handwer STD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公告栏</title>
    <link href="https://blog.handwer-std.top/2019-10-31/BulletinBoard/"/>
    <id>https://blog.handwer-std.top/2019-10-31/BulletinBoard/</id>
    <published>2019-10-31T12:30:10.000Z</published>
    <updated>2018-11-24T04:20:32.080Z</updated>
    
    <content type="html"><![CDATA[<font style="color:#66ccff"><br><center>这里可能会挂些什么东西。 <br>There may be something here.<br></center><br></font><p><b><center>NOIP2018 RP++</center></b><br><b><center><big><span style="color:#3f3fed">热烈庆祝CCF升级评测机配置！</span></big></center></b><br><b><center><big><span style="color:#3f3fed">热烈庆祝CCF升级评测机配置！</span></big></center></b></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font style=&quot;color:#66ccff&quot;&gt;&lt;br&gt;&lt;center&gt;这里可能会挂些什么东西。 &lt;br&gt;There may be something here.&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;/font&gt;

&lt;p&gt;&lt;b&gt;&lt;center&gt;NOIP2018 RP++&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CodeForces 1073B 《Vasya and Books》</title>
    <link href="https://blog.handwer-std.top/2018-12-08/CF1073B/"/>
    <id>https://blog.handwer-std.top/2018-12-08/CF1073B/</id>
    <published>2018-12-08T10:06:40.000Z</published>
    <updated>2018-12-08T10:25:27.128Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>很明显是栈了好吧</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/CF1073B" target="_blank" rel="noopener">题目地址</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定 $n$ 本书,序号分别为$1$到$n$，现在执行$n$个操作， 第$i$个操作需要从栈内取出编号为$b_i$的书，如果该书已经取出，则输出$0$否则将该书从栈内取出，同时取出在栈内比$b_i$靠上的书，并且输出一共取出了几本书</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains one integer $n~(1 \le n \le 2 \cdot 10^5)$ — the number of books in the stack.</p><p>The second line contains $n$ integers $a_1, a_2, \dots, a_n~(1 \le a_i \le n)$ denoting the stack of books.</p><p>The third line contains n n integers $b_1, b_2, \dots, b_n~(1 \le b_i \le n)$ denoting the steps Vasya is going to perform.</p><p>All numbers $a_1 \dots a_n$ are distinct, the same goes for $b_1 \dots b_n$ .</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Print $n$ integers. The $i$ -th of them should be equal to the number of books Vasya moves to his backpack during the $i$ -th step.</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="1"><a href="#1" class="headerlink" title="#1"></a>#1</h2><pre><code>31 2 32 1 3</code></pre><pre><code>2 0 1 </code></pre><h2 id="2"><a href="#2" class="headerlink" title="#2"></a>#2</h2><pre><code>53 1 4 2 54 5 1 3 2</code></pre><pre><code>3 2 0 0 0 </code></pre><h2 id="3"><a href="#3" class="headerlink" title="#3"></a>#3</h2><pre><code>66 5 4 3 2 16 5 3 4 2 1</code></pre><pre><code>1 1 2 0 1 1 </code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本文同步发布于<a href="https://www.luogu.org/blog/handwer-blog/solution-cf1073b" target="_blank" rel="noopener">洛谷博客</a></p><p>粗略看了一下 貌似没人和我的解法相同</p><p>那就来写一发题解吧</p><p>在读入的时候 我们用另一个数组<code>lead[i]</code>来存编号为<code>i</code>的书在<strong>读入的数组<code>book[]</code></strong>的下标</p><p>这样我们在检测读入的书是否被取出时就不用遍历一遍<code>book[]</code></p><hr><p>弹出书本的时候，我们首先看一下这个书本是否被取出 </p><p>如果是就直接输出<code>0</code></p><p>否则就开始弹出书本</p><hr><p>我们用一个变量<code>now = 0</code>记录当前弹出了几个书本，用一个数组<code>vis[i]</code>记录第<code>i</code>本书是否被弹出</p><p>在弹出之前，用一个变量<code>orin</code>记录一下<strong>还没更新</strong>的<code>now</code></p><p>接着在每次弹出的时候更新<code>vis[++now]</code>为真，直到遇到当前要弹出的书本编号</p><p>最后<code>orin - now</code>即为答案</p><hr><p>代码实现：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;stack&gt;using std::cin;using std::cout;using std::endl;using std::string;const int MAXN = 2e5 + 10;int n;int book[MAXN];int lead[MAXN];bool vis[MAXN];int now = 0;int main() {    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; ++i) {        scanf(&quot;%d&quot;, book + i);        lead[book[i]] = i;        // 让lead[]作为book[]的索引，查找的时候快一些    }    for (int i = 1; i &lt;= n; ++i) {        int o;        scanf(&quot;%d&quot;, &amp;o);        if (vis[lead[o]]) printf(&quot;0 &quot;);        // 被弹过了，输出0        else {            int orin = now;            while (book[++now] != o) {                vis[now] = true;                // 循环更新vis（弹出书本）            }            vis[now] = true;            printf(&quot;%d &quot;, now - orin);        }    }    return 0;}</code></pre><p><del>总感觉自己的代码能被 Hack</del></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;很明显是栈了好吧&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="栈" scheme="https://blog.handwer-std.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P4568《飞行路线》</title>
    <link href="https://blog.handwer-std.top/2018-11-25/BZOJ2763-Luogu-P4568-JLOI2011/"/>
    <id>https://blog.handwer-std.top/2018-11-25/BZOJ2763-Luogu-P4568-JLOI2011/</id>
    <published>2018-11-25T01:23:13.000Z</published>
    <updated>2018-12-01T08:19:25.361Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>入门级别的分层图最短路</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P4568" target="_blank" rel="noopener">题目地址</a><br><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2763" target="_blank" rel="noopener">双倍经验</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先介绍一下分层图最短路。</p><p>分层图最短路是指在可以进行分层图的图上解决最短路问题。<br>一般模型是：<br>在图上，有k次机会可以直接通过一条边，问起点与终点之间的最短路径。</p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在nn个城市设有业务，设这些城市分别标记为00到n-1n−1，一共有mm种航线，每种航线连接两个城市，并且航线有一定的价格。</p><p>Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多kk种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>数据的第一行有三个整数，n,m,k，分别表示城市数，航线数和免费乘坐次数。</p><p>第二行有两个整数，s,t，分别表示他们出行的起点城市编号和终点城市编号。</p><p>接下来有m行，每行三个整数，a,b,c，表示存在一种航线，能从城市a到达城市b，或从城市b到达城市a，价格为c。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一行，包含一个整数，为最少花费。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p>输入样例#1： </p><pre><code>5 6 10 40 1 51 2 52 3 53 4 52 3 30 2 100</code></pre><p>输出样例#1：</p><pre><code>8</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这就是分层图最短路的<strong>模板</strong><br><del>但为什么是<code>省选/NOI-</code>呢</del></p><p>我们用DP的思想来看<br>设<code>dis[i][j]</code>表示起点到<code>i</code>点在<code>j</code>层的最短路</p><p>如何分层？<br>理解性记忆。<br>例如本题最多有十层，第<code>k</code>层表示免费了<code>k</code>次的最短路</p><p>如何跑最短路？<br>洛谷卡SPFA，BZOJ不卡SPFA，但是都要注意把空间开大10倍，不然是过不去的（5次TLE的惨痛经验）<br>在跑 Dijkstra 的时候，我们用了一个<code>pair</code>来存当前到达的点和已走过的路径；这次我们需要多维护一个东西：当前的层数。</p><pre><code class="cpp">struct Node {    int id; // 当前到达的点    int weight; // 已走过的路径    int now; // 当前的层数    Node() {        id = weight = now = 0;    }    // 重载运算符，用于优先队列    bool operator &lt; (const Node &amp;that) const {        return weight &gt; that.weight;    }};</code></pre><p>在更新<code>dis</code>的时候，我们需要对这一层的点和下一层的点分别进行更新</p><pre><code class="cpp">if (!vis[to][Floor] &amp;&amp; dis[to][Floor] &gt; dis[now][Floor] + edge[e].weight) {    dis[to][Floor] = dis[now][Floor] + edge[e].weight;    q.push(NewNode(to, dis[to][Floor], Floor));}if (!vis[to][Floor] &amp;&amp; Floor + 1 &lt;= K &amp;&amp; dis[to][Floor + 1] &gt; dis[now][Floor]) {    dis[to][Floor + 1] = dis[now][Floor];    q.push(NewNode(to, dis[to][Floor + 1], Floor + 1));}</code></pre><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXN = 100000 + 10;    const int MAXM = 500000 + 10;    const int MAXK = 10 + 5;    struct Node {        int id, weight, now;        Node() {            id = weight = now = 0;        }        bool operator &lt; (const Node &amp;that) const {            return weight &gt; that.weight;        }    } head[MAXN];    struct Edge {        int now, next, weight;    } edge[MAXM];    int n, m, k, s, t, K, cnt, dis[MAXN][MAXK];    bool vis[MAXN][MAXK];    inline void addEdge(int prev, int next, int weight) {        edge[++cnt].now = next;        edge[cnt].weight = weight;        edge[cnt].next = head[prev].id;        head[prev].id = cnt;    }    Node NewNode(int id, int weight, int now) {        Node tmp;        tmp.id = id;        tmp.weight = weight;        tmp.now = now;        return tmp;    }    void SPFA() {        memset(dis, 0x7f, sizeof(dis));        std::priority_queue&lt;Node&gt; q;        For (i, 0, K) dis[s][i] = 0;        q.push(NewNode(s, 0, 0));        while (!q.empty()) {            Node NowNode = q.top();            q.pop();            int Floor = NowNode.now;            int now = NowNode.id;            if (vis[now][Floor]) continue;            vis[now][Floor] = true;            for (int e = head[now].id; e; e = edge[e].next) {                int to = edge[e].now;                if (!vis[to][Floor] &amp;&amp; dis[to][Floor] &gt; dis[now][Floor] + edge[e].weight) {                    dis[to][Floor] = dis[now][Floor] + edge[e].weight;                    q.push(NewNode(to, dis[to][Floor], Floor));                }                if (!vis[to][Floor] &amp;&amp; Floor + 1 &lt;= K &amp;&amp; dis[to][Floor + 1] &gt; dis[now][Floor]) {                    dis[to][Floor + 1] = dis[now][Floor];                    q.push(NewNode(to, dis[to][Floor + 1], Floor + 1));                }            }        }    }}signed main() {    using namespace Solution;    using FastIO::getint;    n = getint();    m = getint();    k = getint();    s = getint();    t = getint();    K = k;    For (i, 1, m) {        int prev = getint();        int next = getint();        int weight = getint();        addEdge(prev, next, weight);        addEdge(next, prev, weight);    }    SPFA();    int ans = 2147482333;    for (int i = 0; i &lt;= k; ++i) {        ans = std::min(ans, dis[t][i]);    }    FastIO::putint(ans, &#39;\n&#39;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;入门级别的分层图最短路&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="省选" scheme="https://blog.handwer-std.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="分层图" scheme="https://blog.handwer-std.top/tags/%E5%88%86%E5%B1%82%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>让你的 PC 更加安全</title>
    <link href="https://blog.handwer-std.top/2018-11-24/SecureYourPC/"/>
    <id>https://blog.handwer-std.top/2018-11-24/SecureYourPC/</id>
    <published>2018-11-24T04:52:39.000Z</published>
    <updated>2018-11-25T01:16:31.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Password: 🔑</code></p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天（2018.11.24）中午时分<br>我被 Logey 绑住胳膊<br>眼睁睁地看着 RainAir 机惨我<br>RainAir 删除了我的用户密码<br>Shq 修改了我的博客文件<br>折腾了一个中午才恢复过来<br>因为这样 我决定写下这篇文章</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="关于加密"><a href="#关于加密" class="headerlink" title="关于加密"></a>关于加密</h2><p>┌────────────┐<br>│加密，是以某种特殊的算法│<br>│改变原有的信息数据，使得│<br>│未授权的用户即使获得了已│<br>│加密的信息，但因不知解密│<br>│的方法，仍然无法了解信息│<br>│的内容。 ——百度百科&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;│<br>└────────────┘</p><h2 id="为什么要加密"><a href="#为什么要加密" class="headerlink" title="为什么要加密"></a>为什么要加密</h2><p>先不谈什么数据泄露、隐私恶意利用等诸如此类的事，我们来看<big>机惨</big></p><p>一次机惨，轻则「I AK ***」，重则<code>rm -rf / --no-preserve-root</code></p><p>所以锁好自己的电脑是非常重要的</p><h1 id="Windows-amp-macOS-通用解决方案"><a href="#Windows-amp-macOS-通用解决方案" class="headerlink" title="Windows &amp; macOS 通用解决方案"></a>Windows &amp; macOS 通用解决方案</h1><p>当然是设好自己的密码。<br>尽量设复杂且好记的密码，并且保证自己打这个密码的速度足够快，不会让人记住。<br>有生物识别系统的可以考虑安全性高的生物识别系统，像目前已经成熟的「指纹识别」和「Windows Hello」。</p><h1 id="macOS-独占解决方案"><a href="#macOS-独占解决方案" class="headerlink" title="macOS 独占解决方案"></a>macOS 独占解决方案</h1><h2 id="固件密码"><a href="#固件密码" class="headerlink" title="固件密码"></a>固件密码</h2><p>在开机时按住「⌘+R」，进入恢复模式；<br>点击菜单栏中的「实用工具」，点击「启动安全性实用工具」；<br>输入自己的密码并记牢；<br>最后直接重启即可生效。</p><p>用途？<br>设定固件密码之后，进入恢复模式就需要密码了。<br>同样是在恢复模式下，用命令<code>resetpassword</code>可以<strong>更改密码</strong>！</p><h2 id="FileVault"><a href="#FileVault" class="headerlink" title="FileVault"></a>FileVault</h2><p>FileVault 会自动直接地对主目录的内容进行加密和解密。真正的安全感来自知道在没有获得允许的时候，没有人可以翻看你的文件。FileVault 使用最新的政府安全标准来保护你的辛勤劳动成果。它保护你主文件夹上的所有信息不被窥测，因此你的商业机密、假期购物单、以及个人财政记录仍然是秘密。FileVault 使用128位高级加密标准 Advanced Encryption Standard 对你主目录下的所有内容进行加密。这个高性能的算法会自动实时加密和解密，因此你甚至不知道它的发生。</p><p align="right">——百度百科</p><p>打开方式：「系统偏好设置」→「安全性与隐私」→「文件保险箱」</p><h2 id="Time-Machine"><a href="#Time-Machine" class="headerlink" title="Time Machine"></a>Time Machine</h2><p>Time Machine 是自动备份功能的一大突破，它内建於 Mac OS X，能为 Mac 上的一切建立最新拷贝，包括数位相片、音乐、家庭影片与文件。现在，只要您有需要，就能轻易回到过去恢复任何资料。</p><p></p><p align="right">——百度百科</p><br>这种方法主要是用来预防被机惨后发生的所有特殊情况，例如博客文件被覆盖，重要文件丢失等等。<br>打开方式：「系统偏好设置」→「时间机器」<p></p><h2 id="加密映像"><a href="#加密映像" class="headerlink" title="加密映像"></a>加密映像</h2><p>如果有什么东西你想要用密码保护，那加密的映像确实是最好的工具。</p><p>方法：「Spotlight Search」<code>Disk Utility.app</code>【文件】【新建映像】【来自文件夹的映像】<br>注意：映像默认只读，如果想让映像可读写，就必须要在「映像格式」里将「压缩」改成「读/写」</p><h1 id="Windows-独占解决方案"><a href="#Windows-独占解决方案" class="headerlink" title="Windows 独占解决方案"></a>Windows 独占解决方案</h1><p><a href="https://www.baidu.com" target="_blank" rel="noopener">这里</a><br>其实上面说的东西，Windows 都有替代品。<br>固件密码有 BIOS 里的 Secure Lock，加密映像可以用 UltraISO，磁盘加密可以用 BitLocker ……</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Password: 🔑&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="只有经历过的人才知道的世界" scheme="https://blog.handwer-std.top/tags/%E5%8F%AA%E6%9C%89%E7%BB%8F%E5%8E%86%E8%BF%87%E7%9A%84%E4%BA%BA%E6%89%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    
      <category term="使用指南" scheme="https://blog.handwer-std.top/tags/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
      <category term="毒瘤" scheme="https://blog.handwer-std.top/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="优化" scheme="https://blog.handwer-std.top/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="加密" scheme="https://blog.handwer-std.top/tags/%E5%8A%A0%E5%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2010《回文日期》</title>
    <link href="https://blog.handwer-std.top/2018-11-10/Luogu-P2010/"/>
    <id>https://blog.handwer-std.top/2018-11-10/Luogu-P2010/</id>
    <published>2018-11-10T04:19:25.000Z</published>
    <updated>2018-11-24T04:21:13.477Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>枚举+判断</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。</p><p>牛牛习惯用88位数字表示一个日期，其中，前44位代表年份，接下来22位代表月 份，最后22位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。</p><p>牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。现 在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存 在的日期是回文的。</p><p>一个88位数字是回文的，当且仅当对于所有的i ( 1 \le i \le 8)i(1≤i≤8)从左向右数的第i个 数字和第9-i9−i个数字（即从右向左数的第ii个数字）是相同的。</p><p>例如：</p><p>•对于2016年11月19日，用88位数字2016111920161119表示，它不是回文的。</p><p>•对于2010年1月2日，用88位数字2010010220100102表示，它是回文的。</p><p>•对于2010年10月2日，用88位数字2010100220101002表示，它不是回文的。</p><p>每一年中都有1212个月份：</p><p>其中，1,3,5,7,8,10,121,3,5,7,8,10,12月每个月有3131天；4,6,9,114,6,9,11月每个月有3030天；而对于22月，闰年时有2929天，平年时有2828天。</p><p>一个年份是闰年当且仅当它满足下列两种情况其中的一种：</p><p>1.这个年份是44的整数倍，但不是100100的整数倍；</p><p>2.这个年份是400400的整数倍。</p><p>例如：</p><p>•以下几个年份都是闰年：2000,2012,20162000,2012,2016。</p><p>•以下几个年份是平年：1900,2011,20141900,2011,2014。</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两行，每行包括一个88位数字。</p><p>第一行表示牛牛指定的起始日期。</p><p>第二行表示牛牛指定的终止日期。</p><p>保证 $date_i$和都是真实存在的日期，且年份部分一定为4位数字，且首位数字不为0。</p><p>保证 $date_1$—定不晚于 $date_2$ 。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示在$date_1$和$date_2$之间，有多少个日期是回文的。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1： </p><pre><code>2011010120111231</code></pre><p>输出样例#1： </p><pre><code>1</code></pre><p>输入样例#2：</p><pre><code>2000010120101231</code></pre><p>输出样例#2：</p><pre><code>2</code></pre><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【样例说明】</p><p>对于样例1，符合条件的日期是20111102。</p><p>对于样例2，符合条件的日期是20011002和20100102。</p><p>【子任务】</p><p>对于$60\%$的数据，满足$date1 = date2$。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们考虑直接枚举月和日。</p><p>对于每一个月，我们用<code>M[i]</code>表示第<code>i</code>月有多少天。<br>这里要注意的是不用单独判闰年，2月29对应的是92200229，而9220是闰年。</p><p>构建字符串直接参照代码，最后比较一下即可</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */#define GetMonth(x) ((x / 100) % 100)#define GetDay(x) (x % 100)#define GetYear(x) (x / 10000)#define isFullYear(x) ((GetYear(x) % 400 == 0) || (GetYear(x) % 10 == 0 &amp;&amp; GetYear(x) % 4 != 0))using namespace std;namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int M[12 + 1] = {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};    int start;    int endd;    int ans;}signed main() {#define HANDWER_FILE#ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);#endif    using namespace Solution;    cin &gt;&gt; start;    cin &gt;&gt; endd;    for (int i = 1; i &lt;= 12; ++i) {        for (int j = 1; j &lt;= M[i]; ++j) {            int now = 0;            now += j;            now += i * 100;            now += 10000000 * (j % 10);            now += 1000000 * (j / 10);            now += 100000 * (i % 10);            now += 10000 * (i / 10);            if (start &lt;= now &amp;&amp; now &lt;= endd) ++ans;        }    }    FastIO::putint(ans, &#39;\n&#39;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;枚举+判断&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="枚举" scheme="https://blog.handwer-std.top/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="排序" scheme="https://blog.handwer-std.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>「LYOI初中坑题组」模拟赛#2 题解</title>
    <link href="https://blog.handwer-std.top/2018-11-05/LYOI-Mid-KT-Team-Contest2/"/>
    <id>https://blog.handwer-std.top/2018-11-05/LYOI-Mid-KT-Team-Contest2/</id>
    <published>2018-11-05T13:53:03.000Z</published>
    <updated>2018-11-24T04:21:27.649Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>暴力能过的题目</p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题面 &amp; 数据依然来自山河</p><p>评测 Powered by 洛谷OnlineJudge</p><h1 id="T1-复制-粘贴"><a href="#T1-复制-粘贴" class="headerlink" title="T1. 复制-粘贴"></a>T1. 复制-粘贴</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 y 是一个聪明的程序员，但是他懒到了极致，在输入程序时甚至不愿意多打一行代码。</p><p>有一次，小 y 发现他的一个程序需要输入 n 行一模一样的代码，怎么办呢？</p><p>他首先输入了第 1 行，然后通过 1 次“复制-粘贴”命令得到了第 2 行，再通过 1 次“复制-粘贴”命令得到了第 3-4 行………..直到完成这 n 行代码的输入。</p><p>小 y 懒得得意洋洋，正好遇到初学编程的小 x，他就想考考小 x，顺便为难为难他以炫耀自己的聪明才智和编程水平。于是把“复制-粘贴”的伎俩告诉小 x，并让小 x 编程计算最少通过几次“复制-粘贴”命令可以得到正好 n 行的代码？</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：<br>一行一个正整数 n,</p><p>输出格式：<br>一行一个正整数，表示最少的“复制-粘贴”次数</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：<br>4<br>输出样例#1：<br>2</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>简单推一下就可以知道答案是$\lceil log_2n \rceil$</p><p>这里要注意的是C++中的$log$是以$e$为底的<br>求$\lceil log_2n \rceil$的代码为<code>ceil(log(n) / log(2))</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() {    int a;    cin &gt;&gt; a;    cout &lt;&lt; ceil(log(a) / log(2)) &lt;&lt; endl;    return 0;}</code></pre><h1 id="T2-足球联赛"><a href="#T2-足球联赛" class="headerlink" title="T2. 足球联赛"></a>T2. 足球联赛</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个足球联赛由 n 只球队构成。在一个赛季中，每只球队都要与其它球队各比赛两场。</p><p>一场比赛在主场，一场在客场。赢一场得 3 分，输一场不得分，平局两支队伍各得 1 分。现在，给你一个 n*n 的矩阵表示比赛情况。第 i 行第 j 列的字母表示在第 i 只队伍主场的比赛情况， W 表示主队赢， L 表示主队输， D 表示平局。</p><p>需要你求出得分最高的队伍的编号，如果有分数相同的，在一行中按字典序输出队伍编号。</p><h2 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：<br>第一行，一个整数 n 。</p><p>接下来 n 行，每行 n 个字符，表示输赢情况。</p><p>第 i 行第 i 列为 - ,因为一只队伍不可能与自己比赛。</p><p>输出格式：<br>得分最高的队伍编号。如有多个在一行中输出，用一个空格分开</p><h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1： </p><pre><code>3 -WWW-WWW-</code></pre><p>输出样例#1： </p><pre><code>1 2 3</code></pre><p>输入样例#2： </p><pre><code>5 -DWWDL-WLLDD-WDDDL-LDDLL-</code></pre><p>输出样例#2： </p><pre><code>1</code></pre><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接照题意模拟即可</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXN = 50 + 10;    int n;    int score[MAXN];    char sc[MAXN][MAXN];    void Read() {        ios::sync_with_stdio(false);        cin &gt;&gt; n;        For (i, 1, n) {            For (j, 1, n) {                cin &gt;&gt; sc[i][j];            }        }    }    void Work() {        ios::sync_with_stdio(false);        for (int i = 1; i &lt;= n; ++i) {            for (int j = 1; j &lt;= n; ++j) {                if (i == j) continue;                switch(sc[i][j]) {                    case &#39;W&#39;: {                        score[i] += 3;                        break;                    }                    case &#39;L&#39;: {                        score[j] += 3;                        break;                    }                    case &#39;D&#39;: {                        score[i] += 1;                        score[j] += 1;                        break;                    }                }            }        }        int Max = -2147482333;        For (i, 1, n) Max = std::max(Max, score[i]);        For (i, 1, n) if (score[i] == Max) cout &lt;&lt; i &lt;&lt; &#39; &#39;;        cout &lt;&lt; endl;    }}int main(int argc, char *const argv[]) {#define HANDWER_FILE#ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);#endif    using namespace Solution;    Read();    Work();    return 0;}</code></pre><h1 id="T3-捕食关系"><a href="#T3-捕食关系" class="headerlink" title="T3. 捕食关系"></a>T3. 捕食关系</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在海洋中，有食肉类的鱼和食草类的鱼，某种食肉类的鱼捕食食草类的鱼当且仅当自己的体重大于对方。</p><p>现在给出两类鱼各自的体重，求有多少对捕食关系。</p><h2 id="输入输出格式-2"><a href="#输入输出格式-2" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：<br>每组测试数据有三行。</p><p>第一行有两个整数 m， n，分别代表食肉类的鱼的种类数和食草类的鱼的种类数。</p><p>第二行 m 个数，第三行 n 个数，代表各自的体重。</p><p>输出格式：<br>一个整数，表示有多少对捕食关系。</p><h2 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：<br>5 3<br>8 1 7 3 1<br>3 6 1<br>输出样例#1：<br>7</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><big><big><big>正解不会 暴力能过</big></big></big><p>我不知道纯暴力能不能过 反正我们要优化一下</p><p>首先把食草鱼体重从小到大排个序<br>那么我们在枚举食肉鱼的时候，就可以遇见在第一个体重更大的食草鱼的时候<code>break</code>掉，做法的正确性是显然的</p><p>时间复杂度均摊$O(n^2)$</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXNM = 20000 + 10;    int n, m;    int bigFish[MAXNM], smallFish[MAXNM];    void Read() {        using FastIO::getint;        m = getint();        n = getint();        For (i, 1, m) {            bigFish[i] = getint();        }        For (i, 1, n) {            smallFish[i] = getint();        }    }    void Work() {        int cnt = 0;        sort(smallFish + 1, smallFish + 1 + n);        For (i, 1, m) {            For (j, 1, n) {                if (smallFish[j] &gt;= bigFish[i]) break;                ++cnt;            }        }        FastIO::putint(cnt, &#39;\n&#39;);    }}int main(int argc, char *const argv[]) {#define HANDWER_FILE#ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);#endif    using namespace Solution;    Read();    Work();    return 0;}</code></pre><h1 id="T4-幻方"><a href="#T4-幻方" class="headerlink" title="T4. 幻方"></a>T4. 幻方</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道 n 阶奇数幻方吧？如下为一个 5 阶幻方：</p><p>17 24 1 8 15</p><p>23 5 7 14 16</p><p>4 6 13 20 22</p><p>10 12 19 21 3</p><p>11 18 25 2 9<br>现在，输入奇数 n，输出该奇数幻方最右下角的元素值。</p><h2 id="输入输出格式-3"><a href="#输入输出格式-3" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：<br>一行一个数 n。</p><p>输出格式：<br>一行一个数，表示该奇数幻方右下角的值。</p><h2 id="输入输出样例-3"><a href="#输入输出样例-3" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：<br>5<br>输出样例#1：<br>9</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>找规律</p><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">指点迷津</a></p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><p><del>不给</del></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;暴力能过的题目&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="自测" scheme="https://blog.handwer-std.top/tags/%E8%87%AA%E6%B5%8B/"/>
    
      <category term="比赛" scheme="https://blog.handwer-std.top/tags/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="暴力" scheme="https://blog.handwer-std.top/tags/%E6%9A%B4%E5%8A%9B/"/>
    
      <category term="找规律" scheme="https://blog.handwer-std.top/tags/%E6%89%BE%E8%A7%84%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>「LYOI初中坑题组」模拟赛#1 题解</title>
    <link href="https://blog.handwer-std.top/2018-11-03/LYOI-Mid-KT-Team-Contest1/"/>
    <id>https://blog.handwer-std.top/2018-11-03/LYOI-Mid-KT-Team-Contest1/</id>
    <published>2018-11-03T15:10:19.000Z</published>
    <updated>2018-11-24T04:21:22.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当一个选手比你小，还比你强……</p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题面 &amp; 测试输入来自山河</p><h1 id="T1-求和"><a href="#T1-求和" class="headerlink" title="T1. 求和"></a>T1. 求和</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>小马克今年成为小学生。不久后她将进行她的第一次考试，其中包括数学考试。</p><p>她非常认真地复习，她认为自己已经准备好了。她的哥哥通过给她提出问题并解决的方式帮助她。</p><p>他的问题是给定一连串整数：依次由 1 个 1，2 个 2，3 个 3 等组成，即1223334444……。</p><p>现在他给马克两个整数 A 和 B； 他的任务是求出由第 A 个到第 B 个数的。如果 A 是 1， B是 3， 答案为 1+2+2=5。 给一个问题， 然后计算它们的和， 马克的哥哥能够验证答案正确与否。</p><h2 id="输入输出格式-amp-样例"><a href="#输入输出格式-amp-样例" class="headerlink" title="输入输出格式 &amp; 样例"></a>输入输出格式 &amp; 样例</h2><p>输入格式：<br>输入文件 instruckcije.in 只有一行， 包括正整数 A 和 B。</p><p>输出格式：<br>输出文件 instruckcije.out 共一行， 为和的值。</p><p>输入样例#1：<br>1 3<br>输出样例#1：<br>5</p><p>输入样例#2：<br>1 1000<br>输出样例#2：<br>29280</p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1 \leq A,B \leq 1000$</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先这题是一个签到题无误了</p><p>数据范围如此之小，我们可以直接把序列初始化出来，再处理出一个前缀和数组，最后输出即可。</p><p>时间复杂度……$O(1)$？<del>反正都是常数</del></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXLENGTH_1 = 1000 + 10;    int seq[MAXLENGTH_1], sum[MAXLENGTH_1];    void Init() {        int now = 1, cur = 0, i = 0;        while (i &lt;= 1001) {            ++cur;            seq[++i] = now;            if (cur == now) {                cur = 0;                ++now;            }        }        for (int i = 1; i &lt;= 1000; ++i) {            sum[i] = sum[i-1] + seq[i];        }    }    void Work1() {        using FastIO::getint;        Init();        int x = getint();        int y = getint();        if (x &gt; y) swap(x, y);        FastIO::putint(sum[y] - sum[x-1], &#39;\n&#39;);    }}int main(int argc, char *const argv[]) {#define HANDWER_FILE#ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);#endif    using namespace Solution;    using namespace FastIO;    Work1();    return 0;}</code></pre><h1 id="T2-猜歌名"><a href="#T2-猜歌名" class="headerlink" title="T2. 猜歌名"></a>T2. 猜歌名</h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p>“Guess the song” 是一项在年轻程序员中非常流行的游戏。它是一种集技能、智慧、 耐性于一体的游戏。这个游戏给玩游戏的人放音乐， 游戏者的目标是尽可能快地猜这首歌 的歌名。</p><p>Mirko 可能不是一个很好的程序员， 但他是一个世界级的猜歌者。</p><p>Mirko 总是在专辑里的某首歌播放出至少一半歌词的时候猜出歌名。所有歌名的单词是唯一的（没有一个单词会出现一次或更多次）。</p><p>写一个程序， 给出歌名和专辑名， 看看 Mirko 在这首歌的哪个点上（在多少个单词之后）猜出歌名。</p><h2 id="输入输出格式-amp-样例-1"><a href="#输入输出格式-amp-样例-1" class="headerlink" title="输入输出格式 &amp; 样例"></a>输入输出格式 &amp; 样例</h2><p>输入格式：<br>第一行：包含一个整数 N， 它是一首歌里的单词数目。<br>接下来的 N 行每一行包含歌名的一个单词。<br>第 N+2 行： 包含一个整数 M， 它是专辑里的单词数目。<br>接下来的 M 行每一行包含专辑里的一个单词。<br>歌名和专辑里的所有单词由 1 到 15 个小写英文字母组成。</p><p>输出格式：<br>共一行， 包含一个数， 表示 Mirko 在第几个单词处猜出歌曲名。</p><p>输入样例#1：<br>3<br>sedam<br>gladnih<br>patuljaka<br>7<br>sedam<br>dana<br>sedam<br>noci<br>sedam<br>gladnih<br>godina</p><p>输出样例#1：<br>6</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们称输入的N个单词为WN，输入的M个单词为WM</p><p>那么题目就是要求我们找出一个最小ANS，使得在WM中的前ANS个单词满足有至少一半的WN中的单词</p><p>那么数据范围依然极小，直接暴力算完</p><p>当然我看着貌似能二分答案<del>太懒不写</del><br>单调性显然，当$\text{ANS}$成立的时候，满足$\text{ANS} \leq \text{ANS}_1 \leq \text{M}$的$\text{ANS_1}$都是成立的。</p><p>这里要注意的是当N为奇数时，N的一半$=\lfloor\frac{N}{2}\rfloor + 1$，否则N的一半$=\frac{N}{2}$</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXN = 50 + 10;    const int MAXM = 10000 + 10;    string song[MAXN];    string album[MAXM];    map&lt;string, bool&gt; vis;    int n, m, most;    inline bool Check() {        int ret = 0;        For (i, 1, n) if (vis[song[i]]) ++ret;        return ret &gt;= most;    }    void Work2() {        cin &gt;&gt; n;        For(i, 1, n) {            cin &gt;&gt; song[i];        }        cin &gt;&gt; m;        most = ((n % 2) == 0 ? n / 2 : n / 2 + 1);        For(i, 1, m) {            cin &gt;&gt; album[i];            //cout &lt;&lt; album[i] &lt;&lt; endl;            vis[album[i]] = true;            if (Check()) {                printf(&quot;%d\n&quot;, i);                return;            }        }    }}int main(int argc, char *const argv[]) {#define HANDWER_FILE#ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);#endif    using namespace Solution;    using namespace FastIO;    Work2();    return 0;}</code></pre><h1 id="T3-黑白棋"><a href="#T3-黑白棋" class="headerlink" title="T3. 黑白棋"></a>T3. 黑白棋</h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><p>Lagno 是一种二人智力游戏。 游戏设有一个黑方和一个白方。游戏桌面是正方形的， 包含 8 行 8 列。</p><p>如果黑方玩家走出这样一步棋：将一枚黑子放在任一空格上， 而在这个空格的八个方向（上、下、左、右和 4 个对角线方向）的至少一个方向上有一排白子被夹在这枚新下的黑子和其他黑子之间， 任何方向， 在新黑子和原来黑子之间的所有白子都要变成黑子。为这个游戏设计一个程序， 计算一步棋中黑方能转变的白子数量的最大值。</p><h2 id="输入输出格式-amp-样例-2"><a href="#输入输出格式-amp-样例-2" class="headerlink" title="输入输出格式 &amp; 样例"></a>输入输出格式 &amp; 样例</h2><p>输入格式：<br>输入文件 lango.in 共 8 行， 每行 8 个字符；“.”代表一个空格；“B”代表黑子，“W” 代表白子。</p><p>输出格式：<br>输出文件 lango.out 共一行， 有一个整数， 表示一步中黑方能吃掉白子的最大数， 如果无法吃掉就输出“0”。</p><p>输入输出样例<br>输入样例#1： </p><pre><code>...........................BW......WB...........................</code></pre><p>（这个说实话不等宽不行</p><p>输出样例#1： </p><pre><code>1</code></pre><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p><del><big><big><big>暴！力！能！过！</big></big></big></del><br><br><br><del><small><small>输出0拿9分</small></small></del></p><h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>数据范围如此之小，我们不如直接枚举所有空格点，对这个点进行八向扩展，累加答案，最后取$max$即可</p><h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>当然是DFS<br>我们还是枚举每一个点，只不过这次不暴力扩展了。<br>我们用<code>dx[]</code>和<code>dy[]</code>来记八个方向，根据它来扩展。<br><code>dfs(int now, int x, int y)</code>中的<code>now</code>就表示现在是第<code>now</code>个方向</p><p>边界肯定是要判的（<code>x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8</code>），当前是不是空格子也要判（<code>s[i][j] == &#39;.&#39;</code>），如果有任意一个满足就直接<code>return -INF</code><br>如果当前碰到了一个黑格子，说明到头了，<code>return 0</code>即可<br>否则<code>return dfs(now, x + dx[now], y + dy[now]) + 1</code></p><p>想是有点难想的，但是代码很好看懂。</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="暴力算法-1"><a href="#暴力算法-1" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>***<b>毒瘤警告</b>***</p><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int dx[8] = {-1, 1, 0, 0, -1, -1, 1, 1};    const int dy[8] = { 0, 0, -1, 1, -1, 1, -1, 1};    const int MAXX_Y = 8 + 2;    short Map[MAXX_Y][MAXX_Y];    // 0: blank    // 1: Black    // 2: White    int ans = 0;    void Read() {        // 初始化        for (int i = 1; i &lt;= 8; ++i) {            for (int j = 1; j &lt;= 8; ++j) {                char c;                cin &gt;&gt; c;                switch (c) {                    case &#39;.&#39;: {                        Map[i][j] = 0;                        break;                    }                    case &#39;B&#39;: {                        Map[i][j] = 1;                        break;                    }                    case &#39;W&#39;: {                        Map[i][j] = 2;                        break;                    }                }            }        }    }    int getAnswer(int x, int y) {        // 获取上下左右的可扩展数量        int ret = 0;        int current = 0;        int ox = x;        int oy = y;        while (true) { ++current; ++x; if (Map[x][y] == 0) { current = 0; break; } if (Map[x][y] == 1) break; if (x == 8 &amp;&amp; Map[x][y] == 2) { current = 0; break; } }        if (current &gt; 0) --current;        ret += current;        current = 0;        x = ox;        y = oy;        while (true) { ++current; --x; if (Map[x][y] == 0) { current = 0; break; } if (Map[x][y] == 1) break; if (x == 1 &amp;&amp; Map[x][y] == 2) { current = 0; break; } }        if (current &gt; 0) --current;        ret += current;        current = 0;        x = ox;        y = oy;        while (true) { ++current; ++y; if (Map[x][y] == 0) { current = 0; break; } if (Map[x][y] == 1) break; if (y == 8 &amp;&amp; Map[x][y] == 2) { current = 0; break; } }        if (current &gt; 0) --current;        ret += current;        current = 0;        x = ox;        y = oy;        while (true) { ++current; --y; if (Map[x][y] == 0) { current = 0; break; } if (Map[x][y] == 1) break; if (y == 1 &amp;&amp; Map[x][y] == 2) { current = 0; break; } }        if (current &gt; 0) --current;        ret += current;        current = 0;        x = ox;        y = oy;        return ret;    }    int getAnswerAlt(int x, int y) {        // 获取四个对角线上的可扩展数量        int ret = 0;        int current = 0;        int ox = x;        int oy = y;        while (true) { ++current; ++x; ++y; if (Map[x][y] == 0) { current = 0; break; } if (Map[x][y] == 1) break; if ((x == 8 || y == 8) &amp;&amp; Map[x][y] == 2) { current = 0; break; } }        if (current &gt; 0) --current;        ret += current;        current = 0;        x = ox;        y = oy;        while (true) { ++current; --x; --y; if (Map[x][y] == 0) { current = 0; break; } if (Map[x][y] == 1) break; if ((x == 1 || y == 1) &amp;&amp; Map[x][y] == 2) { current = 0; break; } }        if (current &gt; 0) --current;        ret += current;        current = 0;        x = ox;        y = oy;        while (true) { ++current; --x; ++y; if (Map[x][y] == 0) { current = 0; break; } if (Map[x][y] == 1) break; if ((x == 1 || y == 8) &amp;&amp; Map[x][y] == 2) { current = 0; break; } }        if (current &gt; 0) --current;        ret += current;        current = 0;        x = ox;        y = oy;        while (true) { ++current; ++x; --y; if (Map[x][y] == 0) { current = 0; break; } if (Map[x][y] == 1) break; if ((x == 8 || y == 1) &amp;&amp; Map[x][y] == 2) { current = 0; break; } }        if (current &gt; 0) --current;        ret += current;        current = 0;        x = ox;        y = oy;        return ret;    }    void Search() {        for (int i = 1; i &lt;= 8; ++i) {            for (int j = 1; j &lt;= 8; ++j) {                if (Map[i][j] != 0) continue;                ans = std::max(ans, getAnswer(i, j) + getAnswerAlt(i, j));            }        }    }}int main(int argc, char *const argv[]) {#define HANDWER_FILE#ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);#endif    using namespace Solution;    using namespace FastIO;    Read();    Search();    putint(ans, &#39;\n&#39;);    return 0;}</code></pre><h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int dx[8 + 1] = {0, -1, -1, 0, 1, 1,  1,  0, -1};    const int dy[8 + 1] = {0,  0,  1, 1, 1, 0, -1, -1, -1};    const int INF = 2147482333;    char s[8 + 2][8 + 2];    int ans, Max;    void Init() {        for (int i = 1; i &lt;= 8; ++i) {            for (int j = 1; j &lt;= 8; ++j) {                cin &gt;&gt; s[i][j];            }        }    }    int DFS(int now, int x, int y) {        if (x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8 || s[x][y] == &#39;.&#39;) return -INF;        if (s[x][y] == &#39;B&#39;) return 0;        return DFS(now, x + dx[now], y + dy[now]) + 1;    }}int main(int argc, char *const argv[]) {#define HANDWER_FILE#ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);#endif    using namespace Solution;    using namespace FastIO;    Init();    for (int i = 1; i &lt;= 8; ++i) {        for (int j = 1; j &lt;= 8; ++j) {            for (int k = 1; k &lt;= 8; ++k) {                int p = 0;                if (s[i][j] == &#39;.&#39;) {                    p = DFS(k, i + dx[k], j + dy[k]);                    if (p &gt; 0) ans += p; // 累计答案                }            }            Max = std::max(Max, ans); // 更新答案            ans = 0;        }    }    putint(Max, &#39;\n&#39;);    return 0;}</code></pre><h1 id="T4-跳格子"><a href="#T4-跳格子" class="headerlink" title="T4. 跳格子"></a>T4. 跳格子</h1><h2 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h2><p>Nikola 现在已经成为一个游戏里的重要人物。这个游戏是由一行 N 个方格， N个方格 用 1 到 N 的数字表示。 Nikola 开始是在 1 号位置， 然后能够跳到其他的位置， Nikola 的第一跳必须跳到 2 号位置。随后的每一跳必须满足两个条件： 1、如果是向前跳， 必须比前面一跳远一个方格。 2、如果是向后跳， 必须和前面一跳一样远。 比如， 在第一跳之后（当在 2 号位置时）， Nikola 能够跳回 1 号位置， 或者向前跳到 4号位置。 每次他跳入一个位置， Nikola 必须付费。 Nikola 的目标是从一号位置尽可能便宜地跳到 N 号位置。 写一个程序， 看看 Nikola 跳到 N 号位置时最小的花费。</p><h2 id="输入输出格式-amp-样例-3"><a href="#输入输出格式-amp-样例-3" class="headerlink" title="输入输出格式 &amp; 样例"></a>输入输出格式 &amp; 样例</h2><p>输入格式：<br>共有 N+1 行。 第一行：包含一个整数 N， 它是位置的编号。 第 2..N+1 行：第 i+1 行表示第 I 个方格的费用， 是一个正整数</p><p>输出格式：<br>只有一个数， 表示 Nikola 跳到 N 号位置时最小的花费。</p><p>输入输出样例</p><p>输入样例#1：<br>6 1 2 3 4 5 6<br>输出样例#1：<br>12</p><p>输入样例#2：<br>8 2 3 4 3 1 6 1 4<br>输出样例#2：<br>14</p><h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>2≤N≤1000 费用不大于500</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>妥妥的DP</p><p>我们设    $\text{f[i][j]}$表示跳到第 $i$ 个格子上，可以向后跳 $j$ 个格子的时候的最小花费</p><p>转移方程：</p><ul><li>$\text{(default) f[i][j] = LESS_INF}$</li><li>上一次向前跳，显然上一次跳了 $j$ 格。$\text{f[i][j] = min(f[i][j], f[i-j][j-1]}$</li><li>上一次向后跳，显然上一次跳了 $j$ 格。 $\text{f[i][j] = min(f[i][j], f[i+j][j]}$</li></ul><p>最后加上本格的花费$\text{cost[i]}$就是$\text{f[i][j]}$</p><p>需要注意的东西有两个，一个是边界，另一个是答案为$\text{min{f[n][i]} }(i \in [1, n-1])$</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXN = 1000 + 10;    int cost[MAXN];    int f[MAXN][MAXN];    int n;    int DFS(int now, int step, int ncost) {        // 写挂了的搜索        if (now == n) return ncost;        int ret = 2147482333;        cout &lt;&lt; &quot;now = &quot; &lt;&lt; now &lt;&lt; endl;        cout &lt;&lt; &quot;ncost = &quot; &lt;&lt; ncost &lt;&lt; endl;        if (now + step + 1 &lt;= n) ret = std::min(ret, DFS(now + step + 1, step + 1, ncost + cost[now + step + 1]));        if (now != 1 &amp;&amp; step != 0 &amp;&amp; now - step &gt; 0) ret = std::min(ret, DFS(now - step, step, ncost + cost[now - step]));        return ret;    }}int main(int argc, char *const argv[]) {#define HANDWER_FILE#ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);#endif    using namespace Solution;    using namespace FastIO;    n = getint();    For (i, 1, n) cost[i] = getint();    int step = 0;    //putint(DFS(1, 0, cost[1]), &#39;\n&#39;);    //for (int i = 1; i &lt; n; ++i) {    //    int now = 2147482333;    //}    int Min = 2147482333;    for (int i = 2; i &lt;= n; ++i) f[i][0] = 0x3f3f3f3f;    for (int j = 1; j &lt; n; ++j) {        for (int i = n; i &gt;= 1; --i) {            f[i][j] = 0x3f3f3f3f;            if (i &gt; j) f[i][j] = f[i - j][j - 1];            if (i + j &lt;= n) f[i][j] = std::min(f[i][j], f[i + j][j]);            if (f[i][j] != 0x3f3f3f3f) f[i][j] += cost[i];            if (i == n) Min = std::min(Min, f[i][j]);        }    }    putint(Min, &#39;\n&#39;);    return 0;}</code></pre><p>果然我还是太弱了 这题并没有A掉 差这题就AK了</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当一个选手比你小，还比你强……&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="自测" scheme="https://blog.handwer-std.top/tags/%E8%87%AA%E6%B5%8B/"/>
    
      <category term="比赛" scheme="https://blog.handwer-std.top/tags/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="枚举" scheme="https://blog.handwer-std.top/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="自测题" scheme="https://blog.handwer-std.top/tags/%E8%87%AA%E6%B5%8B%E9%A2%98/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="暴力" scheme="https://blog.handwer-std.top/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>CCF 钦定评测系统 Arbiter 使用指南</title>
    <link href="https://blog.handwer-std.top/2018-11-02/Arbiter/"/>
    <id>https://blog.handwer-std.top/2018-11-02/Arbiter/</id>
    <published>2018-11-02T03:01:11.000Z</published>
    <updated>2018-11-24T04:20:26.359Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Developed by GAIT</p></blockquote><a id="more"></a><h1 id="什么是-Arbiter"><a href="#什么是-Arbiter" class="headerlink" title="什么是 Arbiter"></a>什么是 Arbiter</h1><p>Arbiter 是NOI信息学竞赛唯一指定评测工具，分为网络版和单机版，支持目前主流的 Linux 发行版本，多种语言支持（C, C++ 和 Free Pascal），功能多样，配置灵活，并具有精确的时间控制。</p><h1 id="下载-amp-安装"><a href="#下载-amp-安装" class="headerlink" title="下载 &amp; 安装"></a>下载 &amp; 安装</h1><h2 id="Deb-包"><a href="#Deb-包" class="headerlink" title="Deb 包"></a>Deb 包</h2><p>我没有找到关于 Deb 包的任何信息，可能 CCF 暂时移除了。</p><h2 id="NOI-Linux"><a href="#NOI-Linux" class="headerlink" title="NOI Linux"></a>NOI Linux</h2><p>首先，打开<a href="http://www.noi.cn/newsview.html?id=690&amp;hash=9A0662&amp;type=11" target="_blank" rel="noopener">这个网址</a><br>下载 NOI Linux 并安装（实体机虚拟机均可）<br>默认密码 123456</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="打开程序"><a href="#打开程序" class="headerlink" title="打开程序"></a>打开程序</h2><p>在 NOI Linux 中，你可以在左上角的「应用程序」中找到它。<br><img src="/images/Arbiter/1.png" alt="1"></p><p>打开之后，它的主界面是这样的。<br><img src="/images/Arbiter/2.png" alt="2"></p><h2 id="新建竞赛"><a href="#新建竞赛" class="headerlink" title="新建竞赛"></a>新建竞赛</h2><p>点击「NEW」按钮，输入比赛名称，选择存储目录，点击确定。</p><h2 id="打开竞赛"><a href="#打开竞赛" class="headerlink" title="打开竞赛"></a>打开竞赛</h2><p>如果你已经创建过的话，点击「OPEN」，选择竞赛的配置文件(.cfg)，点击确定即可。</p><h2 id="配置竞赛"><a href="#配置竞赛" class="headerlink" title="配置竞赛"></a>配置竞赛</h2><h3 id="试题配置"><a href="#试题配置" class="headerlink" title="试题配置"></a>试题配置</h3><p>打开竞赛之后，它会显示这样的一个界面。<br><img src="/images/Arbiter/3.png" alt="3"><br>我们<strong>右键单击</strong>试题概要<strong>下面的空白处</strong>，选择添加考试，它会添加一场名为「第一场——机试」的考试。<br><img src="/images/Arbiter/4.png" alt="4"><br>如何改名下面会说。</p><p>我们右键这场考试，选择添加试题，并点击「+」号展开这场比赛。试题默认的名字是「Unknow1」，可以自己修改。</p><p><img src="/images/Arbiter/5.png" alt="5"></p><p>在这里，你可以修改针对每一个试题的配置。我个人比较偏好的设置如下图。</p><p><img src="/images/Arbiter/6.png" alt="6"></p><p>关于其他的「比较方式」，在「<code>/path/to/your/contest/filter/readme.txt</code>」中可以了解，对应的比较方式也有源代码。</p><h3 id="数据配置"><a href="#数据配置" class="headerlink" title="数据配置"></a>数据配置</h3><p>所有的数据文件都放在「<code>/path/to/your/contest/evaldata/</code>」里，且无任何子文件夹。</p><p>所有的输入数据的名称都应该是「题目名称 + 编号 + <code>.in</code>」，如下图。</p><p><img src="/images/Arbiter/7.png" alt="7"></p><h1 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h1><h2 id="选手文件"><a href="#选手文件" class="headerlink" title="选手文件"></a>选手文件</h2><p>所有的选手文件夹都放在<code>.../players/</code>里</p><p>像 NOIP 一样，所有的选手文件都需要建立子文件夹。</p><pre><code>| .../players/|||--| SD-66666||------| ccf||----------&gt; ccf.cpp||------| cheat||----------&gt; cheat.cpp||------| money||----------&gt; money.cpp|</code></pre><h2 id="开始评测"><a href="#开始评测" class="headerlink" title="开始评测"></a>开始评测</h2><p>切换到「试题评测」界面，点击「添加选手」，输入姓名和编号，点击确定。<br>点击「导入名单」可以进行批量导入<del>我没试过</del>。</p><p><img src="/images/Arbiter/8.png" alt="8"></p><p>这里要注意编号是和文件夹名相同的。<br><img src="/images/Arbiter/9.png" alt="9"></p><p>首先我们要将「评测第<code>0</code>场」改一下，再点击「全选」，「评定选定选手」就开始评测了。</p><h2 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h2><p>评测完之后，程序会自动显示评测的结果。<br><img src="/images/Arbiter/10.png" alt="10"></p><p>更加详细的信息可以到「成绩统计」里看。「成绩统计」分为4个模块：总体统计、分组统计、试题统计和等级统计。<br><img src="/images/Arbiter/111.png" alt="111"><br><small><center>总体统计</center></small><br><img src="/images/Arbiter/112.png" alt="112"><br><small><center>分组统计</center></small><br><img src="/images/Arbiter/113.png" alt="113"><br><small><center>试题统计</center></small><br><img src="/images/Arbiter/114.png" alt="114"><br><small><center>等级统计</center></small></p><p>不得不说分组统计和等级统计就是专门为 NOIP 系列赛事开发的……</p><p>你可以选择导出或打印。</p><p>对了，成绩为什么多30pts我也不得而知（</p><h1 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h1><center>想问的可以在评论里问或发送邮件到我的邮箱<br>我会抽一些整理出来</center><p>Q1：如何给考试改名？<br>A1：当然是万能的配置文件。<br>打开day1.info，更改<code>NAME=</code>后面的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Developed by GAIT&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="使用指南" scheme="https://blog.handwer-std.top/tags/%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    
      <category term="比赛" scheme="https://blog.handwer-std.top/tags/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="评测系统" scheme="https://blog.handwer-std.top/tags/%E8%AF%84%E6%B5%8B%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2018游记</title>
    <link href="https://blog.handwer-std.top/2018-11-02/NOIP2018-PJ/"/>
    <id>https://blog.handwer-std.top/2018-11-02/NOIP2018-PJ/</id>
    <published>2018-11-02T02:35:19.000Z</published>
    <updated>2018-11-11T02:35:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&amp;GaiGeKaiFang(40)Nian</p></blockquote><a id="more"></a><h1 id="随手一记"><a href="#随手一记" class="headerlink" title="随手一记"></a>随手一记</h1><h2 id="NOIP2018-游记"><a href="#NOIP2018-游记" class="headerlink" title="NOIP2018 游记"></a>NOIP2018 游记</h2><pre><code>rp = 0x3f3f3f3f;rp++;</code></pre><p>出征！</p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h3><p>今天在学生活动中心肝了一个上午<br>又做了几道题 顺便写了一发题解<br>希望能涨涨RP吧</p><h3 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h3><p>等待进场的时间真是漫长。<br>看着队伍一点一点地往前走，我的心也开始激动了起来。</p><p>进场发现有人居然动鼠标，监考老师还不管<br>考前5min就发了密码</p><p>T1水题，上来5min切了<br>不过我居然奶中了，T1就是求一个字符串中有多少字符</p><p>T2是个暴力，最开始想出了$O(n^2)$的做法，后来改了一下就成了一个$O(n)$的做法，没意外应该能拿满</p><p>T3……我被T3切了<br>打了个最大计算量$10^{10}$的算法，结果极限大样例答案不对！心态崩了</p><p>T4随便判了几个情况，希望能骗一点分</p><p>顺便表扬CCF终于换评测机了</p><h1 id="正经的"><a href="#正经的" class="headerlink" title="正经的"></a>正经的</h1><p>Day0</p><p>成堆的人在开包，成堆的人出橙了，成堆的人掉rp。</p><p>不得不说去昌邑的路真漫长，貌似SDSC的时候都没这么长时间。</p><p>下了车第一件事就是拍照，补上SDSC没有拍照的遗憾，毕竟昌邑一中的绿化面积和水系的面积是极大的！这就是我戏称昌邑一中为“昌邑第一自然保护区”的原因。</p><p>晚上去试机，不得不说习惯了 Macbook Pro 2017 的蝶式键盘就真的回不来了。还有对应 Alt 键的 ⌘ 键，实在是习惯了，到那保存就是一个劲地按 Alt + S……敲了一遍代码的默认模板，5分钟敲过，和我预想中的差不多快。</p><p>Day1</p><p>上午去了学生活动中心做题，一口气切了8道题——但是都是「普及-」的题目，这可能是这三天我的活动安排的败笔。我应该做「普及/提高-」的题目的啊……</p><p>中午写了篇题解扔到博客上了，希望能rp++</p><p>下午去的时候手机居然没电了，好自闭啊。还没到2:30就带着一瓶今麦郎的凉白开进了场，居然不到时间就发了密码。<br>第一道题我居然说中了……考试前一天我还在说一道求字符串长度的题，于是用getline5分钟切了。<br>第二题依然是水题，先想到的是$O(n^2)$的做法，发现只能拿80分，于是就开始想正解。很快想到了一个$O(n)$的做法就开始敲，结果最大的样例过不了，然后简单分析了一下发现需要开long long int。不过，我在开了long long int之后只把表示∞的值提高了一点，在Day2的自测中才发现……所以我写$O(n)$的做法跟没写一样，开long long跟没开一样！看到自测的成绩后我心态是真的崩死了。<br>第三题第一眼是DP，但是推不出式子来，于是就开始想贪心做法。写了一个暴力，然后最大的样例死活调不过，浪费了近1个小时。<br>第四题一看就知道不大可做，然后尝试写暴力也没写出来，最后随便判了几个情况算完。</p><p>Day2<br>上午在学生活动中心把题目写了一遍，发现第二题∞的值设的过小，预测了一下省一线</p><h1 id="NOIP2018-普及组题解"><a href="#NOIP2018-普及组题解" class="headerlink" title="NOIP2018 普及组题解"></a>NOIP2018 普及组题解</h1><p>占坑</p><p><del>禁赛预定</del></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&amp;amp;GaiGeKaiFang(40)Nian&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
      <category term="游记" scheme="https://blog.handwer-std.top/tags/%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Manacher 算法介绍</title>
    <link href="https://blog.handwer-std.top/2018-11-01/Manacher/"/>
    <id>https://blog.handwer-std.top/2018-11-01/Manacher/</id>
    <published>2018-11-01T08:52:35.000Z</published>
    <updated>2018-11-24T04:21:31.846Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>$O(n)$回文串</p></blockquote><a id="more"></a><h1 id="Manacher-是什么"><a href="#Manacher-是什么" class="headerlink" title="Manacher 是什么"></a>Manacher 是什么</h1><p>Manacher 是一种可以在$O(n)$的时间复杂度内求出一个字符串的最长回文子串的算法。</p><p>Manacher，中文一般念做「马拉车」。</p><h1 id="Manacher-Algorithm-的思想"><a href="#Manacher-Algorithm-的思想" class="headerlink" title="Manacher Algorithm 的思想"></a>Manacher Algorithm 的思想</h1><p>首先我们来看一道题<a href="https://www.luogu.org/problemnew/show/P3805" target="_blank" rel="noopener">洛谷P3805【模板】manacher算法</a>。</p><p>考虑一下暴力做法，就是枚举字串的边界并进行验证，时间复杂度$O(n^3)$</p><p>考虑一下优化，我们可以枚举所有“回文子串”的对称轴（尽管它现在不一定是回文子串）并向两边进行扩展，用一个数组<code>external[i]</code>记录第<code>i</code>个字符可向外扩展的数量，显然数组中最大值的二倍就是答案，时间复杂度均摊$O(n^2)$。</p><p>但这还不够快……毕竟$\text{|s|} \leq 11000000$</p><p>于是我们考虑在优化的思想基础上进行再次优化。</p><hr><p>在此之前，我们首先要解决一个棘手的问题——字符串的长度。<br>一个字符串子串的对称轴是在字母中间还是在字母上，是由子串长度为偶数还是奇数决定的。于是，为了统一对于奇数长度字符串和偶数长度字符串的做法，我们需要对字符串进行修改。（代码见「代码实现」<code>Pre()</code>部分）</p><pre><code>就比如说 - - - - - -|%|%|%|w|y|h|我们要用一些无关紧要的字符填一下 - - - - - - - - - - -|%|!|%|!|%|!|w|!|y|!|h|这样更好处理</code></pre><p>修改完了之后，就是真正的<code>Manacher()</code>过程了<br>首先，我们要用一个变量<code>maxRight</code>记录「当前的 最靠右的 回文子串的 右端点」，和一个变量<code>mid</code>记录「当前的 最靠右的 回文子串的 对称轴所在的 字符的 下标」，注意这里的<code>mid</code>是可以不赋初值的</p><p>我们循环枚举<strong>经过处理的字符串</strong>的每一个字符。对于每一个字符的下标<code>i</code>，如果<code>i &lt; maxRight</code>，那么我们就可以获取<code>external[i]</code>的部分信息（<code>external[i]</code>的意义和上文相同），否则就只能将<code>external[i]</code>设为1</p><p>接着就是和暴力一样的扩展了，我这里选择用<code>for</code>语句实现（</p><p>最后更新一下<code>maxRight</code>和<code>mid</code>即可</p><p>最终答案就是<code>external[]</code>的最大值——而不是2倍，因为<strong>这是我们扩展过的字符串，最终答案还要$\times \frac{1}{2}$</strong>。</p><h1 id="Manacher-Algorithm-的代码实现"><a href="#Manacher-Algorithm-的代码实现" class="headerlink" title="Manacher Algorithm 的代码实现"></a>Manacher Algorithm 的代码实现</h1><p>同样也是「manacher模版」的代码实现。</p><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXN = 31000000 + 10;    // 没错，就是要开这么大    int n, external[MAXN];    char s[MAXN], str[MAXN &lt;&lt; 1];    void Pre() {        str[0] = str[1] = &#39;~&#39;;        for (int i = 0; i &lt; n; ++i) {            str[i * 2 + 2] = s[i];            str[i * 2 + 3] = &#39;~&#39;;        }        n = n * 2 + 2;        str[n] = 0;    }    void Manacher() {        int maxRight = 0, mid = 0; // mid 初值无所谓        for (int i = 1; i &lt; n; ++i) {            if (i &lt; maxRight) {                external[i] = std::min(external[(mid &lt;&lt; 1) - i], external[mid] + mid - i);            } else {                external[i] = 1;            }            for (; str[i + external[i]] == str[i - external[i]]; ++external[i]);            if (external[i] + i &gt; maxRight) {                maxRight = external[i] + i;                mid = i;            }        }    }    void Work() {        cin &gt;&gt; s;        n = (int) strlen(s);        Pre();        Manacher();        int ans = 1;        for (int i = 0; i &lt; n; ++i) ans = std::max(ans, external[i]);        cout &lt;&lt; ans - 1 &lt;&lt; endl;    }}int main(int argc, char *const argv[]) {#define HANDWER_FILE#ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);#endif    using namespace Solution;    using namespace FastIO;    Work();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;$O(n)$回文串&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="字符串" scheme="https://blog.handwer-std.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Manacher" scheme="https://blog.handwer-std.top/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1280《尼克的任务》</title>
    <link href="https://blog.handwer-std.top/2018-11-01/Luogu-P1280/"/>
    <id>https://blog.handwer-std.top/2018-11-01/Luogu-P1280/</id>
    <published>2018-11-01T08:51:53.000Z</published>
    <updated>2018-11-24T04:20:54.445Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>线性DP</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P1280" target="_blank" rel="noopener">题目🔗</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。</p><p>尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。</p><p>写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入数据第一行含两个用空格隔开的整数$N$和$K(1≤N≤10000，1≤K≤10000)$，$N$表示尼克的工作时间，单位为分钟，$K$表示任务总数。</p><p>接下来共有$K$行，每一行有两个用空格隔开的整数$P$和$T$，表示该任务从第$P$分钟开始，持续时间为$T$分钟，其中$1≤P≤N$，$1≤P+T-1≤N$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>15 61 21 64 118 58 111 5</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>4</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>DP</p><p>我们设<code>f[i]</code>表示在前<code>i</code>分钟内的最大空闲时间<br>但是发现第<code>i</code>分钟的空闲时间是由后面的任务决定的<br>所以我们考虑倒着扫一遍</p><hr><p>我们设<code>f[i]</code>表示在第<code>i</code>$\rightarrow$<code>n</code>分钟内的最大空闲时间<br>转移方程：</p><ul><li>当第<code>i</code>分钟没有任务时，<code>f[i] = f[i + 1] + 1</code></li><li>当第<code>i</code>分钟有任务时，<code>f[i] = std::max(f[i], f[i + seq[j]].time)</code>，其中<code>seq[j].time</code>表示第<code>j</code>个任务的耗时</li></ul><p>如何判断当前有没有任务？<br>我们开一个数组<code>sum[i]</code>表示第<code>i</code>分钟的任务个数<br>更新就很好更新了——<br><code>++sum[seq[j].startTime]</code>，其中<code>seq[j].startTime</code>表示第<code>j</code>个任务的开始时间</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    /*/     *     * 设f[i]表示i-n的空闲时间     * f[i] = f[i+1] + 1（无任务）     * f[i] = max(f[i], f[i + seq[x]])（有任务）     *    /*/    const int MAXK = 10000 + 10;    const int MAXN = MAXK;    struct QwQ {        int start, time;    } qwq[MAXK];    int n, k;    int sum[MAXN];    int f[MAXN];    int num = 1;    bool stlCmp(QwQ x, QwQ y) { return x.start &gt; y.start; }    void Work() {        using FastIO::getint;        n = getint();        k = getint();        For (i, 1, k) {            qwq[i].start = getint();            qwq[i].time = getint();            ++sum[qwq[i].start];        }        sort(qwq + 1, qwq + 1 + k, stlCmp);        // 既然是倒序，所以输入也要排序        for (int i = n; i &gt;= 1; --i) {            if (sum[i] == 0) f[i] = f[i + 1] + 1; // 当前时刻没有任务            else {                for (int j = 1; j &lt;= sum[i]; ++j) {                    f[i] = std::max(f[i], f[i + qwq[num].time]);                     // 当前时刻有至少一个任务，把它们都扫一遍                    ++num;                    // 用一个变量 num 表示当前扫到的任务                }            }        }        FastIO::putint(f[1], &#39;\n&#39;);        // 输出    }}int main(int argc, char *const argv[]) {#define HANDWER_FILE#ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);#endif    using namespace Solution;    using namespace FastIO;    Work();    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;线性DP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1577《切绳子》</title>
    <link href="https://blog.handwer-std.top/2018-10-31/Luogu-P1577/"/>
    <id>https://blog.handwer-std.top/2018-10-31/Luogu-P1577/</id>
    <published>2018-10-31T12:31:05.000Z</published>
    <updated>2018-11-24T04:21:06.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>突然想起《割绳子》</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P1577" target="_blank" rel="noopener">题面🔗</a></p><h1 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h1><p>有N条绳子，它们的长度分别为Li。如果从它们中切割出K条长度相同的绳子，这K条绳子每条最长能有多长？答案保留到小数点后2位。</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数N和K，接下来N行，描述了每条绳子的长度Li。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>切割后每条绳子的最大长度。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>4 118.027.434.575.39</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>2.00</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先这题涉及到了<code>int</code>和<code>double</code>之间的精度转换 <br><br>所以我们可以把输入的<code>double</code>都乘100转为<code>int</code>（题目要求保留两位小数）</p><p>不难看出来这题可以枚举答案 但是显然会炸 <br><br>于是我们要想点优化——二分答案！</p><p>我们选择二分绳子的最大长度 <br><br>这题的单调性是显然的，我就不证了（</p><p><code>Check(int mid)</code>怎么写？ <br><br>我们扫一遍绳子长度<code>L[]</code>，令$ ans=\sum_{i=1}^{n}\lfloor\frac{L[i]}{mid}\rfloor $ <br><br>即最终绳子被分成的段数 <br><br>如果$ans \geq k$（题目中的$\text{k}$）则把左边界赋值为<code>mid + 1</code>，否则把右边界赋值为<code>mid - 1</code> <br><br>这里要注意的是如果<code>mid == 0</code>就直接退出循环</p><p>最后<code>cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (double) r / 100.0 &lt;&lt; endl;</code></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;using namespace std;const int MAXN = 10000 + 10;const double MAXL = 100000.00;int n, k;int L[MAXN];bool Check(int x) {    int ans = 0;    for (int i = 1; i &lt;= n; ++i) ans += L[i] / x;    return ans &gt;= k;}int main(int argc, char *const argv[]) {    ios::sync_with_stdio(false);    cin &gt;&gt; n &gt;&gt; k;    for (int i = 1; i &lt;= n; ++i) {        double P;        cin &gt;&gt; P;        L[i] = (int) (P * 100.0);    }    int l = 0, r = 19260817 + 1;    while (l &lt;= r) {        int mid = (l + r) &gt;&gt; 1;        if (mid == 0) break;        if (Check(mid)) l = mid + 1;        else r = mid - 1;    }    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (double) r / 100.0 &lt;&lt; endl;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;突然想起《割绳子》&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="二分答案" scheme="https://blog.handwer-std.top/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1032《字串变换》</title>
    <link href="https://blog.handwer-std.top/2018-10-30/Luogu-P1032/"/>
    <id>https://blog.handwer-std.top/2018-10-30/Luogu-P1032/</id>
    <published>2018-10-30T09:26:45.000Z</published>
    <updated>2018-11-24T04:20:47.526Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NO ANSWER!</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>已知有两个字串$A,B$及一组字串变换的规则（至多$6$个规则）:</p><p>$A_1 \rightarrow B_1$ </p><p>$A_2 \rightarrow B_2$<br>​<br>规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $B_1$，$A_2$可以变换为 $B_2 \dots$</p><p>例如：$A=$’$abcdabcd$’，$B＝$’$xyzxyz$’</p><p>变换规则为：</p><p>‘$abc$’$\rightarrow$‘$xu$’ <br><br>‘$ud$’$\rightarrow$‘$y$’ <br><br>‘$y$’$\rightarrow$‘$yz$’</p><p>则此时，$A$可以经过一系列的变换变为$B$，其变换的过程为：</p><p>‘$abcd$’$\rightarrow$‘$xud$’$\rightarrow$‘$xy$’$\rightarrow$‘$xyz$’</p><p>共进行了$3$次变换，使得$A$变换为$B$。</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入格式如下：</p><p>$A$ $B$ <br><br>$A_1$ $B_1$<br>​<br>$A_2$ $B_2$​$|\rightarrow$ 变换规则</p><p>… … /</p><p>所有字符串长度的上限为$20$。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>输出至屏幕。格式如下：</p><p>若在$10$步（包含$10$步）以内能将$A$变换为$B$，则输出最少的变换步数；否则输出”NO ANSWER!”</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>abcd xyzabc xuud yy yz</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>3</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是一个 BFS</p><p>题目刚上来就有一个坑 <br><br>输入不给行数 只知道最多六行 <br><br>于是我们用一个变量<code>l</code>来记录输入的行数 <br><br>我这里选择用<code>A[0]</code>和<code>B[0]</code>来存两个原字符串</p><p>首先如果<code>l == 0</code>而且<code>A[0] != B[0]</code>，那直接输出<code>NO ANSWER!</code></p><p>否则用一个变量<code>v</code>来记录<code>BFS()</code>的返回值</p><p>如何搜索？ <br><br><del><a href="www.baidu.com">www.baidu.com</a> </del> <br><br>我们建两个队列<code>q</code>和<code>step</code>，分别存需要修改的字符串和这个字符串所对应的步数 <br><br>循环的时候就不能只判<code>!q.empty()</code>，还要判<code>q.front() != B[0] /* 字符串还需要修改 */</code>和<code>step.front() &lt;= 10 /* 限制只能修改10次 */</code> <br><br>我们还需要用一个<code>map&lt;string, bool&gt;</code>来判重</p><p>剩下的一些解释我直接扔到代码注释里面了</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int MAXN = 6 + 3;map&lt;string, bool&gt; KangShifu;string A[MAXN], B[MAXN];int BoynextdoorFaqSearch(int l) {    int ans = 0;    queue&lt;string&gt; q;    queue&lt;int&gt; step;    q.push(A[0]);    step.push(0);    while (!q.empty() &amp;&amp; q.front() != B[0] &amp;&amp; step.front() &lt;= 10) {        if (KangShifu[q.front()]) {            q.pop();            step.pop();            continue;            // 去重        }        KangShifu[q.front()] = true;        for (int i = 1; i &lt;= l; ++i) {            string s = q.front(); // 用一个string记录下当前需要修改的字符串            while (true) {                // 可能不止修改一次                int loc = s.find(A[i]);                if (loc == -1) break;                // 并没有找到                string ss = q.front();                // 再复制一份需要修改的字符串                ss.replace(loc, A[i].size(), B[i]);                // 修改                q.push(ss);                // 把它扔进队列                step.push(step.front() + 1);                // 步骤数 + 1                s[loc] = &#39;~&#39;;                // 把这个能搜到的地方用一个无关紧要的放起来                // 防止下次还能被搜到            }        }        q.pop();        step.pop();        // 处理完毕    }    if (q.empty() || step.front() &gt; 10) ans = -1;    // 如果队列空了或超过10步了，输出NO ANSWER!    else ans = step.front();    // 否则输出真正的答案    return ans;}int main(int argc, const char * argv[]) {    int l = 0;    while (cin &gt;&gt; A[l] &gt;&gt; B[l]) ++l;    --l;    if (l == 0 &amp;&amp; A[0] != B[0]) puts(&quot;NO ANSWER!&quot;);    else {        int v = BoynextdoorFaqSearch(l);        // Boy Next Door        if (v == -1) puts(&quot;NO ANSWER!&quot;);        else cout &lt;&lt; v &lt;&lt; endl;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;NO ANSWER!&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="字符串" scheme="https://blog.handwer-std.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="搜索" scheme="https://blog.handwer-std.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="BFS" scheme="https://blog.handwer-std.top/tags/BFS/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3952《时间复杂度》</title>
    <link href="https://blog.handwer-std.top/2018-10-29/Luogu-P3952/"/>
    <id>https://blog.handwer-std.top/2018-10-29/Luogu-P3952/</id>
    <published>2018-10-29T15:41:46.000Z</published>
    <updated>2018-11-24T04:41:20.146Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>继《玩具谜题》后的又一力作</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P3952" target="_blank" rel="noopener">题目地址</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。</p><p>A++语言的循环结构如下：</p><pre><code>F i x y    循环体E</code></pre><p>其中 $\text{F i x y}$ 表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i+1$，一旦 $i$ 大于 $y$ 终止循环。</p><p>$x​$ 和 $y​$ 可以是正整数（$x​$ 和 $y​$ 的大小关系不定）或变量 $n​$。$n​$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。</p><p>“$\text{E}$”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。</p><p>注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“$O$”表示通常意义下“$Θ$”的概念。</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 $\text{F i x y}$和$\text{E}$即可计算时间复杂度。注意：循环结构 允许嵌套。</p><p>接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符 串表示这个程序的复杂度，<code>O(1)</code>表示常数复杂度，<code>O(n^w)</code>表示复杂度为$n^w$，其中$w$是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有<code>O(1)</code>和<code>O(n^w)</code> 两种类型。</p><p>接下来 $L$ 行代表程序中循环结构中的$\text{F i x y}$或者 $\text{E<br>}$。 程序行若以$\text{F}$开头，表示进入一个循环，之后有空格分离的三个字符（串）$\text{i x y}$， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。</p><p>程序行若以$E$开头，则表示循环体结束。</p><h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出<code>Yes</code>或<code>No</code>或者<code>ERR</code>，若程序实际复杂度与输入给出的复杂度一致则输出<code>Yes</code>，不一致则输出<code>No</code>，若程序有语法错误（其中语法错误只有: ① $\text{F}$ 和 $\text{E}$ 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出<code>ERR</code> 。</p><p>注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 <code>ERR</code>。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>82 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>YesYesERRYesNoYesYesERR</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先我们肯定一眼就能看出这题是个没有任何优化的<big><big><big>大模拟</big></big></big></p><p>那么如何模拟？ </p><p>首先我们为了方便，把循环体离线下来，用字符串存着 </p><p>根据题意，我们写一个函数<code>GetNumber()</code>把字符串里的数字存下来 具体和快读差不多 </p><p>我们先把小明给出的时间复杂度的$n$的指数记为$\text{w}$，这里注意$O(1)$的情况要用$0$代替</p><p>接着便是求真正的时间复杂度了</p><p>首先是判断ERR 这个比较简单 我们用一个栈来储存所有的循环体<strong>的变量名</strong></p><ul><li>当$\text{E}$已经读完但是栈不空</li><li>当$\text{E}$未读完但是栈空</li><li>当储存的变量名与现在的变量名冲突</li></ul><p>这个过程穿插在代码各处 <br></p><p>当读到$\text{F}$的时候往栈里 Push 循环体变量名，注意要一块把记录变量名的数组<code>used</code>进行判断并更新 <br><br>之后，我们用<code>GetNumber</code>获取一下$x$和$y$两个数，分情况讨论一下</p><ul><li>当$y$是$n$的时候，如果这次循环可以执行，++答案</li><li>当$y&lt;x$的时候，循环不执行，更新一下「最早不能循环的循环体」</li><li>剩下一种情况就是常数，可以不写</li></ul><p>当读到$\text{E}$的时候，先检查栈里还有没有东西，再 Pop 出来，注意要检查一下这个变量是不是「最早不能循环的循环体」的变量</p><p>最后扫完数据，判一下栈是不是还有东西没 Pop 出来，然后验一下答案，输出</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;stack&gt;using namespace std;const int MAX = 100 + 10;string Code[MAX];int t;int GetNumber(int &amp;X, string s) {    int len = s.length();    while (!isdigit(s[X]) &amp;&amp; X &lt; len) {        if (s[X] == &#39;n&#39;) {            ++X;            return 19260817;        }        ++X;    }    int ret = 0;    while (isdigit(s[X])) {        ret = ret * 10 + s[X] - &#39;0&#39;;        ++X;    }    return ret;}int getO(string s) {    if (s[2] == &#39;n&#39;) {        int _ = 3; // 必须要传实参进去        return GetNumber(_, s);    }    return 0;}int GetO(int l) {    int ret = 0;    int now = 0;    char earliestVariant = -1; // 「最早不能循环的循环体」    int x = 0, y = 0;    stack&lt;int&gt; stk;    bool used[27] = { false };    bool ran[27] = { false };    for (int i = 1; i &lt;= l; ++i) {        if (Code[i][0] == &#39;F&#39;) {            char varName = Code[i][2];            if (used[varName - &#39;a&#39;]) return -1;            stk.push(varName);            used[varName - &#39;a&#39;] = true;            // Get X            int X = 4;            x = GetNumber(X, Code[i]);            // Get Y            y = GetNumber(X, Code[i]);            if (y - x &gt; 1000) {                // y = n                if (earliestVariant == -1) {                    ++now;                    ret = std::max(ret, now);                    ran[varName - &#39;a&#39;] = true;                }            } else if (x &gt; y) {                if (earliestVariant == -1) earliestVariant = varName;            }        } else {            if (stk.empty()) return -1;            char nowVarName = stk.top();            stk.pop();            used[nowVarName - &#39;a&#39;] = false;            if (earliestVariant == nowVarName) earliestVariant = -1;            if (ran[nowVarName - &#39;a&#39;]) {                ran[nowVarName - &#39;a&#39;] = false;                --now;            }        }    }    if (!stk.empty()) return -1;    return ret;}int main() {    scanf(&quot;%d&quot;, &amp;t);    while (t --&gt; 0) {        int w, nw, l;        scanf(&quot;%d &quot;, &amp;l);        string o;        getline(cin, o);        nw = getO(o);        for (int i = 1; i &lt;= l; ++i) {            getline(cin, Code[i]);        }        w = GetO(l);        if (w == -1) puts(&quot;ERR&quot;);        else {            if (w == nw) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        }    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;继《玩具谜题》后的又一力作&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="栈" scheme="https://blog.handwer-std.top/tags/%E6%A0%88/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
      <category term="毒瘤" scheme="https://blog.handwer-std.top/tags/%E6%AF%92%E7%98%A4/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1525《关押罪犯》</title>
    <link href="https://blog.handwer-std.top/2018-10-20/Luogu-P1525/"/>
    <id>https://blog.handwer-std.top/2018-10-20/Luogu-P1525/</id>
    <published>2018-10-20T07:09:51.000Z</published>
    <updated>2018-11-24T04:41:19.983Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>敌人的敌人就是朋友！</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/P1525" target="_blank" rel="noopener">题目地址</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>S城现有两座监狱，一共关押着 N 名罪犯，编号分别为 1−N 。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 c 的冲突事件。</p><p>每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。</p><p>在详细考察了 N 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。</p><p>那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>每行中两个数之间用一个空格隔开。第一行为两个正整数N,M，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的M行每行为三个正整数$a_j,b_j,c_j$，表示$a_j$号和$b_j$号罪犯之间存在仇恨，其怨气值为$c_j$。数据保证$1&lt;aj≤bj≤N,0 &lt; cj≤ 1,000,000,000$，且每对罪犯组合只出现一次。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共 1 行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 0。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>4 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>3512</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>显然这是一个并查集</p><p>首先我们把输入记录下来，按照权值从大到小排个序 <br><br>然后对于每一条关系，如果它们的祖先相同，就说明发生了冲突，此时直接输出 + return 0就好 <br><br>否则就进行合并</p><p>如何合并？ <br><br>根据“敌人的敌人就是朋友”的原则，我们维护一个<code>Enemy[i]</code>表示<code>i</code>的的敌人 <br><br>然后对于每一个人，更新它的敌人（如果它的敌人目前没被更新过）<br><br>否则就合并另一个人和他的敌人</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 20000 + 10;const int MAXM = 100000 + 10;struct Relative {    int x, y, weight;} rel[MAXM];int n, m, U[MAXM * 2], E[MAXN * 2];inline void Init() {    for (int i = 1; i &lt;= n; ++i) U[i] = i;}int Find(int x) {    if (x == U[x]) return x;    return U[x] = Find(U[x]);}void Union(int x, int y) {    x = Find(x), y = Find(y);    if (x == y) return;    U[x] = y;}bool stlCmp(Relative x, Relative y) {    return x.weight &gt; y.weight;}int main(int argc, char *const argv[]) {    ios::sync_with_stdio(false);    cin &gt;&gt; n &gt;&gt; m;    Init();    for (int i = 1; i &lt;= m; ++i) {        int x, y, w;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        rel[i].x = x;        rel[i].y = y;        rel[i].weight = w;    }    sort(rel + 1, rel + 1 + m, stlCmp);    for (int i = 1; i &lt;= m; ++i) {        int x = rel[i].x, y = rel[i].y;        int fx = Find(x), fy = Find(y);        if (fx == fy) {            printf(&quot;%d&quot;, rel[i].weight);            return 0;        }        if (E[x] == 0) E[x] = y;        else Union(E[x], y);        if (E[y] == 0) E[y] = x;        else Union(E[y], x);    }    printf(&quot;0&quot;);    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;敌人的敌人就是朋友！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
      <category term="并查集" scheme="https://blog.handwer-std.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>SP3377《A Bug&#39;s Life》</title>
    <link href="https://blog.handwer-std.top/2018-10-20/SP3377/"/>
    <id>https://blog.handwer-std.top/2018-10-20/SP3377/</id>
    <published>2018-10-20T01:51:14.000Z</published>
    <updated>2018-11-24T04:41:20.197Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>谁闲的没事研究同性恋。。。</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problemnew/show/SP3377" target="_blank" rel="noopener">题目地址</a></p><p>本文同步发布于：<a href="https://www.luogu.org/blog/handwer-blog/solution-sp3377" target="_blank" rel="noopener">Handwer’s 洛谷博客</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>就是一个奇怪的ke学家，他专门研究虫子是否存在同性恋。。。</p><p>他为每一只虫子都标上了序号。</p><p>通过这个奇怪的ke学家的研究，找出了在这些虫子中的所有关系的虫子，题目询问在这么多有关系的虫子中是否存在“同性恋”。</p><h1 id="输入格式-amp-样例"><a href="#输入格式-amp-样例" class="headerlink" title="输入格式 &amp; 样例"></a>输入格式 &amp; 样例</h1><p>第一行， 输入一个数，表示有t组数据<br>对于每组数据，第一行输入n,m，表示有n只虫子，有m个关系<br>接下来行每行两个数x,y，表示x,y有关系</p><pre><code>23 31 22 31 34 21 23 4    </code></pre><h1 id="输出格式-amp-样例"><a href="#输出格式-amp-样例" class="headerlink" title="输出格式 &amp; 样例"></a>输出格式 &amp; 样例</h1><p>对于每一组数据： <br><br>先输出：”Scenario #i” ，表示第i组数据 <br><br>然后如果有同性恋的输出”Suspicious bugs found!” <br><br>否则输出”No suspicious bugs found!” <br></p><pre><code>Scenario #1:Suspicious bugs found!Scenario #2:No suspicious bugs found!</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>显然这是一个并查集，但并不是一个裸的并查集</p><p>我们要多维护一个数组<code>rel[]</code>，其中<code>rel[i]</code>表示<code>i</code>和它的祖先的关系（relative）。我们定义<code>rel[i]</code>表示两种性别，当根节点相同且<code>rel[]</code>相同时，它们就是同性恋</p><p><code>rel[]</code>的更新方式：</p><pre><code>(in Find(x))rel[x] = (rel[x] + rel[U[x]]) % 2;</code></pre><pre><code>(in Union(x, y))int fx = Find(x), fy = Find(y);...rel[fx] = (rel[x] + rel[y] + 1) % 2;</code></pre><p><code>rel[]</code>的判断方式：</p><pre><code>(in Union(x, y))if (fx == fy) {    if (rel[x] == rel[y]) suspiciousFound = true;    return;}</code></pre><p>剩下的照常写就行</p><p>注意路径压缩要分开写，先创建一个变量存它的祖先节点再更新 </p><p><del>按秩合并没写过不知道</del></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><del>你们最喜欢的</del>代码实现：</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXM = 1000000 + 10;int n, m;int U[MAXM], rel[MAXM];bool flag;int Find(int x) {    if (x != U[x]) {        // 把路径压缩撑开写        int fux = Find(U[x]);        rel[x] = (rel[x] + rel[U[x]]) % 2; // 更新rel数组        // 1 1 -&gt; 0        // 1 0 / 0 1 -&gt; 1        // 0 0 -&gt; 0        // 其实是一个异或的过程        U[x] = fux； // qwq    }    return U[x];}void Union(int x, int y) {    int fx = Find(x), fy = Find(y);    if (fx == fy) {        if (rel[x] == rel[y]) flag = true; // 判断是否同性        return;    }    U[fx] = fy;    rel[fx] = (rel[x] + rel[y] + 1) % 2; // 更新rel数组}int main(int argc, char *const argv[]) {    int t;    scanf(&quot;%d&quot;, &amp;t);    int _t = 0;    while (t --&gt; 0) {        memset(U, 0, sizeof(U));        memset(rel, 0, sizeof(rel));        n = 0, m = 0, flag = false;        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);        for (int i = 1; i &lt;= n; ++i) U[i] = i;        for (int i = 1; i &lt;= m; ++i) {            int x, y;            scanf(&quot;%d %d&quot;, &amp;x, &amp;y);            Union(x, y);        }        printf(&quot;Scenario #%d:\n&quot;, ++_t);        if (flag) printf(&quot;Suspicious bugs found!\n&quot;);        else printf(&quot;No suspicious bugs found!\n&quot;);    }    return 3; // qwq}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;谁闲的没事研究同性恋。。。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="并查集" scheme="https://blog.handwer-std.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2866《[USACO06NOV]糟糕的一天Bad Hair Day》</title>
    <link href="https://blog.handwer-std.top/2018-10-06/Luogu-P2866/"/>
    <id>https://blog.handwer-std.top/2018-10-06/Luogu-P2866/</id>
    <published>2018-10-06T13:28:46.000Z</published>
    <updated>2018-11-24T04:41:20.121Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有点难想的单调栈模板题</p></blockquote><a id="more"></a><p><a href="https://www.luogu.org/problem/show?pid=2866" target="_blank" rel="noopener">题目地址</a></p><p>暂不提供题面，请自行到洛谷查看题面。</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：一个数N表示奶牛的数量。</p><p>第2到N+1行：第i+1行包含一个整数表示第i头奶牛的高。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行：一个整数，即c1到cN的和</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>610374122</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>5</code></pre><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这就是一个单调栈的模板</p><p>循环读入，每次push读入的数进一个单调栈并维护这个栈的单调性，最后答案累加栈的大小-1即可（显然题意说明奶牛是看不见自己的发型的，要把自己减去）</p><hr><p>以上操作的推导过程：</p><ul><li>我们对于当前读进去的奶牛的高度，计算栈中还有多少比它矮的，把它们pop出来（维护单调性）</li><li>这个过程其实就是在计算当前的奶牛能被多少奶牛看见</li><li>接下来累计答案</li><li>最后将当前奶牛的高度push进去</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    void DEBUG(char comment[], int x) {        cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl;    }    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXN = 80000 + 10;    struct Stack {        int seq[MAXN];        int tail;        Stack() {            memset(seq, 0, sizeof(seq));            tail = 0;        }        void Pop() {            tail--;        }        int Top() {            return seq[tail];        }        bool isEmpty() {            return tail == 0;        }        void Push(int x) {            while (!isEmpty() &amp;&amp; Top() &lt;= x) Pop();            seq[++tail] = x;        }        int Size() {            return tail;        }        int __tail_location() {            return tail;        }    } stk;    // 手写栈无所畏惧    int n;}int main(int argc, char *const argv[]) {    #ifdef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);    #endif    using namespace Solution;    using namespace FastIO;    n = getint();    long long int ans = 0;    For (i, 1, n) {        int x = getint();        stk.Push(x);        ans += stk.Size() - 1;    }    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有点难想的单调栈模板题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="栈" scheme="https://blog.handwer-std.top/tags/%E6%A0%88/"/>
    
      <category term="USACO" scheme="https://blog.handwer-std.top/tags/USACO/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1981《表达式求值》</title>
    <link href="https://blog.handwer-std.top/2018-10-06/Luogu-P1981/"/>
    <id>https://blog.handwer-std.top/2018-10-06/Luogu-P1981/</id>
    <published>2018-10-06T13:28:34.000Z</published>
    <updated>2018-11-24T04:41:20.084Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>新技能：手写计算器</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行，为需要你计算的表达式，表达式中只包含数字、加法运算符“$+$”和乘法运算符“ $\times$ ”，且没有括号，所有参与运算的数字均为 $0$ 到 $2^{31}$的整数。</p><p>输入数据保证这一行只有 $0−9$、$+$、 $\times$ 这 $12$ 种字符。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示这个表达式的值。</p><p>注意：当答案长度多于 4 位时，请只输出最后 4 位，前导 0 不输出。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><p>Case #1:</p><pre><code>1+1*3+4</code></pre><p>Case #2:</p><pre><code>1+1234567890*1</code></pre><p>Case #3:</p><pre><code>1+1000000003*1</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><p>Case #1:</p><pre><code>8</code></pre><p>Case #2:</p><pre><code>7891</code></pre><p>Case #3:</p><pre><code>4</code></pre><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>对于 30\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100；</p><p>对于 80\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤1000；</p><p>对于100\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100000。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们开两个单调栈，一个栈<code>num</code>来存储数字，一个栈<code>operators</code>来存储符号</p><p>其中<code>operators</code>的操作逻辑是这样的：</p><ul><li>首先把<code>~</code>push进去，作为一个占位符</li><li>我们对运算符标一个优先级，规定<code>~ &lt; + &lt; *</code>且相同运算符优先级低（满足从左到右的运算顺序），写一个判断函数</li><li>当push进去的运算符优先级比栈顶的低时，解决所有优先级低的运算符（维护单调性质）再push进去</li><li>当push进去的运算符优先级比栈顶的高时，不用管，直接push进去（满足单调性质）</li></ul><p>处理完输入之后，我们再对数字栈里剩下的数字进行处理</p><p>最后输出即可</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>这里面所有的注释都是我在DEBUG的时候手推的样例</p><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    void DEBUG(char comment[], int x) {        cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl;    }    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    stack&lt;int&gt; num;    stack&lt;int&gt; operators;    // 1: + -    // 2: * /    const int MOD = 10000;    long long int ans = 0;    bool Priority(char op1, char op2) {        // false -&gt; op1 is lower        // true -&gt; op1 is higher        if (op1 == op2) return false;        if (op1 == &#39;~&#39;) return false;        if (op1 == &#39;+&#39; &amp;&amp; op2 == &#39;*&#39;) return false;        if (op1 == &#39;*&#39; &amp;&amp; op2 == &#39;+&#39;) return true;    }}int main(int argc, char *const argv[]) {    #ifdef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);    #endif    using namespace Solution;    using namespace FastIO;    // 1+1*3+4    int ans = 0, now = 0;    char op = 0;    cin &gt;&gt; ans; // 1    num.push(ans % MOD); // &lt; 1    operators.push(&#39;~&#39;); // &lt; ~    while (cin &gt;&gt; op &gt;&gt; now) { // +1 // *3 // +4        char op1 = operators.top(); // ~ // + // *        while (Priority(op1, op)) { // false // false // true // false            int opNum = num.top(); // // // 3            num.pop(); // // //  &lt; 1 1            int opNum2 = num.top(); // // // 1            num.pop(); // // // &lt; 1             if (op1 == &#39;+&#39;) num.push((opNum + opNum2) % MOD); // // // false            if (op1 == &#39;*&#39;) num.push(opNum * opNum2 % MOD); // // // &lt; 1 3            operators.pop(); // &lt; +            op1 = operators.top(); // +        }        operators.push(op); // &lt; + // &lt; + * // &lt; + +        num.push(now); // &lt; 1 1 // &lt; 1 1 3 // &lt; 1 3 4    }    while (num.size() &gt; 1) { // true // true // false        int op = num.top(); // 4 // 7        num.pop(); // &lt; 1 3 // &lt; 1        int op2 = num.top(); // 3 // 1        num.pop(); // &lt; 1 // &lt;        char ope = operators.top();        operators.pop();        if (ope == &#39;+&#39;) num.push((op + op2) % MOD); // &lt; 1 7 // &lt; 8        if (ope == &#39;*&#39;) num.push(op * op2 % MOD);    }    FastIO::putint(num.top() % MOD, &#39;\n&#39;); // 8    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;新技能：手写计算器&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="栈" scheme="https://blog.handwer-std.top/tags/%E6%A0%88/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1750《出栈序列》</title>
    <link href="https://blog.handwer-std.top/2018-10-06/Luogu-P1750/"/>
    <id>https://blog.handwer-std.top/2018-10-06/Luogu-P1750/</id>
    <published>2018-10-06T13:28:13.000Z</published>
    <updated>2018-11-24T04:41:20.002Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这题和栈有多少关系</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个由n个元素构成的序列，你需要将其中的元素按顺序压入一个大小为c的栈并弹出。元素按它们的出栈顺序进行排列，会得到一个新的序列。我们知道，这样的序列会有很多种，请输出所有新序列中第一个元素最小的序列（若第一个元素最小的序列有多个，则令第二个尽可能小；若仍有多个，则令第三个最小，以此类推）。</p><h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个数n,c</p><p>第二行n个数，为序列中n个元素的值</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出n个数，为满足要求的序列。</p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>6 35 2 3 8 7 4</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>2 3 5 4 7 8</code></pre><h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>对于40%的数据，n&lt;=12</p><p>对于100%的数据，c&lt;=n&lt;=10000，元素大小均在2*10^9以内。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO {    void DEBUG(char comment[], int x) {        cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl;    }    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXN = 10000 + 10;    struct Stack {        private:            int __builtin_sequence[MAXN];            int tail;        public:            Stack() {                memset(__builtin_sequence, 0, sizeof(__builtin_sequence));                tail = 0;            }            void push(int x) {                __builtin_sequence[++tail] = x;            }            void pop() {                --tail;            }            int top() {                return __builtin_sequence[tail];            }            bool empty() {                return tail == 0;            }            int size() {                return tail;            }    } stk;     int n, c;    int seq[MAXN];}int main(int argc, char *const argv[]) {    #ifdef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);    #endif    using namespace Solution;    using namespace FastIO;    n = getint();    c = getint();    int used = 0;    int unusedNum = 1;    For (i, 1, n) {        seq[i] = getint();    }    while (stk.size() + used &lt; n) {        int inQueue = stk.size();        int origUnusedNum = unusedNum;        int minN = 2147482333;        int len = c - inQueue;        for (int i = origUnusedNum; i &lt;= n &amp;&amp; i &lt; origUnusedNum + len; ++i) {            if (seq[i] &lt; minN) {                unusedNum = i;                minN = seq[i];            }        }        if (stk.empty() || minN &lt; stk.top()) {            For (i, origUnusedNum, unusedNum) {                stk.push(seq[i]);            }            ++unusedNum;        } else unusedNum = origUnusedNum;        putint(stk.top(), &#39; &#39;);        ++used;        stk.pop();    }    while (!stk.empty()) {        putint(stk.top(), &#39; &#39;);        stk.pop();    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这题和栈有多少关系&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="栈" scheme="https://blog.handwer-std.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>2018 Autumn 清北学堂普及刷题班 Day5 题解</title>
    <link href="https://blog.handwer-std.top/2018-10-05/2018AutumnQBXTDay5/"/>
    <id>https://blog.handwer-std.top/2018-10-05/2018AutumnQBXTDay5/</id>
    <published>2018-10-05T11:00:23.000Z</published>
    <updated>2018-11-24T04:41:19.904Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>暴力分！暴力分！</p></blockquote><a id="more"></a><h1 id="Problem-A-climb"><a href="#Problem-A-climb" class="headerlink" title="Problem A. climb"></a>Problem A. climb</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Bob 在一旁看 Alice 爬台阶玩， Alice 突发奇想让 Bob 闭上眼记录他爬了多少台阶，规则是这样的： Alice每次会想好爬多少级台阶，每爬一级都会数数，爬完之后走回到最底层，注意走回去的那些台阶是不算级数的。 Bob 闭上眼通过 Alice 的报数来统计 Alice 总共爬了几次，每次爬了多少级。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数 N(1 ≤ 100000)，表示 Alice 的报数次数。 <br><br>第二行包含 N 个正整数 Ai(1 ≤ Ai ≤ 1000)，表示 Alice 的报数序列。 <br></p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行包含一个整数，表示 Alice 爬的次数 T。第二行包含 T 个整数，第 i 个整数表示 Alice 每 i 次爬的台阶数。 <br></p><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>71 2 3 1 2 3 4</code></pre><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>23 4</code></pre><h2 id="子任务"><a href="#子任务" class="headerlink" title="子任务"></a>子任务</h2><p>对于 40% 的数据， N ≤ 20。 <br><br>对于 70% 的数据， N ≤ 1000。 <br><br>对于 100% 的数据， N ≤ 100000。 <br></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><del>A不掉的退役吧</del></p><p>显然这题就是让你求有多少个1和每两个1之间的距离 <br><br>当然这题题面有点歧义 求每个1之前的数也可以（数据水</p><p>就没了</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)using namespace std;namespace FastIO {    void DEBUG(char comment[], int x) {        cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl;    }    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXN = 100000 + 10;    int n;    int seq[MAXN];    int T;    vector&lt;int&gt; cnt;    void Work() {        For (i, 1, n) {            if (seq[i] == 1) ++T, cnt.push_back(seq[i-1]);        }        cnt.push_back(seq[n]);    }}int main(int argc, char *const argv[]) {    #ifndef HANDWER_FILE    freopen(&quot;climb.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;climb.out&quot;, &quot;w&quot;, stdout);    #endif    using namespace Solution;    using namespace FastIO;    n = getint();    For (i, 1, n) seq[i] = getint();    Work();    putint(T, &#39;\n&#39;);    int siz = cnt.size();    Forw (i, 1, siz - 1) putint(cnt[i], &#39; &#39;);    putint(cnt[siz - 1], &#39;\n&#39;);    return 0;}</code></pre><h1 id="Problem-B-remove"><a href="#Problem-B-remove" class="headerlink" title="Problem B. remove"></a>Problem B. remove</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个字符串 s，字符串中只会包含⼩写字母 a − z。现在需要通过重复下面这个算法<br>符串中删去 k 个字符：<br>• 如果当前字符串中还存在字符 a，就删去字符串中最前面的一个 a 字符，结束算法<br>• 如果当前字符串中还存在字符 b，就删去字符串中最前面的一个 b 字符，结束算法<br>• …<br>• 如果当前字符串中还存在字符 z，就删去字符串中最前面的一个 z 字符，结束算法<br>求删完 k 个字符后的字符串。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 n; k(1 ≤ k ≤ n ≤ 100000)， n 表示字符串长度， k 表示删去的字符个数。 <br><br>第二行包含一个字符串 s。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，包含删去k个字符的字符串。</p><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h2><p>Case #1:</p><pre><code>15 3cccaabababaccbc</code></pre><p>Case #2:</p><pre><code>15 9cccaabababaccbc</code></pre><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h2><p>Case #1:</p><pre><code>cccbbabaccbc</code></pre><p>Case #2:</p><pre><code>cccccc</code></pre><h2 id="子任务-1"><a href="#子任务-1" class="headerlink" title="子任务"></a>子任务</h2><p>对于 40% 的数据， 1 ≤ k ≤ n ≤ 100。 <br><br>对于 70% 的数据， 1 ≤ k ≤ n ≤ 1000。 <br><br>对于 100% 的数据， 1 ≤ k ≤ n ≤ 100000。 <br></p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题我在考试结束之后20min敲出了正解。。。。。。</p><p>我们开一个桶，把所有的字母记录下来 <br><br>接着把桶扫一遍：</p><ul><li>如果当前的k大于当前的字母数<code>alphabet[i]</code>，就让<code>k -= alphabet[i]</code>，然后把<code>alphabet[i]</code>置为0</li><li>否则让<code>alphabet[i] -= k</code>，然后把<code>k</code>置为0，最后<code>break</code>掉即可</li></ul><p>此时，<code>alphabet</code>的意义已经从字母数量变成了<strong>经过删除后的</strong>还可输出字母数量</p><p>之后，我们开一个bool数组<code>chk[i]</code>表示<code>str[i]</code>是否还能被输出，并<strong>倒序</strong>（注意是倒序，因为题目要求从前面开始删，显然我们要保留后面几位）枚举 $i\ (0 &lt; i &lt; n)$</p><ul><li>当<code>alphabet[str[i] - &#39;a&#39;] &gt; 0</code>时，将<code>chk[i]</code>设为<code>true</code>并<code>--alphabet[str[i] - &#39;a&#39;]</code></li></ul><p>最后，从头扫一遍<code>chk</code>，如果<code>chk[i] == true</code>就输出<code>str[i]</code></p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO {    void DEBUG(char comment[], int x) {        cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl;    }    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXN = 100000 + 10;    int n, k;    string s;    bool chk[MAXN];    string Work(string str) {        // 此为暴力做法        For (i, 1, k) {            Forw (j, 0, 26) {                cout &lt;&lt; str &lt;&lt; endl;                int findnow = str.find(j + &#39;a&#39;);//                printf(&quot;%c\n&quot;, j + &#39;a&#39;);                if (findnow != string::npos) {                    str[findnow] = &#39;-&#39;;                    break;                }            }        }        return str;    }    void nowWork(string str) {        // 此为正解        int alphabet[26 + 2] = { 0 };        bool printal[26] = { true };        Forw (i, 0, n) alphabet[str[i] - &#39;a&#39;]++;        Forw (i, 0, 26) {            //cerr &lt;&lt; (char)(i + &#39;a&#39;)&lt;&lt; &#39;=&#39;;            //cerr &lt;&lt; alphabet[i] &lt;&lt; endl;            if (alphabet[i] &lt; k) {                k -= alphabet[i];                alphabet[i] = 0;            } else {                alphabet[i] -= k;                k = 0;                break;            }        }        Bak (i, n-1, 0) {            if (alphabet[str[i] - &#39;a&#39;] == 0) continue;            chk[i] = true;            --alphabet[str[i] - &#39;a&#39;];        }        Forw (i, 0, n) if (chk[i]) putchar(str[i]);    }    void Print(string str) {        // 此为暴力做法的输出        Forw (i, 0, n) if (str[i] != &#39;-&#39;) putchar(str[i]);    }}int main(int argc, char *const argv[]) {    #ifndef HANDWER_FILE    freopen(&quot;remove.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;remove.out&quot;, &quot;w&quot;, stdout);    #endif    using namespace Solution;    ios::sync_with_stdio(false);//    int t = clock();    cin &gt;&gt; n &gt;&gt; k;    cin &gt;&gt; s;    //Print(Work(s));    nowWork(s);//    cerr &lt;&lt; clock() - t &lt;&lt; endl;    return 0;}</code></pre><h1 id="Problem-C-cut"><a href="#Problem-C-cut" class="headerlink" title="Problem C. cut"></a>Problem C. cut</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个字符串 s，其中每个字符都是 0 9 的数字。现在需要把字符串 s 分割开，这样每个<br>部分就可以看做一个数，求这些数中最多有多少个数是 3 的倍数。 <br><br>如对于字符串 3121，可以分割为 3 | 12 | 1，这样会有两个数是 3 的倍数，如果分割为 31 | 2 | 1，这样就没有数是 3 的倍数了。0 是 3 的倍数，如果 1200045 被拆分为 120 | 0045，则认为分割出来的两个数是 120 和 45，即忽略前导零。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行包含一个字符串s，$|s|\le100000$</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行包含一个整数，表示最多有多少个数是3的倍数。</p><h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h2><p>Case #1:</p><pre><code>3121</code></pre><p>Case #2:</p><pre><code>201920181</code></pre><h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h2><p>Case #1：</p><pre><code>2</code></pre><p>Case #2:</p><pre><code>4</code></pre><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>第一个样例中可以拆分为 3 | 12 | 1。 <br><br>第二个样例中可以拆分为 201 | 9 | 2 | 0 | 18 | 1。 <br></p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先我们对读进来的序列整体mod 3</p><p>接着对这个序列扫一遍</p><ul><li><p>如果当前读到的数是0，根据贪心策略，直接在后面划上一道</p></li><li><p>否则如果当前读的数的下标大于0，就看前面的数<br>如果这个数与上个数的和能被3整除，而且下个数没有被选过，就在后面划上一道</p></li><li><p>否则如果当前读的数的下标大于1，继续看前面的数<br>如果这个数与前面两个数的和能被3整除，而且两个数都没有选过，就在后面划上一道</p></li><li><p>否则什么都不干</p></li></ul><p>最后输出即可</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code class="cpp">/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO {    void DEBUG(char comment[], int x) {        cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl;    }    inline int getint() {        int s = 0, x = 1;        char ch = getchar();        while (!isdigit(ch)) {            if (ch == &#39;-&#39;) x = -1;            ch = getchar();        }        while (isdigit(ch)) {            s = s * 10 + ch - &#39;0&#39;;            ch = getchar();        }        return s * x;    }    inline void __basic_putint(int x) {        if (x &lt; 0) {            x = -x;            putchar(&#39;-&#39;);        }        if (x &gt;= 10) __basic_putint(x / 10);        putchar(x % 10 + &#39;0&#39;);    }    inline void putint(int x, char external) {        __basic_putint(x);        putchar(external);    }}namespace Solution {    const int MAXN = 100000 + 10;    bool vis[MAXN];    int seq[MAXN];     int len;    int Work() {        int ret = 0;        For (i, 1, len) {            if (seq[i] == 0) {                ++ret;                vis[i] = true;            } else if (i &gt; 0 &amp;&amp; (seq[i] + seq[i - 1]) % 3 == 0 &amp;&amp; !vis[i - 1]) {                ++ret;                vis[i] = true;            } else if (i &gt; 1 &amp;&amp; (seq[i] + seq[i - 1] + seq[i - 2]) % 3 == 0 &amp;&amp; !vis[i - 1] &amp;&amp; !vis[i - 2]) {                ++ret;                vis[i] = true;            }        }        return ret;    }}int main(int argc, char *const argv[]) {    #ifndef HANDWER_FILE    freopen(&quot;testdata.in&quot;, &quot;r&quot;, stdin);    freopen(&quot;testdata.out&quot;, &quot;w&quot;, stdout);    #endif    using namespace Solution;    string s;    cin &gt;&gt; s;    len = s.length();    For (i, 1, len) seq[i] = (s[i-1] - &#39;0&#39;) % 3;    int ans = Work();    cout &lt;&lt; ans &lt;&lt; endl;    return 0;}</code></pre><h1 id="Problem-D-sum"><a href="#Problem-D-sum" class="headerlink" title="Problem D. sum"></a>Problem D. sum</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>某些数有奇怪的性质：它十进制下的各位数的平方和的 T 倍等于它本身。求在 [A, B] 范围内的数有多少满足这个性质</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 T, A, B(1 ≤ T; A; B ≤ 10^18; A ≤ B)。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示满足条件的数量。</p><h2 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例"></a>输入样例</h2><pre><code>51 5000 10000</code></pre><h2 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例"></a>输出样例</h2><pre><code>3</code></pre><h2 id="子任务-2"><a href="#子任务-2" class="headerlink" title="子任务"></a>子任务</h2><p>对于 40% 的数据， 1 ≤ T; A; B ≤ 100000; A ≤ B。<br>对于 100% 的数据， 1 ≤ T; A; B ≤ 10^18; A ≤ B。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>此为标程</strong></p><pre><code class="cpp">long long calc(long long x) {    long long ans = 0;    while (x) {        ans += (x % 10) * (x % 10);        x /= 10;    }    return ans;}</code></pre><pre><code class="cpp">long long k, a, b, ans = 0;    scanf(&quot;%lld%lld%lld&quot;, &amp;k, &amp;a, &amp;b);    for(int i = 1; i &lt;= 1600; i++) {        if (a &lt;= k * i &amp;&amp; i &lt;= b / k)            if (calc(k * i) == i) {                printf(&quot;%lld\n&quot;, k * i);                ans++;            }    }    printf(&quot;%lld\n&quot;, ans);    return 0;</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;暴力分！暴力分！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="清北学堂" scheme="https://blog.handwer-std.top/tags/%E6%B8%85%E5%8C%97%E5%AD%A6%E5%A0%82/"/>
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="贪心" scheme="https://blog.handwer-std.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="字符串" scheme="https://blog.handwer-std.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
