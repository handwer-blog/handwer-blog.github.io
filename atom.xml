<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Handwer&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.handwer-std.top/"/>
  <updated>2019-02-16T11:25:59.059Z</updated>
  <id>https://blog.handwer-std.top/</id>
  
  <author>
    <name>Handwer STD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公告栏</title>
    <link href="https://blog.handwer-std.top/2019-10-31/BulletinBoard/"/>
    <id>https://blog.handwer-std.top/2019-10-31/BulletinBoard/</id>
    <published>2019-10-31T12:30:10.000Z</published>
    <updated>2019-02-16T11:25:59.059Z</updated>
    
    <content type="html"><![CDATA[<p><font style="color:#66ccff"></font></p><p><center>这里可能会挂些什么东西。 <br>There may be something here.<br></center><br><br><img src="https://v2.jinrishici.com/one.svg" alt="今日诗词"></p><p>博客累计已突破 100 篇文章</p><p>New！<a href="/2019-02-16/SDWC-Article/">《「文章」百名学生参训 礼堂“变身”教室》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font style=&quot;color:#66ccff&quot;&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;这里可能会挂些什么东西。 &lt;br&gt;There may be something here.&lt;br&gt;&lt;/center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://v2
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>洛谷P2016《战略游戏》</title>
    <link href="https://blog.handwer-std.top/2019-05-11/Luogu-P2016/"/>
    <id>https://blog.handwer-std.top/2019-05-11/Luogu-P2016/</id>
    <published>2019-05-11T06:58:24.000Z</published>
    <updated>2019-05-11T08:41:24.050Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最典型的树形DP</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Bob喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。</p><p>他要建立一个古城堡，城堡中的路形成一棵树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。</p><p>注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被了望到。</p><p>请你编一程序，给定一树，帮Bob计算出他需要放置最少的士兵.</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行 N，表示树中结点的数目。</p><p>第二行至第N+1行，每行描述每个结点信息，依次为：该结点标号i，k(后面有k条边与结点I相连)。</p><p>接下来k个数，分别是每条边的另一个结点标号r1，r2，…，rk。</p><p>对于一个n(0&lt;n&lt;=1500)个结点的树，结点标号在0到n-1之间，在输入数据中每条边只出现一次。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件仅包含一个数，为所求的最少的士兵数目。</p><p>例如，对于如下图所示的树：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">       <span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">3</span></span><br></pre></td></tr></table></figure><p>答案为1（只要一个士兵在结点1上）。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">0</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题，就是这种树形DP最标准的形态<br>「选点DP」</p><hr><p>设 <code>dp[i][0/1]</code> 表示选/不选以i为根的子树时的最大值</p><p>转移方程很显然<br><code>dp[root][0] += dp[child][1]</code><br><code>dp[root][1] += std::min(dp[child][0], dp[child][1])</code></p><p>也就是</p><ul><li><p>如果我不选当前点，那么就必须选我儿子，不然我和我儿子之间这条路没人看</p></li><li><p>如果我选了当前点，我儿子干啥我是不管的，选一个最小的加上</p></li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, dp[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    G[prev].push_back(next);</span><br><span class="line">    G[next].push_back(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    dp[root][<span class="number">1</span>] = <span class="number">1</span>; dp[root][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[root]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(v, root);</span><br><span class="line">        dp[root][<span class="number">1</span>] += <span class="built_in">std</span>::min(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]);</span><br><span class="line">        dp[root][<span class="number">0</span>] += dp[v][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; k;</span><br><span class="line">        ++id;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; qwq;</span><br><span class="line">            ++qwq;</span><br><span class="line">            addEdge(id, qwq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::min(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最典型的树形DP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2014《选课》</title>
    <link href="https://blog.handwer-std.top/2019-05-11/Luogu-P2014/"/>
    <id>https://blog.handwer-std.top/2019-05-11/Luogu-P2014/</id>
    <published>2019-05-11T06:39:08.000Z</published>
    <updated>2019-05-11T07:38:48.545Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>森林上的DP</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数N,M用空格隔开。(1&lt;=N&lt;=300,1&lt;=M&lt;=300)</p><p>接下来的N行,第I+1行包含两个整数ki和si, ki表示第I门课的直接先修课，si表示第I门课的学分。若ki=0表示没有直接先修课（1&lt;=ki&lt;=N, 1&lt;=si&lt;=20）。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一行，选M门课程的最大得分。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">7 </span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span> <span class="number">2</span></span><br><span class="line"><span class="symbol">0 </span> <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span> <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span> <span class="number">1</span></span><br><span class="line"><span class="symbol">7 </span> <span class="number">1</span></span><br><span class="line"><span class="symbol">7 </span> <span class="number">6</span></span><br><span class="line"><span class="symbol">2 </span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>注意到题目中的「每门课有一门或没有直接先修课」<br>所以这是一个森林</p><p>我们用一个虚拟点0把所有的树根连起来，构成一棵大树<br>接下来这个题目就从一个DAG上DP转化为了一个树形DP<br>但是！它事一个树形背包</p><hr><p>设<code>dp[i][j]</code>表示选以i为根的树j个节点</p><p>初始化方程：<br><code>dp[child][i] = dp[root][i] + weight[root]</code><br><code>(0 &lt;= i &lt; 还能选择的节点数)</code><br>至于为什么从零开始……因为可以选择的节点是root的子树的节点数减一，毕竟root占掉了一个节点</p><p>转移方程：<br><code>dp[root][i] = std::max(dp[root][k], dp[child][k-1]);</code><br><code>(1 &lt;= i &lt;= 还能选择的节点数)</code></p><p>答案：<br><code>dp[0][m]</code></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首先这是一个森林</span></span><br><span class="line"><span class="comment"> * 令 f[i][j] 表示以 i 为根的子树选择前 j 个点的最大价值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> weight[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        head[prev].push_back(next);</span><br><span class="line">        weight[next] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 没得选了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> now : head[root]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                dp[now][i] = dp[root][i] + weight[now];</span><br><span class="line">            &#125;</span><br><span class="line">            DFS(now, k - <span class="number">1</span>); <span class="comment">// 对子树进行选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">                dp[root][i] = <span class="built_in">std</span>::max(dp[root][i], dp[now][i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev, weight;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; prev &gt;&gt; weight;</span><br><span class="line">        G.addEdge(prev, i, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    G.DFS(<span class="number">0</span>, m);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">0</span>][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;森林上的DP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
      <category term="背包问题" scheme="https://blog.handwer-std.top/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Luogu-P1967</title>
    <link href="https://blog.handwer-std.top/2019-03-30/Luogu-P1967/"/>
    <id>https://blog.handwer-std.top/2019-03-30/Luogu-P1967/</id>
    <published>2019-03-30T13:46:53.000Z</published>
    <updated>2019-03-30T13:46:53.535Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>洛谷P5018「NOIP2018普及组」《对称二叉树》</title>
    <link href="https://blog.handwer-std.top/2019-03-30/NOIP2018-PJ-Tree-Luogu-P5018/"/>
    <id>https://blog.handwer-std.top/2019-03-30/NOIP2018-PJ-Tree-Luogu-P5018/</id>
    <published>2019-03-30T07:49:29.000Z</published>
    <updated>2019-03-30T08:25:41.810Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个长得像暴力的正解</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树：</p><ol><li>二叉树；</li><li>将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。</li></ol><p>下图中节点内的数字为权值，节点外的 id 表示节点编号。</p><p><img src="https://cdn.luogu.org/upload/pic/43192.png" alt="1"></p><p>现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。</p><p>注意：只有树根的树也是对称二叉树。本题中约定，以节点T 为子树根的一棵“子 树”指的是：节点 T 和它的全部后代节点构成的二叉树。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 $1 \sim n$，其中节点 1 是树根。</p><p>第二行 n 个正整数，用一个空格分隔，第 i 个正整数 $v_i$​ 代表节点 i 的权值。</p><p>接下来 n 行，每行两个正整数 $l_i, r_i$，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 -1 表示。两个数之间用一个空格隔开。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">3</span> </span><br><span class="line"><span class="number">2</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br><span class="line">``` </span><br><span class="line">## 输出样例#<span class="number">1</span></span><br><span class="line">``` </span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> </span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">4</span> <span class="number">4</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">9</span> <span class="number">10</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">5</span> <span class="number">6</span> </span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> </span><br><span class="line"><span class="number">7</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模与约定】<br>共 25 个测试点。<br>$v_i ≤ 1000$。<br>测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。<br>测试点 $4 \sim 8, n ≤ 10$。<br>测试点 $9 \sim 12, n ≤ 10^5$ ，保证输入是一棵“满二叉树” 。<br>测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。<br>测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 1。<br>测试点 $21 \sim 25, n ≤ 10^6$ 。</p><p>本题约定：</p><p>层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 1。</p><p>树的深度：树中节点的最大层次称为树的深度。</p><p>满二叉树：设二叉树的深度为 h，且二叉树有 $2h−1$ 个节点，这就是满二叉树。</p><p>完全二叉树：设二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大 个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>场上没写这道题真是<big>血亏</big><br><del>被T3折磨得心态爆炸&nbsp;也没心情写这题了。。。</del></p><hr><p>首先它求的是满足要求的最大子树的<strong>大小</strong><br>那就先 DFS 一遍求出所有子树的大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// nodes[root].treeSize 已经被赋值为1了</span></span><br><span class="line">    <span class="keyword">if</span> (nodes[root].leftChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].leftChild);</span><br><span class="line">        nodes[root].treeSize += nodes[LC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].rightChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].rightChild);</span><br><span class="line">        nodes[root].treeSize += nodes[RC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后呢？</p><p>一个很暴力的想法，就是暴力枚举根节点，判断一下这棵子树是否对称，对称就更新答案</p><p>判断对称是很好写的，递归即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckSymmetric</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">-1</span> &amp;&amp; n2 == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (n1 != <span class="number">-1</span> &amp;&amp; n2 != <span class="number">-1</span>) <span class="comment">/* 判断是否有完整的节点 */</span></span><br><span class="line">        &amp;&amp; nodes[n1].data == nodes[n2].data <span class="comment">/* 判断节点信息是否相同 */</span></span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n1), RC(n2)) <span class="comment">/* 递归判断两边的节点 */</span></span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n2), RC(n1)) <span class="comment">/* 递归判断中间的节点 */</span></span><br><span class="line">    ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 判断失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>「递归判断两边 / 中间的节点」，是这么回事</p><p><img src="https://cdn.luogu.org/upload/pic/43189.png" alt="2"></p><p>先假装节点<code>id = 2</code>不存在<br><!--好现在枚举到了`id = 10`的节点来写一下伪代码调用函数 CheckSymmetric((id = 10) -> LeftChild, (id = 10) -> RightChild).... n1 = 7, n2 = 8.... n1 != -1, n2 != -1, 判断失败.... n1 != -1, n2 != -1，判断成功，继续判断|... nodes[n1].data == nodes[n2].data，判断成功，继续判断|... 调用函数 CheckSymmetric--></p><p>在进行递归的时候，判断的是<code>(id = 3, id = 6)</code>和<code>(id = 4, id = 5)</code><br>很明显判断对称的时候，要判断的就是这两个节点（和它们的子树）</p><hr><p>代码分析完了，来算算这份暴力的复杂度</p><ul><li><code>DFS</code> 不用说</li><li><code>CheckSymmetric</code> 的最坏情况是原树为完全二叉树，递归次数为树高（即 $\log_2n$），又因为要暴力枚举一共$n$个点，所以复杂度为$O(n\log_2 n)$</li></ul><p>综上，程序复杂度为$O(n\log_2n)$，是能过的</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) ((nodes[x].leftChild))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((nodes[x].rightChild))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> leftChild;</span><br><span class="line">    <span class="keyword">int</span> rightChild;</span><br><span class="line">    <span class="keyword">int</span> treeSize;</span><br><span class="line">    </span><br><span class="line">    Node() : data(<span class="number">0</span>), leftChild(<span class="number">0</span>), rightChild(<span class="number">0</span>), treeSize(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].leftChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].leftChild);</span><br><span class="line">        nodes[root].treeSize += nodes[LC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].rightChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].rightChild);</span><br><span class="line">        nodes[root].treeSize += nodes[RC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckSymmetric</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">-1</span> &amp;&amp; n2 == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (n1 != <span class="number">-1</span> &amp;&amp; n2 != <span class="number">-1</span>)</span><br><span class="line">        &amp;&amp; nodes[n1].data == nodes[n2].data</span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n1), RC(n2))</span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n2), RC(n1))</span><br><span class="line">    ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nodes[i].data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nodes[i].leftChild &gt;&gt; nodes[i].rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// enumerate every subtree</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (CheckSymmetric(LC(i), RC(i))) &#123;</span><br><span class="line">            ans = <span class="built_in">std</span>::max(ans, nodes[i].treeSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一个长得像暴力的正解&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模拟" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
      <category term="暴力" scheme="https://blog.handwer-std.top/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1092「NOIP2004」《虫食算》</title>
    <link href="https://blog.handwer-std.top/2019-03-30/Luogu-P1092/"/>
    <id>https://blog.handwer-std.top/2019-03-30/Luogu-P1092/</id>
    <published>2019-03-30T06:47:17.000Z</published>
    <updated>2019-03-31T00:30:15.878Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>调换搜索顺序以获得更快时间</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的例子：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">43</span>#<span class="number">9865</span>#<span class="number">045</span></span><br><span class="line">+  <span class="number">8468</span>#<span class="number">6633</span></span><br><span class="line"> <span class="number">44445509678</span></span><br></pre></td></tr></table></figure><p>其中$#$号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。</p><p>现在，我们对问题做两个限制：</p><p>首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。</p><p>其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表午的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字：但是这N个字母并不一定顺序地代表0到N−1。输入数据保证N个字母分别至少出现一次。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">BADC</span></span><br><span class="line"><span class="keyword">+CBDA</span></span><br><span class="line"><span class="keyword"> </span>DCCC</span><br></pre></td></tr></table></figure><p>上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>包含四行。<br>第一行有一个正整数$N(N \le 26)$。</p><p>后面的三行，每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有NN位。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，即唯一的那组解。</p><p>解是这样表示的：输出N个数字，分别表示A,B,C,…所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">ABCED</span></span><br><span class="line"><span class="keyword">BDACE</span></span><br><span class="line"><span class="keyword">EBBAA</span></span><br></pre></td></tr></table></figure><h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>对于30％的数据，保证有$N \le 10$；</p><p>对于50％的数据，保证有$N \le 15$；</p><p>对于全部的数据，保证有$N \le 26$。</p><p>noip2004提高组第4题</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑暴力枚举每一个数字</p><p>肯定是过不去的</p><hr><p>考虑枚举算式中的每一个数</p><p>用时大大减小</p><p>但是可能会填出</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code"> 1111</span></span><br><span class="line">+1221</span><br><span class="line">-----</span><br><span class="line"><span class="code"> 2333</span></span><br></pre></td></tr></table></figure><p>这样的情况</p><p>显然这样的情况是无用的</p><p>就需要一个判断</p><p>耗时依然较高</p><hr><p>换一下搜索顺序，每列每列地填</p><p>在填完一列之后判断一下等式是否成立</p><p>就差不多了</p><p>虽然可能会耗点时间<br>但是省出来的时间是多得多的</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDBUG(x,y) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; y;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MDBUG(comment) std::cerr &lt;&lt; comment;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getNum(x) ((ans[x]))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> giveNum(x,y) ((ans[x] = y))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">26</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans[MAXN], col[<span class="number">3</span> + <span class="number">2</span>][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ol[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// convert the letters to numbers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            col[i + <span class="number">1</span>][j + <span class="number">1</span>] = ol[i][j] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Checks &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Check for unfilled letters</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (ans[i] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Check that the equation is correct</span></span><br><span class="line">        <span class="keyword">int</span> nextBit = <span class="number">0</span>; <span class="comment">// addition carry</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// from right to left</span></span><br><span class="line">            <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> C = getNum(col[<span class="number">3</span>][i]);</span><br><span class="line">            <span class="keyword">if</span> ((A + B + nextBit) % n != C) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            nextBit = (<span class="keyword">bool</span>) ((A + B + nextBit) &gt;= n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Other equation correction checking</span></span><br><span class="line">        <span class="keyword">if</span> (getNum(col[<span class="number">1</span>][<span class="number">1</span>]) + getNum(col[<span class="number">2</span>][<span class="number">1</span>]) &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// The first one needs to be carried</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> C = getNum(col[<span class="number">3</span>][i]);</span><br><span class="line">            <span class="keyword">if</span> (A == <span class="number">-1</span> || B == <span class="number">-1</span> || C == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((A + B) % n != C &amp;&amp; (A + B + <span class="number">1</span>) % n != C) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> column = n, <span class="keyword">int</span> line = <span class="number">1</span>, <span class="keyword">int</span> nextBit = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// from right to left</span></span><br><span class="line">    <span class="keyword">if</span> (Checks::check3()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Checks::check1()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Checks::check2()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getNum(col[line][column]) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// unfilled letter, fill it</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (line == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][column]);</span><br><span class="line">                <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][column]);</span><br><span class="line">                <span class="keyword">int</span> C = A + B + nextBit;</span><br><span class="line">                <span class="keyword">if</span> (C % n != i) <span class="keyword">continue</span>;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                giveNum(col[line][column], i);</span><br><span class="line">                DFS(column - <span class="number">1</span>, <span class="number">1</span>, (<span class="keyword">bool</span>) (C &gt;= n));</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">                giveNum(col[line][column], <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                giveNum(col[line][column], i);</span><br><span class="line">                DFS(column, line + <span class="number">1</span>, nextBit);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">                giveNum(col[line][column], <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// filled letter</span></span><br><span class="line">        <span class="keyword">if</span> (line != <span class="number">3</span>) DFS(column, line + <span class="number">1</span>, nextBit);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][column]);</span><br><span class="line">            <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][column]);</span><br><span class="line">            <span class="keyword">int</span> C = A + B + nextBit;</span><br><span class="line">            DFS(column - <span class="number">1</span>, <span class="number">1</span>, (<span class="keyword">bool</span>) (C &gt;= n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ol[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ol[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ol[<span class="number">2</span>];</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;调换搜索顺序以获得更快时间&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="搜索" scheme="https://blog.handwer-std.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="NOIP" scheme="https://blog.handwer-std.top/tags/NOIP/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 735D《Taxes》</title>
    <link href="https://blog.handwer-std.top/2019-03-23/CF735D/"/>
    <id>https://blog.handwer-std.top/2019-03-23/CF735D/</id>
    <published>2019-03-23T11:13:22.000Z</published>
    <updated>2019-03-23T11:39:17.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><del>这™什么破题</del></p></blockquote><a id="more"></a><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>大概就是规定一个数的花费为它的最大真因子（除了本身以外的最大因数，如果这个数是质数，花费为1）</p><p>现在给你一个数 $n$，要求把它拆成几个数相加的形式（也可以不拆），使得拆完后每一个数的花费的和最小</p><p>输出这个最小的和</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>别告诉我你脑子里装的都是暴力</p><p>我现在来说几个有趣的性质</p><p>说完这道题就做完了</p><ol><li>哥德巴赫猜想（即任意大于2的偶数都可以被拆成两个质数的和）</li><li>对于任意大于5的非质奇数（即不是质数的奇数），都可以被拆成3和两个质数的和（哥德巴赫猜想的一个推论）</li></ol><p>好 现在假设哥德巴赫猜想成立 请读者自行证明第二条</p><hr><p>依据这两个性质，我们可以对这道题进行如下的分类讨论</p><ul><li>当给定的为质数时，花费为1</li><li>当给定的为偶数时，根据哥德巴赫猜想可以拆成两个质数，花费为2</li><li>当<code>给定的数-2</code>为质数时，这个数可以拆成2和<code>给定的数-2</code>两个质数，花费为2</li><li>否则这个数可以拆成3和<code>给定的数-3</code>，因为给定的数是奇数，显然<code>给定的数-3</code>是偶数，可以拆成两个质数，花费为3</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span> || x == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这什么破题啊</span></span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(n)) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 根据哥德巴赫猜想，一个偶数可以被拆成两个质数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isPrime(n - <span class="number">2</span>)) <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这个数字可以被拆成 2 和另一个质数的和</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这个数字可以被拆成 3 和另一个偶数的和，这个偶数又可以被拆成两个质数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;del&gt;这™什么破题&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="毒瘤" scheme="https://blog.handwer-std.top/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="Codeforces" scheme="https://blog.handwer-std.top/tags/Codeforces/"/>
    
      <category term="数学" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2922《[USACO08DEC]秘密消息Secret Message》</title>
    <link href="https://blog.handwer-std.top/2019-03-23/Luogu-P2922/"/>
    <id>https://blog.handwer-std.top/2019-03-23/Luogu-P2922/</id>
    <published>2019-03-23T11:13:07.000Z</published>
    <updated>2019-03-23T12:33:25.016Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 Trie 中储存两个信息</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Bessie is leading the cows in an attempt to escape! To do this, the cows are sending secret binary messages to each other.</p><p>Ever the clever counterspy, Farmer John has intercepted the first b_i (1 &lt;= b_i &lt;= 10,000) bits of each of M (1 &lt;= M &lt;= 50,000) of these secret binary messages.</p><p>He has compiled a list of N (1 &lt;= N &lt;= 50,000) partial codewords that he thinks the cows are using. Sadly, he only knows the first c_j (1 &lt;= c_j &lt;= 10,000) bits of codeword j.</p><p>For each codeword j, he wants to know how many of the intercepted messages match that codeword (i.e., for codeword j, how many times does a message and the codeword have the same initial bits). Your job is to compute this number.</p><p>The total number of bits in the input (i.e., the sum of the b_i and the c_j) will not exceed 500,000.</p><p>Memory Limit: 32MB</p><p>POINTS: 270</p><p>贝茜正在领导奶牛们逃跑．为了联络，奶牛们互相发送秘密信息．</p><p>信息是二进制的，共有M(1≤M≤50000)条．反间谍能力很强的约翰已经部分拦截了这些信息，知道了第i条二进制信息的前bi(l《bi≤10000)位．他同时知道，奶牛使用N(1≤N≤50000)条密码．但是，他仅仅了解第J条密码的前cj(1≤cj≤10000)位．</p><p>对于每条密码J，他想知道有多少截得的信息能够和它匹配．也就是说，有多少信息和这条密码有着相同的前缀．当然，这个前缀长度必须等于密码和那条信息长度的较小者．</p><p>在输入文件中，位的总数（即∑Bi+∑Ci）不会超过500000.</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><ul><li><p>Line 1: Two integers: M and N</p></li><li><p>Lines 2..M+1: Line i+1 describes intercepted code i with an integer b_i followed by b_i space-separated 0’s and 1’s</p></li><li><p>Lines M+2..M+N+1: Line M+j+1 describes codeword j with an integer c_j followed by c_j space-separated 0’s and 1’s</p></li></ul><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><ul><li>Lines 1..M: Line j: The number of messages that the jth codeword could match.</li></ul><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">5</span> </span><br><span class="line"><span class="symbol">3 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> </span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">1</span> <span class="number">0</span> </span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> </span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> </span><br><span class="line"><span class="symbol">2 </span><span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="symbol">5 </span><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> </span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span></span><br><span class="line"><span class="symbol">3 </span></span><br><span class="line"><span class="symbol">1 </span></span><br><span class="line"><span class="symbol">1 </span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Four messages; five codewords.</p><p>The intercepted messages start with 010, 1, 100, and 110.</p><p>The possible codewords start with 0, 1, 01, 01001, and 11.</p><p>0 matches only 010: 1 match</p><p>1 matches 1, 100, and 110: 3 matches</p><p>01 matches only 010: 1 match</p><p>01001 matches 010: 1 match</p><p>11 matches 1 and 110: 2 matches</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>查询前缀的题很容易想到 Trie</p><hr><p>维护两个信息 <code>pass</code> 和 <code>lasts</code><br><code>pass</code> 表示当前节点有多少条信息经过， <code>lasts</code> 表示有多少以当前节点结尾的信息（不一定没有相同的串）</p><p>插入就不说了，说说查询</p><hr><p>查询的时候，记一下路径上<code>lasts</code>的和（也就是拿原信息去匹配查询信息）</p><p>首先对于每一条查询信息，都分两种情况</p><ol><li>这条信息被完美的查询完了</li><li>这条信息查到一半断开了</li></ol><p>对于第二种情况，什么都不用管，输出统计的<code>lasts</code>的和就行<br>对于第一种情况，则需要减去<strong>查询信息</strong>的最后一个节点的<code>lasts</code>值，加上<code>pass</code>值再输出</p><p>为什么呢？</p><hr><p><strong><em>这里建议画图理解</em></strong></p><p>首先，如果查到一半断开了，那么答案就是<strong>用原信息去匹配查询信息</strong>的匹配数，也就是<code>lasts</code>的和</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">比如下面的例子</span><br><span class="line">查询信息：</span><br><span class="line">rain_air_txdy</span><br><span class="line">原始信息：</span><br><span class="line">rain</span><br><span class="line">rain_air</span><br><span class="line">rain_air_tql（这个也是没法匹配的，后几个字符不同）</span><br><span class="line">那么匹配数就是<span class="number">2</span>，即为答案</span><br></pre></td></tr></table></figure><p>如果查询完了，那么说明<strong>存在能匹配查询信息的原信息</strong>，所以「用原信息去匹配查询信息的匹配数」还不够，要再加上「用查询信息去匹配原信息的匹配数」，也就是<code>lasts的总和 + pass</code></p><p>有这么一种情况，就是<strong>原信息与查询信息相同</strong>，那么它在当前节点的<code>lasts</code>里面算了一次，在当前节点的<code>pass</code>又算了一次！所以要减去当前节点的<code>lasts</code></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">比如下面的例子</span><br><span class="line">查询信息：</span><br><span class="line">rain_air_txdy</span><br><span class="line">原始信息：</span><br><span class="line">rain_air_txdy_tql</span><br><span class="line">rain_air_txdy</span><br><span class="line">答案是啥？<span class="number">2</span></span><br><span class="line"></span><br><span class="line">注意到y这里的 pass 是<span class="number">2</span>，把两条信息都算上了</span><br><span class="line">但同时y这里的 lasts 也是<span class="number">1</span>啊！！！</span><br><span class="line">这不就重了吗，所以要减去 lasts</span><br></pre></td></tr></table></figure><p><del>我觉得我说的已经够通俗易懂了吧<img src="https://s2.ax1x.com/2019/03/23/AJ3jc8.png" alt="AJ3jc8.png" border="0"></del></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> pass, lasts;</span><br><span class="line">        <span class="keyword">int</span> next[<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        Node() &#123;</span><br><span class="line">            pass = lasts = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span> next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; node[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    Trie() &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SwitchTo</span><span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">bool</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node[now].next[data] == <span class="number">0</span>) &#123;</span><br><span class="line">            node[now].next[data] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = node[now].next[data];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">switchTo</span><span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">bool</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node[now].next[data] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        now = node[now].next[data];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= f; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> nf = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nf;</span><br><span class="line">            t.SwitchTo(pos, nf);</span><br><span class="line">            ++t.node[pos].pass;</span><br><span class="line">        &#125;</span><br><span class="line">        ++t.node[pos].lasts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, pos = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        <span class="keyword">bool</span> cont = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nf = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nf;</span><br><span class="line">            <span class="keyword">if</span> (cont &amp;&amp; t.switchTo(pos, nf)) &#123;</span><br><span class="line">                ans += t.node[pos].lasts;</span><br><span class="line">            &#125; <span class="keyword">else</span> cont = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cont) ans = ans - t.node[pos].lasts + t.node[pos].pass;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在 Trie 中储存两个信息&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="USACO" scheme="https://blog.handwer-std.top/tags/USACO/"/>
    
      <category term="字符串" scheme="https://blog.handwer-std.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Trie" scheme="https://blog.handwer-std.top/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>UVA1508《Equipment》</title>
    <link href="https://blog.handwer-std.top/2019-03-23/UVA1508/"/>
    <id>https://blog.handwer-std.top/2019-03-23/UVA1508/</id>
    <published>2019-03-23T06:22:44.000Z</published>
    <updated>2019-03-23T11:17:11.555Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ProjectDP - 33</p></blockquote><blockquote><p>状态压缩 + DFS</p></blockquote><a id="more"></a><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p><a href="https://uva.onlinejudge.org/external/15/p1508.pdf" target="_blank" rel="noopener">PDF</a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先是这个玄学的数据范围（每个组只有5个元素）<br>很容易让人想到状压</p><hr><p>首先把 <code>k &gt;= 5</code> 的情况特判一下<br>可以选择超过5个组<br>那么显然选择最大的就行了</p><hr><p>对于每一个组，枚举它的每一种状态<br>对于这个状态，统计一下选择这个状态的总和（被选择了的数的和），与所有组里这个状态的总和取个 max</p><p>这样我们就获得了每一种状态总和的最大值<br>对它进行一遍 DFS</p><hr><p>这里说一个位运算技巧<br>枚举子集</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s0 = s; s0; s0 = s &amp; (s0 - <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>s0 即为 s 的某一个子集</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  33.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/3/9.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> qwq[<span class="number">5</span> + <span class="number">5</span>], grps[MAXN][<span class="number">5</span> + <span class="number">5</span>], dp[(<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span> + <span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s0 = s; s0; s0 = s &amp; (s0 - <span class="number">1</span>))</span><br><span class="line">        tmp = <span class="built_in">std</span>::max(tmp, dp[s0] + Search ((s0 ^ s), sum - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(qwq, <span class="number">0</span>, <span class="keyword">sizeof</span> qwq);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; grps[i][j];</span><br><span class="line">                qwq[j] = <span class="built_in">std</span>::max(qwq[j], grps[i][j]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; ++i) ans += qwq[i] ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> (dp)) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> stat = <span class="number">0</span>; stat &lt;= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>; ++stat) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> sel = <span class="number">0</span>; sel &lt; <span class="number">5</span>; ++sel) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (stat &amp; (<span class="number">1</span> &lt;&lt; sel)) tmp += grps[i][sel];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[stat] = <span class="built_in">std</span>::max(dp[stat], tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Search((<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>, k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ProjectDP - 33&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;状态压缩 + DFS&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="ProjectDP" scheme="https://blog.handwer-std.top/tags/ProjectDP/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="状压DP" scheme="https://blog.handwer-std.top/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
  </entry>
  
  <entry>
    <title>使用 Android 自带的文件管理器打开文件</title>
    <link href="https://blog.handwer-std.top/2019-03-19/Android-GetFilePathWithDocumentsProvider/"/>
    <id>https://blog.handwer-std.top/2019-03-19/Android-GetFilePathWithDocumentsProvider/</id>
    <published>2019-03-19T12:36:15.000Z</published>
    <updated>2019-03-19T12:53:09.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Storage Access Framework</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Android4.4中引入了Storage Access Framework存储访问框架，简称（SAF）。SAF为用户浏览手机中存储的内容提供了方便，这些内容不仅包括文档、图片，视频、音频、下载，而且还包括所有由特定ContentProvider（须具有约定的API）提供的内容。不管这些内容来自于哪里，不管是哪个应用调用浏览系统文件内容的命令，系统都会用一个统一的界面让你去浏览。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先我们要传给它一个 Intent</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>); <span class="comment">// 选择文件类型，我设置为了纯文本</span></span><br><span class="line">intent.addCategory(Intent.CATEGORY_OPENABLE);</span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>然后回调</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">        Uri uri = data.getData();</span><br><span class="line">        String filePath = GetFilePath.getPath(<span class="keyword">this</span>, uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候的<code>filePath</code>存的就是文件的名称。可以尝试<code>Log</code>一下看看</p><p>这个时候看到了一个新的类<code>GetFilePath</code>，它是我<del>复制</del>手写的一个类，内部貌似是没有这个类的</p><p>看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.ContentUris;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.database.Cursor;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.provider.DocumentsContract;</span><br><span class="line"><span class="keyword">import</span> android.provider.MediaStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetFilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Uri uri)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DocumentProvider</span></span><br><span class="line">        <span class="keyword">if</span> (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">            <span class="comment">// ExternalStorageProvider</span></span><br><span class="line">            <span class="keyword">if</span> (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">                <span class="keyword">final</span> String[] split = docId.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">final</span> String type = split[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"primary"</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Environment.getExternalStorageDirectory() + <span class="string">"/"</span> + split[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// DownloadsProvider</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isDownloadsDocument(uri)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> String id = DocumentsContract.getDocumentId(uri);</span><br><span class="line">                <span class="keyword">final</span> Uri contentUri = ContentUris.withAppendedId(</span><br><span class="line">                        Uri.parse(<span class="string">"content://downloads/public_downloads"</span>), Long.valueOf(id));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> getDataColumn(context, contentUri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// MediaProvider</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isMediaDocument(uri)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">                <span class="keyword">final</span> String[] split = docId.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">final</span> String type = split[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                Uri contentUri = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"image"</span>.equals(type)) &#123;</span><br><span class="line">                    contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"video"</span>.equals(type)) &#123;</span><br><span class="line">                    contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"audio"</span>.equals(type)) &#123;</span><br><span class="line">                    contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> String selection = <span class="string">"_id=?"</span>;</span><br><span class="line">                <span class="keyword">final</span> String[] selectionArgs = <span class="keyword">new</span> String[]&#123;split[<span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// MediaStore (and general)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"content"</span>.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDataColumn(context, uri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// File</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"file"</span>.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">            <span class="keyword">return</span> uri.getPath();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the value of the data column for this Uri. This is useful for</span></span><br><span class="line"><span class="comment">     * MediaStore Uris, and other file-based ContentProviders.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context       The context.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri           The Uri to query.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selection     (Optional) Filter used in the query.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selectionArgs (Optional) Selection arguments used in the query.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The value of the _data column, which is typically a file path.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataColumn</span><span class="params">(Context context, Uri uri, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String[] selectionArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> String column = <span class="string">"_data"</span>;</span><br><span class="line">        <span class="keyword">final</span> String[] projection = &#123;column&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs,</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> column_index = cursor.getColumnIndexOrThrow(column);</span><br><span class="line">                <span class="keyword">return</span> cursor.getString(column_index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>)</span><br><span class="line">                cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri The Uri to check.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Whether the Uri authority is ExternalStorageProvider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageDocument</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"com.android.externalstorage.documents"</span>.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri The Uri to check.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Whether the Uri authority is DownloadsProvider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDownloadsDocument</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"com.android.providers.downloads.documents"</span>.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri The Uri to check.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Whether the Uri authority is MediaProvider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMediaDocument</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"com.android.providers.media.documents"</span>.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/qq_17290407/article/details/81142931" target="_blank" rel="noopener">Android Uri和文件路径互相转换</a></p><p><a href="https://www.cnblogs.com/banbaise/p/4998661.html" target="_blank" rel="noopener">(转)Android调用系统自带的文件管理器进行文件选择并获得路径</a></p><p><a href="https://www.cnblogs.com/zgqys1980/p/5286208.html" target="_blank" rel="noopener">android: startActivityForResult用法详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Storage Access Framework&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Android 开发" scheme="https://blog.handwer-std.top/tags/Android-%E5%BC%80%E5%8F%91/"/>
    
      <category term="Java" scheme="https://blog.handwer-std.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1868《饥饿的奶牛》</title>
    <link href="https://blog.handwer-std.top/2019-03-09/Luogu-P1868/"/>
    <id>https://blog.handwer-std.top/2019-03-09/Luogu-P1868/</id>
    <published>2019-03-09T13:16:43.000Z</published>
    <updated>2019-03-09T13:51:46.242Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ProjectDP - 7</p></blockquote><blockquote><p>二分查找优化 DP</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。</p><p>现用汉语翻译为：</p><p>有N个区间，每个区间x，y表示提供的x~y共y-x+1堆优质牧草。你可以选择任意区间但不能有重复的部分。</p><p>对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，N，如题</p><p>接下来N行，每行一个数x，y，如题</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，最多能吃到的牧草堆数</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><p>3<br>1 3<br>7 8<br>3 4</p><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><p>5</p><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>1&lt;=n&lt;=150000</p><p>0&lt;=x&lt;=y&lt;=3000000</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>很容易想到设 $dp[i]$ 表示前 $i$ 个区间最多能选多少，转移从最优的 $j\ (j&lt;i)$ 中转移</p><p>时间复杂度 $O(n^2)$，过不去</p><hr><p>第一维 $\forall i \in [1,n]$ 是雷打不动的，优化不了<br>考虑从第二维下手</p><p>首先 $dp[]$ 数组是单调不降的很显然吧<br>那么只需要选择最近的一个「区间无交集」的 $j$ 进行转移即可<br>这个 $j$ 可以二分查找求得</p><p>如果找不到这个 $j$ 的话就从上一次转移过来即可</p><p>转移方程：</p><p>$ dp[i] = \text{max}(dp[i-1],dp[j] \ \times\ (\text{j exists == true}) $<br>$ + (\text{segment[i]’s left endpoint} - \text{segment[i]’s right endpoint} + 1)) $</p><p>中间那个 $(\text{j exists == true})$ 是个布尔表达式，它的返回值为0或1</p><p>至此，时间复杂度被降为 $O(nlog_2n)$</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  7.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/3/9.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">150000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    </span><br><span class="line">    Segment() &#123; l = r = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Segment &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == that.r) <span class="keyword">return</span> l &lt; that.l;</span><br><span class="line">        <span class="keyword">return</span> r &lt; that.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; seg[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = x, ans = <span class="number">-2147482333</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (seg[mid].r &lt; seg[x].l) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; seg[i].l &gt;&gt; seg[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(seg + <span class="number">1</span>, seg + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = BinarySearch(i);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">-2147482333</span>) dp[i] = <span class="built_in">std</span>::max(dp[i - <span class="number">1</span>], seg[i].r - seg[i].l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> dp[i] = <span class="built_in">std</span>::max(dp[i - <span class="number">1</span>], dp[pre] + seg[i].r - seg[i].l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ProjectDP - 7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;二分查找优化 DP&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="DP" scheme="https://blog.handwer-std.top/tags/DP/"/>
    
      <category term="二分查找" scheme="https://blog.handwer-std.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2292《[HNOI2004]L语言》</title>
    <link href="https://blog.handwer-std.top/2019-03-09/Luogu-P2292/"/>
    <id>https://blog.handwer-std.top/2019-03-09/Luogu-P2292/</id>
    <published>2019-03-09T10:03:01.000Z</published>
    <updated>2019-03-09T12:22:54.654Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Trie 的经典应用</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。</p><p>一段文章T是由若干小写字母构成。一个单词W也是由若干小写字母构成。一个字典D是若干个单词的集合。我们称一段文章T在某个字典D下是可以被理解的，是指如果文章T可以被分成若干部分，且每一个部分都是字典D中的单词。</p><p>例如字典D中包括单词{‘is’, ‘name’, ‘what’, ‘your’}，则文章‘whatisyourname’是在字典D下可以被理解的，因为它可以分成4个单词：‘what’, ‘is’, ‘your’, ‘name’，且每个单词都属于字典D，而文章‘whatisyouname’在字典D下不能被理解，但可以在字典D’=D+{‘you’}下被理解。这段文章的一个前缀‘whatis’，也可以在字典D下被理解，而且是在字典D下能够被理解的最长的前缀。</p><p>给定一个字典D，你的程序需要判断若干段文章在字典D下是否能够被理解。并给出其在字典D下能够被理解的最长前缀的位置。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件第一行是两个正整数n和m，表示字典D中有n个单词，且有m段文章需要被处理。之后的n行每行描述一个单词，再之后的m行每行描述一段文章。</p><p>其中1&lt;=n, m&lt;=20，每个单词长度不超过10，每段文章长度不超过1M。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于输入的每一段文章，你需要输出这段文章在字典D可以被理解的最长前缀的位置。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span> </span><br><span class="line"><span class="keyword">is</span></span><br><span class="line"><span class="built_in">name</span></span><br><span class="line">what</span><br><span class="line">your</span><br><span class="line">whatisyourname</span><br><span class="line">whatisyouname</span><br><span class="line">whaisyourname</span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">14 </span> （整段文章’whatisyourname’都能被理解）</span><br><span class="line"><span class="symbol">6 </span> （前缀’whatis’能够被理解）</span><br><span class="line"><span class="symbol">0 </span> （没有任何前缀能够被理解）</span><br></pre></td></tr></table></figure><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这里选用 Trie 来做</p><hr><p>首先把所有的单词扔进树里，记一下最长单词的长度</p><p>枚举字符串的右端点 $r \in [0, \text{The string’s length} - 1]$<br>字符串的左端点 $l \in [max(r - \text{Max Length}, -1), r]$</p><p>判断一下这个子串$s[l + 1, r]$在 Trie 里是不是一个完整的单词，是的话就把答案更新为 $r + 1$ 并退出枚举左端点的循环</p><p>判断单词是否完整只要对每个单词的结尾字母打个标记就行</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TREE_ROOT 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXCHAR = <span class="number">1024</span> * <span class="number">1024</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxlength;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="comment">// 日常封装</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">int</span> linkson[<span class="number">26</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 直接用它来记子节点的位置，类似于链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> last;</span><br><span class="line">        </span><br><span class="line">        Node() &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            last = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">memset</span>(linkson, <span class="number">0</span>, <span class="keyword">sizeof</span> linkson);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; tree[MAXCHAR];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    Trie() &#123; cnt = <span class="number">0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// pos = root</span></span><br><span class="line">        maxlength = <span class="built_in">std</span>::max(maxlength, length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ins = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[pos].linkson[ins] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// insert</span></span><br><span class="line">                tree[pos].linkson[ins] = ++cnt;</span><br><span class="line">                ++tree[pos].size;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = tree[pos].linkson[ins];</span><br><span class="line">        &#125;</span><br><span class="line">        tree[pos].last = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// pos = root</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> que = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[pos].linkson[que] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            pos = tree[pos].linkson[que];</span><br><span class="line">            <span class="comment">// 这里也是和上边插入一模一样</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree[pos].last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> dp[MAXCHAR];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        T.Insert(s.c_str(), (<span class="keyword">int</span>) s.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>) s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; len; ++r) &#123;</span><br><span class="line">            <span class="comment">// 枚举右端点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="built_in">std</span>::max(r - maxlength, <span class="number">-1</span>); l &lt;= r; ++l) &#123;</span><br><span class="line">                <span class="comment">// 枚举左端点</span></span><br><span class="line">                <span class="keyword">if</span> ((l == <span class="number">-1</span> || dp[l]) &amp;&amp; T.Find(s.c_str(), l + <span class="number">1</span>, r)) &#123;</span><br><span class="line">                    dp[r] = <span class="literal">true</span>;</span><br><span class="line">                    ans = r + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Trie 的经典应用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="省选" scheme="https://blog.handwer-std.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="字符串" scheme="https://blog.handwer-std.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Trie" scheme="https://blog.handwer-std.top/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>Trie 树学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-03-02/Trie/"/>
    <id>https://blog.handwer-std.top/2019-03-02/Trie/</id>
    <published>2019-03-02T13:33:37.000Z</published>
    <updated>2019-03-03T00:39:45.273Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>很简单的树形字符串结构</p></blockquote><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在计算机科学中，Trie，又称字典树、单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p><p style="text-align: right">——百度百科</p><p>简单地说，Trie 树就是以字符串的字母为结构建立起来的一棵<strong>多根树</strong><br>画出来大概是这样的</p><p><img src="/images/Trie/1.png" alt=""></p><p>其中，这棵树有这些字符串</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span></span><br><span class="line">AK</span><br><span class="line">AKN</span><br><span class="line">AKO</span><br><span class="line">AKI</span><br><span class="line">AC</span><br><span class="line">ACE</span><br></pre></td></tr></table></figure><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>都很简单。</p><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>给你一个字符串，要求把这个字符串插入到树中</p><p>首先指定树根为0，当前位置为树根<br>枚举字符串的每个字符，看一下当前字符在当前深度有没有，有的话就直接把「当前位置」切换为这个字符所处的位置，没有的话就往里插入这个字符再切换</p><p>建议配合代码理解</p><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>这里以查询是否被查询过为例</p><p>对于每一个字符，记一下以它为结尾的字符串是否被查询过<br>还是像插入一样切换当前位置，如果中间某一字符在那个深度没有，就直接返回字符串不存在<br>切换到字符串最后一个字符之后，看一下刚才记的那个变量是否为真即可</p><p>也还是建议配合代码理解</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>这里以<a href="https://www.luogu.org/problemnew/show/P2580" target="_blank" rel="noopener">洛谷 P2580 于是他错误的点名开始了</a>为例</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>就是给你一堆字符串和一堆询问<br>对于每个询问，输出是否存在这个字符串<br>如果存在，输出它有没有被询问过</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本来这是一道<code>std::map</code>的模板题<br>但是我们是来学 Trie 的<br>那么当然要用 Trie 做啊（逃</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>也是上面那一题的代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="comment">// 日常封装</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">int</span> linkson[<span class="number">26</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 直接用它来记子节点的位置，类似于链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> rep;</span><br><span class="line">        </span><br><span class="line">        Node() &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            rep = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">memset</span>(linkson, <span class="number">0</span>, <span class="keyword">sizeof</span> linkson);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; tree[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    Trie() &#123; cnt = <span class="number">0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// pos = root</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ins = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[pos].linkson[ins] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// insert</span></span><br><span class="line">                tree[pos].linkson[ins] = ++cnt;</span><br><span class="line">                ++tree[pos].size;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = tree[pos].linkson[ins];</span><br><span class="line">            <span class="comment">// 前面提到的切换位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回值就0, 1, 2，用不着 int</span></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// pos = root</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> que = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[pos].linkson[que] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">            <span class="comment">// 没找到这个名字</span></span><br><span class="line">            pos = tree[pos].linkson[que];</span><br><span class="line">            <span class="comment">// 这里也是和上边插入一模一样</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[pos].rep) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 重复点名</span></span><br><span class="line">        tree[pos].rep = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 炉石传说真好玩（逃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        T.Insert(s.c_str(), (<span class="keyword">int</span>) s.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">switch</span>(T.Find(s.c_str(), (<span class="keyword">int</span>) s.size())) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"REPEAT\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"WRONG\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;很简单的树形字符串结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="字符串" scheme="https://blog.handwer-std.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Trie" scheme="https://blog.handwer-std.top/tags/Trie/"/>
    
      <category term="模板" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="数据结构" scheme="https://blog.handwer-std.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P3067《[USACO12OPEN]平衡的奶牛群Balanced Cow Subsets》</title>
    <link href="https://blog.handwer-std.top/2019-03-02/Luogu-P3067/"/>
    <id>https://blog.handwer-std.top/2019-03-02/Luogu-P3067/</id>
    <published>2019-03-02T10:04:39.000Z</published>
    <updated>2019-03-02T12:37:45.970Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Meet in the middle + 状态压缩</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Farmer John’s owns N cows (2 &lt;= N &lt;= 20), where cow i produces M(i) units of milk each day (1 &lt;= M(i) &lt;= 100,000,000). FJ wants to streamline the process of milking his cows every day, so he installs a brand new milking machine in his barn. Unfortunately, the machine turns out to be far too sensitive: it only works properly if the cows on the left side of the barn have the exact same total milk output as the cows on the right side of the barn!</p><p>Let us call a subset of cows “balanced” if it can be partitioned into two groups having equal milk output. Since only a balanced subset of cows can make the milking machine work, FJ wonders how many subsets of his N cows are balanced. Please help him compute this quantity.</p><p>给n个数，从中任意选出一些数，使这些数能分成和相等的两组。</p><p>求有多少种选数的方案。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p>输入格式：</p><ul><li><p>Line 1: The integer N.</p></li><li><p>Lines 2..1+N: Line i+1 contains M(i).</p></li></ul><p>输出格式：</p><ul><li>Line 1: The number of balanced subsets of cows.</li></ul><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">4 </span></span><br><span class="line"><span class="symbol">1 </span></span><br><span class="line"><span class="symbol">2 </span></span><br><span class="line"><span class="symbol">3 </span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>There are 4 cows, with milk outputs 1, 2, 3, and 4.</p><p>There are three balanced subsets: the subset {1,2,3}, which can be partitioned into {1,2} and {3}, the subset {1,3,4}, which can be partitioned into {1,3} and {4}, and the subset {1,2,3,4} which can be partitioned into {1,4} and {2,3}.</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先看一眼数据范围</p><hr><p>对于每一个数，有三种状态：</p><ul><li>放在左边的集合里</li><li>放在右边的集合里</li><li>不选</li></ul><p>好，一个 $O(3^n)$ 的算法就出来了<br>但是过不去</p><hr><p>考虑优化<br>可用 Meet in the middle 进行优化</p><p>对两个区间 $[1, \frac{n}{2}]$ 和 $[\frac{n}{2} + 1, n]$ 分别搜索，时间复杂度降为 $O(3^{\frac{n}{2}})$ ，或者说 $O(\sqrt{(3^n)})$</p><p><del>合并答案这部分我在学的时候也不大理解</del></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FIXED_N = <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    </span><br><span class="line">    S() &#123; sum = status = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; cca[(<span class="number">1</span> &lt;&lt; FIXED_N)], ccb[(<span class="number">1</span> &lt;&lt; FIXED_N)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[MAXN], cnta, cntb, ans;</span><br><span class="line"><span class="keyword">bool</span> uniq[(<span class="number">1</span> &lt;&lt; FIXED_N)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> sum, <span class="keyword">int</span> stat, S cc[], <span class="keyword">int</span> &amp;cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        cc[++cnt].sum = sum;</span><br><span class="line">        cc[cnt].status = stat;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Search(l + <span class="number">1</span>, r, sum, stat, cc, cnt); <span class="comment">// don't choose</span></span><br><span class="line">    Search(l + <span class="number">1</span>, r, sum - a[l], stat + (<span class="number">1</span> &lt;&lt; (l - <span class="number">1</span>)), cc, cnt); <span class="comment">// put the cow to set1</span></span><br><span class="line">    Search(l + <span class="number">1</span>, r, sum + a[l], stat + (<span class="number">1</span> &lt;&lt; (l - <span class="number">1</span>)), cc, cnt); <span class="comment">// put the cow to set2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeAnswer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// double-pointer</span></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">1</span>, p2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= cnta &amp;&amp; p2 &lt;= cntb) &#123;</span><br><span class="line">        <span class="keyword">while</span> (-cca[p1].sum &lt; ccb[p2].sum &amp;&amp; p2 &lt;= cntb) ++p2;</span><br><span class="line">        <span class="keyword">int</span> originalp2 = p2;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= cntb &amp;&amp; -cca[p1].sum == ccb[p2].sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uniq[cca[p1].status | ccb[p2].status] == <span class="literal">false</span>) &#123;</span><br><span class="line">                uniq[cca[p1].status | ccb[p2].status] = <span class="literal">true</span>;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ++p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 + <span class="number">1</span> &lt;= cnta &amp;&amp; -cca[p1].sum == -cca[p1 + <span class="number">1</span>].sum) p2 = originalp2;</span><br><span class="line">        ++p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpa</span><span class="params">(S x, S y)</span> </span>&#123; <span class="keyword">return</span> x.sum &lt; y.sum; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpb</span><span class="params">(S x, S y)</span> </span>&#123; <span class="keyword">return</span> x.sum &gt; y.sum; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    Read();</span><br><span class="line">    Search(<span class="number">1</span>, n / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, cca, cnta);</span><br><span class="line">    Search(n / <span class="number">2</span> + <span class="number">1</span>, n , <span class="number">0</span>, <span class="number">0</span>, ccb, cntb);</span><br><span class="line">    <span class="built_in">std</span>::sort(cca + <span class="number">1</span>, cca + <span class="number">1</span> + cnta, cmpa);</span><br><span class="line">    <span class="built_in">std</span>::sort(ccb + <span class="number">1</span>, ccb + <span class="number">1</span> + cntb, cmpb);</span><br><span class="line">    mergeAnswer();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Meet in the middle + 状态压缩&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="搜索" scheme="https://blog.handwer-std.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="Meet in the middle" scheme="https://blog.handwer-std.top/tags/Meet-in-the-middle/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P4799《[CEOI2015 Day2]世界冰球锦标赛》</title>
    <link href="https://blog.handwer-std.top/2019-03-02/Luogu-P4799/"/>
    <id>https://blog.handwer-std.top/2019-03-02/Luogu-P4799/</id>
    <published>2019-03-02T05:35:35.000Z</published>
    <updated>2019-03-02T08:14:07.047Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>稍微</strong>简单的Meet in the middle题目</p></blockquote><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先来介绍一下「Meet in the middle」是个啥</p><p>顾名思义，Meet in the middle 就是「在中间相遇」，也就是对前一半状态和后一半状态分别进行搜索，最后合并两次搜索产生的答案</p><p>这样的搜索优化（我个人认为这是优化）可以把时间复杂度开一个二次根号</p><p>思想和实现都很简单，难度主要是在合并答案这一块，一般是利用单调性进行合并</p><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>译自 CEOI2015 Day2 T1「Ice Hockey World Championship」</p><p>今年的世界冰球锦标赛在捷克举行。Bobek 已经抵达布拉格，他不是任何团队的粉丝，也没有时间观念。他只是单纯的想去看几场比赛。如果他有足够的钱，他会去看所有的比赛。不幸的是，他的财产十分有限，他决定把所有财产都用来买门票。</p><p>给出 Bobek 的预算和每场比赛的票价，试求：如果总票价不超过预算，他有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。</p><h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行，两个正整数 $N$ 和 $M(1 \leq N \leq 40,1 \leq M \leq 10^{18})$，表示比赛的个数和 Bobek 那家徒四壁的财产。</p><p>第二行，$N$ 个以空格分隔的正整数，均不超过 $10^{16}$，代表每场比赛门票的价格。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行，表示方案的个数。由于 $N$ 十分大，注意：答案 $\le 2^{40}$。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span><span class="number">1000</span></span><br><span class="line"><span class="symbol">100 </span><span class="number">1500</span> <span class="number">500</span> <span class="number">500</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>八种方案分别是：</p><ul><li>一场都不看，溜了溜了</li><li>价格 100 的比赛</li><li>第一场价格 500 的比赛</li><li>第二场价格 500 的比赛</li><li>价格 100 的比赛和第一场价格 500 的比赛</li><li>价格 100 的比赛和第二场价格 500 的比赛</li><li>两场价格 500 的比赛</li><li>价格 1000 的比赛</li></ul><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一个很显然的思路就是暴力搜索<br>枚举所有的状态<br>最高要搜索 $2^{40}$ 次</p><p>这时候 Meet in the middle 就上场了。<br>我们把整个区间分成 $[1, \frac{n}{2}]$ 和 $[\frac{n}{2} + 1, n]$<br>对这两个区间进行分别搜索，得到<strong>两个区间可选的所有方案</strong>，分别存在两个数组 $f[i]$ 和 $b[i]$ 中</p><p>如何合并答案？</p><hr><p>首先你需要知道 <code>upper_bound()</code></p><p><code>upper_bound()</code>返回一个 iterator 它指向在<code>[first,last)</code>标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个大于value的值</p><p>通俗的讲，<code>upper_bound()</code>函数就是用来求第一个<strong>大于</strong>val的值的<strong>下标</strong>，内部使用二分查找实现<br>那排序肯定是没跑了（但是只需要对一个序列排序）（当然如果你两个序列都排序的话也没事，<code>upper_bound()</code>这里只用来查找一个序列）</p><p>枚举未排序序列的每一个元素（这里记为 $f[i]$，另一个序列中的元素记为 $b[i]$），显然 $m - f[i]$ 为「选择当前方案后剩下的钱数」，记为 $fafa$<br>对另一个序列 $b[i]$ 进行 <code>upper_bound()</code> 查找，找到第一个大于等于它的数的下标（这个数即为在另一个区间搜出来的「当前方案的花费」）<br>又因为这个区间是有序的，那么显然 <code>upper_bound()</code> 出来的下标<strong>之前</strong>的所有方案都是可选的（所有在它之前的方案花费都是小于等于 $fafa$ 的，自然是可选的），更新一下答案即可</p><p>写成代码是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(b + <span class="number">1</span>, b + <span class="number">1</span> + cntb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnta; ++i) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ext = m - f[i]; <span class="comment">// 对应之前的 fafa</span></span><br><span class="line">    ans += ((<span class="built_in">std</span>::upper_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + cntb, ext) - b) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>至此这道题就做完了。<br>还有一个小的细节：<strong>三年 OI 一场空，不开 long long 见祖宗</strong></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">40</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FIXED_MAX = <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> suma[(<span class="number">1</span> &lt;&lt; FIXED_MAX) + <span class="number">10</span>], sumb[(<span class="number">1</span> &lt;&lt; FIXED_MAX) + <span class="number">10</span>], cnta, cntb;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> seq[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> &amp;cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        a[++cnt] = sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Search(l + <span class="number">1</span>, r, sum, a, cnt); <span class="comment">// don't choose</span></span><br><span class="line">    Search(l + <span class="number">1</span>, r, sum + seq[l], a, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">mergeAnswer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">0l</span>l;</span><br><span class="line">    <span class="built_in">std</span>::sort(sumb + <span class="number">1</span>, sumb + <span class="number">1</span> + cntb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnta; ++i) &#123;</span><br><span class="line">        ret += (<span class="built_in">std</span>::upper_bound(sumb + <span class="number">1</span>, sumb + <span class="number">1</span> + cntb, m - suma[i]) - sumb) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// m - suma[i]: the money left when I choose suma[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; seq[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="keyword">int</span>) n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Search(<span class="number">1</span>, mid, <span class="number">0l</span>l, suma, cnta);</span><br><span class="line">    Search(mid + <span class="number">1</span>, (<span class="keyword">int</span>) n, <span class="number">0l</span>l, sumb, cntb);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mergeAnswer() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;稍微&lt;/strong&gt;简单的Meet in the middle题目&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="搜索" scheme="https://blog.handwer-std.top/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="Meet in the middle" scheme="https://blog.handwer-std.top/tags/Meet-in-the-middle/"/>
    
  </entry>
  
  <entry>
    <title>「文章」百名学生参训 礼堂“变身”教室</title>
    <link href="https://blog.handwer-std.top/2019-02-16/SDWC-Article/"/>
    <id>https://blog.handwer-std.top/2019-02-16/SDWC-Article/</id>
    <published>2019-02-16T07:53:14.000Z</published>
    <updated>2019-02-16T11:33:12.439Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文纯属胡扯</strong><br><strong>请勿当真</strong></p></blockquote><blockquote><p><big><big>正</big></big>月初八，年味儿正浓。但是，不少全国各地的中学生却来到了泰安。他们不是利用假期前来观光旅游的，而是进城参加竞赛培训。记者暗访发现，某未经教育部批准的机构培训机构打着“竞赛培训”“自主招生”的旗号，开设冬令营，面向全国各地中学招生。这个机构组织学生进行竞赛辅导、模拟考试。七天的培训，学费竟然高达3000元左右。</p></blockquote><a id="more"></a><p><img src="/images/SDWC-Article/1.jpg" alt="1"></p><p>记者了解到，不少高一、高二甚至初中学生参加这样的冬令营，目的是希望能够获得各类学科竞赛的奖项，从而在高校自主招生、保送生选拔录取中占得先机。为此，记者向多所“双一流”高校招生负责人求证，得到的一致答复是，获得自主招生认定与是否参加过竞赛培训没有任何关系，学生申请自主招生可以通过各种材料证明自己的特长，竞赛获奖证书只是其中很小一部分，并且自主招生最终认定结果，必须经由申请高校考核后确定。</p><big><big>四名学生一个宿舍<br>教学、食宿均安排在学校之内</big></big><p>正月初八，一辆又一辆大巴车开进泰安一中。一批批满脸稚气的中学生，拉着行李走进学校。工作人员协助学生们办理报到、入住、领取餐券等手续。不少学生家长陪同前来，但是，办完手续后，家长被告知“可以离开了”。工作人员的解释是，这里是封闭式管理，谢绝家长陪住。</p><p><img src="/images/SDWC-Article/3.jpg" alt="3"></p><p>此时，这所学校已经摇身变成一家培训教育机构寒假冬令营的营区。工作人员介绍，营区主要开设普通班、高级班两个班级，其中，普通班有学生200人，高级班有学生240人左右。这意味着来自全国各地的百余名学生参加这家机构的培训。</p><p>据介绍，营区的教学、食宿均安排在学校之内。每名学生的学费为2400元，另外不需缴纳食宿费。“四名学生一个宿舍。”工作人员说。</p><p>学校工作人员告诉记者，培训机构几乎包下了所有的宿舍房间。</p><big><big>从早八点半学到晚九点<br>后排学生只能看“现场直播”</big></big><p><img src="/images/SDWC-Article/2.jpg" alt="2"></p><p>培训课程已开课几天。营区占用一间大礼堂作为教室，学生们被分成了多个座位区，对应一个投影幕布。因为“教室”里的学生太多，在最后一排已经几乎看不见老师，只能通过听声音、看课件来听老师讲题。到下午4点，后方座位区已经有学生难以专注听课，趴到了桌子上。</p><p>记者探访营区，感受到了学生们高强度的学习节奏。现场公布的一份营地作息时间表显示，学生们每天的起床时间为6点至7点，之后有40分钟的早餐时间。8点开始上课，一直到11点半。中午学生有两小时左右的中餐和午休时间，之后又是3个半小时的课程。</p><p>入夜后，学生们也不能歇着。记者在营区看到，晚上6点刚过，吃过晚餐的学生陆陆续续回到机房开始自习。工作人员透露，晚上6点到9点是学生的答疑、考试和讲评时间。晚上10点查寝，11点熄灯。</p><big><big>拼竞赛争取进名校<br>任课教师多是竞赛金牌选手</big></big><p>小王是华北地区一所中学的初二学生。这次，他是由学校老师带队，与同学们一起参加竞赛的培训。小王很明确地告诉记者，上辅导班就是为了拼竞赛，获得进名校的“敲门砖”。“如果能在省赛区拿到一等奖，那么，申请211、985院校自主招生的通过概率就很大。全国学科竞赛夺金牌进国家集训队，就可以直接保送了。”</p><p>小王坦言，在老家学校里，大家主要的任务都在应对高考。老师讲课、考试都是围绕高考进行，竞赛生“吃不饱”。因为没有专门的竞赛指导老师，训练主要是靠从网上找习题。“来这里学，确实收获很大，这边老师讲的好几个知识点，一下子打通了我之前一年的困惑。”</p><p>培训机构市场部的一位工作人员告诉记者，如果只凭高中课堂学习的知识积累，去拼名校的自主招生，没有多大意义。因此，必须走一轮竞赛，材料才过硬。他透露，竞赛培训的主讲老师大部分是当年竞赛的金牌选手，培训中会有竞赛例题的讲解，还有模拟竞赛考试，学生可以充分熟悉考试的流程。</p><big><big>多所高校招办答复<br>自招认定与竞赛培训无关</big></big><p>今年1月，教育部印发了《关于做好2019年高校自主招生工作的通知》，从招生政策、招生程序、加强监管等方面提出规范高校自主招生的“十严格”要求。“十严格”中明确高校不得简单以论文、专利、中介机构举办的竞赛活动等作为报考条件和初审通过依据。此外，要严格审核申请材料，高校成立专门自主招生审核专家组，采用多名专家“背靠背”分别独立审核、复核等方式，对考生提交的证明材料进行全覆盖核查。</p><p>昨晚，本市多所“双一流”高校的招办负责人向记者表示，绝大多数考生最终能否获得自主招生的认定，与是否参加过竞赛、拿过奖没有必然联系，与竞赛培训更是无关。“我们严格遵守教育部相关规定，学生申请自主招生可以根据自己的兴趣和特长提交相关材料，竞赛成绩只是其中很小一部分。此外学生通过材料初审后，也必须要参加学校组织的自主招生初试和复试，通过并完成公示后才能获得认定。这些流程都与校外培训机构无关，希望学生能展现真实的才华。”一所“双一流”大学招办主任说道。</p><p>来源：泰安Fa♂︎报<br>供图：abc1763613206</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;本文纯属胡扯&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;请勿当真&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;big&gt;&lt;big&gt;正&lt;/big&gt;&lt;/big&gt;月初八，年味儿正浓。但是，不少全国各地的中学生却来到了泰安。他们不是利用假期前来观光旅游的，而是进城参加竞赛培训。记者暗访发现，某未经教育部批准的机构培训机构打着“竞赛培训”“自主招生”的旗号，开设冬令营，面向全国各地中学招生。这个机构组织学生进行竞赛辅导、模拟考试。七天的培训，学费竟然高达3000元左右。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="毒瘤" scheme="https://blog.handwer-std.top/tags/%E6%AF%92%E7%98%A4/"/>
    
      <category term="记录" scheme="https://blog.handwer-std.top/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="OI相关" scheme="https://blog.handwer-std.top/tags/OI%E7%9B%B8%E5%85%B3/"/>
    
      <category term="文章" scheme="https://blog.handwer-std.top/tags/%E6%96%87%E7%AB%A0/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P1122《最大子树和》</title>
    <link href="https://blog.handwer-std.top/2019-02-16/Luogu-P1122/"/>
    <id>https://blog.handwer-std.top/2019-02-16/Luogu-P1122/</id>
    <published>2019-02-16T05:48:47.000Z</published>
    <updated>2019-02-16T06:02:42.690Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>ProjectDP - 35</p></blockquote><blockquote><p>最简单的树形DP问题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：</p><p>一株奇怪的花卉，上面共连有N N朵花，共有N-1N−1条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。</p><p>老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数N(1 ≤ N ≤ 16000)。表示原始的那株花卉上共N朵花。</p><p>第二行有N个整数，第I个整数表示第I朵花的美丽指数。</p><p>接下来N-1行每行两个整数a,b，表示存在一条连接第a朵花和第b朵花的枝条。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过2147483647。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模与约定】</p><p>对于60%的数据，有N≤1000；</p><p>对于100%的数据，有N≤16000。</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>只需要一维</p><hr><p>设 $f[i]$ 表示以 $i$ 为根的子树的最大值</p><p>初始化：$f[i]$ 为结点 $i$ 的权值</p><p>转移：</p><p>$$ f[u] = f[u] + max(f[v], 0) $$</p><p>其中 $v$ 是 $u$ 的儿子</p><p>答案：$f$ 数组的最大值</p><hr><big><big><big>简单吧！</big></big></big><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  35.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/2/16.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="keyword">int</span> flower[MAXN], dp[MAXN], n, id[MAXN], ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[u] += std::max(0, dp[v]);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dp[u] = flower[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = head[u].begin(); it != head[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*it) == fa) <span class="keyword">continue</span>;</span><br><span class="line">        DFS((*it), u);</span><br><span class="line">        dp[u] += <span class="built_in">std</span>::max(<span class="number">0</span>, dp[(*it)]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">std</span>::max(ans, dp[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; flower[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, next = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; prev &gt;&gt; next;</span><br><span class="line">        <span class="keyword">if</span> (prev &gt; next) <span class="built_in">std</span>::swap(prev, next);</span><br><span class="line">        head[prev].push_back(next);</span><br><span class="line">        head[next].push_back(prev);</span><br><span class="line">        ++id[next];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (root = <span class="number">1</span>; root &lt;= n; ++root)</span><br><span class="line">        <span class="keyword">if</span> (id[root] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    DFS(root, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;ProjectDP - 35&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;最简单的树形DP问题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="DFS" scheme="https://blog.handwer-std.top/tags/DFS/"/>
    
      <category term="ProjectDP" scheme="https://blog.handwer-std.top/tags/ProjectDP/"/>
    
      <category term="动态规划，DP" scheme="https://blog.handwer-std.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8CDP/"/>
    
      <category term="树形DP" scheme="https://blog.handwer-std.top/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>ST算法学习笔记</title>
    <link href="https://blog.handwer-std.top/2019-02-15/RMQ-SparseTable/"/>
    <id>https://blog.handwer-std.top/2019-02-15/RMQ-SparseTable/</id>
    <published>2019-02-15T12:58:48.000Z</published>
    <updated>2019-02-15T23:59:19.236Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>$O(1)$查询区间最值</p></blockquote><a id="more"></a><h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>RMQ (Range Minimum/Maximum Query)问题是指：对于长度为n的数列A，回答若干询问RMQ(A,i,j)(i,j&lt;=n)，返回数列A中下标在i,j里的最小(大）值，也就是说，RMQ问题是指求区间最值的问题。</p><p style="text-align:right"> ——百度百科 </p><p>ST（Sparse Table，稀疏表）算法是求解RMQ问题的经典在线算法，以O(nlogn)时间预处理，然后在O(1)时间内回答每个查询。</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>ST算法实际上采用了DP的思想</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>定义 $F(i,j)$ 表示区间 $[i, i + 2^j - 1]$ 内的最小值，$P[i]$ 为原序列</p><p>那么显然<br>$$ F(i,0) = P[i] $$</p><p>状态转移方程？</p><hr><p>首先，任意一个区间的最小值等于 $min($这个区间前一半的最小值$,$ 这个区间后一半点最小值$)$<br>这个很好理解吧<br>把$F(\ )$结合进去，就是</p><p>$$ F(i,j) = min(F(i,j-1),F(i + 2^{j-1}, j - 1)) $$</p><hr><p>还有什么细节？<br>上面的式子看的你很想递归是吧（反正我是）<br>如果你不想递归的话，你八成会：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ...)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; ...)</span><br><span class="line">        F[i][j] = ...</span><br></pre></td></tr></table></figure><p>其实……这样都是<strong>错</strong>的，这样会导致有几个状态被过早地枚举</p><p>我们要把枚举 $j$ 的循环<strong>放在外层</strong>，至于为什么……你模<small><small>拟</small></small>一下就行了</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>此处的内容可能有点<strong>难以理解</strong>，请消化不了的同学多看几遍</p><hr><p>上面说了查询是 $O(1)$ 的<del>听起来就好简单啊</del></p><p>实现确实是很简单，但是原理就……<del>也是很简单</del></p><hr><p>首先给你一个定理：<br>对于任意 $x \in \mathbb{N^*}$ ，都有 $ 2^{\lfloor log_2(x) \rfloor} &gt; \lfloor \frac{x}{2} \rfloor $</p><p>然后令查询区间$[l,r]$的长度 $\text{len} = r - (l - 1),\ \text{ll} = log_2(\text{len})$<br>那么根据上边可得 $ 2^{\text{ll}} &gt; \lfloor \frac{len}{2} \rfloor $<br>这意味着什么？<br>这意味着查询的区间有重叠！<br>不过这并不能意味啥，重叠又怎么样，只是查询的区间变了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">原来我们查询区间，都是查询这个区间的一半</span><br><span class="line">比如更新[l,r]之间的最小值就是</span><br><span class="line">f[<span class="string">l</span>][<span class="symbol">r</span>] = std::min(f[<span class="string">l</span>][<span class="symbol">mid</span>], f[<span class="string">mid + 1</span>][<span class="symbol">r</span>]);</span><br><span class="line"></span><br><span class="line">但是这次不一样，这次的mid超过了区间的一半</span><br><span class="line">那就可以这么写：</span><br><span class="line"></span><br><span class="line">int Query(int l, int r) &#123;</span><br><span class="line"><span class="code">    int k = std::log(r - (l - 1)) / std::log(2);</span></span><br><span class="line"><span class="code">    return std::min(f[l][k], f[r - ((1 &lt;&lt; k) -1)][k]);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是 $O(1)$ 的吧</p><p>它查询的区间相当于是这样的：<br><strong>（画的不准确，仅供参考）</strong></p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> <span class="keyword">_</span> </span><br><span class="line">-------====       f[l][k]</span><br><span class="line">       ====------ f[r - ((<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>)][k]</span><br><span class="line">       </span><br><span class="line">等号就是两个查询区间的并集</span><br></pre></td></tr></table></figure><p>这也就是它为什么不能查询区间和的原因<br><del>前缀和足够了</del></p><p><img src="https://cdn.luogu.org/upload/pic/5010.png" alt="qwq"></p><h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ \text{Algorithm 1: Sparse Table} $<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ \text{Init(The Sparse Table } f, \text{The original sequence } a, \text{no return value})$<br>&nbsp;&nbsp;$ 1. \text{For } i \text{ from 1 to n do}$<br>&nbsp;&nbsp;$ 2. \ \ \ \ f[i][0] = a[i] $<br>&nbsp;&nbsp;$ 3. \text{End For} $<br>&nbsp;&nbsp;$ 4. \ j \leftarrow 1, i \leftarrow 1$<br>&nbsp;&nbsp;$ 5. \text{While } 2^j \leq n \text{ do} $<br>&nbsp;&nbsp;$ 6. \ \ \ \ \text{While } i + 2^j - 1 \leq n \text{ do} $<br>&nbsp;&nbsp;$ 7. \ \ \ \ \ \ \ \ f[i][j] = min(f[i][j-1], f[i + 2^{j-1}][j-1]) $<br>&nbsp;&nbsp;$ 8. \ \ \ \ \ \ \ \ i \leftarrow i + 1 $<br>&nbsp;&nbsp;$ 9. \ \ \ \ \text{End While}$<br>$ 10. \ \ \ \ j \leftarrow j + 1 $<br>$ 11. \text{End While} $ </p><p>$ \text{Query(}l,r\text{,return a value x}) $<br>$ 1. k \leftarrow log_2(r - l + 1)$<br>$ 2. \text{return } x = min(f[l][k], f[r - (2^k - 1)][k]$<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">100000</span> + <span class="number">10</span>) * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLOG = <span class="number">17</span> + <span class="number">10</span>; <span class="comment">// floor(log2(100000 + 10))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> Table[MAXN][MAXLOG];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">            Table[i][j] = <span class="built_in">std</span>::max(Table[i][j<span class="number">-1</span>], Table[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">std</span>::<span class="built_in">log</span>(r - (l - <span class="number">1</span>)) / <span class="built_in">std</span>::<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::max(Table[l][k], Table[r - ((<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>)][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Table[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 这里可以省去seq[i]，对Table[i][0]进行直接写入</span></span><br><span class="line">    BuildTable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">洛谷P3865【模板】ST表</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;$O(1)$查询区间最值&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="算法" scheme="https://blog.handwer-std.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ST表" scheme="https://blog.handwer-std.top/tags/ST%E8%A1%A8/"/>
    
      <category term="RMQ问题" scheme="https://blog.handwer-std.top/tags/RMQ%E9%97%AE%E9%A2%98/"/>
    
      <category term="模板" scheme="https://blog.handwer-std.top/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Handwer&#39;s Blog 突破100篇文章</title>
    <link href="https://blog.handwer-std.top/2019-02-14/100-articles/"/>
    <id>https://blog.handwer-std.top/2019-02-14/100-articles/</id>
    <published>2019-02-14T14:51:18.000Z</published>
    <updated>2019-02-14T15:08:45.675Z</updated>
    
    <content type="html"><![CDATA[<p>2019年2月14日22点，在键盘的敲击声中，Handwer’s Blog的第100篇博客诞生了。</p><p>第一个里程碑已经达成，下一个里程碑：200篇</p><p>2019也要加油啊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019年2月14日22点，在键盘的敲击声中，Handwer’s Blog的第100篇博客诞生了。&lt;/p&gt;
&lt;p&gt;第一个里程碑已经达成，下一个里程碑：200篇&lt;/p&gt;
&lt;p&gt;2019也要加油啊&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="只有经历过的人才知道的世界" scheme="https://blog.handwer-std.top/tags/%E5%8F%AA%E6%9C%89%E7%BB%8F%E5%8E%86%E8%BF%87%E7%9A%84%E4%BA%BA%E6%89%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    
      <category term="博客相关" scheme="https://blog.handwer-std.top/tags/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>洛谷P2504《[HAOI2006]聪明的猴子》</title>
    <link href="https://blog.handwer-std.top/2019-02-14/Luogu-P2504/"/>
    <id>https://blog.handwer-std.top/2019-02-14/Luogu-P2504/</id>
    <published>2019-02-14T14:40:55.000Z</published>
    <updated>2019-02-14T14:48:07.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最小生成树板子题</p></blockquote><a id="more"></a><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。</p><p>现在，在这个地区露出水面的有N棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。</p><p>在这个地区住着的猴子有M个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。</p><p>【问题】现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。</p><h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件monkey.in包括：</p><p>第1行为一个整数，表示猴子的个数M(2&lt;=M&lt;=500)；</p><p>第2行为M个整数，依次表示猴子的最大跳跃距离（每个整数值在1–1000之间）；</p><p>第3行为一个整数表示树的总棵数N(2&lt;=N&lt;=1000)；</p><p>第4行至第N+3行为N棵树的坐标（横纵坐标均为整数，范围为：-1000–1000）。</p><p>（同一行的整数间用空格分开）</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件monkey.out包括一个整数，表示可以在这个地区的所有树冠上觅食的猴子数。</p><h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">-2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模】</p><p>对于40%的数据，保证有2&lt;=N &lt;=100，1&lt;=M&lt;=100</p><p>对于全部的数据，保证有2&lt;=N &lt;= 1000，1&lt;=M=500</p><p>感谢@charlie003 修正数据</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先构造完全图（边数为初二数学内容），再跑一遍最小生成树</p><p>之后枚举每一个猴子，判断它的跳跃距离是否大于等于生成树的最大边权即可</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>                  + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">500</span>                   + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXE = (MAXN - <span class="number">1</span>) * MAXN / <span class="number">2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    Node() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> previd, nextid;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    </span><br><span class="line">    Edge() &#123; previd = nextid = <span class="number">0</span>; weight = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; that.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edge[MAXE];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">    </span><br><span class="line">    UnionFind() &#123; <span class="built_in">memset</span>(seq, <span class="number">0</span>, <span class="keyword">sizeof</span> seq); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> !seq[x] ? x : (seq[x] = Find(seq[x])); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = Find(x); y = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        seq[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; U;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetDist</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> idy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> absx = <span class="built_in">std</span>::<span class="built_in">abs</span>(node[idx].x - node[idy].x);</span><br><span class="line">    <span class="keyword">int</span> absy = <span class="built_in">std</span>::<span class="built_in">abs</span>(node[idx].y - node[idy].y);</span><br><span class="line">    ret = <span class="built_in">sqrt</span>(absx * absx + absy * absy);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> monkey[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> maxWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (U.Union(edge[i].previd, edge[i].nextid)) &#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            maxWeight = <span class="built_in">std</span>::max(maxWeight, edge[i].weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tot == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">cin</span> &gt;&gt; monkey[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">    <span class="comment">// initialize edges</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            edge[++cnt].previd = i;</span><br><span class="line">            edge[cnt].nextid = j;</span><br><span class="line">            edge[cnt].weight = GetDist(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> maxW = Kruskal();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (monkey[i] &gt;= maxW) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最小生成树板子题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="编程" scheme="https://blog.handwer-std.top/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="题解" scheme="https://blog.handwer-std.top/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="图论" scheme="https://blog.handwer-std.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="生成树" scheme="https://blog.handwer-std.top/tags/%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
      <category term="最小生成树" scheme="https://blog.handwer-std.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
</feed>
