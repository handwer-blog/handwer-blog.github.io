<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>对「共青团中央」微信公众号转发关于“华为 251 事件”文章的一些看法</title>
    <url>/2019-12-07/Some-Thinking-About-Article-of-Huawei-251/</url>
    <content><![CDATA[<blockquote>
<p>我把 Wikipedia 上的“251 事件”经过看了一遍、整篇文章读了三遍，目的就是让自己的观点尽量的客观、准确。</p>
<p>原文链接：<a href="https://mp.weixin.qq.com/s/ulrfQFNFdVGepT7tHNWUuQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ulrfQFNFdVGepT7tHNWUuQ</a><br>Handwer 的 Evernote 备份：<a href="https://app.yinxiang.com/shard/s62/nl/21474206/ed6c5aa4-6ebd-49c3-a8ef-b19c5d49f1df" target="_blank" rel="noopener">https://app.yinxiang.com/shard/s62/nl/21474206/ed6c5aa4-6ebd-49c3-a8ef-b19c5d49f1df</a></p>
<p>本文记录的是一个<em>心智不成熟</em>的初中生的主观感受</p>
</blockquote>
<a id="more"></a>
<p>原来以为是洗地文章，看完发现不是。</p>
<p>首先，个人觉得，华为这家公司的风评、做事底线与它的最近国际上的处境是两码事。我认为这篇文章的观点没大问题，就算 251 事件出了更大的事也没有问题——因为它讲的根本就不是 251 事件本身及其影响，而是 251 事件之后外媒和网络上一些人的反应。这和其他大部分文章的角度是不同的。</p>
<p>也正因如此，没有谈及 251 事件性质的该文章被网络上的大部分人当做了“不该出现的洗地文”，再经过一些人的断章取义，加上这还是「共青团中央」转发的所谓“维护资产阶级企业家及其企业形象”的文章，就导致大量攻击官媒的高赞评论出现——而我觉得他们大部分可能都没有读完文章，也可能是只看了我所说的图片就直接去评论了，因为你只要完整地看完了这篇文章，就直接能明白：这篇文章是在借民众对“251 事件”及一些报道的反应谈这种愤怒情绪对整个社会的影响，而并非是为华为洗地。</p>
<p>文章中有一句话我很喜欢，就是含有讽刺意的这句：</p>
<blockquote>
<p>什么最重要？保持愤怒情绪最重要。</p>
</blockquote>
<p>被情绪冲昏了头脑的人没有办法理性思考，只会跟着舆论方向乱起哄，而一些不怀好意的人——包括国内的所谓“恨国党”、境外媒体、还有据传不是李洪元写的“李洪元写给任正非的公开信”的真正作者、和那些可能并无恶意的普通自媒体，他们提供的海量的信息就是头脑被冲昏的重要因素之一。包括现在正在写这篇文章的作者我，在多方了解事件进展时，脑袋也差点被搅糊涂了。文章论证了“251 事件”的炒作与“反送中”别无二致，都是通过煽动不明真相也没法独立思考的群众来做到混淆视听或者引起社会的波澜以放缓中国的发展，这很值得我们（包括作者我）来进行反思：我们思考的时候到底有没有被外界影响？此时还能否做到理性思考？这些没有一点理性的愤怒会给整个社会带来多少影响？而那整篇文章就是在说：「不要失去理性，失去理性的愤怒会“搞垮整个社会”！」这恰恰就是“境外势力”和“精神境外势力”（指恨国党）的目的：搞垮整个社会，阻碍中国发展。对于他们，让群众「保持愤怒」自然是最重要的了。还需要说明的一点是，达成目标所需要的一切力量并不来自境外，而是来自那些被煽动的境内群众。</p>
<p>「共青团中央」之所以会转发这篇文章，就是因为这篇文章并不是从微观角度谈“251 事件”，而是从宏观角度谈“Fake News”对整个社会的影响。假设「共青团中央」只是一个普通的自媒体的话，带来流量最多的华为新闻肯定早就被它转遍了，但是啊，它是一个官媒，它关心的是整个国家、整个社会，而不仅仅是一个比较大的企业或者一个行业中发生的事情。提到官媒转发华为事件，很多人应该都能想到人民网转发文章被删的事吧。文章被删可能确实是“黑恶势力”在作祟，也可能只是内部觉得不妥而删除而已。抛开这些不管，假如文章还活着的话，我依然会赞同这篇文章的观点，更有可能两篇都会支持——这个观点我已经明确表示过了，两篇文章谈的是同一件事的两个角度，说的也都是我认为正确的，我当然都会赞同，这其中没有任何自相矛盾，华为这个公司的品行是一回事，这件事引发的舆论影响又是一回事。我支持运用法律的武器打击流氓企业，抨击华为的这种钻法律空子的行为，同时痛恨肆意扩大这件事的影响来给自己赚流量而不顾当事人感受的部分自媒体，和那些见不得中国好的外媒及“中国人”。</p>
<p>另外，文章中提到的“公知大 V”我找不到相关信息，故不对此做出评论，还是建议原作者随便附几个例子，这样应该可以堵住一小部分人的嘴。</p>
<p>最后，以原作者的一句话结尾，祝华为早日挺过公关危机，也希望华为这个公司的品行能越来越好。</p>
<blockquote>
<p>我们不要被人利用了，不要被人当枪使，美国舆论轰炸机《纽约时报》，CNN都立刻带着”251炸弹“起飞了，还看不明白吗？</p>
</blockquote>
<hr>
<p>另附一份 PDF 版本，包含完整的脚注、格式，<a href="/files/对「共青团中央」微信公众号转发关于“华为 251 事件”文章的一些看法.pdf">链接</a></p>
]]></content>
      <tags>
        <tag>记录</tag>
        <tag>文章</tag>
        <tag>华为</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2449《[SDOI2005]矩形》</title>
    <url>/2019-11-05/Luogu-P2449/</url>
    <content><![CDATA[<blockquote>
<p>真就正解是暴力呗</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>现在我们在一个平面上画了n个矩形。每一个矩形的两边都与坐标轴相平行，且矩形定点的坐标均为整数。现我们定义满足如下性质的图形为一个块：</p>
<p>1.每一个矩形都是一个块；</p>
<p>2.如果两个块有一段公共的部分，那么这两个块就会形成一个新的块，否则这两个块就是不同的。</p>
<p>示例：</p>
<p>图1中的矩形形成了两个不同的块。图2中的矩形形成了一个块。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/1579.png" alt></p>
<p>任务：</p>
<p>请写一个程序：</p>
<p>1.从文本文件PRO.IN中读入各个矩形的顶点坐标；</p>
<p>2.找出这些矩形中不同的块的数目；</p>
<p>3.把结果输出到文本文件PRO.OUT中。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>文本文件PRO.IN的第一行包括一个整数n，1 &lt;= n &lt;= 7000，为矩形的数目。以下的n行为矩形顶点的坐标。每一个矩形都是用四个整数来描述的：左下角的x坐标、左下角的y坐标、右上角的x坐标和右上角的y坐标。所有的坐标都是不大于10000的非负整数。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>在文本文件PRO.OUT中输出唯一的一个整数——这些矩形所形成的不同的块的数目。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>考试题</p>
<p>当时看到这题发现自己只会 $O(n^2\log n)$，最后拿了 54pts<br>考试结束看了一眼洛谷题解，发现这玩意真就是个暴力。。。自己写丑了才少拿了分</p>
<p>具体就是 $O(n^2)$ 枚举所有的矩形，判断是否是一个联通块，是就用并查集把编号连起来，时间复杂度 $O(n^2\log n)$</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>这里不给出代码，原因是洛谷数据过水导致我的 AC 代码可以被 Hack 掉。。找个时间再放上来吧</p>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>并查集</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3200《[HNOI2009]有趣的数列》</title>
    <url>/2019-11-04/Luogu-P3200/</url>
    <content><![CDATA[<blockquote>
<p>卡特兰数 + 质因数分解</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>我们称一个长度为2n的数列是有趣的，当且仅当该数列满足以下三个条件：</p>
<p>(1)它是从1到2n共2n个整数的一个排列{ai}；</p>
<p>(2)所有的奇数项满足a1&lt;a3&lt;…&lt;a2n-1，所有的偶数项满足a2&lt;a4&lt;…&lt;a2n；</p>
<p>(3)任意相邻的两项a2i-1与a2i(1&lt;=i&lt;=n)满足奇数项小于偶数项，即：a2i-1&lt;a2i。</p>
<p>现在的任务是：对于给定的n，请求出有多少个不同的长度为2n的有趣的数列。因为最后的答案可能很大，所以只要求输出答案 mod P的值。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入文件只包含用空格隔开的两个整数n和P。输入数据保证，50%的数据满足n&lt;=1000，100%的数据满足n&lt;=1000000且P&lt;=1000000000。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>仅含一个整数，表示不同的长度为2n的有趣的数列个数mod P的值。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先给出结论：卡特兰数。</p>
<hr>
<p>注意到偶数位的数字必须大于前面偶数位、偶数位必须大于奇数位两个性质，可以得出这个结论：</p>
<blockquote>
<p>对于任意偶数位的数字，都满足该数字大于前面的所有数字</p>
</blockquote>
<p>考虑把偶数位、奇数位拆出来看，即拆成一个两行 n 列的矩阵，第一行表示奇数位，第二行表示偶数位。<br>上面的式子可以写成：</p>
<blockquote>
<p>对于任意在第二行的数字，都满足它大于它左边、左上边（不含正上方）的所有数字</p>
</blockquote>
<p>把第一排的数字都记为 0，第二排的数字都记为 1，放回到原序列，再联系前面的结论，可以得出：</p>
<blockquote>
<p>在（更新为 0 或 1 的）原序列中，对于任意一位 0，都满足前面的所有 0 的个数不小于前面所有 1 的个数；对于任意一位 1，都满足前面的所有 0 的个数大于前面所有 1 的个数</p>
</blockquote>
<p>如果把 0 看作栈的入栈操作，1 看作栈的出栈操作，那么上面的式子可以写成：</p>
<blockquote>
<p>在一个栈操作序列中，对于任意一个入栈操作，都满足前面的入栈操作数不小于前面的出栈操作数；对于任意一个出栈操作，都满足前面的入栈操作数大于前面的出栈操作数</p>
</blockquote>
<p>也就是求 <strong>长度为 n 的合法栈操作序列个数 / 出栈序列个数</strong></p>
<p>这个怎么求我不用再多说了吧</p>
<hr>
<p>接下来是另一个问题：取模</p>
<p>题目的 $p$ 是读入的，样例就明明白白的说了不一定是质数，甚至还可能很小</p>
<p>怎么办？</p>
<p>分解质因数。</p>
<p>注意到</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text{ans} &= {C_{2n}^n \over n + 1}
\\ &= { { { (2n)! } \over { n! \times n! } } \over { n + 1 } }
\\ &= { { (2n)! } \over { (n!)^2(n + 1) } }
\\ &= { { 1\times 2\times\dots \times (n - 1)\times n\times (n + 1)\times\dots\times (2n - 1)\times 2n } \over { [1\times 2\times\dots \times (n - 1)\times n] \times [1\times 2\times\dots \times (n - 1)\times n] \times (n + 1) } }
\end{aligned}</script><p>分数上下消一消</p>
<script type="math/tex; mode=display">
\begin{aligned}
\text{ans} &= { {(n + 2) \times (n + 3) \times \dots \times (2n - 1) \times 2n} \over {1\times 2\times\dots \times (n - 1)\times n} }
\end{aligned}</script><p>然后记 $f_i(i \in \text{Primes})$ 表示在答案中，编号为 $i$ 的质数被乘了几次，<br>也就是把 $ans$ 进行唯一分解放到一个数组里</p>
<p>怎么求 $f$ ？</p>
<p>直接上代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在线性筛中，如果 i 这个数是被第 k 个质数筛掉的，那么 sieveBy[i] = k</span></span><br><span class="line"><span class="comment">// prs[i] 表示第 i 个质数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">	<span class="comment">// 加上分子 n + 2 到 2n 的乘积的分解</span></span><br><span class="line">	<span class="keyword">int</span> x = i;</span><br><span class="line">	<span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">// 分解质因数</span></span><br><span class="line">		++f[sieveBy[x]];</span><br><span class="line">		x = x / prs[sieveBy[x]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">	<span class="comment">// 消去分母中 1 到 n 的乘积的分解</span></span><br><span class="line">	<span class="keyword">int</span> x = i;</span><br><span class="line">	<span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		--f[sieveBy[x]];</span><br><span class="line">		x = x / prs[sieveBy[x]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后 for 一遍所有的质数，快速幂乘一下就好了</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notprime[<span class="number">2000000</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> prs[<span class="number">2000000</span> + <span class="number">10</span>], cnt;</span><br><span class="line"><span class="keyword">int</span> sieveBy[<span class="number">2000000</span> + <span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n, p;</span><br><span class="line"><span class="keyword">int</span> calcs[<span class="number">2000000</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b) &#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="number">1l</span>l * ret * <span class="number">1l</span>l * a % p;</span><br><span class="line">		a = <span class="number">1l</span>l * a * <span class="number">1l</span>l * a % p;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	notprime[<span class="number">0</span>] = notprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!notprime[i]) &#123;</span><br><span class="line">			prs[++cnt] = i;</span><br><span class="line">			sieveBy[i] = cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; i * prs[j] &lt;= <span class="number">2</span> * n; ++j) &#123;</span><br><span class="line">			notprime[i * prs[j]] = <span class="literal">true</span>;</span><br><span class="line">			sieveBy[i * prs[j]] = j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;p);</span><br><span class="line">	sieve();</span><br><span class="line">	<span class="comment">// 	ans = ((2n)! / (n! * n!) * (n + 1))</span></span><br><span class="line">	<span class="comment">// 		= ((1 * 2 * ... * (n - 1) * n * (n + 1) * (n + 2) * (n + 3) * ... * 2n) /</span></span><br><span class="line">	<span class="comment">//			(1 * 2 * ... * (n - 1) * n) * (1 * 2 * ... * (n - 1) * n) * (n + 1))</span></span><br><span class="line">	<span class="comment">// 		= ((n + 1) * (n + 2) * (n + 3) * ... * 2n) /</span></span><br><span class="line">	<span class="comment">// 			 ((1 * 2 * ... * (n - 1) * n) * (n + 1))</span></span><br><span class="line">	<span class="comment">// 		= ((n + 2) * (n + 3) * ... * 2n) / ((1 * 2 * ... * (n - 1) * n)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = i;</span><br><span class="line">		<span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// printf("Now exting: %d\n", x);</span></span><br><span class="line">			++calcs[sieveBy[x]];</span><br><span class="line">			x = x / prs[sieveBy[x]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// printf("Calc 1.\n");</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = i;</span><br><span class="line">		<span class="keyword">while</span> (x &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			--calcs[sieveBy[x]];</span><br><span class="line">			x = x / prs[sieveBy[x]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">		ans = <span class="number">1l</span>l * ans * <span class="number">1l</span>l * fastPow(prs[i], calcs[i], p) % p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>筛法</tag>
        <tag>质数</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3331《[BeiJing2013]压力》</title>
    <url>/2019-11-03/BZOJ3331/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一张 n 个点 m 条边的无向图，再给你 q 个点对，让你计算对于每一个点，有多少个点对间的路径必定经过这个点。N≤100000,M,Q≤200000。</p>
<a id="more"></a>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先可以发现这样一个东西：</p>
<blockquote>
<p>在原图对应的圆方树上，一个点对之间的所有圆点都会被经过</p>
</blockquote>
<p>那就好做了</p>
<p>首先建出圆方树，然后问题转化为了一个树上链修改，单点查询的题目</p>
<p>直接树上差分一下就行了</p>
<hr>
<p>我还是讲一下这个差分吧</p>
<p>具体就是对于点对<code>(u,v)</code>，<code>diff[u]++, diff[v]++, diff[LCA(u,v)]--, diff[father[LCA(u,v)]]--</code></p>
<p>最后一遍 dfs 还原一下树上前缀和即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/11/2.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: [BeiJing2013]压力</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> NEWN = MAXN &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXQ = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> next; <span class="keyword">bool</span> typ;</span><br><span class="line">    Node(<span class="keyword">int</span> _next = <span class="number">0</span>, <span class="keyword">bool</span> _typ = <span class="literal">false</span>) &#123; next = _next; typ = _typ; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qu</span> &#123;</span> <span class="keyword">int</span> u, v; qu(<span class="keyword">int</span> _u = <span class="number">0</span>, <span class="keyword">int</span> _v = <span class="number">0</span>) &#123; u = _u; v = _v; &#125; &#125; qs[MAXQ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, tn, m, q;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[NEWN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tarjan &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> dfn[MAXN], low[MAXN], timestamp;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> stk[MAXN], top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tn = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tn; ++i) <span class="keyword">if</span> (!dfn[i]) work(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        dfn[u] = low[u] = ++timestamp;</span><br><span class="line">        stk[++top] = u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                work(v, u);</span><br><span class="line">                low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">                <span class="keyword">if</span> (low[v] &gt;= dfn[u]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = <span class="number">-1</span>; ++tn; <span class="comment">// 直接在这里建圆方树，++tn 是给圆方树的方点分配编号</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        x = stk[top--];</span><br><span class="line">                        tree[tn].push_back(x);</span><br><span class="line">                        tree[x].push_back(tn);</span><br><span class="line"><span class="comment">//                        printf("Edge connected: &lt;%d, %d&gt;\n", tn, x);</span></span><br><span class="line">                    &#125; <span class="keyword">while</span> (x != v);</span><br><span class="line">                    tree[u].push_back(tn); tree[tn].push_back(u);</span><br><span class="line"><span class="comment">//                    printf("Edge connected: &lt;%d, %d&gt;\n", tn, u);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v != fa) low[u] = <span class="built_in">std</span>::min(low[u], dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> LCA &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> father[NEWN][<span class="number">30</span>], depth[NEWN];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> lg[NEWN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tn; ++i) &#123;</span><br><span class="line">            lg[i] = lg[i - <span class="number">1</span>] + (<span class="number">1</span> &lt;&lt; lg[i - <span class="number">1</span>] == i);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">        father[u][<span class="number">0</span>] = fa; depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= depth[u]; ++i) &#123;</span><br><span class="line">            father[u][i] = father[father[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) tree[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = tree[u][i];</span><br><span class="line">            <span class="keyword">if</span> (v != fa) dfs(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth[u] &lt; depth[v]) <span class="built_in">std</span>::swap(u, v);</span><br><span class="line">        <span class="keyword">while</span> (depth[u] &gt; depth[v]) &#123;</span><br><span class="line">            u = father[u][lg[depth[u] - depth[v]] - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = lg[depth[u]]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (father[u][i] != father[v][i]) &#123;</span><br><span class="line">                u = father[u][i]; v = father[v][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[u][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Difference &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> diff[NEWN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = LCA::get(u, v);</span><br><span class="line"><span class="comment">//        printf("u = %d, v = %d, LCA&lt;%d, %d&gt; = %d, LCA's father = %d\n", u, v, u, v, l, LCA::father[l][0]);</span></span><br><span class="line">        ++diff[u]; ++diff[v];</span><br><span class="line">        --diff[l]; --diff[LCA::father[l][<span class="number">0</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        printf("[dfs(u)] u = %d\n", u);</span></span><br><span class="line">        <span class="keyword">using</span> LCA::father;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) tree[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = tree[u][i]; <span class="keyword">if</span> (v == father[u][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            dfs(v);</span><br><span class="line">            diff[u] += diff[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        head[u].push_back(v); head[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v; <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        qs[i] = qu(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    Tarjan::tarjan();</span><br><span class="line">    LCA::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = qs[i].u, v = qs[i].v;</span><br><span class="line"><span class="comment">//        printf("Query #%d: u = %d, v = %d\n", i, u, v);</span></span><br><span class="line">        Difference::modify(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    Difference::dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Difference::diff[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>差分</tag>
        <tag>Tarjan</tag>
        <tag>圆方树</tag>
        <tag>LCA</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title>可持久化线段树学习笔记</title>
    <url>/2019-11-03/Persistent-Segment-Tree/</url>
    <content><![CDATA[<blockquote>
<p>可持久化数据结构初探</p>
</blockquote>
<a id="more"></a>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>请设计一个支持如下操作的数据结构：</p>
<ol>
<li>扩大这个数据结构的范围（如从 $[1,n]$ 扩大到 $[1,n + k]$，保证最终的大小不会超过 $10^5$）</li>
<li>在最新版本基础上修改某个位置上的值</li>
<li>查询最新版本某个位置上的值</li>
<li>回滚到某一个版本</li>
<li>在某一个版本基础上修改某个位置的值</li>
<li>查询某一个版本某个位置上的值</li>
</ol>
<p>为了方便，初始时数据结构范围为 $[1,1]$；输入数据均为正整数；每次修改时，都要新建一个版本（基于哪一个版本取决于操作的编号）；每次查询时，新建一个与最新版本相同的版本</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>前置条件：</p>
<ol>
<li>数组下标从 1 开始</li>
<li>一开始就直接开到最大数据结构大小</li>
</ol>
<h2 id="朴素算法-1"><a href="#朴素算法-1" class="headerlink" title="朴素算法 1"></a>朴素算法 1</h2><p>将版本视为一个时间轴，建立一个二维数组，第一维表示版本，第二维存对应版本的数据，每一次操作时把基于的版本复制一遍，然后修改、查询。</p>
<p>时空复杂度 $\mathcal{O}(nm)$，其中 $n$ 为数据结构最大大小，$m$ 为数据结构最大版本数</p>
<h2 id="朴素算法-2"><a href="#朴素算法-2" class="headerlink" title="朴素算法 2"></a>朴素算法 2</h2><p>依然将版本视为一个时间轴，建立意义与朴素算法 1 相同的二维数组，不同的是，这次不再复制整个数组，取而代之的是在没有用到的下标 0 处记录这个版本是基于哪个版本的，修改只需修改对应的元素即可。查询时，先看这个元素是不是 0（意味着未被修改），是则跳到下标 0 记录的版本，重复这个过程，直到元素非 0，输出即可</p>
<p>空间复杂度 $\mathcal{O}(nm)$；<br>修改时间复杂度 $\mathcal{O}(1)$，查询时间复杂度最坏为 $\mathcal{O}(m)$；<br>$n,m$ 意义同朴素算法 1。</p>
<h2 id="可持久化线段树"><a href="#可持久化线段树" class="headerlink" title="可持久化线段树"></a>可持久化线段树</h2><p>为什么要说算法 2 呢？<br>我个人认为，算法 2 <strong>只修改有用的点</strong>的特性正符合可持久化线段树的特点。</p>
<p>顺着算法 2 想下去。发现算法 2 有大量无用的空间，怎么办？</p>
<p>搬出树形结构，再加动态开点。</p>
<h3 id="树的结构及修改操作"><a href="#树的结构及修改操作" class="headerlink" title="树的结构及修改操作"></a>树的结构及修改操作</h3><p>一棵线段树长这样：</p>
<p><img src="https://s2.ax1x.com/2019/11/03/KX0NHU.md.png" alt="KX0NHU.md.png"></p>
<p>然后发现修改第二个元素需要经历这些节点：<br><img src="https://s2.ax1x.com/2019/11/03/KX0gHO.md.png" alt="KX0gHO.md.png"></p>
<p>依据算法 2，开一些新的点作为这个版本的点<br><img src="https://s2.ax1x.com/2019/11/03/KXDUfJ.md.png" alt="KXDUfJ.md.png"><br>蓝点为原来的点，橙点为这个版本经过的点</p>
<p>可以发现它不再是一棵树。但是如果不看那些“被修改”的蓝点，它仍然是一棵二叉树……怎么办？</p>
<p>不妨把它视为多棵线段树，每一棵树都是一个版本，最顶上的依然是树根，只不过<strong>这些线段树共享了一些相同的节点</strong>。</p>
<p>具体实现的话，就把线段树的根节点<strong>们</strong>存在一个数组<code>root[]</code>中，这样，<code>root[i]</code>就表示第 i 棵（第 i 个版本的）线段树的根节点编号。</p>
<p>看一眼代码吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建树，把原始数列建到树的 0 版本上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> roots[]; <span class="comment">// 根节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs, val;</span><br><span class="line">    <span class="comment">// ls 表示左儿子编号，rs 表示右儿子编号，val 表示节点信息</span></span><br><span class="line">&#125; tree[];</span><br><span class="line"><span class="keyword">int</span> cnt; <span class="comment">// 节点编号计数器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// root 要引用的原因是操作过程中</span></span><br><span class="line">    <span class="comment">// 要对存放根节点、左儿子（左子树的根节点）、右儿子（右子树的根节点）编号的变量进行更新</span></span><br><span class="line">    <span class="comment">// 直接引用变量的话可以省一步赋值，写起来也方便</span></span><br><span class="line">    root = ++cnt; <span class="comment">// 给新的节点——当前子树的根节点分配编号</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ((<span class="keyword">void</span>) (tree[root].val = seq[l]));</span><br><span class="line">    <span class="comment">// 经典的线段树赋值  </span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    buildTree(tree[root].ls, l, mid);  </span><br><span class="line">    buildTree(tree[root].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 左右子树建树  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    buildTree(roots[<span class="number">0</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="comment">// 把 0 版本的根节点编号传进去</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改操作，root 表示当前子树根节点编号，引用也是因为更新方便</span></span><br><span class="line"><span class="comment">// base 表示当前修改的是基于哪个版本的，存的是那个版本「对应深度」子树的根节点编号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> base, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> k)</span> </span>&#123;  </span><br><span class="line">    root = ++cnt; tree[root] = tree[base];  </span><br><span class="line">    <span class="comment">// 分配根节点编号，把节点信息原份复制下来，后面再修改</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; tree[root].val = k; <span class="keyword">return</span>; &#125;  </span><br><span class="line">    <span class="comment">// 经典的单点赋值</span></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) modify(tree[root].ls, tree[base].ls, l, mid, pos, k);  </span><br><span class="line">    <span class="keyword">else</span> modify(tree[root].rs, tree[base].rs, mid + <span class="number">1</span>, r, pos, k);  </span><br><span class="line">    <span class="comment">// 对左右子树修改，顺便可以直接更新这个节点的左右儿子信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    modify(roots[新的版本], roots[基于哪个版本], <span class="number">1</span>, n, 修改的位置, 值);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p>明白了 <code>root[]</code> 数组的意义，查询就很简单了</p>
<hr>
<p><img src="https://s2.ax1x.com/2019/11/03/KX258O.md.png" alt="KX258O.md.png"></p>
<p>比如说查询版本 1（初始版本为 0），就是顺着版本 1 的根节点往下找对应位置，查到底部返回。图中灰色的节点是查版本 1 永远碰不到的节点——因为它们在版本 1 中被修改了，而剩下的点依然形成了一棵线段树，顺着这棵树查下去就完事了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查询操作，root 不加引用是因为查询操作没必要对线段树进行修改</span></span><br><span class="line"><span class="comment">// 经典的单点查询，不讲了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[root].val;  </span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) <span class="keyword">return</span> query(tree[root].ls, l, mid, pos);  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(tree[root].rs, mid + <span class="number">1</span>, r, pos);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    query(roots[查询的版本], <span class="number">1</span>, n, 查询的位置);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><h4 id="扩大数据结构范围"><a href="#扩大数据结构范围" class="headerlink" title="扩大数据结构范围"></a>扩大数据结构范围</h4><p>这个其实不用管。。。毕竟一开始就已经把范围开好了</p>
<h4 id="回滚到某个版本"><a href="#回滚到某个版本" class="headerlink" title="回滚到某个版本"></a>回滚到某个版本</h4><p>对线段树的具体内容没有一点操作，直接把新版本的根节点编号设为回滚到的版本</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    roots[新的版本] = roots[回滚到的版本];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关于数据范围"><a href="#关于数据范围" class="headerlink" title="关于数据范围"></a>关于数据范围</h4><p>由于线段树的空间开销本身就很大，再加上可持久化的节点，一般开到原数据范围的 32 倍（即<code>MAXN &lt;&lt; 5</code>）</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>题目：洛谷P3919《【模板】可持久化数组》<br>支持的操作：操作 2、3、5、6</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/11/2.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: 可持久化数组</span></span><br><span class="line"><span class="comment">// Used data structure: 可持久化线段树</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs, val;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> _ls = <span class="number">0</span>, <span class="keyword">int</span> _rs = <span class="number">0</span>, <span class="keyword">int</span> _val = <span class="number">0</span>) &#123; ls = _ls; rs = _rs; val = _val; &#125;</span><br><span class="line">&#125; tree[MAXN &lt;&lt; <span class="number">5</span>]; <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, seq[MAXN], roots[MAXN], versions;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    root = ++cnt;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ((<span class="keyword">void</span>) (tree[root].val = seq[l]));</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    buildTree(tree[root].ls, l, mid);</span><br><span class="line">    buildTree(tree[root].rs, mid + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> base, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    root = ++cnt; tree[root] = tree[base];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123; tree[root].val = k; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) modify(tree[root].ls, tree[base].ls, l, mid, pos, k);</span><br><span class="line">    <span class="keyword">else</span> modify(tree[root].rs, tree[base].rs, mid + <span class="number">1</span>, r, pos, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[root].val;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) <span class="keyword">return</span> query(tree[root].ls, l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(tree[root].rs, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, seq + i);</span><br><span class="line">    buildTree(roots[<span class="number">0</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ver, cmd, loc;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;ver, &amp;cmd, &amp;loc);</span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            modify(roots[++versions], roots[ver], <span class="number">1</span>, n, loc, x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(roots[ver], <span class="number">1</span>, n, loc));</span><br><span class="line">            roots[++versions] = roots[ver];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1383「IOI 2012」《高级打字机》</title>
    <url>/2019-11-02/Luogu-P1383/</url>
    <content><![CDATA[<blockquote>
<p>IOI 也出板子题？</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>早苗入手了最新的高级打字机。最新款自然有着与以往不同的功能，那就是它具备撤销功能，厉害吧。</p>
<p>请为这种高级打字机设计一个程序，支持如下3种操作：</p>
<p>1.T x：在文章末尾打下一个小写字母x。(type操作)</p>
<p>2.U x：撤销最后的x次修改操作。（Undo操作）</p>
<p>（注意Query操作并不算修改操作）</p>
<p>3.Q x：询问当前文章中第x个字母并输出。（Query操作）</p>
<p>文章一开始可以视为空串。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第1行：一个整数n，表示操作数量。</p>
<p>以下n行，每行一个命令。保证输入的命令合法。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>每行输出一个字母，表示Query操作的答案。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">T a</span><br><span class="line">T b</span><br><span class="line">T c</span><br><span class="line">Q 2</span><br><span class="line">U 2</span><br><span class="line">T c</span><br><span class="line">Q 2</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure></p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>【数据范围】</p>
<p>对于40%的数据 n&lt;=200;</p>
<p>对于100%的数据 n&lt;=100000；保证Undo操作不会撤销Undo操作。</p>
<p>&lt;高级挑战&gt;</p>
<p>对于200%的数据 n&lt;=100000；Undo操作可以撤销Undo操作。</p>
<ioi挑战>

<p>必须使用在线算法完成该题。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="普通数据"><a href="#普通数据" class="headerlink" title="普通数据"></a>普通数据</h2><p>就是个模拟。。。没啥好讲的</p>
<p>代码之后会给</p>
<h2 id="IOI-挑战"><a href="#IOI-挑战" class="headerlink" title="IOI 挑战"></a>IOI 挑战</h2><p>原题为 IOI2012 Scrivener <a href="http://www.ioi2012.org/wp-content/uploads/2011/12/Scrivener.pdf" target="_blank" rel="noopener">PDF 链接</a></p>
<p>这不就是个可持久化数组板子吗。。。<br><del> 就这还 IOI 题？</del></p>
<hr>
<p>算了还是好好说一下三种操作吧</p>
<ol>
<li>插入操作<br>提前开好一个大小为 n 的可持久化数组，每次插入的时候建一个新的版本，把上个版本的长度 + 1 处字符修改了就好</li>
<li>撤销操作<br>直接新开一个版本，把版本信息（根节点和长度）修改成撤销到的那个版本就行了</li>
<li>查询操作<br>这个就是模板操作了，不再赘述</li>
</ol>
<hr>
<p>什么？听说你不会可持久化数据结构？<br><del>不久之后</del>我会专门开一篇讲的</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="普通数据-1"><a href="#普通数据-1" class="headerlink" title="普通数据"></a>普通数据</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ptr;</span><br><span class="line"><span class="keyword">char</span> ss[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">3</span>], a[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'T'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br><span class="line">            ss[++ptr] = a[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">'U'</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            ptr -= x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, ss[x]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IOI-挑战-1"><a href="#IOI-挑战-1" class="headerlink" title="IOI 挑战"></a>IOI 挑战</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ls, rs; <span class="keyword">char</span> val;</span><br><span class="line">    Node(<span class="keyword">int</span> _ls = <span class="number">0</span>, <span class="keyword">int</span> _rs = <span class="number">0</span>, <span class="keyword">char</span> _val = <span class="number">0</span>) &#123; ls = _ls; rs = _rs; val = _val; &#125;</span><br><span class="line">&#125; tree[MAXN &lt;&lt; <span class="number">5</span>]; <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, roots[MAXN &lt;&lt; <span class="number">5</span>], lens[MAXN &lt;&lt; <span class="number">5</span>], version;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> base, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos, <span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">    root = ++cnt; tree[root] = tree[base];</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="keyword">void</span>) (tree[root].val = val);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) modify(tree[root].ls, tree[base].ls, l, mid, pos, val);</span><br><span class="line">    <span class="keyword">else</span> modify(tree[root].rs, tree[base].rs, mid + <span class="number">1</span>, r, pos, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[root].val;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= mid) <span class="keyword">return</span> query(tree[root].ls, l, mid, pos);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(tree[root].rs, mid + <span class="number">1</span>, r, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> cmd[<span class="number">3</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, cmd);</span><br><span class="line">        <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'T'</span>) &#123;</span><br><span class="line">            ++version; lens[version] = lens[version - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> sss[<span class="number">3</span>]; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, sss);</span><br><span class="line">            modify(roots[version], roots[version - <span class="number">1</span>], <span class="number">1</span>, n, lens[version], sss[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd[<span class="number">0</span>] == <span class="string">'U'</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ver; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ver);</span><br><span class="line">            ++version; roots[version] = roots[version - ver - <span class="number">1</span>];</span><br><span class="line">            lens[version] = lens[version - ver - <span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> pos; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;pos);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, query(roots[version], <span class="number">1</span>, n, pos));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</ioi挑战>]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>可持久化数据结构</tag>
        <tag>线段树</tag>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2090《数字对》</title>
    <url>/2019-11-01/Luogu-P2090/</url>
    <content><![CDATA[<blockquote>
<p>更相减损术</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>对于一个数字对(a, b)，我们可以通过一次操作将其变为新数字对(a+b, b)或(a, a+b)。</p>
<p>给定一正整数n，问最少需要多少次操作可将数字对(1, 1)变为一个数字对，该数字对至少有一个数字为n。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行一个正整数 n</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一个整数表示答案。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>样例解释：</p>
<p>(1,1)  →  (1,2)  →  (3,2)  →  (5,2)</p>
<p>对于30%的数据， 1 &lt;= n &lt;= 1000</p>
<p>对于60%的数据， 1 &lt;= n &lt;= 20000</p>
<p>对于100%的数据，1 &lt;= n &lt;= 10^6</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>先手玩一下样例，发现式子是这样的：</p>
<blockquote>
<p>$(a,b) \leftarrow (a’ + b, b)$</p>
</blockquote>
<p>反过来写</p>
<blockquote>
<p>$(a’,b) \rightarrow (a - b, b)$</p>
</blockquote>
<p>这个不是。。。更相减损术？</p>
<hr>
<p>所以题目就转化成了：找到一个数字对 $(n,a)$ 使得 <code>gcd(n, a)</code> 进行更相减损的次数最小。</p>
<p>考虑枚举 $a$，上界怎么确定？</p>
<p>手玩的时候顺便发现从 $(1,1)$ 分出的两条分支是对称的，那么超出 $n$ 的枚举是没有必要的，所以 $1\leq a \leq n$</p>
<hr>
<p>每一次 <code>gcd</code> 传下去的参数都是 <code>b,a mod b</code>，更相减损了 $\lfloor {a \over b} \rfloor$ 次， 每次步数要加上这个数；<br>最后如果 $b = 1$，那么步数要另加上 $a - 1$ （从 $(1,1)$ 转移到 $(a,1)$ 需要 $a - 1$ 步）；<br>最后如果 $b = 0$ 那就无解，直接 <code>return inf</code> 别让答案更新就好</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/11/1.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: 数字对</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">    <span class="keyword">return</span> a / b + gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans, gcd(n, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2062《分队问题》</title>
    <url>/2019-11-01/Luogu-P2062/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定n个选手，将他们分成若干只队伍。其中第i个选手要求自己所属的队伍的人数大等于a[i]人。</p>
<p>在满足所有选手的要求的前提下，最大化队伍的总数。</p>
<p>注：每个选手属于且仅属于一支队伍。</p>
<a id="more"></a>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行一个整数n，表示人数。</p>
<p>以下n行，每行一个整数表示a[i]。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出队伍总数的最大值。数据保证有解。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>对于20%的数据，n &lt;= 10</p>
<p>对于40%的数据，n &lt;= 1000</p>
<p>对于60%的数据，n &lt;= 10000</p>
<p>对于100%的数据，1 &lt;= n &lt;= 10^6</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应是个贪心</p>
<p>就是从大往小排序，然后从前往后扫，每碰到一个人就把它后面的人都拉进队</p>
<p>每个元素只会访问一次，时间复杂度$\mathcal{O}(n)$</p>
<hr>
<p>但是这个是错的</p>
<p>考虑这组数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">n = <span class="number">4</span>, a[] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>
<p>贪心跑出来是 2，答案应该是 3<br>原因在于贪心无法判断当前的人是另开一队更优还是加入已有队伍更优，赛后我看了一眼洛谷题解，有人判了这个之后贪心过了<del>但我没看懂</del></p>
<hr>
<p>考虑 dp</p>
<p>首先把 <code>a[]</code>  从小到大排个序</p>
<p>然后设 <code>f[i]</code> 表示当前安排了前 i 个人所能获得的最大队伍数<br>转移方程：</p>
<script type="math/tex; mode=display">
f_i=\left\{\begin{array}{ll}{f_{i - 1}} & {\left(i < a_i)\right.} \\ {f_{i - a_{i}} + 1} & {\left(i \geq a_i\right)}\end{array}\right.</script><p>就是，对于一个人，可以把他塞进旧队伍里，也可以接着前面的 $a_i$ 个人开一个新队伍</p>
<p>时间复杂度 $\mathcal{O}(n)$</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/11/1.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: 分队问题</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, arr[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, arr + i);</span><br><span class="line">    <span class="built_in">std</span>::sort(arr + <span class="number">1</span>, arr + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; arr[i]) f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> f[i] = <span class="built_in">std</span>::max(f[i - <span class="number">1</span>], f[i - arr[i]] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title>公告栏</title>
    <url>/2019-10-31/BulletinBoard/</url>
    <content><![CDATA[<font style="color:#66ccff">
<center>这里可能会挂些什么东西。 <br>There may be something here.
</center>
</font>

<p><img src="https://v2.jinrishici.com/one.svg" alt="今日诗词"></p>
<!--博客累计已突破 100 篇文章-->
<!--New！[《「文章」百名学生参训 礼堂“变身”教室》](/2019-02-16/SDWC-Article/)-->
<center><a href="/2019-08-14/Articles-Moving-To-cnblogs/">《关于新开的&nbsp;cnblogs&nbsp;博客的一些说明》</a></center>
]]></content>
  </entry>
  <entry>
    <title>Codeforces 1244D《Paint the Tree》</title>
    <url>/2019-10-28/CF1244D/</url>
    <content><![CDATA[<blockquote>
<p>因为细节问题没过 pretest 导致我掉分的题目</p>
</blockquote>
<a id="more"></a>
<h1 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h1><p>有一棵树，有3种颜色，第i个节点染成第j种颜色的代价是$c_{j,i}$，现在要你求出一种染色方案，使得总代价最小，且对于任意三个相邻的节点，颜色不能相同。输出最小代价与其中一种方案。无解输出$-1$。</p>
<p>$3\le n\le 10^5$</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3 2 3</span><br><span class="line">4 3 2</span><br><span class="line">3 1 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 3 2</span><br></pre></td></tr></table></figure></p>
<p><strong>输入 #2</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 1 2</span><br><span class="line">4 2 1 5 4</span><br><span class="line">5 3 2 1 1</span><br><span class="line">1 2</span><br><span class="line">3 2</span><br><span class="line">4 3</span><br><span class="line">5 3</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #2</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure></p>
<p><strong>输入 #3</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 1 2</span><br><span class="line">4 2 1 5 4</span><br><span class="line">5 3 2 1 1</span><br><span class="line">1 2</span><br><span class="line">3 2</span><br><span class="line">4 3</span><br><span class="line">5 4</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #3</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">1 3 2 1 3</span><br></pre></td></tr></table></figure></p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>拿到样例之后就<del>随便</del>手玩一下，然后再<del>随便</del>举几个例子<br>发现这样一个奇怪的事情：</p>
<blockquote>
<p>好像任意的$k(k \geq 2)$叉树都没法染色。。。</p>
</blockquote>
<p>这里直接用二叉树的情况解释一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">A --&gt; B</span><br><span class="line">A --&gt; C</span><br><span class="line">B --&gt; D</span><br><span class="line">B --&gt; E</span><br></pre></td></tr></table></figure>
<p>发现在无论怎么染色，对 A、B、D、E 进行染色总会冲突</p>
<p>所以分析了半天可以发现这样一个有趣的性质：</p>
<blockquote>
<p>一棵树能被正确进行染色当且仅当这棵树为一条链。</p>
</blockquote>
<hr>
<p>判完 -1 再来想一想怎么搞一条链的情况</p>
<p><del>不会了啊。。。完了今晚要掉分了</del></p>
<p>想一下暴力是怎么做的：$3^n$枚举所有的点怎么填颜色，然后扫一遍判断。继续手玩一条链的情况，发现一个事情：</p>
<blockquote>
<p>两个点确定了，整条链的染色方案就唯一确定了。</p>
</blockquote>
<hr>
<p>做法就出来了。</p>
<blockquote>
<p>首先判断树是否为一条链（判断每个点的度），不为链则 Failed；<br>然后两重循环大力枚举前两个点的颜色，之后扫一遍确定其他点的颜色，顺便算出花费，更新答案<br>输出最终答案</p>
</blockquote>
<hr>
<p>实现的时候要注意细节很多。。。我比赛的时候因为时间不太够写的很急，结果没过 pretest。。。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/10/27.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: Paint the Tree</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, linkTop;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">10000000000000000</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> cost[MAXN][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> degree[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="keyword">int</span> next[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> col[MAXN], fcol[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : head[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == pre) <span class="keyword">continue</span>;</span><br><span class="line">        next[now] = v;</span><br><span class="line">        DFS(v, now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre, <span class="keyword">int</span> ppre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; now; now = next[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[ppre] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[pre] == <span class="number">2</span>) col[now] = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> col[now] = <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col[ppre] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[pre] == <span class="number">1</span>) col[now] = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">else</span> col[now] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (col[pre] == <span class="number">1</span>) col[now] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> col[now] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ppre = pre; pre = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> fcost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fcost += cost[i][col[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans &gt;= fcost) &#123;</span><br><span class="line">        ans = fcost;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            fcol[i] = col[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">3</span>; ++c) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; cost[i][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">0</span>, v = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;u, &amp;v);</span><br><span class="line">        head[u].push_back(v); ++degree[u];</span><br><span class="line">        head[v].push_back(u); ++degree[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degree[i] &gt; <span class="number">2</span>) <span class="keyword">return</span> (<span class="number">0</span> &amp; <span class="built_in">puts</span>(<span class="string">"-1"</span>));</span><br><span class="line">        <span class="keyword">if</span> (degree[i] == <span class="number">1</span> &amp;&amp; !linkTop) linkTop = i;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(linkTop, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        col[linkTop] = i;</span><br><span class="line">        <span class="keyword">int</span> linkNext = next[linkTop];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            col[linkNext] = j;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            Search(next[linkNext], linkNext, linkTop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fcol[i] &lt;&lt; (i == n ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P5142《区间方差》</title>
    <url>/2019-10-26/Luogu-P5142/</url>
    <content><![CDATA[<blockquote>
<p>简单的数据结构题目以及无处不在的取模</p>
</blockquote>
<a id="more"></a>
<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>出题人并没有能力写有趣的题面……</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>对于一个长度为n的序列$a_1,a_2,a_3\cdots a_n$​，我们定义它的平均数a为:</p>
<p>$a=\frac{1}{n}\sum_{i=1}^{n}a_i$</p>
<p>并定义它的方差d为:</p>
<p>$d=\frac{1}{n}\sum_{i=1}^{n}(a_i-a)^2$</p>
<p>现在给定一个长度为n的序列$b_1,b_2\cdots b_n$​。你需要支持两种操作。每种操作的格式为c x y。</p>
<p>若c=1，为修改操作，代表将$b_x$​赋值为y。</p>
<p>若c=2，为查询操作，代表查询$b_x$​到$b_y$的方差。</p>
<p>为了避免浮点数误差，请以分数取模形式输出结果（对1000000007（$10^9+7$）取模）。如果不知道什么是分数取模，请看下文。</p>
<blockquote>
<p>作者注：原文这里是对乘法逆元对介绍，在此省略</p>
</blockquote>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行两个数n,m，代表序列b的长度为n，有m个操作。</p>
<p>第二行n个整数$b_i$​，表示序列b的初始值。</p>
<p>下面有m行整数，每行格式为c a b，含义如上文所示。保证所有操作合法。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>对于每个操作2，输出一行。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 8</span><br><span class="line">0 0 0 0</span><br><span class="line">1 1 1</span><br><span class="line">1 2 2</span><br><span class="line">1 3 3</span><br><span class="line">1 4 4</span><br><span class="line">2 1 1</span><br><span class="line">2 1 2</span><br><span class="line">2 1 3</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">250000002</span><br><span class="line">666666672</span><br><span class="line">250000003</span><br></pre></td></tr></table></figure></p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>四次修改后，序列b为：1,2,3,4。</p>
<p>区间[1,1]的方差为0.</p>
<p>区间[1,2]的方差为1/4。4的逆元为250000002。</p>
<p>区间[1,3]的方差为2/3。3的逆元为333333336，2*333333336%M=666666672。</p>
<p>对于50%的数据，n≤1000，m≤1000.</p>
<p>对于100%的数据，n≤100000，m≤100000，1≤b_i≤1000000000，1≤x≤n。对于操作1，1≤y≤1000000000。对于操作2，x≤y≤n。</p>
<p>保证逆元一定存在。注意M=1000000007（10^9+7）。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>没啥可解析的……推推式子就完了</p>
<p>查询 $[l,r]$ 的方差：<br>首先令 $N = r - l + 1$，有</p>
<script type="math/tex; mode=display">
a = {1 \over N} \sum_{i = l}^{r} a_i</script><p>而且</p>
<script type="math/tex; mode=display">
d = {1 \over N} \sum_{i = l}^{r} (a_i - a)^2</script><p>对下面的式子作一番变形：</p>
<script type="math/tex; mode=display">
\begin{align*}
d &= {1 \over N} \sum_{i = l}^{r} (a_i - a)^2
\\&= {1 \over N} \sum_{i = l}^{r} (a_i^2 + a^2 - 2 a \cdot a_i)
\\&= {1 \over N} \big( \sum_{i = l}^{r} a_i^2 + \sum_{i = l}^{r} a^2 - \sum_{i = l}^{r} 2 a \cdot a_i \big)
\\&= {1\over N} \big(\sum_{i = l}^{r} a_i^2 + N \times a^2 - 2a \sum_{i = l}^{r} a_i\big)
\\&={1\over N}\sum_{i = l}^{r} a_i^2 + {1\over N} \times N \times a^2 - {1\over N} \times2a \sum_{i = l}^{r} a_i
\\&={1\over N}\sum_{i = l}^{r} a_i^2 + a^2 - {1\over N} \times2a \sum_{i = l}^{r} a_i
\end{align*}</script><p>这个式子复杂的令人自闭。。<br>这时设 </p>
<script type="math/tex; mode=display">
F = \sum_{i = l}^{r} a_i, G = \sum_{i = l}^{r} a_i^2</script><p>这样到后面式子会好看许多，把 $a$ 代入继续变形</p>
<script type="math/tex; mode=display">
\begin{align*}
d &= {1\over N}\sum_{i = l}^{r} a_i^2 + a^2 - {1\over N} \times2a \sum_{i = l}^{r} a_i
\\&= {1\over N}\cdot G + {\big({1 \over N} \sum_{i = l}^{r} a_i\big)}^2 - 2 \times {1 \over N} \times {1 \over N} \sum_{i = l}^{r} a_i \times \sum_{i = l}^{r} a_i
\\&= {1\over N} \cdot G + {1\over N^2} \cdot F^2-2\times {1\over N^2}\cdot F^2
\\&= {1\over N} \cdot G -{1\over N^2}\cdot F^2
\end{align*}</script><p>这个就是最后的方差式子。。。终于推出来了</p>
<p>注意到之前设的 $F$ 和 $G$ 是</p>
<script type="math/tex; mode=display">
F = \sum_{i = l}^{r} a_i, G = \sum_{i = l}^{r} a_i^2</script><p>发现这个东西似乎可以用数据结构维护</p>
<hr>
<p>然后就是一道树状数组模板题了</p>
<p>维护两个树状数组，一个记录区间和，一个记录区间平方和</p>
<p>这个很好做吧，下面放代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前缀和</span></span><br><span class="line"><span class="function">lli <span class="title">qu</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;  </span><br><span class="line">    lli r = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        (r += bit[p]) %= HA;  </span><br><span class="line">        lb(p, <span class="number">-1l</span>l);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> r;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 前缀平方和</span></span><br><span class="line"><span class="function">lli <span class="title">qux</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;  </span><br><span class="line">    lli r = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        (r += bitt[p]) %= HA;  </span><br><span class="line">        lb(p, <span class="number">-1l</span>l);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> r;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 修改，注意操作是单点覆盖而不是单点加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> p, lli x)</span> </span>&#123;  </span><br><span class="line">    lli d = x - (qu(p) - qu(p - <span class="number">1</span>)),  </span><br><span class="line">            dx = x * x - (qux(p) - qux(p - <span class="number">1</span>));  </span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123;  </span><br><span class="line">        bit[p] = (bit[p] + d) % HA;  </span><br><span class="line">        bitt[p] = (bitt[p] + dx) % HA;  </span><br><span class="line">        lb(p, <span class="number">1l</span>l);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后这道<code>省选/NOI-</code>的题目就做完了<br>真就评分虚高嗷</p>
<hr>
<p>注意几个坑点</p>
<ol>
<li>题目的操作是单点覆盖，但是树状数组只能区间加，要先查询一下当前点的值然后加上差值，这个见代码吧</li>
<li><big><big>取模！取模！取模</big> 修改和查询都要取模！还要注意负数取模的问题！</big>

</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/10/23.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: 区间方差</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lb(x,y) ((x = x + y * (x &amp; (-x))))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> lli HA = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">lli bit[MAXN], bitt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function">lli <span class="title">qu</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; lli r = <span class="number">0</span>; <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) &#123; (r += bit[p]) %= HA; lb(p, <span class="number">-1l</span>l); &#125; <span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="function">lli <span class="title">qux</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123; lli r = <span class="number">0</span>; <span class="keyword">while</span> (p &gt;= <span class="number">1</span>) &#123; (r += bitt[p]) %= HA; lb(p, <span class="number">-1l</span>l); &#125; <span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mo</span><span class="params">(<span class="keyword">int</span> p, lli x)</span> </span>&#123;</span><br><span class="line">    lli d = x - (qu(p) - qu(p - <span class="number">1</span>)), dx = x * x - (qux(p) - qux(p - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= n) &#123; bit[p] = (bit[p] + d) % HA; bitt[p] = (bitt[p] + dx) % HA; lb(p, <span class="number">1l</span>l); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lli <span class="title">pw</span><span class="params">(lli a, lli b)</span> </span>&#123; lli r = <span class="number">1</span>; <span class="keyword">while</span> (b) &#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>) r = r * a % HA; a = a * a % HA; b &gt;&gt;= <span class="number">1</span>; &#125; <span class="keyword">return</span> r; &#125;</span><br><span class="line"><span class="function">lli <span class="title">inv</span><span class="params">(lli a)</span> </span>&#123; <span class="keyword">return</span> pw(a, HA - <span class="number">2</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); m = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) mo(i, getint());</span><br><span class="line">    rap (i, <span class="number">1</span>, m, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getint(); <span class="keyword">int</span> x = getint(); <span class="keyword">int</span> y = getint();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">1</span>) mo(x, y);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lli N = (y - x + <span class="number">1</span>); lli iN = inv(N);</span><br><span class="line">            lli fx = (qu(y) - qu(x - <span class="number">1</span>) + HA) % HA, gx = (qux(y) - qux(x - <span class="number">1</span>) + HA) % HA;</span><br><span class="line">            lli tx = (iN * gx % HA - iN * iN % HA * fx % HA * fx % HA); <span class="keyword">while</span> (tx &lt;= <span class="number">0</span>) tx += HA; tx %= HA;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, tx % HA);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>代码也不长啊，不就50行吗</del></p>
<h1 id="相似题目"><a href="#相似题目" class="headerlink" title="相似题目"></a>相似题目</h1><p>强化版：<a href="https://www.luogu.org/problem/P1471" target="_blank" rel="noopener">洛谷P1471《方差》</a></p>
]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 453A《Little Pony and Expected Maximum》</title>
    <url>/2019-10-25/CF453A/</url>
    <content><![CDATA[<blockquote>
<p>简单期望题目</p>
</blockquote>
<a id="more"></a>
<h1 id="题意翻译"><a href="#题意翻译" class="headerlink" title="题意翻译"></a>题意翻译</h1><blockquote>
<p>翻译来自洛谷</p>
</blockquote>
<p>暮暮刚刚在和她的朋友——AJ（苹果杰克）、FS（小蝶）、RD（云宝黛西）玩Ludo游戏。但是她马品没攒够总是输。回到城堡过后，她对游戏用的骰子产生了兴趣。</p>
<p>题目描述</p>
<p>这个骰子有M面：骰子的第一面有一个点，第二面有两个点，以此类推，第m面含有M点。暮暮确信的是，当掷骰子时，每一面都有1/m的可能性出现，并且每次投掷的概率都是都是独立的。请你帮助她计算掷N次骰子后每次得到的点数中最大值的期望。</p>
<p>输入输出格式</p>
<p>输入格式：</p>
<p>一行两个整数 m 和 n (1 ≤ m, n ≤ 10^5).</p>
<p>输出格式：</p>
<p>输出一行一个实数，与答案误差不大于10^-4</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 1</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3.500000000000</span><br></pre></td></tr></table></figure></p>
<p><strong>输入 #2</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #2</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4.958333333333</span><br></pre></td></tr></table></figure></p>
<p><strong>输入 #3</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #3</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.750000000000</span><br></pre></td></tr></table></figure></p>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>Consider the third test example. If you’ve made two tosses:</p>
<ol>
<li>You can get 1 in the first toss, and 2 in the second. Maximum equals to 2.</li>
<li>You can get 1 in the first toss, and 1 in the second. Maximum equals to 1.</li>
<li>You can get 2 in the first toss, and 1 in the second. Maximum equals to 2.</li>
<li>You can get 2 in the first toss, and 2 in the second. Maximum equals to 2.</li>
</ol>
<p>The probability of each outcome is 0.25, that is expectation equals to:<br>$(2+1+2+2) \cdot 0.25=\frac{7}{4}$<br>You can read about expectation using the following link: <a href="http://en.wikipedia.org/wiki/Expected_value" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Expected_value</a></p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>代码里什么都有</p>
<p>期望的公式是 $E(x) = \sum P(x = i) \times i$</p>
<p>顺便把注释里的两个式子渲染一下：</p>
<script type="math/tex; mode=display">
ans = {\sum_{i = 1}^{m} i \times [i^n - (i - 1)^n] \over m^n}</script><script type="math/tex; mode=display">
ans = \sum_{i = 1}^{m} i \times \big[\big({i \over m}\big)^n - \big({i - 1 \over m}\big)^n\big]</script><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> db;</span><br><span class="line"></span><br><span class="line"><span class="function">db <span class="title">fp</span><span class="params">(db a, <span class="keyword">int</span> b)</span> </span>&#123; db r = <span class="number">1</span>; <span class="keyword">while</span> (b) &#123; <span class="keyword">if</span> (b &amp; <span class="number">1</span>) r = r * a; a = a * a; b &gt;&gt;= <span class="number">1</span>; &#125; <span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 掷 n 次骰子，最大点数不超过 k 的方案数为 k^n</span></span><br><span class="line"><span class="comment"> * 掷 n 次骰子，最大点数不超过 k - 1 的方案数为 (k - 1)^n</span></span><br><span class="line"><span class="comment"> * 减一下就可以知道最大点数为 k 的方案数</span></span><br><span class="line"><span class="comment"> * 然后套一下期望的公式就可以知道</span></span><br><span class="line"><span class="comment"> * ans = &#123;\sum_&#123;i = 1&#125;^&#123;m&#125; i \times [i^n - (i - 1)^n] \over m^n&#125;</span></span><br><span class="line"><span class="comment"> * 整理一下得到</span></span><br><span class="line"><span class="comment"> * ans = \sum_&#123;i = 1&#125;^&#123;m&#125; i \times \big[\big(&#123;i \over m&#125;\big)^n - \big(&#123;i - 1 \over m&#125;\big)^n\big]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">    <span class="keyword">double</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        db d = fp(((<span class="keyword">double</span>) i * <span class="number">1.0</span>) / ((<span class="keyword">double</span>) m * <span class="number">1.0</span>), n);</span><br><span class="line">        ans = ans + ((<span class="keyword">double</span>) i * <span class="number">1.0</span>) * (d - last);</span><br><span class="line">        last = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%0.12lf\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>Codeforces</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1074《靶型数独》</title>
    <url>/2019-10-20/LuoguP1074/</url>
    <content><![CDATA[<blockquote>
<p>基于常识的搜索顺序优化</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。</p>
<p>靶形数独的方格同普通数独一样，在  99  格宽×99  格高的大九宫格中有99  个  33  格宽×33  格高的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入  11  到  99的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图）</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/28.png" alt></p>
<p>上图具体的分值分布是：最里面一格（黄色区域）为  1010  分，黄色区域外面的一圈（红色区域）每个格子为99分，再外面一圈（蓝色区域）每个格子为88  分，蓝色区域外面一圈（棕色区域）每个格子为77分，最外面一圈（白色区域）每个格子为66分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和</p>
<p>总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/29.png" alt></p>
<p>由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>一共  99  行。每行99个整数（每个数都在  0-90−9  的范围内），表示一个尚未填满的数独方格，未填的空格用“00”表示。每两个数字之间用一个空格隔开。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出共  11  行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数-1−1。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 0 0 9 0 0 0 0 1 </span><br><span class="line">1 0 0 0 0 5 9 0 0 </span><br><span class="line">0 0 0 2 0 0 0 8 0 </span><br><span class="line">0 0 5 0 2 0 0 0 3 </span><br><span class="line">0 0 0 0 0 0 6 4 8 </span><br><span class="line">4 1 3 0 0 0 0 0 0 </span><br><span class="line">0 0 7 0 0 2 0 9 0 </span><br><span class="line">2 0 1 0 6 0 8 0 4 </span><br><span class="line">0 8 0 5 0 4 0 1 2</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong>复制<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2829</span><br></pre></td></tr></table></figure></p>
<p><strong>输入 #2</strong>复制<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 0 7 0 2 4 5 3 </span><br><span class="line">9 0 0 0 0 8 0 0 0 </span><br><span class="line">7 4 0 0 0 5 0 1 0 </span><br><span class="line">1 9 5 0 8 0 0 0 0 </span><br><span class="line">0 7 0 0 0 0 0 2 5 </span><br><span class="line">0 3 0 5 7 9 1 0 8 </span><br><span class="line">0 0 0 6 0 1 0 0 0 </span><br><span class="line">0 6 0 9 0 0 0 0 1 </span><br><span class="line">0 0 0 0 0 0 0 0 6</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #2</strong>复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2852</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>拿到题目：<br>这啥啊。。。不是很会啊。。。暴搜估计搜不过去啊。。。</p>
<p>无奈之下看了一眼题解，忽然就想起来了自己以前填数独的技巧。</p>
<hr>
<p>填数独有一个技巧，就是提前填工作量最小的地方，也就是<strong>优先填数最满的地方</strong></p>
<p>确定这个搜索顺序之后这个题就差不多做完了</p>
<hr>
<p>分别开三个数组记录这一行某一个数字是否被填过，这一列某一个数字是否被填过，这一个宫是否被填过</p>
<p>每次搜索记录当前搜到了哪个点，枚举当前格子是填 1-9 中哪个数字，搜一搜就好了</p>
<hr>
<p>搜索顺序如何求出？<br>再开俩数组分别记录每一行填了多少数字，每一列填了多少数字，转移时先枚举填的数字最多的行，然后在这一行中确定<strong>没填过的</strong>格子对应的填的数字最多的列，下一次搜索的时候就搜行列相交处的格子</p>
<p>建议配合代码理解</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><del>我写完代码之后才发觉 line 和 row 都是「行」的意思。。</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">9</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> weight[<span class="number">11</span>][<span class="number">11</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>,<span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> area[<span class="number">11</span>][<span class="number">11</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Order</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, siz;</span><br><span class="line">    Order(<span class="keyword">int</span> _id = <span class="number">0</span>, <span class="keyword">int</span> _siz = <span class="number">0</span>) : id(_id), siz(_siz) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Order &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> siz &gt; that.siz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; order[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">9</span>, sd[MAXN][MAXN], linesiz[MAXN], rowsiz[MAXN];</span><br><span class="line"><span class="keyword">bool</span> lineUsed[MAXN][<span class="number">10</span>], rowUsed[MAXN][<span class="number">10</span>], areaUsed[MAXN][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>, vis = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%c"</span>, sd[i][j], j == n ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">placeNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    sd[x][y] = num;</span><br><span class="line">    ++linesiz[x]; ++rowsiz[y];</span><br><span class="line">    lineUsed[x][num] = rowUsed[y][num] = <span class="literal">true</span>;</span><br><span class="line">    areaUsed[area[x][y]][num] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">displaceNum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    sd[x][y] = <span class="number">0</span>;</span><br><span class="line">    --linesiz[x]; --rowsiz[y];</span><br><span class="line">    lineUsed[x][num] = rowUsed[y][num] = <span class="literal">false</span>;</span><br><span class="line">    areaUsed[area[x][y]][num] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> line = <span class="number">0</span>, <span class="keyword">int</span> row = <span class="number">0</span>, <span class="keyword">int</span> totalPlaced = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (totalPlaced == <span class="number">81</span>) &#123;</span><br><span class="line">        vis = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> fans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                fans += sd[i][j] * weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        print();</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; fans &lt;&lt; endl;</span></span><br><span class="line">        ans = <span class="built_in">std</span>::max(ans, fans);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="number">9</span>; ++num) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lineUsed[line][num]</span><br><span class="line">        || rowUsed[row][num]</span><br><span class="line">        || areaUsed[area[line][row]][num]) <span class="keyword">continue</span>;</span><br><span class="line">        placeNum(line, row, num);</span><br><span class="line">        <span class="keyword">int</span> nextLine = <span class="number">0</span>, maxSize = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxSize &lt; linesiz[i] &amp;&amp; linesiz[i] != <span class="number">9</span>) &#123;</span><br><span class="line">                maxSize = linesiz[i]; nextLine = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextRow = <span class="number">0</span>; maxSize = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxSize &lt; rowsiz[i] &amp;&amp; !sd[nextLine][i]) &#123;</span><br><span class="line">                maxSize = rowsiz[i]; nextRow = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        printf("\nModified &lt;%d,%d&gt;: %d\n", line, row, sd[line][row]);</span></span><br><span class="line"><span class="comment">//        print();</span></span><br><span class="line">        DFS(nextLine, nextRow, totalPlaced + <span class="number">1</span>);</span><br><span class="line">        displaceNum(line, row, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxSiz1 = <span class="number">-1</span>, lc = <span class="number">0</span>, maxSiz2 = <span class="number">-1</span>, rc = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            sd[i][j] = getint();</span><br><span class="line">            <span class="keyword">if</span> (sd[i][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            cnt += (sd[i][j] &gt; <span class="number">0</span>);</span><br><span class="line">            linesiz[i] += (sd[i][j] &gt; <span class="number">0</span>);</span><br><span class="line">            rowsiz[j] += (sd[i][j] &gt; <span class="number">0</span>);</span><br><span class="line">            lineUsed[i][sd[i][j]]</span><br><span class="line">            = rowUsed[j][sd[i][j]] = <span class="literal">true</span>;</span><br><span class="line">            areaUsed[area[i][j]][sd[i][j]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxSiz1 &lt; linesiz[i] &amp;&amp; linesiz[i] != <span class="number">9</span>) &#123;</span><br><span class="line">            lc = i; maxSiz1 = linesiz[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxSiz2 &lt; rowsiz[i] &amp;&amp; !sd[lc][i]) &#123;</span><br><span class="line">            rc = i; maxSiz2 = rowsiz[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(lc, rc, cnt);</span><br><span class="line">    <span class="keyword">if</span> (!vis) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4514《上帝造题的七分钟》</title>
    <url>/2019-10-20/LuoguP4514/</url>
    <content><![CDATA[<blockquote>
<p>二维树状数组</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>“第一分钟，X说，要有矩阵，于是便有了一个里面写满了0的n×m矩阵。<br>第二分钟，L说，要能修改，于是便有了将左上角为(a,b)，右下角为(c,d)的一个矩形区域内的全部数字加上一个值的操作。<br>第三分钟，k说，要能查询，于是便有了求给定矩形区域内的全部数字和的操作。<br>第四分钟，彩虹喵说，要基于二叉树的数据结构，于是便有了数据范围。<br>第五分钟，和雪说，要有耐心，于是便有了时间限制。<br>第六分钟，吃钢琴男说，要省点事，于是便有了保证运算过程中及最终结果均不超过32位有符号整数类型的表示范围的限制。<br>第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”<br>——《上帝造裸题的七分钟》<br>所以这个神圣的任务就交给你了。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入数据的第一行为<code>X n m</code>，代表矩阵大小为n×m。<br>从输入数据的第二行开始到文件尾的每一行会出现以下两种操作：</p>
<ul>
<li><code>L a b c d delta</code>  —— 代表将(a,b),(c,d)为顶点的矩形区域内的所有数字加上delta。</li>
<li><code>k a b c d</code>  —— 代表求(a,b),(c,d)为顶点的矩形区域内所有数字的和。</li>
</ul>
<p>请注意，kk为小写。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>针对每个k操作，在单独的一行输出答案。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X 4 4</span><br><span class="line">L 1 1 3 3 2</span><br><span class="line">L 2 2 4 4 1</span><br><span class="line">k 2 2 3 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>不多说了。。。</p>
<p>就是一个支持矩阵的子矩阵加减、子矩阵和查询的树状数组模板题</p>
<p>讲解见<a href="https://blog.handwer-std.top/2019-10-17/BinaryIndexedTree/#子矩阵加减、子矩阵和查询">这里</a>吧</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>代码也不放了。。上面的链接给的代码就是这题的 AC 代码</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4145《上帝造题的七分钟2 / 花神游历各国》</title>
    <url>/2019-10-20/LuoguP4145/</url>
    <content><![CDATA[<blockquote>
<p>你会支持区间开平方的数据结构吗？</p>
</blockquote>
<a id="more"></a>
<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>XLk觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>“第一分钟，X说，要有数列，于是便给定了一个正整数数列。</p>
<p>第二分钟，L说，要能修改，于是便有了对一段数中每个数都开平方(下取整)的操作。</p>
<p>第三分钟，k说，要能查询，于是便有了求一段数的和的操作。</p>
<p>第四分钟，彩虹喵说，要是noip难度，于是便有了数据范围。</p>
<p>第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。</p>
<p>第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过64位有符号整数类型的表示范围的限制。</p>
<p>第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”</p>
<p>——《上帝造题的七分钟·第二部》</p>
<p>所以这个神圣的任务就交给你了。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行一个整数n，代表数列中数的个数。</p>
<p>第二行n个正整数，表示初始状态下数列中的数。</p>
<p>第三行一个整数m，表示有m次操作。</p>
<p>接下来m行每行三个整数<code>k,l,r</code>，</p>
<ul>
<li><code>k=0</code>表示给[l,r]中的每个数开平方(下取整)</li>
<li><code>k=1</code>表示询问[l,r]中各个数的和。</li>
</ul>
<p><strong>数据中有可能l&gt;r，所以遇到这种情况请交换l和r</strong>。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>对于询问操作，每行输出一个回答。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong>复制<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">5</span><br><span class="line">0 1 10</span><br><span class="line">1 1 10</span><br><span class="line">1 1 5</span><br><span class="line">0 5 8</span><br><span class="line">1 4 8</span><br></pre></td></tr></table></figure></p>
<p><strong>输出 #1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19</span><br><span class="line">7</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我不会支持区间开方的数据结构。怎么办呢？</p>
<p>一个<del>很容易发现的</del>事实是题目给的所有数最多被开方6次（原题数据范围1e12）。为什么呢？</p>
<p><img src="https://s2.ax1x.com/2019/10/20/KMPKDH.png" alt="KMPKDH.png"></p>
<p>懂了吧</p>
<hr>
<p>所以开方操作直接暴力修改就好。每次修改之前查询一下这个块的最大值是不是1，是的话就不去开方这个区间了，这样跑的飞快</p>
<p>查询操作就是正常的不带 lazy tag 的查询函数</p>
<p>还有一个坑点就是 l 和 r 的大小关系，这个注意一下就好了</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD.</span></span><br><span class="line"><span class="comment">// Copyright (c) 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">// Title: 上帝造题的七分钟2 / 花神游历各国</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// sto Qingyu orz</span></span><br><span class="line"><span class="comment">// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，</span></span><br><span class="line"><span class="comment">// 使其天天爆零</span></span><br><span class="line"><span class="comment">// 我不由自主地膜拜真神sqy。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> down(a,t,s,i) for (int a = t; a &gt;= s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">lli osq[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SegmentTree &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (root &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (root &lt;&lt; 1 | 1)</span></span><br><span class="line"></span><br><span class="line">    lli sum[MAXN &lt;&lt; <span class="number">2</span>], max[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function">    </span>&#123; sum[root] = sum[lson] + sum[rson]; max[root] = <span class="built_in">std</span>::max(max[lson], max[rson]); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> (<span class="keyword">void</span>) (sum[root] = max[root] = osq[l]);</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        buildTree(lson, l, mid); buildTree(rson, mid + <span class="number">1</span>, r);</span><br><span class="line">        update(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            sum[root] = max[root] = <span class="built_in">sqrt</span>(sum[root]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= mid &amp;&amp; max[lson] &gt; <span class="number">1</span>)</span><br><span class="line">            modify(ll, rr, lson, l, mid);</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= rr &amp;&amp; max[rson] &gt; <span class="number">1</span>)</span><br><span class="line">            modify(ll, rr, rson, mid + <span class="number">1</span>, r);</span><br><span class="line">        update(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">lli <span class="title">querySum</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> l = <span class="number">1</span>, <span class="keyword">int</span> r = n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> sum[root];</span><br><span class="line">        lli rt = <span class="number">0</span>; <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= mid) rt += querySum(ll, rr, lson, l, mid);</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= rr) rt += querySum(ll, rr, rson, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> rt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) osq[i] = getll();</span><br><span class="line">    SegmentTree::buildTree();</span><br><span class="line">    m = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, m, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmd = getint();</span><br><span class="line">        <span class="keyword">int</span> l = getint(); <span class="keyword">int</span> r = getint();</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="built_in">std</span>::swap(l, r);</span><br><span class="line">        <span class="keyword">if</span> (!cmd) SegmentTree::modify(l, r);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, SegmentTree::querySum(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>暴力</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「初赛」康托展开学习笔记</title>
    <url>/2019-10-17/Cantor-Expansion/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>康托展开</strong>是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。</p>
<p style="text-align: right">——Wikipedia</p>

<a id="more"></a>
<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>直接给式子吧</p>
<p>对于一个长度为 $n$ 的排列，它在全排列中的排名为</p>
<script type="math/tex; mode=display">x=1+a_{n}(n-1) !+a_{n-1}(n-2) !+\cdots+a_{1} \cdot 0 !</script><p>其中$a_i$为给定排列前 $i - 1$个数中 <strong>小于 $a_i$ 的</strong> <em>没有出现的</em> 数的数量</p>
<p>例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t = &#123;1, 6, 4, 5, 3, 2&#125;</span><br><span class="line">那么</span><br><span class="line">a = &#123;0, 4&lt;2,3,4,5&gt;, 2&lt;2,3&gt;, 2&lt;2,3&gt;, 1&lt;2&gt;, 0&#125;</span><br><span class="line">其中&lt;&gt;里具体说明了是哪几个数</span><br><span class="line">此时 x = 114</span><br></pre></td></tr></table></figure></p>
<p>另外，$x-1$就是有多少个排列比给定排列要小。这个很显然。</p>
<h1 id="逆康托展开"><a href="#逆康托展开" class="headerlink" title="逆康托展开"></a>逆康托展开</h1><p>前面说了是可逆的，那么说一说怎么逆回去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如n=5,x=96时：</span><br><span class="line"></span><br><span class="line">首先用96-1得到95，说明x之前有95个排列.(将此数本身减去1)</span><br><span class="line">用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.</span><br><span class="line">用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.</span><br><span class="line">用5去除2!得到2余1，类似地，这一位是3.</span><br><span class="line">用1去除1!得到1余0，这一位是2.</span><br><span class="line">最后一位只能是1.</span><br><span class="line">所以这个排列是&#123;4, 5, 3, 2, 1&#125;.</span><br><span class="line"></span><br><span class="line">再给一个例子：</span><br><span class="line">n = 6, x = 123</span><br><span class="line">123 / (5!) = 1...3</span><br><span class="line">3 / (4!) = 0...3</span><br><span class="line">...（结果都是0...3）</span><br><span class="line">3 / (2!) = 1...1</span><br><span class="line">1 / (1!) = 1...0</span><br><span class="line">0 / (0!) = 0...0</span><br><span class="line"></span><br><span class="line">所以最终排列为&#123;2, 1, 3, 5, 6, 4&#125;</span><br></pre></td></tr></table></figure>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>写这玩意有什么用？打开NOIP2018提高组初赛第21题看程序写输出，他要求的就是给定排列往后数t个得到的排列</p>
<p>使用这个方法就可以将给定排列转化为排名，加t之后再转化回排列，进而得到结果</p>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>学习笔记</tag>
        <tag>数学</tag>
        <tag>初赛</tag>
        <tag>排列</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组学习笔记</title>
    <url>/2019-10-17/BinaryIndexedTree/</url>
    <content><![CDATA[<blockquote>
<p>高效又好写的数据结构</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>树状数组</strong>或<strong>二叉索引树</strong>（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以${\displaystyle O(\log n)}$的时间得到任意前缀和${\displaystyle \sum _{i=1}^{j}A[i],1&lt;=j&lt;=N}$!，并同时支持在${\displaystyle O(\log n)}$时间内支持动态单点值的修改。空间复杂度${\displaystyle O(n)}$。</p>
<p style="text-align: right">——Wikipedia</p>

<p>简单的说，树状数组就是一个便于在 $O(\log n)$ 时间内维护一个数列 / 矩阵的前缀和，可以支持单点修改、查询，区间修改、查询的数据结构。</p>
<p>依据支持操作的不同（包含关系），我这里把它分为六类：</p>
<ul>
<li>支持序列单点加减、区间和查询的树状数组</li>
<li>支持序列区间加减、单点查询的树状数组</li>
<li>支持序列区间加减、区间和查询的树状数组</li>
<li>支持矩阵单点加减、子矩阵和查询的树状数组</li>
<li>支持矩阵的子矩阵加减、单点查询的树状数组</li>
<li>支持矩阵的子矩阵加减、子矩阵和查询的树状数组</li>
</ul>
<p>这些会一个一个的讲。</p>
<h1 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h1><h2 id="单点加减、区间和查询"><a href="#单点加减、区间和查询" class="headerlink" title="单点加减、区间和查询"></a>单点加减、区间和查询</h2><p>这个是最基础的树状数组，应该没有人不会吧……</p>
<p>原理就是通过维护前缀和，修改的时候像暴力维护前缀和一样一个一个往后加，不过每次增长的值不是1而是lowbit，其中“一个数取lowbit能跳到哪”这个关系连边后就形成了一个二叉搜索树。</p>
<blockquote>
<p>按照Peter M. Fenwick的说法，正如所有的整数都可以表示成2的幂和，我们也可以把一串序列表示成一系列子序列的和。采用这个想法，我们可将一个前缀和划分成多个子序列的和，而划分的方法与数的2的幂和具有极其相似的方式。一方面，子序列的个数是其二进制表示中1的个数，另一方面，子序列代表的f[i]的个数也是2的幂。</p>
<p style="text-align: right">——Wikipedia</p>

</blockquote>
<p><img src="https://s2.ax1x.com/2019/10/17/KAb2Se.png" alt="KAb2Se.png"></p>
<p>比如说这一棵就是八个元素的树状数组，对照下面的表可以发现上面的连边规律（点下面的是编号，请自动忽略根节点 9 以及那条边）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&apos;s lowbit = 1, 1 + lowbit = 2</span><br><span class="line">2&apos;s lowbit = 2, 2 + lowbit = 4</span><br><span class="line">3&apos;s lowbit = 1, 3 + lowbit = 4</span><br><span class="line">4&apos;s lowbit = 4, 4 + lowbit = 8</span><br><span class="line">5&apos;s lowbit = 1, 5 + lowbit = 6</span><br><span class="line">6&apos;s lowbit = 2, 6 + lowbit = 8</span><br><span class="line">7&apos;s lowbit = 1, 7 + lowbit = 8</span><br><span class="line">8&apos;s lowbit = 8, 8 + lowbit = 16</span><br><span class="line">9&apos;s lowbit = 1, 9 + lowbit = 10</span><br><span class="line">10&apos;s lowbit = 2, 10 + lowbit = 12</span><br></pre></td></tr></table></figure>
<p>那么代码就很容易写出来了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, tree[MAX_SIZE];</span><br><span class="line"><span class="comment">// n 为元素个数，tree[] 为树状数组维护的前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (x) &amp; (-x); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 pos 位置的数加上 x</span></span><br><span class="line">    <span class="keyword">for</span> (; pos &lt;= n; pos += lowbit(pos)) tree[pos] += x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询 [1,pos] 之间的数的和</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; pos &gt;= <span class="number">1</span>; pos -= lowbit(pos)) ret += tree[pos];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rangeQuery</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询 [l,r] 之间的数的和</span></span><br><span class="line">    <span class="keyword">return</span> Query(r) - Query(l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间加减、单点查询"><a href="#区间加减、单点查询" class="headerlink" title="区间加减、单点查询"></a>区间加减、单点查询</h2><p>不知道你们有没有听说过一个东西叫做「差分」</p>
<p>定义差分数组 <code>d[i] = a[i] - a[i - 1]</code>，其中 <code>a[]</code> 表示原数列<br>那么对 <code>d[i]</code> 求一个前缀和就可以得出 <code>a[i]</code>的值了<br>举个例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组下标从 0 开始，元素存储从 1 开始，a[0] = d[0] = 0</span><br><span class="line">a[] = &#123;0, 1, 3, 4, 2&#125;</span><br><span class="line">d[] = &#123;/, 1, 2, 2, -2&#125;</span><br></pre></td></tr></table></figure></p>
<p>发现了什么？</p>
<script type="math/tex; mode=display">\sum_{i = 1}^{n} d_i = a_i</script><p>如何修改$\text{[L,R]}+x$？<br>先给结论：在$\text{L}$处$+x$，在$\text{R+1}$处$-x$<br>直观理解：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下标从 1 开始。</span><br><span class="line">原数列：0 0 0 0 0 0</span><br><span class="line">按照上面的方法 [2,4]+x</span><br><span class="line">0 x 0 0 -x 0</span><br><span class="line">看看前缀和之后会发生什么……</span><br><span class="line">0 x x x 0 0</span><br><span class="line">！！！！！</span><br></pre></td></tr></table></figure></p>
<hr>
<p>而维护前缀和这种事情，树状数组最在行了</p>
<p>可以写出代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, a[MAXN], bit[MAXN];  </span><br><span class="line"><span class="comment">// n 为元素个数，a 为原数组，bit 为差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (; pos &lt;= n; pos += lowbit(pos)) bit[pos] += x;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rangeModify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    Modify(l, x); Modify(r + <span class="number">1</span>, -x);</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (; pos &gt;= <span class="number">1</span>; pos -= lowbit(pos)) ret += bit[pos];  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> to n increase <span class="number">1</span>) &#123;  </span><br><span class="line">        read a[i]</span><br><span class="line">        rangeModify(i, i, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    read x, read y, read k </span><br><span class="line">    rangeModify(x, y, k);</span><br><span class="line">    <span class="comment">// 将 [x,y] 区间内的数加上 k  </span></span><br><span class="line">    ...</span><br><span class="line">    read k</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(k));  </span><br><span class="line">    <span class="comment">// 查询 k 位置的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间加减、区间和查询"><a href="#区间加减、区间和查询" class="headerlink" title="区间加减、区间和查询"></a>区间加减、区间和查询</h2><p><del>线段树天下第一</del><br>但是线段树难写、难调，常数还大，占空间还多。。。</p>
<p>如果你只需要区间加减、区间和查询，树状数组无疑是你最好的选择</p>
<hr>
<p>区间加减维护一下差分数组就行了</p>
<p>考虑区间和本质是</p>
<script type="math/tex; mode=display">\sum_{a = 1}^{p}\sum_{i = 1}^{a}d_i</script><p>计算一下每个 $d_i$ 被算的次数，顺便把式子变换一下</p>
<script type="math/tex; mode=display">\sum_{a = 1}^{p}d_a \times (p - a + 1)</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举个例子</span><br><span class="line">比如说 p = 5 时，可以发现 </span><br><span class="line">ans = </span><br><span class="line">d[1] + </span><br><span class="line">d[1] + d[2] +</span><br><span class="line">d[1] + d[2] + d[3] + </span><br><span class="line">d[1] + d[2] + d[3] + d[4] + </span><br><span class="line">d[1] + d[2] + d[3] + d[4] + d[5]</span><br><span class="line">找一找规律就可以搞出上面的式子了</span><br></pre></td></tr></table></figure>
<p>拆一下 $\sum$，可以变换成</p>
<script type="math/tex; mode=display">(p + 1)\sum_{a = 1}^{p}d_a - \sum_{a = 1}^{p}d_a \times a</script><p>这样的话，只需要分别维护两个差分数组，一个记 $d_a$，一个记 $d_a \times a$ 就行</p>
<p>修改$\text{[L,R] + }x$的时候，像上面<a href="#区间加减、单点查询">区间加减、单点查询</a>一样，把 $\text{[L]} + x,\text{[R+1]} - x$（对两个数组进行的修改可以合并到 <code>Modify()</code> 函数中，具体见代码）<br>查询的时候像上面<a href="#单点加减、区间和查询">单点加减、区间和查询</a>一样，是前缀和作差</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码没有经过提交，仅进行了一些小样例测试！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;  </span><br><span class="line">lli ss[MAXN];  </span><br><span class="line">lli biti[MAXN], bitpi[MAXN];</span><br><span class="line"><span class="comment">// ss 表示原数组，biti 表示维护 d[a] 的数组， bitpi 表示维护 d[a] * a 的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> pos, lli x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> dx = pos;  </span><br><span class="line">    <span class="keyword">for</span> (; pos &lt;= n; pos += lowbit(pos)) &#123;  </span><br><span class="line">        <span class="comment">// 为了方便，可以把 rangeModify() 里的乘法挪到 Modify() 里面</span></span><br><span class="line">        biti[pos] += x; bitpi[pos] += x * <span class="number">1l</span>l * dx;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rangeModify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, lli x)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 这是把括号里的乘法挪到 Modify() 里面的写法</span></span><br><span class="line">    Modify(l, x); Modify(r + <span class="number">1</span>, -x);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function">lli <span class="title">Query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;  </span><br><span class="line">    lli ret = <span class="number">0</span>, dx = pos;  </span><br><span class="line">    <span class="keyword">while</span> (pos &gt;= <span class="number">1</span>) &#123; ret += (dx + <span class="number">1</span>) * <span class="number">1l</span>l * biti[pos] - bitpi[pos]; pos -= lowbit(pos); &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function">lli <span class="title">rangeQuery</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123; <span class="keyword">return</span> Query(r) - Query(l - <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure>
<h1 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h1><p>一维的操作都讲完了，那能不能把它推广到二维上面呢？答案是肯定的。<br>提前说一句，以下操作从访问$n$个元素变成了$nm$个元素，时间复杂度变为$O(\log(nm))$</p>
<h2 id="单点加减、子矩阵和查询"><a href="#单点加减、子矩阵和查询" class="headerlink" title="单点加减、子矩阵和查询"></a>单点加减、子矩阵和查询</h2><p>前面说过，树状数组是利用前缀和的思想进行实现的，既然二维也有前缀和，何不照葫芦画瓢把而为树状数组搞出来呢？</p>
<hr>
<p>先来复习一下。</p>
<script type="math/tex; mode=display">\sum_{i = l}^{r} a_i = \sum_{i = 1}^{r} a_i - \sum_{i = 1}^{l - 1} a_i</script><p>为了方便，定义 <script type="math/tex">f(x,y)=\sum_{i = 1}^{x} \sum_{j = 1}^{y} a_{i,j}</script></p>
<script type="math/tex; mode=display">\sum_{i = x_1}^{x_2}\sum_{j = y_1}^{y_2}a_{i,j}=f(x_2,y_2)-f(x_1 - 1,y_2)-f(x_2,y_1-1)+f(x_1-1,y_1-1)</script><p>直观来看，</p>
<p><img src="https://s2.ax1x.com/2019/10/17/KE3Zkj.png" alt="KE3Zkj.png"></p>
<p>定义$\text{Sum}(a,b,c,d)$为以$(a,b)$为左下角，$(c,d)$为右上角（对于矩阵是反着的）的矩阵元素之和，那么很显然能看出 $\text{Sum}(5,4,7,5)=\text{Sum}(1,1,7,5)-\text{Sum}(1,1,7,3)-\text{Sum}(1,1,4,5)+\text{Sum}(1,1,4,3)$，也就是四边形$\text{ABCD}-\text{ABGI}-\text{AHFD}+\text{AHEI}$元素的值</p>
<p>二维树状数组和一位的除了多了一维之外没多大区别，手法从一维前缀和换到了二维前缀和</p>
<p>看代码就知道了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码没有经过提交，仅进行了一些小样例测试！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, bit[MAXN][MAXN];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 是不是和一维的手法差不多（逃</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (; x &lt;= n; x += lowbit(x)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fy = y; fy &lt;= m; fy += lowbit(fy)) &#123;  </span><br><span class="line">            <span class="comment">// 说一个坑：这里不要对 y 进行直接修改</span></span><br><span class="line">            <span class="comment">// 因为下一次循环 x 的时候需要用 y</span></span><br><span class="line">            <span class="comment">// 我当初在这里栽坑调了快 10min。。。</span></span><br><span class="line">            bit[x][fy] += w;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (; x &gt;= <span class="number">1</span>; x -= lowbit(x)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fy = y; fy &gt;= <span class="number">1</span>; fy -= lowbit((fy))) &#123;  </span><br><span class="line">            ans += bit[x][fy];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ans;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">matrixQuery</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// x1 &lt;= x2, y1 &lt;= y2  </span></span><br><span class="line">    <span class="keyword">int</span> a = Query(x2, y2);  </span><br><span class="line">    <span class="keyword">int</span> b = Query(x1 - <span class="number">1</span>, y2);  </span><br><span class="line">    <span class="keyword">int</span> c = Query(x2, y1 - <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">int</span> d = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>);    </span><br><span class="line">    <span class="keyword">return</span> a - b - c + d;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子矩阵加减、单点查询"><a href="#子矩阵加减、单点查询" class="headerlink" title="子矩阵加减、单点查询"></a>子矩阵加减、单点查询</h2><p>还记得<a href="#区间加减、单点查询">区间加减、单点查询</a>吗？<br>接下来把它推广到二维！</p>
<hr>
<p>查询手法一样的，二维前缀和</p>
<p>如何修改$(x_1,y_1)\text{ to }(x_2,y_2)$？<br>先说结论：<br>$d[x_1][y_1] + x,d[x_1][y_2+1]-x,d[x_2+1][y_1]-x,d[x_2+1][y_2+1]+x$<br>直观理解：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下标从 1 开始</span><br><span class="line">  1 2 3 4 5</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">2 0 0 0 0 0</span><br><span class="line">3 0 0 0 0 0</span><br><span class="line">4 0 0 0 0 0</span><br><span class="line">修改(1,2)-&gt;(4,3) + x</span><br><span class="line">  1  2  3  4  5</span><br><span class="line">1 0  0  0  0  0</span><br><span class="line">2 x  0  0  0 -x</span><br><span class="line">3 0  0  0  0  0</span><br><span class="line">4 -x 0  0  0  x</span><br><span class="line">前缀和：</span><br><span class="line">  1 2 3 4 5</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">2 x x x x 0</span><br><span class="line">3 x x x x 0</span><br><span class="line">4 0 0 0 0 0</span><br></pre></td></tr></table></figure></p>
<p>放代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码没有经过提交，仅进行了一些小样例测试！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, bit[MAXN][MAXN];  </span><br><span class="line"><span class="comment">// n,m 为矩阵大小，bit 为差分数组</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += lowbit(j)) &#123;  </span><br><span class="line">            bit[i][j] += w;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrixModify</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// x1 &lt;= x2  </span></span><br><span class="line">    Modify(x1, y1, w); Modify(x1, y2 + <span class="number">1</span>, -w);  </span><br><span class="line">    Modify(x2 + <span class="number">1</span>, y1, -w); Modify(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>, w);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i -= lowbit(i)) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &gt;= <span class="number">1</span>; j -= lowbit(j)) &#123;  </span><br><span class="line">            ret += bit[i][j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="子矩阵加减、子矩阵和查询"><a href="#子矩阵加减、子矩阵和查询" class="headerlink" title="子矩阵加减、子矩阵和查询"></a>子矩阵加减、子矩阵和查询</h2><p>最后一种操作，也是最难的操作</p>
<p>……其实并不难，如果你把前面都学懂了。</p>
<p>和<a href="#区间加减、区间和查询">区间加减、区间和查询</a>一样，先看看查询操作的本质</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{x} \sum_{j=1}^{y} \sum_{k=1}^{i} \sum_{h=1}^{j} d[h][k]</script><p>先统计一下 $d[i][j]$ 被访问了多少次，然后<big>稍微</big>整理一下式子，变成</p>
<script type="math/tex; mode=display">
{\sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times(x+1-i) \times(y+1-j)} \\= {(x+1)(y+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j]} \\ {-(y+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times i} \\ {-(x+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times j} \\ {\quad+\sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times i \times j}</script><!--![KEdzbq.png](https://s2.ax1x.com/2019/10/17/KEdzbq.png)-->
<p>所以，实现区修区查需要维护四个差分数组！</p>
<ul>
<li>第一个：维护$d[i][j]$</li>
<li>第二个：维护$d[i][j]\times i$</li>
<li>第三个：维护$d[i][j]\times j$</li>
<li>第四个：维护$d[i][j]\times i\times j$</li>
</ul>
<p>接下来是<strong>完整</strong>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/10/17.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 洛谷 P4514 《上帝造题的七分钟》</span></span><br><span class="line"><span class="comment">// 常数略大。。开O2过的  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) ((x &amp; (-x)))  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;  </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;  </span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2048</span> + <span class="number">10</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> n, m, q;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">namespace</span> BIT &#123;  </span><br><span class="line">    <span class="keyword">int</span> d[MAXN][MAXN], di[MAXN][MAXN];  </span><br><span class="line">    <span class="keyword">int</span> dj[MAXN][MAXN], dij[MAXN][MAXN];  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i)) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &lt;= m; j += lowbit(j)) &#123;  </span><br><span class="line">                d[i][j] += w; di[i][j] += w * x;  </span><br><span class="line">                dj[i][j] += w * y; dij[i][j] += w * x * y;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">matrixModify</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> w)</span> </span>&#123;  </span><br><span class="line">        Modify(x1, y1, w); Modify(x2 + <span class="number">1</span>, y2 + <span class="number">1</span>, w);  </span><br><span class="line">        Modify(x1, y2 + <span class="number">1</span>, -w); Modify(x2 + <span class="number">1</span>, y1, -w);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt;= <span class="number">1</span>; i -= lowbit(i)) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y; j &gt;= <span class="number">1</span>; j -= lowbit(j)) &#123;  </span><br><span class="line">                ret += d[i][j] * (x + <span class="number">1</span>) * (y + <span class="number">1</span>)  </span><br><span class="line">                       - (y + <span class="number">1</span>) * di[i][j]  </span><br><span class="line">                       - (x + <span class="number">1</span>) * dj[i][j]  </span><br><span class="line">                       + dij[i][j];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">matrixQuery</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a = Query(x2, y2);  </span><br><span class="line">        <span class="keyword">int</span> b = Query(x1 - <span class="number">1</span>, y1 - <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">int</span> c = Query(x1 - <span class="number">1</span>, y2);  </span><br><span class="line">        <span class="keyword">int</span> d = Query(x2, y1 - <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">return</span> a - c - d + b;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _s; <span class="built_in">cin</span> &gt;&gt; _s;  </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;  </span><br><span class="line"><span class="comment">//    rap (i, 1, n, 1) &#123;  </span></span><br><span class="line"><span class="comment">//        rap (j, 1, m, 1) &#123;  </span></span><br><span class="line"><span class="comment">//            int fx = 0;  </span></span><br><span class="line"><span class="comment">//            scanf("%d", &amp;fx);  </span></span><br><span class="line"><span class="comment">//            BIT::matrixModify(i, j, i, j, fx);  </span></span><br><span class="line"><span class="comment">//        &#125;  </span></span><br><span class="line"><span class="comment">//    &#125;  </span></span><br><span class="line">  <span class="keyword">char</span> ch = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch) &#123;  </span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, d = <span class="number">0</span>;  </span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;  </span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'L'</span>) &#123;  </span><br><span class="line">            <span class="keyword">int</span> delta = <span class="number">0</span>;  </span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; delta;  </span><br><span class="line">            BIT::matrixModify(a, b, c, d, delta);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line"><span class="comment">//            scanf("\n");  </span></span><br><span class="line"><span class="comment">//            printf("%d\n", BIT::matrixQuery(a, b, c, d));  </span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; BIT::matrixQuery(a, b, c, d) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"><span class="comment">//        getchar();  </span></span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU6108《小C的倍数问题》</title>
    <url>/2019-10-13/HDU6108/</url>
    <content><![CDATA[<blockquote>
<p>真·小学数学</p>
</blockquote>
<a id="more"></a>
<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>根据小学数学的知识，我们知道一个正整数x是3的倍数的条件是x每一位加起来的和是3的倍数。反之，如果一个数每一位加起来是3的倍数，则这个数肯定是3的倍数。  </p>
<p>现在给定进制P，求有多少个B满足P进制下，一个正整数是B的倍数的充分必要条件是每一位加起来的和是B的倍数。</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个正整数T表示数据组数(1&lt;=T&lt;=20)。  </p>
<p>接下来T行，每行一个正整数P(2 &lt; P &lt; 1e9)，表示一组询问。</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>对于每组数据输出一行，每一行一个数表示答案。</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>小 学 数 学</p>
<hr>
<p>考虑$p$进制表示的实质是<br>$x = a<em>1p^n+a_2p^{(n - 1)} + a_3p^{(n - 2)} + \dots + a</em>{n+1}$<br>稍微变形一下</p>
<script type="math/tex; mode=display">x=a_1(p^n-1)+a_2(p^{n-1}-1)+a_3(p^{n - 3} - 1) + \dots + \sum_{i = 1}^{n + 1}a_i</script><p>然后注意到$p^n - 1=(p - 1)(p^{n - 1} + p^{n - 2} + \dots + 1)$<br>把它代入进去</p>
<script type="math/tex; mode=display">
\begin{aligned}
x&=a_1(p - 1)(p^{n - 1} + p^{n - 2} + \dots + 1)
\\&+a_2(p - 1)(p^{n - 2} + p^{n - 3} + \dots + 1)
\\&+a_3(p - 1)(p^{n - 3} + p^{n - 4} + \dots + 1) + \dots 
\\&+ \sum_{i = 1}^{n + 1}a_i
\end{aligned}</script><p>发现前面几项都有一个 $p - 1$<br>那么，当且仅当$\sum_{i = 1}^{n + 1}a_i$，即 x 各位数字之和 $\equiv 0(\bmod (p - 1))$ 时，$x \equiv 0 (\bmod (p - 1))$</p>
<p>one more thing<br>对于任意的自然数$a,p$，如果 $a \mod p = 0$，那么有$a \mod x = 0(x \mid p)$</p>
<p>所以这题的思路已经很明显了，求的就是$p - 1$的因子个数</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by HandwerSTD on 2019/10/13.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> fx = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;fx); --fx;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, fs = <span class="built_in">sqrt</span>(fx); i &lt;= fs; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fx % i != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            ++ans; <span class="keyword">if</span> ((fx / i) != i) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>中国剩余定理（CRT）学习笔记</title>
    <url>/2019-10-03/ChinaRemainderTheroem/</url>
    <content><![CDATA[<blockquote>
<p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>孙子定理是中国古代求解一次同余式组（见同余）的方法。是数论中一个重要定理。又称中国余数定理。</p>
<p style="text-align: right">——百度百科</p>

<h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><p>孙子定理是用来求解这样的方程组的：</p>
<p><img src="https://s2.ax1x.com/2019/10/04/uBlVUJ.png" alt="uBlVUJ.png"></p>
<p>（我博客行间公式渲染好像有点问题……）</p>
<p>CRT 的使用条件是 $m_i$ 两两互质，$m_i$ 两两不互质需要使用 exCRT 即扩展中国剩余定理</p>
<hr>
<p>首先定义 $M = \prod_{i = 1}^n m_i$，并设 $M_i = \lfloor {M \over {m_i}} \rfloor$，$t_i = M_i^{-1} \bmod M$（即$t_i$满足$M_i t_i \equiv 1 (\bmod M)$）<br>那么该同余方程的一个解为</p>
<script type="math/tex; mode=display">
x_0=(\sum_{i=1}^{k} a_{i} M_i t_{i})\bmod M</script><p>通解为 $x = x_0 + i \times M$，最小非负整数解为 $(x_0 \bmod M + M) \bmod M$</p>
<p>如果有 $a &lt; 0$ 的情况时要注意负数取模问题</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CRT.cpp</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/10/3.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line">lli k, a[<span class="number">10000</span> + <span class="number">10</span>], m[<span class="number">10000</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ChinaRemainderTheorem &#123;</span><br><span class="line">    <span class="function">lli <span class="title">exgcd</span><span class="params">(lli a, lli b, lli &amp;x, lli &amp;y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123; x = <span class="number">1</span>; y = <span class="number">0</span>; <span class="keyword">return</span> a; &#125;</span><br><span class="line">        lli g = exgcd(b, a % b, y, x);</span><br><span class="line">        y -= a / b * x;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">lli <span class="title">CRT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lli X = <span class="number">0</span>, M = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (lli i = <span class="number">1</span>; i &lt;= k; ++i) M *= m[i];</span><br><span class="line">        <span class="keyword">for</span> (lli i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            lli ti = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">            lli mmi = M / m[i];</span><br><span class="line">            exgcd(mmi, m[i], ti, y);</span><br><span class="line">            X = ((X + a[i] * mmi * ti) % M + M) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> X &lt; <span class="number">0</span> ? (X + M) : X;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    k = getll();</span><br><span class="line">    <span class="comment">/// x === ai (mod mi)</span></span><br><span class="line">    rap (i, <span class="number">1</span>, k, <span class="number">1</span>) &#123; m[i] = getll(); a[i] = getll(); &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ChinaRemainderTheorem::CRT());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1168《中位数》</title>
    <url>/2019-10-02/Luogu-P1168/</url>
    <content><![CDATA[<blockquote>
<p>两个优先队列</p>
</blockquote>
<a id="more"></a>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应肯定是堆，毕竟自带排序，找中位数也方便</p>
<p>关键是 <code>std::priority_queue</code>  不能访问内部元素就很烦</p>
<p>但是，要访问的内部元素好像就一个中位数啊？</p>
<hr>
<p>考虑把中位数手动记下来，然后把中位数前边的数用一个大根堆存一下，把中位数后面的数用一个小根堆存一下，这样依然能保证元素是始终有序的</p>
<p>依次读入每一个数，如果这个数比「当前记着的中位数」小就放进大根堆里，否则放进小根堆里</p>
<p>查询的时候需要对中位数进行更新：<br>如果左右两个堆的大小相等，说明中位数还是那个中位数；<br>否则分两种情况讨论：</p>
<ol>
<li>大根堆更大<br>说明中位数一定在大根堆里，那么就把中位数塞进小根堆里，再把大根堆堆顶取出来当新的中位数，重复做直到两个堆大小相等</li>
<li>小根堆更大<br>说明中位数一定在小根堆里，那么就把中位数塞进大根堆里，再把小根堆堆顶取出来当新的中位数，重复做直到两个堆大小相等</li>
</ol>
<p>最后输出更新完的中位数即可</p>
<p>本方法对应代码中的 <code>Method1</code></p>
<hr>
<p>或者可以直接使用 <code>std::vector</code> 和 <code>std::upper_bound</code> 来模拟一个堆，输出的时候直接访问 <code>vec[(i / 2 + 1) - 1]</code> 即可</p>
<p><code>std::upper_bound(Begin Iterator, End Iterator, Value)</code> 是一个使用二分查找，在有序序列 <code>[Begin Iterator, End Iterator)</code> 中查找第一个大于 <code>Value</code> 的位置的函数；<code>std::vector&lt;int&gt;::insert(Position Iterator, Value)</code> 可以在 <code>Position Iterator</code> 前面插入元素 <code>Value</code>，利用这两个函数可以实现插入元素而不破坏序列的有序性。</p>
<p>本方法对应代码中的 <code>Method2</code></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP1168.cpp</span></span><br><span class="line"><span class="comment">//  Title: 中位数</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/10/2.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Method1 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此题正解</span></span><br><span class="line"><span class="comment">     * 用一个大根堆维护中位数之前的数，一个小根堆维护中位数之后的数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; before;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt; &gt; after;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> _main() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = getint();</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123; mid = now; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; mid) before.push(now);</span><br><span class="line">                <span class="keyword">else</span> after.push(now);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> befsiz = before.size();</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> aftsiz = after.size();</span><br><span class="line">                <span class="keyword">while</span> (befsiz != aftsiz) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (befsiz &lt; aftsiz) &#123;</span><br><span class="line">                        before.push(mid);</span><br><span class="line">                        mid = after.top(); after.pop();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        after.push(mid);</span><br><span class="line">                        mid = before.top(); before.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    befsiz = before.size(); aftsiz = after.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Method2 &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 沙雕做法</span></span><br><span class="line"><span class="comment">     * 使用 std::vector 和 std::lower_bound 手写堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> _main() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = getint();</span><br><span class="line">            vec.insert(<span class="built_in">std</span>::upper_bound(vec.begin(), vec.end(), now), now);</span><br><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, vec.at(i / <span class="number">2</span> + <span class="number">1</span> - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> + <span class="number">1</span> == <span class="number">3</span>) Method2::_main();</span><br><span class="line">    <span class="keyword">else</span> Method1::_main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>队列</tag>
        <tag>堆</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2158《[SDOI2008]仪仗队》</title>
    <url>/2019-08-18/Luogu-P2158-BZOJ2190/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。</p>
<a id="more"></a>  
<p><img src="https://www.lydsy.com/JudgeOnline/images/2190.jpg" alt></p>
<p>现在，C君希望你告诉他队伍整齐时能看到的学生人数。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>共一个数 N</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>共一个数，即C君应看到的学生人数。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>【数据规模和约定】</p>
<p>对于 100% 的数据，1 ≤ N ≤ 40000</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>来快乐推一推式子</p>
<p>首先考虑一下没有被看到的点长什么样<br>显然没有被看到的点$(x,y)$与原点的连线上一定有一点，记为 $(\frac x t , \frac y t )$</p>
<p>由于所有坐标都是整数，那么有</p>
<script type="math/tex; mode=display">
t \mid x, t \mid y  \Leftrightarrow  t \mid \gcd(x, y)</script><p>所以可以知道这个事情：<br>一个点$(x, y)$不可以被看到，等价于$\gcd(x, y) \neq 1$。<br>所以题目要求的就是所有的数对$(x,y)$的个数，满足 $\gcd(x, y) = 1$</p>
<hr>
<p>分开考虑答案</p>
<p>首先是坐标形如 $(0, y), (x, 0)$ 的这些点，也就是在 $x$ 轴和 $y$ 轴上的点，均只能看见一个 $(0, 1),(1, 0)$，统计答案的时候就直接 $+ 2$ 就行了。</p>
<p>然后是在直线 $y = x$ 上的点，也只能被看见一个 $(1, 1)$，统计答案的时候再来个 $+ 1$。</p>
<p>剩下的点可以用两个 $\sum$ 统计。<br>最后式子长这样（注意$\text{ans}$函数的参数值）：</p>
<script type="math/tex; mode=display">
\begin{align}
\text{ans}(n + 1) = 3 + \sum_{x = 1}^{n} \sum_{y = 1}^{x - 1}[\gcd(x, y) = 1] + \sum_{x = 1}^{n} \sum_{y = x + 1}^{n}[\gcd(x, y) = 1] 
\end{align}</script><p>看一眼这张图：</p>
<p><img src="https://i.loli.net/2019/08/18/rDIhj6WHcpUnbNa.png" alt></p>
<p>可以发现，第一种情况对应的是点 $U, V$，第二种情况对应的是 $W$，两个 $\sum$ 分别对应点 $A \rightarrow J$ 和 $K \rightarrow T$ 的能看见的点的数量。</p>
<p>还是不懂？ 手动模拟一下吧，看看它会统计哪些点<br>两个 $\sum$ 相当于语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ans = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> y = <span class="number">1</span> to x - <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">		ans = ans + (gcd(x,y) == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> x = <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">	<span class="keyword">for</span> y = x + <span class="number">1</span> to n <span class="keyword">do</span></span><br><span class="line">		ans = ans + (gcd(x,y) == <span class="number">1</span>)</span><br><span class="line">ans = ans + <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>显然可以看到的点是关于直线 $y = x$ 对称的，所以上面的式子又可以写成</p>
<script type="math/tex; mode=display">
\text{ans}(n + 1) = 3 + 2\sum_{x = 1}^{n} \sum_{y = 1}^{x - 1}[\gcd(x, y) = 1]</script><hr>
<p>这个式子肯定跑不过去的。把这个式子化简一下</p>
<p>注意到一个很常见的积性函数</p>
<script type="math/tex; mode=display">
\varphi(x) = \sum_{i = 1}^{x}[\gcd(i, x) = 1]</script><p>代入原式！</p>
<p>$\text{ans}(n + 1) = 3 + 2\sum<em>{x = 1}^{n} \sum</em>{y = 1}^{x - 1}[\gcd(x, y) = 1]$<br>$= 3 + 2\sum<em>{x = 1}^{n} (\sum</em>{y = 1}^{x}[\gcd(x, y) = 1] - [\gcd(x, x) = 1])$<br>$= 3 + 2\sum_{x = 1}^{n} (\varphi(x) - [\gcd(x, x) = 1])$</p>
<p>好了，现在就有了一个可以 $O(n)$ 计算的式子了！</p>
<p>（式子要分行写是因为我博客的 Math 引擎好像炸了。。。渲染不了多行，将就看吧/kk）</p>
<hr>
<p>最后说个事，$n = 1$ 的时候答案为 $0$，这个很显然吧，都没有学生了（</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2158.cpp</span></span><br><span class="line"><span class="comment">//  Title: [SDOI2008]仪仗队</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ2190</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/18.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">40000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> notprime[MAXN];</span><br><span class="line"><span class="keyword">int</span> prime[MAXN], phi[MAXN], cnt;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">lli ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    notprime[<span class="number">0</span>] = notprime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!notprime[i]) &#123;</span><br><span class="line">            prime[++cnt] = i; phi[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; (i * prime[j]) &lt; MAXN; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = i * prime[j];</span><br><span class="line">            notprime[x] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) &#123; phi[x] = phi[i] * prime[j]; <span class="keyword">break</span>; &#125;</span><br><span class="line">            phi[x] = phi[i] * (prime[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> fn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= fn; ++x) &#123;</span><br><span class="line">        ans += phi[x];</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) ans -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Sieve();</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> (<span class="number">0</span> &amp; <span class="built_in">printf</span>(<span class="string">"0\n"</span>));</span><br><span class="line">    Solve(n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans * <span class="number">2</span> + <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>各省省选</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2196《Computer》</title>
    <url>/2019-08-15/HDU2196/</url>
    <content><![CDATA[<blockquote>
<p>利用树的直径的性质</p>
</blockquote>
<a id="more"></a>
<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>A school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information.  </p>
<p><img src="http://acm.hdu.edu.cn/data/images/C128-1005-1.JPG" alt></p>
<p>Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N).</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">2 1</span><br><span class="line">3 1</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先有一个性质：在一棵树上，距离任意点最远的点一定是这棵树直径的一个端点</p>
<p>然后这题不就好做了吗</p>
<p>先以 1 为根求一遍直径，再分别以两个端点为根求一遍这个点到其他点的距离，取个最大值，输出即可，这个可以写一个DFS调用三遍</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU2196.cpp</span></span><br><span class="line"><span class="comment">//  Title: Computer</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/15.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, farthest;</span><br><span class="line">lli maxdis;</span><br><span class="line">lli f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    head[u].push_back(Edge(v, w));</span><br><span class="line">    head[v].push_back(Edge(u, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, lli dis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dis &gt; maxdis) &#123; maxdis = dis; farthest = u; &#125;</span><br><span class="line">    f[u] = <span class="built_in">std</span>::max(f[u], dis);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = head[u][i].v, w = head[u][i].w;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(v, u, dis + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _main() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = getint(); <span class="keyword">int</span> w = getint();</span><br><span class="line">        addEdge(i + <span class="number">1</span>, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">    DFS(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    p1 = farthest;</span><br><span class="line">    DFS(p1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 以上这两遍DFS是在求树的直径</span></span><br><span class="line">    <span class="comment">// 第二遍DFS顺便更新了一下从某一个端点出发的答案</span></span><br><span class="line">    p2 = farthest;</span><br><span class="line">    DFS(p2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 由于在每个点的最长路径可能到达两个端点</span></span><br><span class="line">    <span class="comment">// 所以要对两个端点分别更新一遍答案</span></span><br><span class="line">    <span class="comment">// 这一遍DFS是在更新从另一个端点出发的答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[i]);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) head[i].clear();</span><br><span class="line">    n = maxdis = farthest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF) _main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3714《Kuglarz》</title>
    <url>/2019-08-15/BZOJ3714/</url>
    <content><![CDATA[<blockquote>
<p>这是最小生成树？</p>
</blockquote>
<a id="more"></a>
<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>魔术师的桌子上有n个杯子排成一行，编号为1,2,…,n，其中某些杯子底下藏有一个小球，如果你准确地猜出是哪些杯子，你就可以获得奖品。花费c_ij元，魔术师就会告诉你杯子i,i+1,…,j底下藏有球的总数的奇偶性。<br>采取最优的询问策略，你至少需要花费多少元，才能保证猜出哪些杯子底下藏着球？</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行一个整数n(1&lt;=n&lt;=2000)。<br>第i+1行(1&lt;=i&lt;=n)有n+1-i个整数，表示每一种询问所需的花费。其中c_ij（对区间[i,j]进行询问的费用，1&lt;=i&lt;=j&lt;=n,1&lt;=c_ij&lt;=10^9）为第i+1行第j+1-i个数。</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一个整数，表示最少花费。</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5  </span><br><span class="line">1 2 3 4 5  </span><br><span class="line">4 3 2 1  </span><br><span class="line">3 4 5  </span><br><span class="line">2 1  </span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><del>从代码里复制过来的</del></p>
<p>知道两段杯子的奇偶性，相当于知道左边杯子左边的缝到右边杯子右边的缝到奇偶性</p>
<p>然后显然这个东西具有传递性，即知道缝a到缝b、缝b到缝c的奇偶性 $\Leftrightarrow$ 缝a到缝c的奇偶性</p>
<p>知道所有数列要保证缝两两之间的奇偶性都要知道</p>
<p>那么就可以把缝抽象成点，缝两两之间的奇偶性信息抽象成边，边权为询问的代价</p>
<p>一遍最小生成树完事</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  BZOJ3714.cpp</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/15.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 知道两段杯子的奇偶性，相当于知道左边杯子左边的缝到右边杯子右边的缝到奇偶性</span></span><br><span class="line"><span class="comment"> * 然后显然这个东西具有传递性，即知道缝a到缝b、缝b到缝c的奇偶性 &lt;=&gt; 缝a到缝c的奇偶性</span></span><br><span class="line"><span class="comment"> * 知道所有数列要保证缝两两之间的奇偶性都要知道</span></span><br><span class="line"><span class="comment"> * 那么就可以把缝抽象成点，缝两两之间的奇偶性信息抽象成边，边权为询问的代价</span></span><br><span class="line"><span class="comment"> * 一遍最小生成树完事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u[MAXN];</span><br><span class="line">    </span><br><span class="line">    UnionFind() &#123; <span class="built_in">memset</span>(u, <span class="number">0</span>, <span class="keyword">sizeof</span> u); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; ++i) u[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> u[x] == x ? x : (u[x] = Find(u[x])); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = Find(x); y = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        u[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; U;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> u = <span class="number">0</span>, <span class="keyword">int</span> v = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : u(u), v(v), w(w) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; that.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt;</span><br><span class="line">lli ans;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; edge;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//    std::sort(edge + 1, edge + 1 + cnt);</span></span><br><span class="line">    <span class="built_in">std</span>::sort(edge.begin(), edge.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (U.Union(edge[i].u, edge[i].v)) &#123;</span><br><span class="line">            <span class="comment">//            printf("choosed edge[%d] = &#123; %d %d %d &#125;\n", i, edge[i].u, edge[i].v, edge[i].w);</span></span><br><span class="line">            ++tot; ans += <span class="number">1l</span>l * edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    U.Init(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = getint();</span><br><span class="line">            edge.push_back(Edge(i, j, x));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = (<span class="keyword">int</span>) edge.size();</span><br><span class="line">    Kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>关于新开的 cnblogs 博客的一些说明</title>
    <url>/2019-08-14/Articles-Moving-To-cnblogs/</url>
    <content><![CDATA[<p>因为一些原因，文章没有被各大搜索引擎收录多少，PV和UV都很低（截止2019.08.12 7:20，没有破 5K），于是就想找一个博客网站放一些自己的文章，希望更多人能看到自己的文章，同时可以给自己博客引引流，最后选中了 cnblogs</p>
<p>文章会陆续按照创建时间排序搬上来，以后两个博客（有时候可能会在洛谷博客也更新）同步更新</p>
<p>一些很沙雕的文章可能不会放上去（</p>
<p>不过这么做可能会引来转载，比如说某aichengxu、某voidcn啊之类的，链个博客链接应该就没事了（</p>
]]></content>
      <tags>
        <tag>博客相关</tag>
      </tags>
  </entry>
  <entry>
    <title>ZROI 918《「良心普及组」黄队的宫殿》</title>
    <url>/2019-08-13/ZROI918/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）" />
    <label for="pass">密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号）</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>只有经历过的人才知道的世界</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU1483《Automatic Correction of Misspellings》</title>
    <url>/2019-08-08/HDU1483/</url>
    <content><![CDATA[<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>Some text editors offer a feature to correct words which seem to be written incorrectly. In this problem you are asked to implement a simple Automatic Correction of Misspellings (ACM).  </p>
<a id="more"></a>
<p>ACM takes care of the following misspellings of words:  </p>
<p>1.One letter is missing (e.g., letter is written leter) or too much (e.g., letter is written lettter).<br>2.One letter is wrong (e.g., letter is written ketter)<br>3.The order of two adjacent letters is wrong (e.g., letter is written lettre)  </p>
<p>ACM is based on a dictionary of known words. When a text contains a word which is not in the dictionary, ACM will try to replace it by a similar word of the dictionary. Two words are similar if we can transform one word into the other by doing exactly one of the misspellings listed above. An unknown word is left unchanged if there is no similar word in the dictionary.  </p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>The first line of the input file will give the number n of words in the dictionary (n ≤ 10000). The next n lines contain the dictionary words. The following line contains an integer q ≤ 1000, the number of query words. The next q lines contain the query words. You may assume that each word in the input consists of 1 to 25 lower case letters (‘a’ to ‘z’).  </p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each query word, print one line with the query word followed by one of the following possibilities:  </p>
<ol>
<li>is correct, if the word occurs in the dictionary.  </li>
<li>is a misspelling of <x>, where <x> is a word of the dictionary similar to the query word, and the query word is not in the dictionary. In the case that there are several possibilities, select the word from the dictionary which appeared earlier in the input.  </x></x></li>
<li>is unknown, if cases 1 and 2 do not apply.  </li>
</ol>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">this</span><br><span class="line">is</span><br><span class="line">a</span><br><span class="line">dictionary</span><br><span class="line">that</span><br><span class="line">we</span><br><span class="line">will</span><br><span class="line">use</span><br><span class="line">for</span><br><span class="line">us</span><br><span class="line">6</span><br><span class="line">su</span><br><span class="line">as</span><br><span class="line">the</span><br><span class="line">dictonary</span><br><span class="line">us</span><br><span class="line">willl</span><br></pre></td></tr></table></figure>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su is a misspelling of us</span><br><span class="line">as is a misspelling of is</span><br><span class="line">the is unknown</span><br><span class="line">dictonary is a misspelling of dictionary</span><br><span class="line">us is correct</span><br><span class="line">willl is a misspelling of will</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><del>还是从代码里复制过来的（</del></p>
<p>场上写一个 Trie 写到自闭。。。<br>赛后来补一下</p>
<p>道理我都懂，但是这题为什么暴力能过。。。</p>
<p>以下，将字典中的串称作「字典串」，将询问的串称作「匹配串」</p>
<p>首先扫一遍字典，有相同的直接输出 correct</p>
<p>然后如果没有相同的，再扫一遍字典，对于每一个字典串，做这样几件事：</p>
<ol>
<li>如果字典串和匹配串长度相等，就说明这个匹配串可能是当前字典串的一个错误拼写<br>逐位扫一遍两个串，记一下错误的次数，以及最后一次错误的下标<br>如果错误次数是 1 就直接输出 misspelling，此时匹配串相对于字典串只错了一个字符<br>如果错误次数是 2 就判断一下是否是顺序弄反了，这个用最后一次错误下标很好写，如果是就输出 misspelling<br>否则就凉凉</li>
<li>如果字典串比匹配串长 1，就说明这个匹配串可能是当前字典串漏了一个字<br>逐位扫一遍字典串，用一个变量 k 记录当前字典串这一位对应的是匹配串的哪一位<br>如果当前的两个串对应字符相等，就让 k 正常加一，否则就不让 k 加一<br>显然如果真的是只漏了一个字，那么最后 k 一定等于匹配串长度，输出 misspelling<br>否则 k 一定不等于匹配串长度（具体会变成什么值我也不大清楚，反正模拟一下就好了）</li>
<li>如果字典串比匹配串短 1，就说明这个匹配串可能是当前字典串添了一个字<br>仿照着情况 2 做就完事了</li>
</ol>
<p>最后如果三种情况都没有，输出 unknown</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU1483.cpp</span></span><br><span class="line"><span class="comment">//  Title: Automatic Correction of Misspellings</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/8.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dict[MAXN];</span><br><span class="line"><span class="keyword">int</span> dictlen[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoCorrectionMachine</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMisspelling</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> wrong = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] != m[i]) &#123; ++wrong; pos = i; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (wrong == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (wrong == <span class="number">2</span> &amp;&amp; (d[pos] == m[pos - <span class="number">1</span>] &amp;&amp; d[pos - <span class="number">1</span>] == m[pos])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCharacterDeletion</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> lend, <span class="keyword">int</span> lenm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lend; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] != m[k++]) --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == lenm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCharacterAddition</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> d, <span class="built_in">std</span>::<span class="built_in">string</span> m, <span class="keyword">int</span> lend, <span class="keyword">int</span> lenm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenm; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m[i] != d[k++]) --k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == lend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; acm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; dict[i];</span><br><span class="line">        dictlen[i] = (<span class="keyword">int</span>) dict[i].length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> env;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; env;</span><br><span class="line">        <span class="keyword">int</span> lenenv = (<span class="keyword">int</span>) env.length();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; env;</span><br><span class="line">        <span class="keyword">bool</span> cor = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (dict[i] == env) &#123; cor = <span class="literal">true</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cor) <span class="built_in">cout</span> &lt;&lt; <span class="string">" is correct\n"</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dictlen[i] == lenenv) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isMisspelling(dict[i], env, lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dictlen[i] == lenenv + <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isCharacterDeletion(dict[i], env, dictlen[i], lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dictlen[i] == lenenv - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (acm.isCharacterAddition(dict[i], env, dictlen[i], lenenv)) &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">" is a misspelling of "</span> &lt;&lt; dict[i] &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == n + <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">" is unknown\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU3183《A Magic Lamp》</title>
    <url>/2019-08-08/HDU3183/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>Kiki likes traveling. One day she finds a magic lamp, unfortunately the genie in the lamp is not so kind. Kiki must answer a question, and then the genie will realize one of her dreams.  </p>
<a id="more"></a> 
<p>The question is: give you an integer, you are allowed to delete exactly m digits. The left digits will form a new integer. You should make it minimum.<br>You are not allowed to change the order of the digits. Now can you help Kiki to realize her dream?  </p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>There are several test cases.<br>Each test case will contain an integer you are given (which may at most contains 1000 digits.) and the integer m (if the integer contains n digits, m will not bigger then n). The given integer will not contain leading zero.  </p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, output the minimum result you can get in one line.<br>If the result contains leading zero, ignore it.  </p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">178543 4 </span><br><span class="line">1000001 1</span><br><span class="line">100001 2</span><br><span class="line">12345 2</span><br><span class="line">54321 2</span><br></pre></td></tr></table></figure>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">123</span><br><span class="line">321</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然删除从左向右遇到的第一个比下一个数大的数，也就是让最高位最小的过程。那么按这样的策略做 m 次即可获得正确答案，删除后的序列可使用双向链表（STL 里有<code>std::list&lt;int&gt;</code>）来维护。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  HDU3183.cpp</span></span><br><span class="line"><span class="comment">//  Title: A Magic Lamp</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/8/8.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> charat(x) ((x - 1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除从左向右遇到的第一个比下一个数大的数</span></span><br><span class="line"><span class="comment"> * 用一个双向链表维护</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = (<span class="keyword">int</span>) s.length();</span><br><span class="line">        lst.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            lst.insert(lst.end(), s[charat(i)] - <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.begin(); i != lst.end(); i++) &#123;</span><br><span class="line">                i++; <span class="keyword">if</span> (i == lst.end()) &#123; --i; lst.erase(i); <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">int</span> next = (*i);</span><br><span class="line">                --i;</span><br><span class="line">                <span class="keyword">if</span> (*i &gt; next) &#123; lst.erase(i); <span class="keyword">break</span>; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> fz = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : lst) &#123; <span class="keyword">if</span> (fz &amp;&amp; i == <span class="number">0</span>) <span class="keyword">continue</span>; fz = <span class="literal">false</span>; <span class="built_in">printf</span>(<span class="string">"%d"</span>, i); &#125;</span><br><span class="line">        <span class="keyword">if</span> (fz) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 402B《Trees in a Row》</title>
    <url>/2019-08-07/CF402B/</url>
    <content><![CDATA[<h1 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h1><p>有n个正整数，可以对一个数进行修改(修改后也是正整数)，要求修改之后满足$a_i+k=a{i+1}$，求最少的修改次数以及具体的修改方案</p>
<a id="more"></a>
<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>The Queen of England has n trees growing in a row in her garden. At that, the i-th (1 ≤ i ≤ n) tree from the left has height ai meters. Today the Queen decided to update the scenery of her garden. She wants the trees’ heights to meet the condition: for all i (1 ≤ i &lt; n), ai + 1 - ai = k, where k is the number the Queen chose.</p>
<p>Unfortunately, the royal gardener is not a machine and he cannot fulfill the desire of the Queen instantly! In one minute, the gardener can either decrease the height of a tree to any positive integer height or increase the height of a tree to any positive integer height. How should the royal gardener act to fulfill a whim of Her Majesty in the minimum number of minutes?</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>The first line contains two space-separated integers: n, k (1 ≤ n, k ≤ 1000). The second line contains n space-separated integers a1, a2, …, an (1 ≤ ai ≤ 1000) — the heights of the trees in the row.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>In the first line print a single integer p — the minimum number of minutes the gardener needs. In the next p lines print the description of his actions.</p>
<p>If the gardener needs to increase the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, then print in the corresponding line “+ j x”. If the gardener needs to decrease the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, print on the corresponding line “- j x”.</p>
<p>If there are multiple ways to make a row of trees beautiful in the minimum number of actions, you are allowed to print any of them.</p>
<h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>input<br>4 1<br>1 2 1 5</p>
<p>output<br>2</p>
<ul>
<li>3 2</li>
</ul>
<ul>
<li>4 1</li>
</ul>
<p>input<br>4 1<br>1 2 3 4</p>
<p>output<br>0</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本文同步发布于<a href="[https://www.luogu.org/blog/handwer-blog/](https://www.luogu.org/blog/handwer-blog/">洛谷博客</a>)</p>
<hr>
<p><del>先说点题外话</del></p>
<p>这道题是我今天（发题解的那一天，2019.08.07）打 ACM 的时候做的，当时看到这题口胡了一下做法，没敢写，交给队友去写了，然后一遍AC</p>
<p>感谢队友把我带飞</p>
<hr>
<p>言归正传。</p>
<p>考虑枚举第一棵树的高度，因为这样就能直接确定后面的树的高度了 </p>
<p>然后假设当前枚举第一棵树高度为 $l$，那么第 $i$ 棵树的高度 $h_i$ 就应该是 $l + k(i - 1)$，这个应该很好理解吧，如果不懂可以评论区留个言，我找个时间写一下</p>
<p>那么再套一层循环，枚举所有的树，如果当前枚举到的第 $i$ 棵树的高度不是 $l + k(i - 1)$，就意味着这棵树需要被修改，需要增高 / 降低的高度是 $\text{abs}(l - k(i - 1))$，需要增高还是降低取决于 $l - k(i - 1)$ 的符号</p>
<p>统计一下修改了多少次，作为一个方案，最后取一个最优方案的输出就行了</p>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXNKH = <span class="number">1000</span> + <span class="number">10</span>; <span class="comment">// the max of n, k, height</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> LOC = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MODIFY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, ans = <span class="number">0x7f7f7f7f</span>, ansf[MAXNKH][<span class="number">2</span>], p, f[MAXNKH][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> height[MAXNKH];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); k = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) height[i] = getint();</span><br><span class="line">    rap (h1, <span class="number">1</span>, <span class="number">1000</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 枚举第一棵树的高度，可以直接确定后面树的高度</span></span><br><span class="line">        p = <span class="number">0</span>; <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] - (i - <span class="number">1</span>) * k != h1) &#123;</span><br><span class="line">            	<span class="comment">// 记一下要修改的树的下标和要增加 / 减少的值</span></span><br><span class="line">                f[++p][LOC] = i;</span><br><span class="line">                f[p][MODIFY] = (h1 + (i - <span class="number">1</span>) * k) - height[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p &lt; ans) &#123;</span><br><span class="line">            <span class="comment">// 更优的方案，更新一下</span></span><br><span class="line">            ans = p;</span><br><span class="line">            <span class="built_in">memcpy</span>(ansf, f, <span class="keyword">sizeof</span> f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    rap (i, <span class="number">1</span>, ans, <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%c %d %d\n"</span>, (ansf[i][MODIFY] &lt; <span class="number">0</span> ? <span class="string">'-'</span> : <span class="string">'+'</span>), ansf[i][LOC], <span class="built_in">std</span>::<span class="built_in">abs</span>(ansf[i][MODIFY]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Code by Handwer</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3177《[HAOI2015]树上染色》</title>
    <url>/2019-07-31/Luogu-P3177-BZOJ4033/</url>
    <content><![CDATA[<blockquote>
<p>我推式子推了半个小时。。。</p>
</blockquote>
<a id="more"></a>
<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>有一棵点数为N的树，树边有边权。给你一个在0~N之内的正整数K，你要在这棵树中选择K个点，将其染成黑色，并</p>
<p>将其他的N-K个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间距离的和的收益。</p>
<p>问收益最大值是多少。</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>第一行两个整数N,K。</p>
<p>接下来N-1行每行三个正整数fr,to,dis，表示该树中存在一条长度为dis的边(fr,to)。</p>
<p>输入保证所有点之间是联通的。</p>
<p>N&lt;=2000,0&lt;=K&lt;=N</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>输出一个正整数，表示收益的最大值。</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 2  </span><br><span class="line">1 2 3  </span><br><span class="line">1 5 1  </span><br><span class="line">2 3 1  </span><br><span class="line">2 4 2</span><br></pre></td></tr></table></figure>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17</span><br></pre></td></tr></table></figure>
<p>【样例解释】<br>将点1,2染黑就能获得最大收益。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应设 $\text{dp[i][j]}$ 表示以 i 为根的子树选 j 个黑点的最大收益<br>但是是错的</p>
<p>康了一眼<a href="https://www.luogu.org/blog/ahaha254/solution-p3177" target="_blank" rel="noopener">这个</a>我就瞬间明白了<br>关于式子的推导，组成部分的意义，还有循环顺序的选择，这篇文章都讲得很清楚</p>
<p>老规矩，题解都在代码里</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  BZOJ4033.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2015]树上染色</span></span><br><span class="line"><span class="comment">//  Alternatives: Luogu-P3177</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参考资料：https://www.luogu.org/blog/ahaha254/solution-p3177</span></span><br><span class="line"><span class="comment"> * 关于 val(x,y) 和枚举顺序的解释可以康一康这篇文章</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设 f[i][j] 表示以 i 为根的子树中取了 j 个黑点「对答案的贡献」</span></span><br><span class="line"><span class="comment"> * 转移方程：</span></span><br><span class="line"><span class="comment"> * f[u][j] = max(</span></span><br><span class="line"><span class="comment"> *     f[u][j],</span></span><br><span class="line"><span class="comment"> *     f[u][j - k] + f[v][k] + val(u,v)</span></span><br><span class="line"><span class="comment"> * )</span></span><br><span class="line"><span class="comment"> * 其中 v 是 u 的儿子，k 是枚举出来的</span></span><br><span class="line"><span class="comment"> * j = min(m,size(x)) -&gt; 0, k = 0 -&gt; min(j,size(y))</span></span><br><span class="line"><span class="comment"> * 其中 val(x,y) 表示边 (x,y) 对答案的贡献，它等于</span></span><br><span class="line"><span class="comment"> * 「该边两边黑点数量的乘积 乘以 边长 加上 该边两边白点数量的乘积 乘以 边长」</span></span><br><span class="line"><span class="comment"> * 也就是 val(x,y) = k * (m - k) * weight(x,y) + (size(y) - k) * ((n - m) - (size(y) - k)) * weight(x,y)</span></span><br><span class="line"><span class="comment"> * 其中 m 是总的黑点数，k 是边 (x,y) 另一边的黑点数，那么 (m - k) 就是这一边的黑点数</span></span><br><span class="line"><span class="comment"> * size(y) 是以 y 为根的子树的大小，也就意味着 (size(y) - k) 是另一边的白点数（另一边的肯定不是黑点就是白点）</span></span><br><span class="line"><span class="comment"> * (n - m) 是总的白点数，(size(y) - k) 是另一边的白点数，也就意味着 ((n - m) - (size(y) - k)) 是边 (x,y) 这一边的白点数（白点肯定不在那边就在这边）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    lli w;</span><br><span class="line">    </span><br><span class="line">    Edge(<span class="keyword">int</span> v = <span class="number">0</span>, lli w = <span class="number">0</span>) : v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, size[MAXN];</span><br><span class="line">lli dp[MAXN][MAXK];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN][MAXK];</span><br><span class="line"><span class="comment">// dp 数组大概 31 MB</span></span><br><span class="line"><span class="comment">// size 数组大概 8 KB</span></span><br><span class="line"><span class="comment">// vis 数组大概 4 MB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    size[root] = <span class="number">1</span>;</span><br><span class="line">    vis[root][<span class="number">0</span>] = vis[root][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i].v;</span><br><span class="line">        <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(next, root);</span><br><span class="line">        size[root] += size[next];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i].v;</span><br><span class="line">        <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">        lli weight = head[root][i].w;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">std</span>::min(m, size[root]); j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">int</span> up = <span class="built_in">std</span>::min(j, size[next]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= up; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!vis[root][j - k]) <span class="keyword">continue</span>;</span><br><span class="line">                lli val = k * (m - k) * weight + (size[next] - k) * ((n - m) - (size[next] - k)) * weight;</span><br><span class="line">                dp[root][j] = <span class="built_in">std</span>::max(dp[root][j], dp[root][j - k] + dp[next][k] + val);</span><br><span class="line">                vis[root][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); m = getint();</span><br><span class="line">    rap (i, <span class="number">1</span>, n - <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint(), next = getint(), weight = getint();</span><br><span class="line">        head[prev].push_back(Edge(next, weight));</span><br><span class="line">        head[next].push_back(Edge(prev, weight));</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>各省省选</tag>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>TopCoder 13955《WalkOverATree》</title>
    <url>/2019-07-31/TopCoder13955/</url>
    <content><![CDATA[<h1 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h1><p>Given is a tree on n nodes. The nodes are numbered 0 through n-1. You are given the description of the tree as a int[]  <strong>parent</strong>  with n-1 elements. For each valid i, there is an edge between vertices (i+1) and  <strong>parent</strong>[i].</p>
<a id="more"></a>
<p>A person is currently standing in node 0. In a single step, the person can move from its current node to any adjacent node. You are given an int  <strong>L</strong>. The person is allowed to make at most  <strong>L</strong>  steps.</p>
<p>Return the maximum number of nodes the person can visit during the walk. Node 0 (where the walk starts) and the node where the walk ends count as visited. Each visited node is only counted once, even if it is visited multiple times.</p>
<h1 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h1><p>Class: WalkOverATree<br>Method: maxNodesVisited<br>Parameters: int[], int<br>Returns: int<br>Method signature: int maxNodesVisited(int[] parent, int L)<br>(be sure your method is public)</p>
<h1 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h1><ul>
<li><p><strong>parent</strong>  will contain between 0 and 49 elements, inclusive.</p>
</li>
<li><p>For each i,  <strong>parent</strong>[i] will be between 0 and i, inclusive.</p>
</li>
<li><p><strong>L</strong>  will be between 1 and 100, inclusive.</p>
</li>
</ul>
<h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>请自行到 vjudge 上寻找</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>英文很好懂，只需人教初二水平（反正我准初三选手看懂了）</p>
<p>题目大意：<br>给定一棵 n 个点的树，编号 0~n-1。连边方式以输入每个点的父亲给出，对于每个 i，有一条边连接点 (i+1) 和点 father[i]，而且 father[i] 是 (i+1) 的父亲。<br>有一个人站在点 0，可以向四周走不超过 L 步，求出这个人能经过多少不同的点</p>
<p>这题和 dp 有什么关系吗。。。</p>
<p>这题的难点大概就是 class 的使用和答案统计了吧</p>
<p>class 的使用可以参考<a href="https://blog.csdn.net/qq_31908675/article/details/81198751" target="_blank" rel="noopener">这里</a></p>
<p>答案统计和基本的思路见代码吧</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  TopCoder13955.cpp</span></span><br><span class="line"><span class="comment">//  Title: WalkOverATree</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/31.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt;= s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WalkOverATree</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 直接暴力就好了。。。</span></span><br><span class="line"><span class="comment">     * 一遍 DFS 预处理出所有的点的深度（根节点深度为 0）</span></span><br><span class="line"><span class="comment">     * 答案的输出见下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXL = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> depthWalk[MAXL];</span><br><span class="line">    <span class="keyword">int</span> maxstep = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>, <span class="keyword">int</span> step = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        depthWalk[root] = step;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[root].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = head[root][i];</span><br><span class="line">            <span class="keyword">if</span> (next == father) <span class="keyword">continue</span>;</span><br><span class="line">            DFS(next, root, step + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNodesVisited</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        maxstep = L;</span><br><span class="line">        <span class="keyword">int</span> N = (<span class="keyword">int</span>) father.size() + <span class="number">1</span>; <span class="comment">// 把根节点算上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = N - <span class="number">1</span>; i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = (i + <span class="number">1</span>) + <span class="number">1</span>, next = father[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 编号整体加一</span></span><br><span class="line">            head[prev].push_back(next);</span><br><span class="line">            head[next].push_back(prev);</span><br><span class="line">        &#125;</span><br><span class="line">        DFS();</span><br><span class="line">        ans = *<span class="built_in">std</span>::max_element(depthWalk + <span class="number">1</span>, depthWalk + <span class="number">1</span> + N);</span><br><span class="line">        <span class="keyword">if</span> (ans &gt; L) <span class="keyword">return</span> L + <span class="number">1</span>; <span class="comment">// 能走的最长的路径已经超过了 L，直接返回 L + 1（把根节点算上）</span></span><br><span class="line">        ans = <span class="built_in">std</span>::min(N, ans + <span class="number">1</span> + (L - ans) / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// ans + 1：走过的最长路径加上根节点</span></span><br><span class="line">        <span class="comment">// L - ans：剩下能走的路径，不能浪费</span></span><br><span class="line">        <span class="comment">// (L - ans) / 2：需要一半的路径来折返</span></span><br><span class="line">        <span class="comment">// 注意：剩下的 L - ans 这些路径可以在任何地方用来走，不只是用来在最深的点折返</span></span><br><span class="line">        <span class="comment">// 还有一种情况：所有的点都走完了，还有步数</span></span><br><span class="line">        <span class="comment">// 这时候答案就不会再继续累加了</span></span><br><span class="line">        <span class="comment">// 这种情况下 ans 就要对 N 取个 min</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记得最后提交的时候不要带 main 函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> int main() &#123;</span></span><br><span class="line"><span class="comment"> std::vector&lt;int&gt; fa;</span></span><br><span class="line"><span class="comment"> fa.clear();</span></span><br><span class="line"><span class="comment"> int x = 0;</span></span><br><span class="line"><span class="comment"> while (true) &#123;</span></span><br><span class="line"><span class="comment"> cin &gt;&gt; x;</span></span><br><span class="line"><span class="comment"> if (x == -1) break;</span></span><br><span class="line"><span class="comment"> fa.push_back(x);</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> int l = 0;</span></span><br><span class="line"><span class="comment"> cin &gt;&gt; l;</span></span><br><span class="line"><span class="comment"> WalkOverATree wk;</span></span><br><span class="line"><span class="comment"> cout &lt;&lt; wk.maxNodesVisited(fa, l) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"> return 0;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>TopCoder</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2519《[HAOI2011]problem a》</title>
    <url>/2019-07-30/Luogu-P2519-BZOJ2298/</url>
    <content><![CDATA[<blockquote>
<p>人类智慧题</p>
</blockquote>
<a id="more"></a>
<p>由于一些原因，不对题面作出展示，请自行寻找</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我个人对「人类智慧题」对定义是「运用人脑求特殊解也想不出来的问题」</p>
<p>第一眼看到这题的时候，我一脸问号<br>直到老师开始讲题……</p>
<hr>
<p>首先把题目转化一下<br>对于每个学生，给定了有多少成绩比他好、比他差，那就把数据转换为一个成绩区间，表示这个区间内的人（可能只有 1 个）成绩相同</p>
<p>然后考虑一下「假话」的判断方式</p>
<ol>
<li>成绩比他好的 + 成绩比他差的 + 他 &gt; 总人数<br>这个请自行理解</li>
<li>两个有交集的区间没有完全相同，那么两个区间必有一个是假话<br>这个很显然吧，就是两个区间有交集的话说明它们是一个成绩，然而小于这个成绩的人或大于这个成绩的人却不相同</li>
<li>对于一堆完全相同的区间，它们之间是真话的个数至多是[区间长度]个，超出的部分全都是假话<br>想一想区间长度的现实意义是什么：有[区间长度]个学生成绩相同。那么，一个成绩是有[区间长度]个人的，也就是说，至多有[区间长度]个属于这个区间对应的成绩的学生在说真话（可以看作他们的成绩属于这个区间对应的成绩），剩下的学生都在说假话。<br>这样说应该会好理解一些吧……实在不行我举个例子：[2,4]，意味着这个区间对应的成绩有 3 个人获得了，那么如果有 4 个人说“我获得了这个成绩”，那么肯定有 1 个人在说假话。</li>
</ol>
<p>经过筛选，区间数量减少了一些，再去个重，把相同的区间个数用权值的形式表示出来（对每种区间分配唯一 id），比如说我有三个[2,4]和一个[7,8]，我就可以对[2,4]这个区间加一个权值 3，对[7,8]这个区间加一个权值 1。</p>
<hr>
<p>那么问题现在变成了：带权值的线段覆盖，求最大权值和</p>
<p>这个就是一个 dp 问题了</p>
<p>下面这一段也是从我代码里复制过来的（</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 设 F[i] 表示选择右端点不超过 i 的最大权值</span><br><span class="line">// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话</span><br><span class="line">// 初始：F[i] = F[i - 1]</span><br><span class="line">// 转移：当 i 点为某一线段的右端点时，</span><br><span class="line">// F[i] = max(F[i], F[j - 1] + Weight)</span><br><span class="line">// 其中 j 为该线段的左端点，Weight 为该线段的权值</span><br><span class="line">// (j - 1) 是因为线段不能重叠</span><br></pre></td></tr></table></figure>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>代码里有很多注释，应该会很好理解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2519.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2011]problem a</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ2298</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, w;</span><br><span class="line">    </span><br><span class="line">    Segment(<span class="keyword">int</span> l = <span class="number">0</span>, <span class="keyword">int</span> r = <span class="number">0</span>, <span class="keyword">int</span> w = <span class="number">0</span>) : l(l), r(r), w(w) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Segment &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == that.r) <span class="keyword">return</span> l &lt; that.l;</span><br><span class="line">        <span class="keyword">return</span> r &lt; that.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; segt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Ls[MAXN], Rs[MAXN], Ws[MAXN];</span><br><span class="line"><span class="comment">// segt 记录读入后经过处理的线段，Ls, Rs, Ws 记录去重后的线段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt, cntnew;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="comment">// 将给定的数据转化为学生 i 的排名</span></span><br><span class="line">        <span class="comment">// 用区间[l,r]的形式表示（按成绩排名）第 l 个人到第 r 个人成绩相同</span></span><br><span class="line">        <span class="comment">// 考虑把所有完全相同的线段记为单个带权值的线段</span></span><br><span class="line">        <span class="comment">// 那么问题就变为了一个带权线段覆盖问题</span></span><br><span class="line">        <span class="keyword">if</span> (l + r &gt;= n) <span class="keyword">continue</span>; <span class="comment">// 学生数量不合法，显然是错的</span></span><br><span class="line">        ++l; r = (n - ((r + <span class="number">1</span>) - <span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 避免出现左端点为 0 的情况，因为读入的 l 有可能是 0</span></span><br><span class="line">        segt[++cnt] = Segment(l, r); <span class="comment">// 记一下目前合法的线段数量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(segt + <span class="number">1</span>, segt + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(segt[i].l == segt[i - <span class="number">1</span>].l &amp;&amp; segt[i].r == segt[i - <span class="number">1</span>].r)) ++cntnew;</span><br><span class="line">        <span class="comment">// 两条线段如果重合，就增加该线段的权值</span></span><br><span class="line">        <span class="comment">// 两条线段如果不重合，就新开一条线段</span></span><br><span class="line">        <span class="comment">// 本质是一个去重并合并权值的过程</span></span><br><span class="line">        Ws[cntnew] = <span class="built_in">std</span>::min((segt[i].r - segt[i].l + <span class="number">1</span>), Ws[cntnew] + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 重合的线段表示有(线段长度)个人是相同成绩的</span></span><br><span class="line">        <span class="comment">// 所以每组重合线段（按线段长度分组）的个数如果超过了它的长度</span></span><br><span class="line">        <span class="comment">// 则超出去的那部分必定是假话</span></span><br><span class="line">        Ls[cntnew] = segt[i].l; Rs[cntnew] = segt[i].r;</span><br><span class="line">        <span class="comment">// 记一下去重后的线段</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 设 F[i] 表示选择右端点不超过 i 的最大权值</span></span><br><span class="line">        <span class="comment">// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话</span></span><br><span class="line">        <span class="comment">// 初始：F[i] = F[i - 1]</span></span><br><span class="line">        <span class="comment">// 转移：当 i 点为某一线段的右端点时，</span></span><br><span class="line">        <span class="comment">// F[i] = max(F[i], F[j - 1] + Weight)</span></span><br><span class="line">        <span class="comment">// 其中 j 为该线段的左端点，Weight 为该线段的权值</span></span><br><span class="line">        <span class="comment">// (j - 1) 是因为线段不能重叠</span></span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= cntnew &amp;&amp; Rs[j] == i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">std</span>::max(dp[i], dp[Ls[j] - <span class="number">1</span>] + Ws[j]);</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于 F[i] 表示说真话的数量，所以答案为学生的数量 - 说真话的数量</span></span><br><span class="line">    <span class="comment">// 也就是 n - dp[n]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n - dp[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>各省省选</tag>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CF816E / CF815C《Karen and Supermarket》</title>
    <url>/2019-07-30/CF816E-CF815C/</url>
    <content><![CDATA[<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>On the way home, Karen decided to stop by the supermarket to buy some groceries.</p>
<a id="more"></a>
<p><img src="https://vj.ti12z.cn/7bda7944615fd91edd669116f72aa574?v=1564372682" alt></p>
<p>She needs to buy a lot of goods, but since she is a student her budget is still quite limited. In fact, she can only spend up to  $b$  dollars.</p>
<p>The supermarket sells  $n$  goods. The  $i$-th good can be bought for  $c_i$  dollars. Of course, each good can only be bought once.</p>
<p>Lately, the supermarket has been trying to increase its business. Karen, being a loyal customer, was given  $n$  coupons. If Karen purchases the  $i$-th good, she can use the  $i$-th coupon to decrease its price by  $d_i$. Of course, a coupon cannot be used without buying the corresponding good.</p>
<p>There is, however, a constraint with the coupons. For all  $i≥ 2$, in order to use the  $i$-th coupon, Karen must also use the  $x_i$ -th coupon (which may mean using even more coupons to satisfy the requirement for that coupon).</p>
<p>Karen wants to know the following. What is the maximum number of goods she can buy, without exceeding her budget  $b$?</p>
<h1 id="Input-Format"><a href="#Input-Format" class="headerlink" title="Input Format"></a>Input Format</h1><p>The first line of input contains two integers  nn  and  bb  (  1&lt;=n&lt;=50001&lt;=n&lt;=5000  ,  1&lt;=b&lt;=10^{9}1&lt;=b&lt;=109  ), the number of goods in the store and the amount of money Karen has, respectively.</p>
<p>The next  nn  lines describe the items. Specifically:</p>
<ul>
<li>The  ii  -th line among these starts with two integers,  c<em>{i}ci​  and  d</em>{i}di​  (  1&lt;=d<em>{i}&lt;c</em>{i}&lt;=10^{9}1&lt;=di​&lt;ci​&lt;=109  ), the price of the  ii  -th good and the discount when using the coupon for the  ii  -th good, respectively.</li>
<li>If  i&gt;=2i&gt;=2  , this is followed by another integer,  x<em>{i}xi​  (  1&lt;=x</em>{i}&lt;i1&lt;=xi​&lt;i  ), denoting that the  x_{i}xi​  -th coupon must also be used before this coupon can be used.</li>
</ul>
<h1 id="Output-Format"><a href="#Output-Format" class="headerlink" title="Output Format"></a>Output Format</h1><p>Output a single integer on a line by itself, the number of different goods Karen can buy, without exceeding her budget.</p>
<h3 id="Input-Output-Samples"><a href="#Input-Output-Samples" class="headerlink" title="Input / Output Samples"></a>Input / Output Samples</h3><p><strong>Input #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 16</span><br><span class="line">10 9</span><br><span class="line">10 5 1</span><br><span class="line">12 2 1</span><br><span class="line">20 18 3</span><br><span class="line">10 2 3</span><br><span class="line">2 1 5</span><br></pre></td></tr></table></figure>
<p><strong>Output #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>Input #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 10</span><br><span class="line">3 1</span><br><span class="line">3 1 1</span><br><span class="line">3 1 2</span><br><span class="line">3 1 3</span><br><span class="line">3 1 4</span><br></pre></td></tr></table></figure>
<p><strong>Output #2</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>从代码里复制过来的（</p>
<p>一道树形 DP</p>
<p>显然优惠券的使用逻辑可以构成一棵树<br>设 $\text{f[i][j][0/1]}$ 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费<br>初始状态：</p>
<p>$\text{f[][][] = INF}$<br>$\text{f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read}$</p>
<p>转移方程：<br>$\text{f[root][i + j][0] = min{ f[root][i + j][0], f[root][i][0] + f[u][j][0] | u} \in subtree(root) \ }$<br>$\text{f[root][i + j][1] = min{ f[root][i + j][1], f[root][i][1] + min{ f[u][j][0], f[u][j][1] } | u}  \in subtree(root)\ }$</p>
<p>其中 $i \leq \text{size[root]}, j \leq \text{size[u]}$，i 需要倒序枚举来避免重复选商品</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  CF816E.cpp</span></span><br><span class="line"><span class="comment">//  Title: Karen and Supermarket</span></span><br><span class="line"><span class="comment">//  Alternatives: CF815C</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/30.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="comment">// CodeForces 中请使用 %I64d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 显然优惠券的使用逻辑可以构成一棵树</span></span><br><span class="line"><span class="comment"> * 设 f[i][j][0/1] 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费</span></span><br><span class="line"><span class="comment"> * 初始状态：</span></span><br><span class="line"><span class="comment"> * f[][][] = INF</span></span><br><span class="line"><span class="comment"> * f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read</span></span><br><span class="line"><span class="comment"> * 转移方程：</span></span><br><span class="line"><span class="comment"> * f[root][i + j][0] = min&#123; f[root][i + j][0], f[root][i][0] + f[u][j][0] | u 为 root 的孩子 &#125;</span></span><br><span class="line"><span class="comment"> * f[root][i + j][1] = min&#123; f[root][i + j][1], f[root][i][1] + min&#123; f[u][j][0], f[u][j][1] &#125; | u 为 root 的孩子 &#125;</span></span><br><span class="line"><span class="comment"> * 其中 i &lt;= size[root], j &lt;= size[u]，i 需要倒序枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, b;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">lli dp[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> size[MAXN];</span><br><span class="line"><span class="comment">// dp 数组耗空间约 383MB</span></span><br><span class="line"><span class="comment">// size 数组耗空间约 20KB</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u = <span class="number">1</span>, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : head[u]) &#123;</span><br><span class="line">        DFS(v, u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size[u]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= size[v]; ++j) &#123;</span><br><span class="line">                dp[u][i + j][<span class="number">0</span>] = <span class="built_in">std</span>::min(</span><br><span class="line">                    dp[u][i + j][<span class="number">0</span>],</span><br><span class="line">                    dp[u][i][<span class="number">0</span>] + dp[v][j][<span class="number">0</span>]</span><br><span class="line">                );</span><br><span class="line">                dp[u][i + j][<span class="number">1</span>] = <span class="built_in">std</span>::min(</span><br><span class="line">                    dp[u][i + j][<span class="number">1</span>],</span><br><span class="line">                    dp[u][i][<span class="number">1</span>] + <span class="built_in">std</span>::min(</span><br><span class="line">                        dp[v][j][<span class="number">0</span>],</span><br><span class="line">                        dp[v][j][<span class="number">1</span>]</span><br><span class="line">                    )</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); b = getint();</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x7f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    rap (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">0</span>] = getll();</span><br><span class="line">        dp[i][<span class="number">1</span>][<span class="number">1</span>] = dp[i][<span class="number">1</span>][<span class="number">0</span>] - getll();</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = getint();</span><br><span class="line">            head[next].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="keyword">int</span> i = n;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[<span class="number">1</span>][i][<span class="number">0</span>] &lt;= b || dp[<span class="number">1</span>][i][<span class="number">1</span>] &lt;= b) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2218《[HAOI2007]覆盖问题》</title>
    <url>/2019-07-30/Luogu-P2218-BZOJ1052/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>某人在山上种了N棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用3个L*L的正方形塑料薄膜将小树遮起来。</p>
<a id="more"></a>
<p>我们不妨将山建立一个平面直角坐标系，设第i棵小树的坐标为（Xi,Yi），3个L*L的正方形的边要求平行 与坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求L最小值。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有一个正整数N，表示有多少棵树。</p>
<p>接下来有N行，第i+1行有2个整数Xi,Yi，表示第i棵树的坐标，保证不会有2个树的坐标相同。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>一行，输出最小的L值。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 1</span><br><span class="line">0 -1</span><br><span class="line">1 0</span><br><span class="line">-1 0</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>数据范围</p>
<p>100%的数据，-1,000,000,000&lt;=Xi,Yi&lt;=1,000,000,000</p>
<p>30%的数据，N&lt;=100</p>
<p>50%的数据，N&lt;=2000</p>
<p>100%的数据，N&lt;=20000</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然答案具有单调性，因为边长为 k 的正方形能覆盖的话，边长为 k + 1 的正方形一定能覆盖<br>考虑二分答案</p>
<hr>
<p>首先用一个最小的矩形覆盖所有的点</p>
<p>很容易想到一个做法：先把矩形的左上角、右下角用正方形覆盖，再把中间的用正方形覆盖<br>然而这样是不行的，反例很多，这里就不写了<br>但是换个思路，矩形的四个角一定会有贴着边放的正方形</p>
<p>所以换一个做法：枚举矩形的四个角，放正方形；此时还剩下一些点，再找一个最小的矩形覆盖所有点，递归进去做即可，深度只有 3 层</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2218.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2007]覆盖问题</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ1052</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::min;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">lli n, maxx = -(<span class="number">0x3f3f3f3f</span>), minx = (<span class="number">0x3f3f3f3f</span>), maxy = -(<span class="number">0x3f3f3f3f</span>), miny = (<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">lli x[MAXN], y[MAXN];</span><br><span class="line"><span class="keyword">int</span> cov[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 确定一个最小的矩形使得这个矩形可以覆盖所有点。</span></span><br><span class="line"><span class="comment"> * 枚举这个矩形的四个角，把一个正方形放到这个角上，</span></span><br><span class="line"><span class="comment"> * 有一些点会被覆盖，此时递归进去确定剩下未被覆盖的点即可</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Cover(<span class="keyword">int</span> lx, <span class="keyword">int</span> rx, <span class="keyword">int</span> ly, <span class="keyword">int</span> ry, <span class="keyword">int</span> ts) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!cov[i]</span><br><span class="line">            &amp;&amp; lx &lt;= x[i] &amp;&amp; x[i] &lt;= rx</span><br><span class="line">            &amp;&amp; ly &lt;= y[i] &amp;&amp; y[i] &lt;= ry)</span><br><span class="line">            cov[i] = ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Uncover</span><span class="params">(<span class="keyword">int</span> ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cov[i] == ts)</span><br><span class="line">            cov[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _CHECK(<span class="keyword">int</span> mid, <span class="keyword">int</span> depth) &#123;</span><br><span class="line">    lli minx = INF, maxx = -INF, miny = INF, maxy = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!cov[i]) &#123;</span><br><span class="line">            minx = min(minx, x[i]); maxx = max(maxx, x[i]);</span><br><span class="line">            miny = min(miny, y[i]); maxy = max(maxy, y[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (max(maxx - minx, maxy - miny) &lt;= mid) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    _Cover(minx, minx + mid, miny, miny + mid, depth); <span class="comment">// ld</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(minx, minx + mid, maxy - mid, maxy, depth); <span class="comment">// lu</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(maxx - mid, maxx, miny, miny + mid, depth); <span class="comment">// rd</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    _Cover(maxx - mid, maxx, maxy - mid, maxy, depth); <span class="comment">// ru</span></span><br><span class="line">    <span class="keyword">if</span> (_CHECK(mid, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    Uncover(depth);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(cov, <span class="number">0</span>, <span class="keyword">sizeof</span> cov);</span><br><span class="line">    <span class="keyword">return</span> _CHECK(mid, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123; x[i] = getint(); y[i] = getint(); &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid))</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>模拟</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2341《[HAOI2006]受欢迎的牛》</title>
    <url>/2019-07-29/Luogu-P2341-BZOJ1051-LOJ10091/</url>
    <content><![CDATA[<blockquote>
<p>Tarjan 缩点板子题</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶</p>
<p>牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜</p>
<p>欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你</p>
<p>算出有多少头奶牛可以当明星。</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行：两个用空格分开的整数：N和M</p>
<p>第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>第一行：单独一个整数，表示明星奶牛的数量</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明/提示"></a>说明/提示</h1><p>只有 3 号奶牛可以做明星</p>
<p>【数据范围】</p>
<p>10%的数据N&lt;=20, M&lt;=50</p>
<p>30%的数据N&lt;=1000,M&lt;=20000</p>
<p>70%的数据N&lt;=5000,M&lt;=50000</p>
<p>100%的数据N&lt;=10000,M&lt;=50000 </p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>首先把题目转化一下</p>
<p>显然能成为明星的奶牛<strong>们</strong>一定是互相喜欢的<br>那么可以这样想：能成为明星的奶牛们都是在一个强连通分量中的，这样意味着互相喜欢<br>所以问题转化为了求图中强连通分量大小，这个用 Tarjan 来完成</p>
<p>值得注意的是，把强连通分量缩点之后，所得的图一定是一个DAG（这是一个性质）（实际写代码的时候不需要重新建图）<br>回到题目，缩完点之后，强连通分量对应的点的出度一定为0，而且有且仅有强连通分量对应的点出度为 0，因为如果强连通分量对应的点出度大于 0，则连出去的边与其他的点连到强连通分量的边就构成了一个环，与上面的性质相矛盾</p>
<p>注意到强连通分量对应的点出度为 0，那么该图合法必须要保证只有一个强连通分量（想一想，为什么）</p>
<p>所以写代码的思路就大体形成了：<br>Tarjan求强连通分量大小➡️缩点求出度➡️判断强连通分量个数➡️输出0或者强连通分量大小</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  LuoguP2341.cpp</span></span><br><span class="line"><span class="comment">//  Title: [HAOI2006]受欢迎的牛</span></span><br><span class="line"><span class="comment">//  Alternatives: BZOJ1051-LOJ10091</span></span><br><span class="line"><span class="comment">//  Debugging</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/7/28.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 HandwerSTD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN], low[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inStack[MAXN];</span><br><span class="line"><span class="keyword">int</span> rep[MAXM], ren[MAXM];</span><br><span class="line"><span class="comment">// 把输入数据存一下</span></span><br><span class="line"><span class="keyword">int</span> sizSC[MAXN], ode[MAXN];</span><br><span class="line"><span class="keyword">int</span> ftot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> top, Stack[MAXN];</span><br><span class="line"><span class="keyword">int</span> col, timestamp, SC[MAXN];</span><br><span class="line"><span class="comment">// dfn：dfs的时间戳</span></span><br><span class="line"><span class="comment">// low：在点u的子树能到达的节点中dfn的最小值</span></span><br><span class="line"><span class="comment">// SC：点u属于哪一个强连通分量</span></span><br><span class="line"><span class="comment">// inStack：是否在栈中</span></span><br><span class="line"><span class="comment">// sizSC：该强连通分量的大小</span></span><br><span class="line"><span class="comment">// ode：该“点”的出度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; head[x].push_back(y); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    low[u] = dfn[u] = ++timestamp;</span><br><span class="line">    Stack[++top] = u;</span><br><span class="line">    inStack[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[u].size(); i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">        <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">            <span class="comment">// 没被访问过</span></span><br><span class="line">            Tarjan(v);</span><br><span class="line">            low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inStack[v]) low[u] = <span class="built_in">std</span>::min(low[u], low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">        <span class="comment">// 意味着u的子树中没有能到达u的祖先的边，也就是找到了一个强连通分量</span></span><br><span class="line">        SC[u] = ++col;</span><br><span class="line">        inStack[u] = <span class="literal">false</span>;</span><br><span class="line">        ++sizSC[col];</span><br><span class="line">        <span class="keyword">while</span> (Stack[top] != u) &#123;</span><br><span class="line">            SC[Stack[top]] = col;</span><br><span class="line">            ++sizSC[col];</span><br><span class="line">            inStack[Stack[top--]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        addEdge(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) Tarjan(i);</span><br><span class="line">    <span class="comment">// 对所有联通块进行tarjan</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[i].size(); j &lt; siz; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = head[i][j];</span><br><span class="line">            <span class="keyword">if</span> (SC[i] != SC[v]) ++ode[SC[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= col; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!ode[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans) &#123; <span class="built_in">printf</span>(<span class="string">"0"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">            ans = sizSC[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tm这题我调了2h</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2606《排列计数》</title>
    <url>/2019-07-21/Luogu-P2606/</url>
    <content><![CDATA[<blockquote>
<p>披着数论皮的图论</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>称一个1,2,…,N的排列P1,P2…,Pn是Magic的，当且仅当2&lt;=i&lt;=N时，Pi&gt;Pi/2. 计算1，2，…N的排列中有多少是Magic的，答案可能很大，只能输出模P以后的值</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件的第一行包含两个整数 n和p，含义如上所述。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件中仅包含一个整数，表示计算1,2,⋯, N的排列中， Magic排列的个数模 p的值。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p>输入样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 23</span><br></pre></td></tr></table></figure>
<p>输出样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>100%的数据中，1 ≤N ≤ 10^6, P≤ 10^9，p是一个质数。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>考虑这么一个事情：<br><br>$P<em>i &gt; P</em>{i / 2}$放到一棵树上是什么？<br>把$P_i$看作第$i$个点的权值，那么…… <br>第$i$个点的权值比第$i/2$个点的权值要大，也就是第$i$个点的权值要比第$i \times 2$个点的权值要小……<br>想一想二叉树的表示方法……这好像是一个小根堆？</p>
<p>问题转化为了：求1-n的所有排列中，可以构成一个小根堆的排列的个数</p>
<p>考虑dp<br>设<code>dp[u]</code>表示以u为根结点分配1~size(u)的小根堆的方案数<br>转移：<script type="math/tex">d p(x)=\left(\begin{array}{c}{\operatorname{sz}(x)-1} \\ {\operatorname{sz}\left(u_{1}\right), s z\left(u_{2}\right), \ldots, s z\left(u_{r}\right)}\end{array}\right) \prod d p\left(u_{i}\right)</script></p>
<p>最终答案就是$dp(1)$</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>我开了O2才过。。。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n, HA, fac[MAXN], inv[MAXN], siz[MAXN], dp[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">long long int getll() &#123; </span></span><br><span class="line"><span class="comment">    long long int s = 0, x = 1; </span></span><br><span class="line"><span class="comment">    char ch = getchar(); </span></span><br><span class="line"><span class="comment">    while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; </span></span><br><span class="line"><span class="comment">    while (isdigit(ch)) &#123; s = s * x + 1ll * ch - 1ll * '0'; ch = getchar(); &#125; </span></span><br><span class="line"><span class="comment">    return 1ll * s * x; </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">void putll(long long int x) &#123; </span></span><br><span class="line"><span class="comment">    if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; </span></span><br><span class="line"><span class="comment">    putll(x / 10); putchar(x % 10 + '0'); </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fastPow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">1</span>) <span class="keyword">return</span> a % HA;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = ret * a % HA;</span><br><span class="line">        a = a * a % HA;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> m, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 洛谷上数据水不用 Lucas 定理</span></span><br><span class="line">    <span class="comment">// n! / (m!(n - m)!)</span></span><br><span class="line">    <span class="keyword">return</span> fac[n] * inv[m] % HA * inv[n - m] % HA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    head[prev].push_back(next);</span><br><span class="line">    head[next].push_back(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> father = <span class="number">0</span>, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    siz[root] = <span class="number">1</span>;</span><br><span class="line">    dp[root] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, ss = head[root].size(); i &lt; ss; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> next = head[root][i];</span><br><span class="line">        <span class="keyword">if</span> (father == next) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(root, next);</span><br><span class="line">        siz[root] += siz[next];</span><br><span class="line">        dp[root] = <span class="number">1l</span>l * dp[root] * C(siz[next], siz[root] - <span class="number">1</span>) % HA * dp[next] % HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//n = getll(); HA = getll();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;n, &amp;HA);</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>; inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fac[i] = fac[i - <span class="number">1</span>] * i % HA;</span><br><span class="line">        inv[i] = fastPow(fac[i], HA - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> lson = (i &lt;&lt; <span class="number">1</span>), rson = (i &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (lson &lt;= n) addEdge(i, lson);</span><br><span class="line">        <span class="keyword">if</span> (rson &lt;= n) addEdge(i, rson);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="comment">//putll(dp[1] % HA);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>] % HA);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>数论</tag>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈专项练习</title>
    <url>/2019-07-21/MonotoneStack-Luogu-P1901-Luogu-P1823-Luogu-P2947/</url>
    <content><![CDATA[<blockquote>
<p>单调数据结构</p>
</blockquote>
<a id="more"></a>
<h1 id="练习：洛谷P2947《Look-Up》"><a href="#练习：洛谷P2947《Look-Up》" class="headerlink" title="练习：洛谷P2947《Look Up》"></a>练习：洛谷P2947《Look Up》</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Farmer John’s N (1 &lt;= N &lt;= 100,000) cows, conveniently numbered 1..N, are once again standing in a row. Cow i has height H_i (1 &lt;= H_i &lt;= 1,000,000).</p>
<p>Each cow is looking to her left toward those with higher index numbers. We say that cow i ‘looks up’ to cow j if i &lt; j and H_i &lt; H_j. For each cow i, FJ would like to know the index of the first cow in line looked up to by cow i.</p>
<p>Note: about 50% of the test data will have N &lt;= 1,000.</p>
<p>约翰的N(1≤N≤10^5)头奶牛站成一排，奶牛i的身高是Hi(l≤Hi≤1,000,000)．现在，每只奶牛都在向右看齐．对于奶牛i，如果奶牛j满足i&lt;j且Hi&lt;Hj，我们可以说奶牛i可以仰望奶牛j． 求出每只奶牛离她最近的仰望对象．</p>
<p>Input</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><ul>
<li><p>Line 1: A single integer: N</p>
</li>
<li><p>Lines 2..N+1: Line i+1 contains the single integer: H_i</p>
</li>
</ul>
<p>第 1 行输入 N，之后每行输入一个身高 H_i。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><ul>
<li>Lines 1..N: Line i contains a single integer representing the smallest index of a cow up to which cow i looks. If no such cow exists, print 0.</li>
</ul>
<p>共 N 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 0。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">3 </span><br><span class="line">2 </span><br><span class="line">6 </span><br><span class="line">1 </span><br><span class="line">1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>输出样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 </span><br><span class="line">3 </span><br><span class="line">0 </span><br><span class="line">6 </span><br><span class="line">6 </span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>FJ has six cows of heights 3, 2, 6, 1, 1, and 2.</p>
<p>Cows 1 and 2 both look up to cow 3; cows 4 and 5 both look up to cow 6; and cows 3 and 6 do not look up to any cow.</p>
<p>【输入说明】6 头奶牛的身高分别为 3, 2, 6, 1, 1, 2.</p>
<p>【输出说明】奶牛#1,#2 仰望奶牛#3，奶牛#4,#5 仰望奶牛#6，奶牛#3 和#6 没有仰望对象。</p>
<p>【数据规模】</p>
<p>对于 20%的数据： 1≤N≤10；</p>
<p>对于 50%的数据： 1≤N≤1,000；</p>
<p>对于 100%的数据：1≤N≤100,000；1≤H_i≤1,000,000；</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>题目就是说，依次给出一堆线段，求对于每条线段，第一个在它右面，长度大于它的线段的下标是多少<br>我们先来模拟一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1[===] 歪着看体验更佳（逃</span><br><span class="line">2[==]</span><br><span class="line">3[======]</span><br><span class="line">4[=]</span><br><span class="line">5[=]</span><br><span class="line">6[==]</span><br></pre></td></tr></table></figure>
<p>第一次，1号进来了，没有比它高的，让它等一会<br>第二次，2号进来了，它甚至比1号还低，对1号的答案没有什么影响，也让它等一会<br>第三次，3号进来了，它比1、2号都高！此时1、2号的答案都是3号，而且1、2号<strong>对于以后的线段答案是没有影响的</strong>，呆在队伍里已经没有什么用了，让它们出去即可<br>第四次、第五次，4号和5号依次进来，对3号的答案并没有什么影响<br>第六次，6号进来了，4号和5号的答案更新为6号，而且对以后的线段答案也是没有什么影响的（如果以后还有线段的话），出去即可<br>队伍里还有俩线段3和6，它们的答案没有被更新过，也就是没有答案</p>
<hr>
<p>这就是一个单调栈的工作流程，通过清除栈里的元素来维护单调性，而本题中第三次循环和第六次循环则是对于单调数据结构进行具体问题具体分析的关键点</p>
<p>可以看出，实质上是维护了一个单调不增的栈，在维护栈的单调性过程中求出了答案</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cow</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> height, id;</span><br><span class="line">    </span><br><span class="line">    Cow() : height(<span class="number">0</span>), id(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Cow(<span class="keyword">int</span> height, <span class="keyword">int</span> id) : height(height), id(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Cow&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> height = getint();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt; height) &#123;</span><br><span class="line">            <span class="comment">// stk.top().height &lt; height 维护栈内元素单调不增性</span></span><br><span class="line">            <span class="comment">// 如果 stk.top().height &gt; height 则单调性仍存在，不必维护</span></span><br><span class="line">            ans[stk.top().id] = i;</span><br><span class="line">            <span class="comment">// 更新答案</span></span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push((Cow) &#123; height, i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]); &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="巩固：洛谷P1901《发射站》"><a href="#巩固：洛谷P1901《发射站》" class="headerlink" title="巩固：洛谷P1901《发射站》"></a>巩固：洛谷P1901《发射站》</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>某地有 N 个能量发射站排成一行，每个发射站 i 都有不相同的高度 Hi，并能向两边（当 然两端的只能向一边）同时发射能量值为 Vi 的能量，并且发出的能量只被两边最近的且比 它高的发射站接收。</p>
<p>显然，每个发射站发来的能量有可能被 0 或 1 或 2 个其他发射站所接受，特别是为了安 全，每个发射站接收到的能量总和是我们很关心的问题。由于数据很多，现只需要你帮忙计 算出接收最多能量的发射站接收的能量是多少。</p>
<h2 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h3><p>第 1 行：一个整数 N;</p>
<p>第 2 到 N+1 行：第 i+1 行有两个整数 Hi 和 Vi，表示第 i 个人发射站的高度和发射的能量值。</p>
<h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅一行，表示接收最多能量的发射站接收到的能量值，答案不超过 longint。</p>
<h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 </span><br><span class="line">3 5 </span><br><span class="line">6 10</span><br></pre></td></tr></table></figure>
<p>输出样例#1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>
<h2 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h2><p>对于 40%的数据，1&lt;=N&lt;=5000；1&lt;=Hi&lt;=100000；1&lt;=Vi&lt;=10000;</p>
<p>对于 70%的数据，1&lt;=N&lt;=100000；1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000;</p>
<p>对于 100%的数据，1&lt;=N&lt;=1000000;1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000。</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>同样的，先来模拟一下这个过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1[====](2)</span><br><span class="line">2[===](5)</span><br><span class="line">3[======](10)</span><br></pre></td></tr></table></figure>
<p>第一次，1号发射站进来，它莫得其他发射站来传输能量<br>第二次，2号发射站进来，它可以给1号传输能量<br>第三次，3号发射站进来：<br>2号发射站可以给3号发射站传输能量，1号发射站亦可。由于这两个发射站对于其他发射站的答案已经没有贡献，自己的答案也确定了，让它们出去即可</p>
<hr>
<p>本质上也是维护了一个单调递减的栈，在维护单调性的同时确定答案</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Launcher</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> height; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> energy;</span><br><span class="line">    <span class="comment">// height: 该发射站的高度</span></span><br><span class="line">    <span class="comment">// energy: 该发射站的能量强度</span></span><br><span class="line">    Launcher() &#123; id = height = energy = <span class="number">0</span>; &#125;</span><br><span class="line">    Launcher(<span class="keyword">int</span> id, <span class="keyword">int</span> height, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> energy) : id(id), height(height), energy(energy) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans[MAXN]; <span class="comment">// 答案不超过 long int</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Launcher&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = getint();</span><br><span class="line">        <span class="keyword">int</span> energy = getint();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt; h) &#123;</span><br><span class="line">            ans[i] += stk.top().energy; <span class="comment">// 栈顶对应的发射站能「向右」发射能量到当前的发射站</span></span><br><span class="line">            stk.pop(); <span class="comment">// 维护栈的单调递减性</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stk.empty()) ans[stk.top().id] += energy; <span class="comment">// 当前发射站能「向左」发射能量到栈顶对应的发射站</span></span><br><span class="line">        stk.push((Launcher) &#123; i, h, energy &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>) *<span class="built_in">std</span>::max_element(ans + <span class="number">1</span>, ans + <span class="number">1</span> + n));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="提高：洛谷P1823《Patrik-音乐会的等待》"><a href="#提高：洛谷P1823《Patrik-音乐会的等待》" class="headerlink" title="提高：洛谷P1823《Patrik 音乐会的等待》"></a>提高：洛谷P1823《Patrik 音乐会的等待》</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>N个人正在排队进入一个音乐会。人们等得很无聊，于是他们开始转来转去，想在队伍里寻找自己的熟人。队列中任意两个人A和B，如果他们是相邻或他们之间没有人比A或B高，那么他们是可以互相看得见的。</p>
<p>写一个程序计算出有多少对人可以互相看见。</p>
<h2 id="输入输出格式-2"><a href="#输入输出格式-2" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入的第一行包含一个整数N (1 ≤ N ≤ 500 000), 表示队伍中共有N个人。</p>
<p>接下来的N行中，每行包含一个整数，表示人的高度，以毫微米(等于10的-9次方米)为单位，每个人的调度都小于2^31毫微米。这些高度分别表示队伍中人的身高。</p>
<h3 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出仅有一行，包含一个数S，表示队伍中共有S对人可以互相看见。</p>
<h2 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 </span><br><span class="line">2 </span><br><span class="line">4 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">2 </span><br><span class="line">5 </span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>输出样例#1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>依然来模拟一下：，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1[==]</span><br><span class="line">2[====]</span><br><span class="line">3[=]</span><br><span class="line">4[==]</span><br><span class="line">5[==]</span><br><span class="line">6[=====]</span><br><span class="line">7[=]</span><br></pre></td></tr></table></figure>
<p>第一次，1号进入，它谁都望不到<br>第二次，2号进入，1、2号能互相看见，此时1号对答案已经没有贡献，出去即可<br>第三次，3号进入，2、3号能互相看见<br>第四次，4号进入，3、4号能互相看见，同时2、4号也可以互相看见，此时3号对答案已经没有贡献，出去即可<br>第五次……第六次……第七次……</p>
<hr>
<p>已经很明显了，依然是维护一个单调不增的栈，在维护元素单调性的同时更新答案<br>但是这里的代码实现有一定的技巧</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Height</span> &#123;</span></span><br><span class="line">    <span class="comment">// 按照顺序把相邻等高的人视为一组</span></span><br><span class="line">    <span class="keyword">int</span> height; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> amount;</span><br><span class="line">    <span class="comment">// height: 该组的高度</span></span><br><span class="line">    <span class="comment">// amount: 该组的人数</span></span><br><span class="line">    Height() &#123; height = amount = <span class="number">0</span>; &#125;</span><br><span class="line">    Height(<span class="keyword">int</span> height, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> amount) : height(height), amount(amount) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;Height&gt; stk;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> h = getint();</span><br><span class="line">        Height hh = (Height) &#123; h, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; stk.top().height &lt;= h) &#123;</span><br><span class="line">            ans += stk.top().amount; <span class="comment">// 当前人能够看见上一组整组的人</span></span><br><span class="line">            <span class="keyword">if</span> (stk.top().height == h) hh.amount += stk.top().amount; <span class="comment">// 如果两组人等高，就把两组人归到一组去</span></span><br><span class="line">            stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!stk.empty()) ++ans;</span><br><span class="line">        <span class="comment">// 在放当前的人进栈之前，如果栈非空，说明栈顶这个人是能看见当前的人的</span></span><br><span class="line">        stk.push(hh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="comment">// C(100000, 2) &gt; (1 &lt;&lt; 31)</span></span><br><span class="line">    <span class="comment">// 答案超过 int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>专项练习</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3884 洛谷P4139《上帝与集合的正确用法》</title>
    <url>/2019-07-18/BZOJ3884-Luogu-P4139/</url>
    <content><![CDATA[<blockquote>
<p>  $2^{2^{2^{2^{2^{…}}}}}$</p>
</blockquote>
<a id="more"></a>
<h1 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h1><p>根据一些书上的记载，上帝的一次失败的创世经历是这样的：<br>第一天，    上帝创造了一个世界的基本元素，称做“元”。<br>第二天，    上帝创造了一个新的元素，称作“α”。“α”被定义为“元”构成的集合。容易发现，一共有两种不同的“α”。<br>第三天，    上帝又创造了一个新的元素，称作“β”。“β”被定义为“α”构成的集合。容易发现，一共有四种不同的“β”。<br>第四天，    上帝创造了新的元素“γ”，“γ”被定义为“β”的集合。显然，一共会有16种不同的“γ”。<br>如果按照这样下去，上帝创造的第四种元素将会有65536种，第五种元素将会有2^65536种。这将会是一个天文数字。<br>然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……<br>然而不久，当上帝创造出最后一种元素“θ”时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。<br>至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素“θ”一共有多少种？<br>上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对p取模后的值即可。<br>你可以认为上帝从“α”到“θ”一共创造了10^9次元素，或10^18次，或者干脆∞次。<br>一句话题意：<br>求 $2^{2^{2^{2^{2^{…}}}}}\bmod p$的值</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>接下来T行，每行一个正整数p，代表你需要取模的值</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>T行，每行一个正整数，为答案对p取模后的值</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h1 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h1><p>对于100%的数据，T&lt;=1000,p&lt;=10^7</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>一开始看到这个题目，我是懵逼的</p>
<p>这题让我们求$2^\infty\bmod p$的值，考虑把它转化一下</p>
<p>根据扩展欧拉定理可知</p>
<script type="math/tex; mode=display">
a ^ b= \begin{cases} a ^ {b \bmod \varphi(p)} \quad & \gcd(a,p)=1 \\ a ^ b \quad & \gcd(a,p) \not=1, b < \varphi(p)\\ a ^ {b \bmod \varphi(p) + \varphi (p)} \quad & \gcd(a,p) \not=1, b \ge \varphi(p)\\ \end{cases}</script><p>所以把它变成第三条的形式</p>
<script type="math/tex; mode=display">
2^{2^{2^{2^{2^{...}}}}}\bmod p=2^{2^{2^{2^{2^{...}}}} \bmod \varphi(p) + \varphi(p)}</script><p>把第一个2的指数摘出来单独康一康</p>
<script type="math/tex; mode=display">
2^{2^{2^{2^{...}}}} \bmod \varphi(p) + \varphi(p)</script><p>设$\varphi(p) + \varphi(p) = a$，上式变为</p>
<script type="math/tex; mode=display">
2^{2^{2^{2^{...}}}} \bmod a</script><p>好像在哪见过……那就再来一遍</p>
<script type="math/tex; mode=display">
2^{2^{2^{2^{2^{...}}}}}\bmod a=2^{2^{2^{2^{2^{...}}}} \bmod \varphi(a) + \varphi(a)}</script><p>这是个递归式！</p>
<p>那么解法就很显然了：<br>根据扩展欧拉定理，把指数部分变形，然后递归进去继续变形指数部分的指数部分……</p>
<hr>
<p>找一找递归出口<br>在模$p$的意义下，一个数的取值范围是$[0,p-1]$<br>考虑让这个数变成定值，显然$p=1$时，这个数为$0$<br>这个就是递归出口，当模数为1时，返回0</p>
<p>求$\varphi(i)$建议使用根号算法，更快一些</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &amp; <span class="number">1</span>) ret = ret * x % p;</span><br><span class="line">        x = x * x % p;</span><br><span class="line">        a &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">phi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = x, a = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span>) &#123; <span class="comment">// 如果i是a的质因子</span></span><br><span class="line">            ret = ret / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i; <span class="comment">// 筛去所有的i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">1</span>) ret = ret / a * (a - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> pp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> pf = phi(pp);</span><br><span class="line">    <span class="keyword">return</span> fastPower(<span class="number">2</span>, solve(pf) + pf, pp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T = getint();</span><br><span class="line">    countdown (T) &#123;</span><br><span class="line">        p = getll();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, solve(p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>EXGCD</tag>
      </tags>
  </entry>
  <entry>
    <title>关于近期对博客大部分文章进行整理的说明</title>
    <url>/2019-07-12/Articles-Reform/</url>
    <content><![CDATA[<p>利用这几天时间对博客文章的排版、一句话说明、标签等内容进行修改和更新</p>
<p>博客主题也有大幅度变动的可能</p>
<p>特此说明</p>
]]></content>
      <tags>
        <tag>博客相关</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3907《圈的异或》</title>
    <url>/2019-07-12/Luogu-P3907/</url>
    <content><![CDATA[<blockquote>
<p>  暴力 DFS 即可<small>(???)</small></p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出无向图G，边(A_i,B_i) 的权是C_i，判断下列性质是否成立：</p>
<p>对于任意圈C，其边权的异或和是0</p>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第1 行，1 个整数T，表示数据的组数。</p>
<p>每组数据第1 行，2 个整数N,M，表示图G 点和边的数量。</p>
<p>M 行，每行3 个整数A_i,B_i,C_i</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>对每个数据输出一行，“Yes” 或者“No”</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p>输入 #1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 2</span><br><span class="line">3 1 3</span><br><span class="line">1 1</span><br><span class="line">1 1 1</span><br></pre></td></tr></table></figure>
<p>输出 #1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>第一反应搜索</p>
<p>其他的都没的说，如何判断异或和？</p>
<p>维护一个 $\text{prefix[x]}​$ 数组表示 dfs 序中从起点到点$\text{x}​$的边权异或和，可以理解为一个类似于前缀和的东西 <br>它工作是这样一个过程：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1g4xcci5vtrj30mg0jijsh.jpg" alt="image-20190712204439157"></p>
<p>比如说这么一个图，我从 6 开始搜索</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4xcltwnf5j30mg0jh0vn.jpg" alt="image-20190712205341779"></p>
<p>当前搜到了 5，检测出来返祖边了，在这停下不知所措<br>黑色部分是$\text{prefix[5]}$，青色部分是$\text{prefix[1]}$</p>
<p>那么答案就是从 1 走到 5 的异或和（设为$X$） $\text{xor}$ $\text{weight}(1,5)$ <br>$X$怎么求？来想一想 $\text{xor}$ 的性质吧：$a \text{ xor } a=0, a\text{ xor }0=a $  <br>那么……</p>
<script type="math/tex; mode=display">
\text{sum[5]}=X\text{ xor sum[1]}\\
\text{sum[5] xor sum[1]}
\\=X \text{ xor sum[1] xor sum[1]}
\\=X\text{ xor 0}</script><p>$\text{prefix[5]}=X \text{ xor prefix[1]}$  <br>所以 $\text{prefix[5] xor prefix[1]}$ <br>$=X \text{ xor prefix[1] xor prefix[1]}\=X \text{ xor } 0 \ = X$</p>
<p>！！！<br>那么求 $X$ 就直接把上面那俩 xor 一下就行了</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> next, weight;</span><br><span class="line">        </span><br><span class="line">        Edge() &#123; next = weight = <span class="number">0</span>; &#125;</span><br><span class="line">        Edge(<span class="keyword">int</span> next, <span class="keyword">int</span> weight) : next(next), weight(weight) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Edge&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> prefix[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN], exitNeeded;</span><br><span class="line"></span><br><span class="line">    Graph() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(prefix, <span class="number">0</span>, <span class="keyword">sizeof</span> prefix);</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">        exitNeeded = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        head[prev].push_back((Edge) &#123; next, weight &#125;);</span><br><span class="line">        head[next].push_back((Edge) &#123; prev, weight &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> last, <span class="keyword">int</span> ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (exitNeeded) <span class="keyword">return</span>;</span><br><span class="line">        vis[now] = <span class="literal">true</span>;</span><br><span class="line">        prefix[now] = ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, siz = (<span class="keyword">int</span>) head[now].size(); i &lt; siz &amp;&amp; !exitNeeded; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> next = head[now][i].next;</span><br><span class="line">            <span class="keyword">if</span> (!vis[next]) DFS(next, now, ans ^ head[now][i].weight);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 前面的点被搜过了，返祖边！</span></span><br><span class="line">                <span class="keyword">if</span> (now != last) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (head[now][i].weight ^ prefix[now] ^ prefix[next]) &#123;</span><br><span class="line">                        <span class="comment">// 对应解析中 X 的求法</span></span><br><span class="line">                        exitNeeded = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T = getint();</span><br><span class="line">    countdown (T) &#123;</span><br><span class="line">        Graph G;</span><br><span class="line">        n = getint(); m = getint();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = getint();</span><br><span class="line">            <span class="keyword">int</span> next = getint();</span><br><span class="line">            <span class="keyword">int</span> weight = getint();</span><br><span class="line">            G.addEdge(prev, next, weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!G.vis[i]) G.DFS(i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (G.exitNeeded) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(G.exitNeeded ? <span class="string">"No"</span> : <span class="string">"Yes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2023《维护序列》</title>
    <url>/2019-07-06/Luogu-P2023/</url>
    <content><![CDATA[<blockquote>
<p>  多操作线段树标记下方是有顺序的</p>
</blockquote>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。 有长为N的数列，不妨设为a1,a2,…,aN 。有如下三种操作形式：<br>(1)把数列中的一段数全部乘一个值;<br>(2)把数列中的一段数全部加一个值;<br>(3)询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模P的值。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：</p>
<p>第一行两个整数N和P(1≤P≤1000000000）。<br>第二行含有N个非负整数,从左到右依次为a1,a2,…,aN, (0≤ai≤1000000000,1≤i≤N)。<br>第三行有一个整数M，表示操作总数。<br>从第四行开始每行描述一个操作，输入的操作有以下三种形式：<br>操作1：“1 t g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai×c(1≤t≤g≤N,0≤c≤1000000000)。<br>操作2：“2 t g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai+c (1≤t≤g≤N,0≤c≤1000000000)。<br>操作3：“3 t g”(不含双引号)。询问所有满足t≤i≤g的ai的和模P的值 (1≤t≤g≤N)。<br>同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。</p>
<p>输出格式：</p>
<p>对每个操作3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 43</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">5</span><br><span class="line">1 2 5 5</span><br><span class="line">3 2 4</span><br><span class="line">2 3 7 9</span><br><span class="line">3 1 3</span><br><span class="line">3 4 7</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">35</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>多操作线段树模板题，同《线段树 2》</p>
<h3 id="大致方向"><a href="#大致方向" class="headerlink" title="大致方向"></a>大致方向</h3><p>首先我们来康一康只有区间加的时候怎么做 <br>维护一个标记<code>add[i]</code>表示节点<code>i</code>对应的区间<code>[l,r]</code>被加了多少 <br>在下放标记时，<code>sum[i]</code>会被更新为<code>sum[i] + add[i] * (r - l + 1)</code> <br>我们把它看作 $x + b$ 的形式，其中<code>sum[i]</code>对应$x$， <code>add[i]</code> 对应$b$，后面的看作常数就好啦 <br>那么区间加乘的形式就应该是 $ax+b$，也就意味着要多维护一个标记<code>mul[i]</code>表示节点<code>i</code>对应的区间<code>[l,r]</code>被乘了多少，<code>sum[i]</code>会被更新为<code>sum[i] * mul[i] + add[i] * (r - l + 1)</code> <br></p>
<hr>
<h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><p>先看乘法，比如<code>i</code>节点对应区间<code>[l,r]</code>被乘了一个$k$，本质上就是$k(ax+b)$，拆出来就是$kax + kb$，也就是把<code>mul[i]</code>和<code>add[i]</code>都乘上一个$k$ <br>加法本质上就是 $ax + b + k$，整理得 $ax + (b + k)$，那么把<code>add[i]</code>加上$k$就行了</p>
<h3 id="标记下放"><a href="#标记下放" class="headerlink" title="标记下放"></a>标记下放</h3><p>同样地，把每个节点看作 $ax+b$  的关系，在这里<code>i</code>节点对应的区间和<code>[l,r]</code>为$ax+b$，左子树<code>lc(i)</code>对应的区间和<code>[l, mid]</code>为$a’y+b’$ <br>遵循先乘后加的原则，对左子树乘上一个$a$得 <br><script type="math/tex">aa'y+ab'</script> <br>然后加上 $b$ <br><script type="math/tex">aa'y+ab'+b</script> <br>整理得 <br><script type="math/tex">(aa')y + (ab' + b)</script> <br>观察下这个式子，把它写成$ax+b$的形式 <br><script type="math/tex">Ay+B\ (A=aa',B=ab' + b)</script> <br>发现了什么？</p>
<p>本质上就是，<br>左子树的乘法标记 乘上 当前点的乘法标记 <br>左子树的加法标记 先乘上 当前点的乘法标记 再加上 当前点的加法标记</p>
<p><code>mul[lc(i)] *= mul[i], add[lc(i)] = add[lc(i)] * mul[i] + add[i]</code></p>
<p>对右子树进行一遍同样的操作，清空标记即可（稍有常识的人都知道<code>mul[i]</code>要初始化为1）</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> repp(a,s,t,i) for (int a = s; a &lt; t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, CH, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a[MAXN / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SegmentTree</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> mul[MAXN &lt;&lt; <span class="number">2</span>], add[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lc(x) ((x &lt;&lt; 1))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rc(x) ((x &lt;&lt; 1 | 1))</span></span><br><span class="line">    </span><br><span class="line">    SegmentTree() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="built_in">memset</span>(mul, <span class="number">1</span>, <span class="keyword">sizeof</span> mul);</span><br><span class="line">        <span class="built_in">memset</span>(add, <span class="number">0</span>, <span class="keyword">sizeof</span> add);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PushTag</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mul[root] == <span class="number">1</span> &amp;&amp; add[root] == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 该处标记不存在或已被下放</span></span><br><span class="line">        <span class="keyword">if</span> (l != r) &#123;</span><br><span class="line">            mul[lc(root)] = mul[lc(root)] * mul[root] % CH;</span><br><span class="line">            mul[rc(root)] = mul[rc(root)] * mul[root] % CH;</span><br><span class="line">            add[lc(root)] = (add[lc(root)] * mul[root] % CH + add[root]) % CH;</span><br><span class="line">            add[rc(root)] = (add[rc(root)] * mul[root] % CH + add[root]) % CH;</span><br><span class="line">        &#125;</span><br><span class="line">        sum[root] = (sum[root] * mul[root] % CH + add[root] * (r - l + <span class="number">1</span>) % CH) % CH;</span><br><span class="line">        mul[root] = <span class="number">1</span>; add[root] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *seq)</span> </span>&#123;</span><br><span class="line">        mul[root] = <span class="number">1</span>; add[root] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123; sum[root] = seq[l]; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        buildTree(lc(root), l, mid, seq);</span><br><span class="line">        buildTree(rc(root), mid + <span class="number">1</span>, r, seq);</span><br><span class="line">        sum[root] = (sum[lc(root)] + sum[rc(root)]) % CH;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">        PushTag(root, l, r);</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> sum[root];</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= mid) ret = (ret + Query(lc(root), l, mid, ll, rr)) % CH;</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= rr) ret = (ret + Query(rc(root), mid + <span class="number">1</span>, r, ll, rr)) % CH;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> method, <span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PushTag(root, l, r);</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (method == <span class="number">1</span>) &#123;</span><br><span class="line">                mul[root] = mul[root] * k % CH;</span><br><span class="line">                add[root] = add[root] * k % CH;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                add[root] = (add[root] + k) % CH;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= mid) Modify(method, lc(root), l, mid, ll, rr, k);</span><br><span class="line">        <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= rr) Modify(method, rc(root), mid + <span class="number">1</span>, r, ll, rr, k);</span><br><span class="line">        PushTag(lc(root), l, mid);</span><br><span class="line">        PushTag(rc(root), mid + <span class="number">1</span>, r);</span><br><span class="line">        sum[root] = (sum[lc(root)] + sum[rc(root)]) % CH;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getint(); CH = getint();</span><br><span class="line">    rep (i, <span class="number">1</span>, n, <span class="number">1</span>) a[i] = getint();</span><br><span class="line">    Tree.buildTree(<span class="number">1</span>, <span class="number">1</span>, n, a);</span><br><span class="line">    m = getint();</span><br><span class="line">    countdown (m) &#123;</span><br><span class="line">        <span class="keyword">int</span> op = getint();</span><br><span class="line">        <span class="keyword">int</span> l = getint();</span><br><span class="line">        <span class="keyword">int</span> r = getint();</span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k = getll();</span><br><span class="line">                Tree.Modify(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, n, l, r, k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> k = getll();</span><br><span class="line">                Tree.Modify(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, n, l, r, k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Tree.Query(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2016《战略游戏》</title>
    <url>/2019-05-11/Luogu-P2016/</url>
    <content><![CDATA[<blockquote>
<p>最典型的树形DP</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Bob喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。</p>
<p>他要建立一个古城堡，城堡中的路形成一棵树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。</p>
<p>注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被了望到。</p>
<p>请你编一程序，给定一树，帮Bob计算出他需要放置最少的士兵.</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行 N，表示树中结点的数目。</p>
<p>第二行至第N+1行，每行描述每个结点信息，依次为：该结点标号i，k(后面有k条边与结点I相连)。</p>
<p>接下来k个数，分别是每条边的另一个结点标号r1，r2，…，rk。</p>
<p>对于一个n(0&lt;n&lt;=1500)个结点的树，结点标号在0到n-1之间，在输入数据中每条边只出现一次。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件仅包含一个数，为所求的最少的士兵数目。</p>
<p>例如，对于如下图所示的树：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       0</span><br><span class="line">1</span><br><span class="line">2      3</span><br></pre></td></tr></table></figure>
<p>答案为1（只要一个士兵在结点1上）。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 1</span><br><span class="line">1 2 2 3</span><br><span class="line">2 0</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题，就是这种树形DP最标准的形态<br>「选点DP」</p>
<hr>
<p>设 <code>dp[i][0/1]</code> 表示选/不选以i为根的子树时的最大值</p>
<p>转移方程很显然<br><code>dp[root][0] += dp[child][1]</code><br><code>dp[root][1] += std::min(dp[child][0], dp[child][1])</code></p>
<p>也就是</p>
<ul>
<li><p>如果我不选当前点，那么就必须选我儿子，不然我和我儿子之间这条路没人看</p>
</li>
<li><p>如果我选了当前点，我儿子干啥我是不管的，选一个最小的加上</p>
</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, dp[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    G[prev].push_back(next);</span><br><span class="line">    G[next].push_back(prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>, <span class="keyword">int</span> father = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    dp[root][<span class="number">1</span>] = <span class="number">1</span>; dp[root][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G[root]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == father) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(v, root);</span><br><span class="line">        dp[root][<span class="number">1</span>] += <span class="built_in">std</span>::min(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]);</span><br><span class="line">        dp[root][<span class="number">0</span>] += dp[v][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; id &gt;&gt; k;</span><br><span class="line">        ++id;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; qwq;</span><br><span class="line">            ++qwq;</span><br><span class="line">            addEdge(id, qwq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::min(dp[<span class="number">1</span>][<span class="number">0</span>], dp[<span class="number">1</span>][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2014《选课》</title>
    <url>/2019-05-11/Luogu-P2014/</url>
    <content><![CDATA[<blockquote>
<p>森林上的DP</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数N,M用空格隔开。(1&lt;=N&lt;=300,1&lt;=M&lt;=300)</p>
<p>接下来的N行,第I+1行包含两个整数ki和si, ki表示第I门课的直接先修课，si表示第I门课的学分。若ki=0表示没有直接先修课（1&lt;=ki&lt;=N, 1&lt;=si&lt;=20）。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一行，选M门课程的最大得分。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7  4</span><br><span class="line">2  2</span><br><span class="line">0  1</span><br><span class="line">0  4</span><br><span class="line">2  1</span><br><span class="line">7  1</span><br><span class="line">7  6</span><br><span class="line">2  2</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>注意到题目中的「每门课有一门或没有直接先修课」<br>所以这是一个森林</p>
<p>我们用一个虚拟点0把所有的树根连起来，构成一棵大树<br>接下来这个题目就从一个DAG上DP转化为了一个树形DP<br>但是！它事一个树形背包</p>
<hr>
<p>设<code>dp[i][j]</code>表示选以i为根的树j个节点</p>
<p>初始化方程：<br><code>dp[child][i] = dp[root][i] + weight[root]</code><br><code>(0 &lt;= i &lt; 还能选择的节点数)</code><br>至于为什么从零开始……因为可以选择的节点是root的子树的节点数减一，毕竟root占掉了一个节点</p>
<p>转移方程：<br><code>dp[root][i] = std::max(dp[root][k], dp[child][k-1]);</code><br><code>(1 &lt;= i &lt;= 还能选择的节点数)</code></p>
<p>答案：<br><code>dp[0][m]</code></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 首先这是一个森林</span></span><br><span class="line"><span class="comment"> * 令 f[i][j] 表示以 i 为根的子树选择前 j 个点的最大价值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line">    <span class="keyword">int</span> weight[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        head[prev].push_back(next);</span><br><span class="line">        weight[next] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 没得选了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> now : head[root]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                dp[now][i] = dp[root][i] + weight[now];</span><br><span class="line">            &#125;</span><br><span class="line">            DFS(now, k - <span class="number">1</span>); <span class="comment">// 对子树进行选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">                dp[root][i] = <span class="built_in">std</span>::max(dp[root][i], dp[now][i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; G;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev, weight;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; prev &gt;&gt; weight;</span><br><span class="line">        G.addEdge(prev, i, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    G.DFS(<span class="number">0</span>, m);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[<span class="number">0</span>][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1967「NOIP2013」《货车运输》</title>
    <url>/2019-03-30/Luogu-P1967/</url>
    <content><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>A国有n座城市，编号从  1到n，城市之间有  m  条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有  q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p>
<a id="more"></a>
<h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>第一行有两个用一个空格隔开的整数n,m，表示  A  国有n  座城市和  m  条道路。</p>
<p>接下来  m行每行3个整数  x, y, z，每两个整数之间用一个空格隔开，表示从  x号城市到y号城市有一条限重为  z  的道路。注意： <strong>  x  不等于  y，两座城市之间可能有多条道路 </strong> 。</p>
<p>接下来一行有一个整数 q，表示有 q 辆货车需要运货。</p>
<p>接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： <strong> x 不等于 y </strong> 。</p>
<h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>共有  q  行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出−1。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p><strong>输入 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2 4</span><br><span class="line">2 3 3</span><br><span class="line">3 1 1</span><br><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<p><strong>输出 #1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">-1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>题目让我们求对于每个司机，最多能运多少货物，也就是在给定的两点间必经路线中求最大边权，显然我们要最大化这个边权，才能使答案更优。</p>
<p>注意到一些边是无论如何都不会被经过的，这些边通常较小，经过它们会劣化答案。那么一个很显然的贪心就是，排个序，依次选择最大的边加入新图，尽量不选较小的边，直到新图联通且无环，两点间有唯一的不重复经过同一条边的路径</p>
<p>等等……这个是最大生成树？<strong>是的。</strong></p>
<hr>
<p>想一想答案怎么求。<br>既然新图有一个性质「两点间有唯一的不重复经过同一条边的路径」，那么走一遍这条路径不就求出答案了吗！</p>
<p>为什么不再往上走一走？能运载的最大货物量是由这条路径决定的，往上走只可能有两种结果：上面边权比最小值大，上面边权比最小值小。第一种情况对答案没有什么贡献（因为最大值影响不了最小值），第二种情况则会<strong>劣化答案</strong>！</p>
<p>显然这条路径被这两个点的 LCA 分成两段，从一个点向上到 LCA 再向下到另一个点，那么在求 LCA 往上蹦的过程中求一下最小值就行了。可以倍增。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <algorithm></algorithm></h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include "></a>include <iostream></iostream></h1><h1 id="include-2"><a href="#include-2" class="headerlink" title="include "></a>include <cstring></cstring></h1><h1 id="include-3"><a href="#include-3" class="headerlink" title="include "></a>include <cstdio></cstdio></h1><h1 id="define-FILE-IN-fname-freopen-fname-“r”-stdin"><a href="#define-FILE-IN-fname-freopen-fname-“r”-stdin" class="headerlink" title="define FILE_IN(fname) freopen(fname, “r”, stdin)"></a>define FILE_IN(<strong>fname) freopen(</strong>fname, “r”, stdin)</h1><h1 id="define-FILE-OUT-fname-freopen-fname-“w”-stdout"><a href="#define-FILE-OUT-fname-freopen-fname-“w”-stdout" class="headerlink" title="define FILE_OUT(fname) freopen(fname, “w”, stdout)"></a>define FILE_OUT(<strong>fname) freopen(</strong>fname, “w”, stdout)</h1><h1 id="define-IMPROVE-IO-std-ios-sync-with-stdio-false"><a href="#define-IMPROVE-IO-std-ios-sync-with-stdio-false" class="headerlink" title="define IMPROVE_IO() std::ios::sync_with_stdio(false)"></a>define IMPROVE_IO() std::ios::sync_with_stdio(false)</h1><p>using std::cin;<br>using std::cout;<br>using std::endl;</p>
<p>const int MAXN = 100000 + 10;<br>const int MAXM = MAXN * 5;<br>const int LOG = 21;</p>
<p>int n, m, q;</p>
<p>namespace Graph{<br>    struct RawEdge {<br>        int prev, next, weight;</p>
<pre><code>    bool operator &lt; (const RawEdge &amp;that) const {
        return weight &gt; that.weight;
    }
} redge[MAXM];

struct Edge {
    int now, next, weight;
} edge[MAXM];

int head[MAXN], cnt;

bool vis[MAXN];

void addEdge(int prev, int next, int weight) {
    edge[++cnt].now = next;
    edge[cnt].weight = weight;
    edge[cnt].next = head[prev];
    head[prev] = cnt;
}

struct UnionFind{
    int seq[MAXN];

    UnionFind() { memset(seq, 0, sizeof seq); }

    int Find(int x) {
        if (seq[x] == 0) return x;
        return seq[x] = Find(seq[x]);
    }

    bool Union(int x, int y) {
        x = Find(x); y = Find(y);
        if (x == y) return false;
        seq[x] = y;
        return true;
    }
} U;

void Kruskal() {
    std::sort(redge + 1, redge + 1 + m);
    for(int i = 1; i &lt;= m; ++i) {
        if (U.Union(redge[i].prev, redge[i].next)) {
            addEdge(redge[i].prev, redge[i].next, redge[i].weight);
            addEdge(redge[i].next, redge[i].prev, redge[i].weight);
        }
    }
}
</code></pre><p>}</p>
<p>namespace LCAs {<br>    using namespace Graph;<br>    int depth[MAXN], fa[MAXN][LOG], w[MAXN][LOG];</p>
<pre><code>void Search(int root) {
    vis[root] = true;
    for(int e = head[root]; e; e = edge[e].next) {
        int now = edge[e].now;
        if (vis[now]) continue;
        depth[now] = depth[root] + 1;
        fa[now][0] = root;
        w[now][0] = edge[e].weight;
        Search(now);
    }
}

int GetAnswer(int x, int y) {
    if (U.Find(x) != U.Find(y)) return -1;
    int ans = 0x7f7f7f7f;
    if (depth[x] &gt; depth[y]) std::swap(x,y);

    for (int i = LOG - 1; i &gt;= 0; --i) {
        if (depth[fa[y][i]] &gt;= depth[x]) {
            ans = std::min(ans, w[y][i]);
            y = fa[y][i];
        }
    }

    if (x == y) return ans;

    for (int i = LOG - 1; i &gt;= 0; --i) {
        if (fa[x][i] != fa[y][i]) {
            ans = std::min(ans, std::min(w[x][i], w[y][i]));
            x = fa[x][i];
            y = fa[y][i];
        }
    }

    ans = std::min(ans, std::min(w[x][0], w[y][0]));
    return ans;
}
</code></pre><p>}</p>
<p>int main() {<br>    using namespace LCAs;<br>    using namespace Graph;</p>
<pre><code>scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
for (int i = 1; i &lt;= m; ++i) {
    int x, y, z;
    scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);
    redge[i].prev = x;
    redge[i].next = y;
    redge[i].weight = z;
}

Kruskal();

for (int i = 1; i &lt;= n; ++i){
    if (!vis[i]) {
        depth[i] = 1;
        Search(i);
        fa[i][0] = i;
        w[i][0] = 0x7f7f7f7f;
    }
}
for (int i = 1; i &lt;= LOG - 1; ++i) {
    for (int j = 1; j &lt;= n; ++j) {
        fa[j][i] = fa[fa[j][i-1]][i-1];
        w[j][i] = std::min(w[j][i-1], w[fa[j][i-1]][i-1]);
    }
}

scanf(&quot;%d&quot;, &amp;q);
for (int i = 1; i &lt;= q; ++i) {
    int prev, next;
    cin &gt;&gt; prev &gt;&gt; next;
    printf(&quot;%d\n&quot;, GetAnswer(prev, next));
}
return 0;
</code></pre><p>}</p>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
        <tag>DFS</tag>
        <tag>LCA</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P5018「NOIP2018普及组」《对称二叉树》</title>
    <url>/2019-03-30/NOIP2018-PJ-Tree-Luogu-P5018/</url>
    <content><![CDATA[<blockquote>
<p>一个长得像暴力的正解</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树：</p>
<ol>
<li>二叉树；</li>
<li>将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。</li>
</ol>
<p>下图中节点内的数字为权值，节点外的 id 表示节点编号。</p>
<p><img src="https://cdn.luogu.org/upload/pic/43192.png" alt="1"></p>
<p>现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。</p>
<p>注意：只有树根的树也是对称二叉树。本题中约定，以节点T 为子树根的一棵“子 树”指的是：节点 T 和它的全部后代节点构成的二叉树。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 $1 \sim n$，其中节点 1 是树根。</p>
<p>第二行 n 个正整数，用一个空格分隔，第 i 个正整数 $v_i$​ 代表节点 i 的权值。</p>
<p>接下来 n 行，每行两个正整数 $l_i, r_i$，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 -1 表示。两个数之间用一个空格隔开。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 </span><br><span class="line">1 3 </span><br><span class="line">2 -1 </span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 </span><br><span class="line">2 2 5 5 5 5 4 4 2 3 </span><br><span class="line">9 10 </span><br><span class="line">-1 -1 </span><br><span class="line">-1 -1 </span><br><span class="line">-1 -1 </span><br><span class="line">-1 -1 </span><br><span class="line">-1 2 </span><br><span class="line">3 4 </span><br><span class="line">5 6 </span><br><span class="line">-1 -1 </span><br><span class="line">7 8</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模与约定】<br>共 25 个测试点。<br>$v_i ≤ 1000$。<br>测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。<br>测试点 $4 \sim 8, n ≤ 10$。<br>测试点 $9 \sim 12, n ≤ 10^5$ ，保证输入是一棵“满二叉树” 。<br>测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。<br>测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 1。<br>测试点 $21 \sim 25, n ≤ 10^6$ 。</p>
<p>本题约定：</p>
<p>层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 1。</p>
<p>树的深度：树中节点的最大层次称为树的深度。</p>
<p>满二叉树：设二叉树的深度为 h，且二叉树有 $2h−1$ 个节点，这就是满二叉树。</p>
<p>完全二叉树：设二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大 个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>场上没写这道题真是<big>血亏</big><br><del>被T3折磨得心态爆炸&nbsp;也没心情写这题了。。。</del></p>
<hr>
<p>首先它求的是满足要求的最大子树的<strong>大小</strong><br>那就先 DFS 一遍求出所有子树的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// nodes[root].treeSize 已经被赋值为1了</span></span><br><span class="line">    <span class="keyword">if</span> (nodes[root].leftChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].leftChild);</span><br><span class="line">        nodes[root].treeSize += nodes[LC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].rightChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].rightChild);</span><br><span class="line">        nodes[root].treeSize += nodes[RC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后呢？</p>
<p>一个很暴力的想法，就是暴力枚举根节点，判断一下这棵子树是否对称，对称就更新答案</p>
<p>判断对称是很好写的，递归即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckSymmetric</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">-1</span> &amp;&amp; n2 == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (n1 != <span class="number">-1</span> &amp;&amp; n2 != <span class="number">-1</span>) <span class="comment">/* 判断是否有完整的节点 */</span></span><br><span class="line">        &amp;&amp; nodes[n1].data == nodes[n2].data <span class="comment">/* 判断节点信息是否相同 */</span></span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n1), RC(n2)) <span class="comment">/* 递归判断两边的节点 */</span></span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n2), RC(n1)) <span class="comment">/* 递归判断中间的节点 */</span></span><br><span class="line">    ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 判断失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>「递归判断两边 / 中间的节点」，是这么回事</p>
<p><img src="https://cdn.luogu.org/upload/pic/43189.png" alt="2"></p>
<p>先假装节点<code>id = 2</code>不存在<br><!--好现在枚举到了`id = 10`的节点
来写一下伪代码
调用函数 CheckSymmetric((id = 10) -> LeftChild, (id = 10) -> RightChild)
.... n1 = 7, n2 = 8
.... n1 != -1, n2 != -1, 判断失败
.... n1 != -1, n2 != -1，判断成功，继续判断
|... nodes[n1].data == nodes[n2].data，判断成功，继续判断
|... 调用函数 CheckSymmetric
--></p>
<p>在进行递归的时候，判断的是<code>(id = 3, id = 6)</code>和<code>(id = 4, id = 5)</code><br>很明显判断对称的时候，要判断的就是这两个节点（和它们的子树）</p>
<hr>
<p>代码分析完了，来算算这份暴力的复杂度</p>
<ul>
<li><code>DFS</code> 不用说</li>
<li><code>CheckSymmetric</code> 的最坏情况是原树为完全二叉树，递归次数为树高（即 $\log_2n$），又因为要暴力枚举一共$n$个点，所以复杂度为$O(n\log_2 n)$</li>
</ul>
<p>综上，程序复杂度为$O(n\log_2n)$，是能过的</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC(x) ((nodes[x].leftChild))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC(x) ((nodes[x].rightChild))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> leftChild;</span><br><span class="line">    <span class="keyword">int</span> rightChild;</span><br><span class="line">    <span class="keyword">int</span> treeSize;</span><br><span class="line">    </span><br><span class="line">    Node() : data(<span class="number">0</span>), leftChild(<span class="number">0</span>), rightChild(<span class="number">0</span>), treeSize(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">&#125; nodes[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].leftChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].leftChild);</span><br><span class="line">        nodes[root].treeSize += nodes[LC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nodes[root].rightChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        DFS(nodes[root].rightChild);</span><br><span class="line">        nodes[root].treeSize += nodes[RC(root)].treeSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckSymmetric</span><span class="params">(<span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n1 == <span class="number">-1</span> &amp;&amp; n2 == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// leaf node</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        (n1 != <span class="number">-1</span> &amp;&amp; n2 != <span class="number">-1</span>)</span><br><span class="line">        &amp;&amp; nodes[n1].data == nodes[n2].data</span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n1), RC(n2))</span><br><span class="line">        &amp;&amp; CheckSymmetric(LC(n2), RC(n1))</span><br><span class="line">    ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nodes[i].data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nodes[i].leftChild &gt;&gt; nodes[i].rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// enumerate every subtree</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (CheckSymmetric(LC(i), RC(i))) &#123;</span><br><span class="line">            ans = <span class="built_in">std</span>::max(ans, nodes[i].treeSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>DFS</tag>
        <tag>暴力</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1092「NOIP2004」《虫食算》</title>
    <url>/2019-03-30/Luogu-P1092/</url>
    <content><![CDATA[<blockquote>
<p>调换搜索顺序以获得更快时间</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 43#9865#045</span><br><span class="line">+  8468#6633</span><br><span class="line"> 44445509678</span><br></pre></td></tr></table></figure>
<p>其中$#$号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。</p>
<p>现在，我们对问题做两个限制：</p>
<p>首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。</p>
<p>其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表午的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字：但是这N个字母并不一定顺序地代表0到N−1。输入数据保证N个字母分别至少出现一次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> BADC</span><br><span class="line">+CBDA</span><br><span class="line"> DCCC</span><br></pre></td></tr></table></figure>
<p>上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>包含四行。<br>第一行有一个正整数$N(N \le 26)$。</p>
<p>后面的三行，每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有NN位。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，即唯一的那组解。</p>
<p>解是这样表示的：输出N个数字，分别表示A,B,C,…所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">ABCED</span><br><span class="line">BDACE</span><br><span class="line">EBBAA</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 0 3 4 2</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>对于30％的数据，保证有$N \le 10$；</p>
<p>对于50％的数据，保证有$N \le 15$；</p>
<p>对于全部的数据，保证有$N \le 26$。</p>
<p>noip2004提高组第4题</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑暴力枚举每一个数字</p>
<p>肯定是过不去的</p>
<hr>
<p>考虑枚举算式中的每一个数</p>
<p>用时大大减小</p>
<p>但是可能会填出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 1111</span><br><span class="line">+1221</span><br><span class="line">-----</span><br><span class="line"> 2333</span><br></pre></td></tr></table></figure>
<p>这样的情况</p>
<p>显然这样的情况是无用的</p>
<p>就需要一个判断</p>
<p>耗时依然较高</p>
<hr>
<p>换一下搜索顺序，每列每列地填</p>
<p>在填完一列之后判断一下等式是否成立</p>
<p>就差不多了</p>
<p>虽然可能会耗点时间<br>但是省出来的时间是多得多的</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DDBUG(x,y) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; y;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MDBUG(comment) std::cerr &lt;&lt; comment;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getNum(x) ((ans[x]))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> giveNum(x,y) ((ans[x] = y))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">26</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans[MAXN], col[<span class="number">3</span> + <span class="number">2</span>][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ol[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// convert the letters to numbers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            col[i + <span class="number">1</span>][j + <span class="number">1</span>] = ol[i][j] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Checks &#123;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Check for unfilled letters</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (ans[i] == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Check that the equation is correct</span></span><br><span class="line">        <span class="keyword">int</span> nextBit = <span class="number">0</span>; <span class="comment">// addition carry</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// from right to left</span></span><br><span class="line">            <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> C = getNum(col[<span class="number">3</span>][i]);</span><br><span class="line">            <span class="keyword">if</span> ((A + B + nextBit) % n != C) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            nextBit = (<span class="keyword">bool</span>) ((A + B + nextBit) &gt;= n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Other equation correction checking</span></span><br><span class="line">        <span class="keyword">if</span> (getNum(col[<span class="number">1</span>][<span class="number">1</span>]) + getNum(col[<span class="number">2</span>][<span class="number">1</span>]) &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// The first one needs to be carried</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][i]);</span><br><span class="line">            <span class="keyword">int</span> C = getNum(col[<span class="number">3</span>][i]);</span><br><span class="line">            <span class="keyword">if</span> (A == <span class="number">-1</span> || B == <span class="number">-1</span> || C == <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((A + B) % n != C &amp;&amp; (A + B + <span class="number">1</span>) % n != C) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> column = n, <span class="keyword">int</span> line = <span class="number">1</span>, <span class="keyword">int</span> nextBit = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// from right to left</span></span><br><span class="line">    <span class="keyword">if</span> (Checks::check3()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Checks::check1()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Checks::check2()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getNum(col[line][column]) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// unfilled letter, fill it</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (line == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][column]);</span><br><span class="line">                <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][column]);</span><br><span class="line">                <span class="keyword">int</span> C = A + B + nextBit;</span><br><span class="line">                <span class="keyword">if</span> (C % n != i) <span class="keyword">continue</span>;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                giveNum(col[line][column], i);</span><br><span class="line">                DFS(column - <span class="number">1</span>, <span class="number">1</span>, (<span class="keyword">bool</span>) (C &gt;= n));</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">                giveNum(col[line][column], <span class="number">-1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">                giveNum(col[line][column], i);</span><br><span class="line">                DFS(column, line + <span class="number">1</span>, nextBit);</span><br><span class="line">                vis[i] = <span class="literal">false</span>;</span><br><span class="line">                giveNum(col[line][column], <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// filled letter</span></span><br><span class="line">        <span class="keyword">if</span> (line != <span class="number">3</span>) DFS(column, line + <span class="number">1</span>, nextBit);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> A = getNum(col[<span class="number">1</span>][column]);</span><br><span class="line">            <span class="keyword">int</span> B = getNum(col[<span class="number">2</span>][column]);</span><br><span class="line">            <span class="keyword">int</span> C = A + B + nextBit;</span><br><span class="line">            DFS(column - <span class="number">1</span>, <span class="number">1</span>, (<span class="keyword">bool</span>) (C &gt;= n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ol[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ol[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ol[<span class="number">2</span>];</span><br><span class="line">    Init();</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    DFS();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 735D《Taxes》</title>
    <url>/2019-03-23/CF735D/</url>
    <content><![CDATA[<blockquote>
<p><del>这™什么破题</del></p>
</blockquote>
<a id="more"></a>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>大概就是规定一个数的花费为它的最大真因子（除了本身以外的最大因数，如果这个数是质数，花费为1）</p>
<p>现在给你一个数 $n$，要求把它拆成几个数相加的形式（也可以不拆），使得拆完后每一个数的花费的和最小</p>
<p>输出这个最小的和</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>别告诉我你脑子里装的都是暴力</p>
<p>我现在来说几个有趣的性质</p>
<p>说完这道题就做完了</p>
<ol>
<li>哥德巴赫猜想（即任意大于2的偶数都可以被拆成两个质数的和）</li>
<li>对于任意大于5的非质奇数（即不是质数的奇数），都可以被拆成3和两个质数的和（哥德巴赫猜想的一个推论）</li>
</ol>
<p>好 现在假设哥德巴赫猜想成立 请读者自行证明第二条</p>
<hr>
<p>依据这两个性质，我们可以对这道题进行如下的分类讨论</p>
<ul>
<li>当给定的为质数时，花费为1</li>
<li>当给定的为偶数时，根据哥德巴赫猜想可以拆成两个质数，花费为2</li>
<li>当<code>给定的数-2</code>为质数时，这个数可以拆成2和<code>给定的数-2</code>两个质数，花费为2</li>
<li>否则这个数可以拆成3和<code>给定的数-3</code>，因为给定的数是奇数，显然<code>给定的数-3</code>是偶数，可以拆成两个质数，花费为3</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span> || x == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i) <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这什么破题啊</span></span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (isPrime(n)) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 根据哥德巴赫猜想，一个偶数可以被拆成两个质数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isPrime(n - <span class="number">2</span>)) <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这个数字可以被拆成 2 和另一个质数的和</span></span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 这个数字可以被拆成 3 和另一个偶数的和，这个偶数又可以被拆成两个质数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>数学</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2922《[USACO08DEC]秘密消息Secret Message》</title>
    <url>/2019-03-23/Luogu-P2922/</url>
    <content><![CDATA[<blockquote>
<p>在 Trie 中储存两个信息</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Bessie is leading the cows in an attempt to escape! To do this, the cows are sending secret binary messages to each other.</p>
<p>Ever the clever counterspy, Farmer John has intercepted the first b_i (1 &lt;= b_i &lt;= 10,000) bits of each of M (1 &lt;= M &lt;= 50,000) of these secret binary messages.</p>
<p>He has compiled a list of N (1 &lt;= N &lt;= 50,000) partial codewords that he thinks the cows are using. Sadly, he only knows the first c_j (1 &lt;= c_j &lt;= 10,000) bits of codeword j.</p>
<p>For each codeword j, he wants to know how many of the intercepted messages match that codeword (i.e., for codeword j, how many times does a message and the codeword have the same initial bits). Your job is to compute this number.</p>
<p>The total number of bits in the input (i.e., the sum of the b_i and the c_j) will not exceed 500,000.</p>
<p>Memory Limit: 32MB</p>
<p>POINTS: 270</p>
<p>贝茜正在领导奶牛们逃跑．为了联络，奶牛们互相发送秘密信息．</p>
<p>信息是二进制的，共有M(1≤M≤50000)条．反间谍能力很强的约翰已经部分拦截了这些信息，知道了第i条二进制信息的前bi(l《bi≤10000)位．他同时知道，奶牛使用N(1≤N≤50000)条密码．但是，他仅仅了解第J条密码的前cj(1≤cj≤10000)位．</p>
<p>对于每条密码J，他想知道有多少截得的信息能够和它匹配．也就是说，有多少信息和这条密码有着相同的前缀．当然，这个前缀长度必须等于密码和那条信息长度的较小者．</p>
<p>在输入文件中，位的总数（即∑Bi+∑Ci）不会超过500000.</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><ul>
<li><p>Line 1: Two integers: M and N</p>
</li>
<li><p>Lines 2..M+1: Line i+1 describes intercepted code i with an integer b_i followed by b_i space-separated 0’s and 1’s</p>
</li>
<li><p>Lines M+2..M+N+1: Line M+j+1 describes codeword j with an integer c_j followed by c_j space-separated 0’s and 1’s</p>
</li>
</ul>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><ul>
<li>Lines 1..M: Line j: The number of messages that the jth codeword could match.</li>
</ul>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5 </span><br><span class="line">3 0 1 0 </span><br><span class="line">1 1 </span><br><span class="line">3 1 0 0 </span><br><span class="line">3 1 1 0 </span><br><span class="line">1 0 </span><br><span class="line">1 1 </span><br><span class="line">2 0 1 </span><br><span class="line">5 0 1 0 0 1 </span><br><span class="line">2 1 1</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 </span><br><span class="line">3 </span><br><span class="line">1 </span><br><span class="line">1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Four messages; five codewords.</p>
<p>The intercepted messages start with 010, 1, 100, and 110.</p>
<p>The possible codewords start with 0, 1, 01, 01001, and 11.</p>
<p>0 matches only 010: 1 match</p>
<p>1 matches 1, 100, and 110: 3 matches</p>
<p>01 matches only 010: 1 match</p>
<p>01001 matches 010: 1 match</p>
<p>11 matches 1 and 110: 2 matches</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>查询前缀的题很容易想到 Trie</p>
<hr>
<p>维护两个信息 <code>pass</code> 和 <code>lasts</code><br><code>pass</code> 表示当前节点有多少条信息经过， <code>lasts</code> 表示有多少以当前节点结尾的信息（不一定没有相同的串）</p>
<p>插入就不说了，说说查询</p>
<hr>
<p>查询的时候，记一下路径上<code>lasts</code>的和（也就是拿原信息去匹配查询信息）</p>
<p>首先对于每一条查询信息，都分两种情况</p>
<ol>
<li>这条信息被完美的查询完了</li>
<li>这条信息查到一半断开了</li>
</ol>
<p>对于第二种情况，什么都不用管，输出统计的<code>lasts</code>的和就行<br>对于第一种情况，则需要减去<strong>查询信息</strong>的最后一个节点的<code>lasts</code>值，加上<code>pass</code>值再输出</p>
<p>为什么呢？</p>
<hr>
<p><strong><em>这里建议画图理解</em></strong></p>
<p>首先，如果查到一半断开了，那么答案就是<strong>用原信息去匹配查询信息</strong>的匹配数，也就是<code>lasts</code>的和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如下面的例子</span><br><span class="line">查询信息：</span><br><span class="line">rain_air_txdy</span><br><span class="line">原始信息：</span><br><span class="line">rain</span><br><span class="line">rain_air</span><br><span class="line">rain_air_tql（这个也是没法匹配的，后几个字符不同）</span><br><span class="line">那么匹配数就是2，即为答案</span><br></pre></td></tr></table></figure>
<p>如果查询完了，那么说明<strong>存在能匹配查询信息的原信息</strong>，所以「用原信息去匹配查询信息的匹配数」还不够，要再加上「用查询信息去匹配原信息的匹配数」，也就是<code>lasts的总和 + pass</code></p>
<p>有这么一种情况，就是<strong>原信息与查询信息相同</strong>，那么它在当前节点的<code>lasts</code>里面算了一次，在当前节点的<code>pass</code>又算了一次！所以要减去当前节点的<code>lasts</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如下面的例子</span><br><span class="line">查询信息：</span><br><span class="line">rain_air_txdy</span><br><span class="line">原始信息：</span><br><span class="line">rain_air_txdy_tql</span><br><span class="line">rain_air_txdy</span><br><span class="line">答案是啥？2</span><br><span class="line"></span><br><span class="line">注意到y这里的 pass 是2，把两条信息都算上了</span><br><span class="line">但同时y这里的 lasts 也是1啊！！！</span><br><span class="line">这不就重了吗，所以要减去 lasts</span><br></pre></td></tr></table></figure>
<p><del>我觉得我说的已经够通俗易懂了吧<img src="https://s2.ax1x.com/2019/03/23/AJ3jc8.png" alt="AJ3jc8.png" border="0"></del></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> pass, lasts;</span><br><span class="line">        <span class="keyword">int</span> next[<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        Node() &#123;</span><br><span class="line">            pass = lasts = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span> next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; node[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    Trie() &#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SwitchTo</span><span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">bool</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node[now].next[data] == <span class="number">0</span>) &#123;</span><br><span class="line">            node[now].next[data] = ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        now = node[now].next[data];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">switchTo</span><span class="params">(<span class="keyword">int</span> &amp;now, <span class="keyword">bool</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node[now].next[data] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        now = node[now].next[data];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= f; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> nf = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nf;</span><br><span class="line">            t.SwitchTo(pos, nf);</span><br><span class="line">            ++t.node[pos].pass;</span><br><span class="line">        &#125;</span><br><span class="line">        ++t.node[pos].lasts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, pos = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; f;</span><br><span class="line">        <span class="keyword">bool</span> cont = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= f; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nf = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; nf;</span><br><span class="line">            <span class="keyword">if</span> (cont &amp;&amp; t.switchTo(pos, nf)) &#123;</span><br><span class="line">                ans += t.node[pos].lasts;</span><br><span class="line">            &#125; <span class="keyword">else</span> cont = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cont) ans = ans - t.node[pos].lasts + t.node[pos].pass;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>USACO</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA1508《Equipment》</title>
    <url>/2019-03-23/UVA1508/</url>
    <content><![CDATA[<blockquote>
<p>ProjectDP - 33</p>
<p>状态压缩 + DFS</p>
</blockquote>
<a id="more"></a>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p><a href="https://uva.onlinejudge.org/external/15/p1508.pdf" target="_blank" rel="noopener">PDF</a></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先是这个玄学的数据范围（每个组只有5个元素）<br>很容易让人想到状压</p>
<hr>
<p>首先把 <code>k &gt;= 5</code> 的情况特判一下<br>可以选择超过5个组<br>那么显然选择最大的就行了</p>
<hr>
<p>对于每一个组，枚举它的每一种状态<br>对于这个状态，统计一下选择这个状态的总和（被选择了的数的和），与所有组里这个状态的总和取个 max</p>
<p>这样我们就获得了每一种状态总和的最大值<br>对它进行一遍 DFS</p>
<hr>
<p>这里说一个位运算技巧<br>枚举子集</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s0 = s; s0; s0 = s &amp; (s0 - <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>s0 即为 s 的某一个子集</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  33.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/3/9.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> qwq[<span class="number">5</span> + <span class="number">5</span>], grps[MAXN][<span class="number">5</span> + <span class="number">5</span>], dp[(<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span> + <span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s0 = s; s0; s0 = s &amp; (s0 - <span class="number">1</span>))</span><br><span class="line">        tmp = <span class="built_in">std</span>::max(tmp, dp[s0] + Search ((s0 ^ s), sum - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(qwq, <span class="number">0</span>, <span class="keyword">sizeof</span> qwq);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; ++j)&#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; grps[i][j];</span><br><span class="line">                qwq[j] = <span class="built_in">std</span>::max(qwq[j], grps[i][j]) ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">5</span> ; ++i) ans += qwq[i] ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> (dp)) ;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> stat = <span class="number">0</span>; stat &lt;= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>; ++stat) &#123;</span><br><span class="line">                    <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> sel = <span class="number">0</span>; sel &lt; <span class="number">5</span>; ++sel) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (stat &amp; (<span class="number">1</span> &lt;&lt; sel)) tmp += grps[i][sel];</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[stat] = <span class="built_in">std</span>::max(dp[stat], tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; Search((<span class="number">1</span> &lt;&lt; <span class="number">5</span>) - <span class="number">1</span>, k) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Android 自带的文件管理器打开文件</title>
    <url>/2019-03-19/Android-GetFilePathWithDocumentsProvider/</url>
    <content><![CDATA[<blockquote>
<p>Storage Access Framework</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Android4.4中引入了Storage Access Framework存储访问框架，简称（SAF）。SAF为用户浏览手机中存储的内容提供了方便，这些内容不仅包括文档、图片，视频、音频、下载，而且还包括所有由特定ContentProvider（须具有约定的API）提供的内容。不管这些内容来自于哪里，不管是哪个应用调用浏览系统文件内容的命令，系统都会用一个统一的界面让你去浏览。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>首先我们要传给它一个 Intent</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT);</span><br><span class="line">intent.setType(<span class="string">"text/plain"</span>); <span class="comment">// 选择文件类型，我设置为了纯文本</span></span><br><span class="line">intent.addCategory(Intent.CATEGORY_OPENABLE);</span><br><span class="line">startActivityForResult(intent, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>然后回调</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resultCode == RESULT_OK) &#123;</span><br><span class="line">        Uri uri = data.getData();</span><br><span class="line">        String filePath = GetFilePath.getPath(<span class="keyword">this</span>, uri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候的<code>filePath</code>存的就是文件的名称。可以尝试<code>Log</code>一下看看</p>
<p>这个时候看到了一个新的类<code>GetFilePath</code>，它是我<del>复制</del>手写的一个类，内部貌似是没有这个类的</p>
<p>看代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.ContentUris;</span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.database.Cursor;</span><br><span class="line"><span class="keyword">import</span> android.net.Uri;</span><br><span class="line"><span class="keyword">import</span> android.os.Build;</span><br><span class="line"><span class="keyword">import</span> android.os.Environment;</span><br><span class="line"><span class="keyword">import</span> android.provider.DocumentsContract;</span><br><span class="line"><span class="keyword">import</span> android.provider.MediaStore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetFilePath</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPath</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Uri uri)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// DocumentProvider</span></span><br><span class="line">        <span class="keyword">if</span> (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123;</span><br><span class="line">            <span class="comment">// ExternalStorageProvider</span></span><br><span class="line">            <span class="keyword">if</span> (isExternalStorageDocument(uri)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">                <span class="keyword">final</span> String[] split = docId.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">final</span> String type = split[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"primary"</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Environment.getExternalStorageDirectory() + <span class="string">"/"</span> + split[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// DownloadsProvider</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isDownloadsDocument(uri)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> String id = DocumentsContract.getDocumentId(uri);</span><br><span class="line">                <span class="keyword">final</span> Uri contentUri = ContentUris.withAppendedId(</span><br><span class="line">                        Uri.parse(<span class="string">"content://downloads/public_downloads"</span>), Long.valueOf(id));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> getDataColumn(context, contentUri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// MediaProvider</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (isMediaDocument(uri)) &#123;</span><br><span class="line">                <span class="keyword">final</span> String docId = DocumentsContract.getDocumentId(uri);</span><br><span class="line">                <span class="keyword">final</span> String[] split = docId.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">final</span> String type = split[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">                Uri contentUri = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"image"</span>.equals(type)) &#123;</span><br><span class="line">                    contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"video"</span>.equals(type)) &#123;</span><br><span class="line">                    contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"audio"</span>.equals(type)) &#123;</span><br><span class="line">                    contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> String selection = <span class="string">"_id=?"</span>;</span><br><span class="line">                <span class="keyword">final</span> String[] selectionArgs = <span class="keyword">new</span> String[]&#123;split[<span class="number">1</span>]&#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> getDataColumn(context, contentUri, selection, selectionArgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// MediaStore (and general)</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"content"</span>.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">            <span class="keyword">return</span> getDataColumn(context, uri, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// File</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"file"</span>.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">            <span class="keyword">return</span> uri.getPath();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the value of the data column for this Uri. This is useful for</span></span><br><span class="line"><span class="comment">     * MediaStore Uris, and other file-based ContentProviders.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context       The context.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri           The Uri to query.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selection     (Optional) Filter used in the query.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selectionArgs (Optional) Selection arguments used in the query.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The value of the _data column, which is typically a file path.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataColumn</span><span class="params">(Context context, Uri uri, String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String[] selectionArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Cursor cursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> String column = <span class="string">"_data"</span>;</span><br><span class="line">        <span class="keyword">final</span> String[] projection = &#123;column&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs,</span><br><span class="line">                    <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span> &amp;&amp; cursor.moveToFirst()) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> column_index = cursor.getColumnIndexOrThrow(column);</span><br><span class="line">                <span class="keyword">return</span> cursor.getString(column_index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (cursor != <span class="keyword">null</span>)</span><br><span class="line">                cursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri The Uri to check.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Whether the Uri authority is ExternalStorageProvider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExternalStorageDocument</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"com.android.externalstorage.documents"</span>.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri The Uri to check.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Whether the Uri authority is DownloadsProvider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isDownloadsDocument</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"com.android.providers.downloads.documents"</span>.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uri The Uri to check.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Whether the Uri authority is MediaProvider.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isMediaDocument</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"com.android.providers.media.documents"</span>.equals(uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/qq_17290407/article/details/81142931" target="_blank" rel="noopener">Android Uri和文件路径互相转换</a></p>
<p><a href="https://www.cnblogs.com/banbaise/p/4998661.html" target="_blank" rel="noopener">(转)Android调用系统自带的文件管理器进行文件选择并获得路径</a></p>
<p><a href="https://www.cnblogs.com/zgqys1980/p/5286208.html" target="_blank" rel="noopener">android: startActivityForResult用法详解
</a></p>
]]></content>
      <tags>
        <tag>Android 开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1868《饥饿的奶牛》</title>
    <url>/2019-03-09/Luogu-P1868/</url>
    <content><![CDATA[<blockquote>
<p>ProjectDP - 7</p>
<p>二分查找优化 DP</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。</p>
<p>现用汉语翻译为：</p>
<p>有N个区间，每个区间x，y表示提供的x~y共y-x+1堆优质牧草。你可以选择任意区间但不能有重复的部分。</p>
<p>对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，N，如题</p>
<p>接下来N行，每行一个数x，y，如题</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，最多能吃到的牧草堆数</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><p>3<br>1 3<br>7 8<br>3 4</p>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><p>5</p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>1&lt;=n&lt;=150000</p>
<p>0&lt;=x&lt;=y&lt;=3000000</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>很容易想到设 $dp[i]$ 表示前 $i$ 个区间最多能选多少，转移从最优的 $j\ (j&lt;i)$ 中转移</p>
<p>时间复杂度 $O(n^2)$，过不去</p>
<hr>
<p>第一维 $\forall i \in [1,n]$ 是雷打不动的，优化不了<br>考虑从第二维下手</p>
<p>首先 $dp[]$ 数组是单调不降的很显然吧<br>那么只需要选择最近的一个「区间无交集」的 $j$ 进行转移即可<br>这个 $j$ 可以二分查找求得</p>
<p>如果找不到这个 $j$ 的话就从上一次转移过来即可</p>
<p>转移方程：</p>
<p>$ dp[i] = \text{max}(dp[i-1],dp[j] \ \times\ (\text{j exists == true}) $<br>$ + (\text{segment[i]’s left endpoint} - \text{segment[i]’s right endpoint} + 1)) $</p>
<p>中间那个 $(\text{j exists == true})$ 是个布尔表达式，它的返回值为0或1</p>
<p>至此，时间复杂度被降为 $O(nlog_2n)$</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  7.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/3/9.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">150000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segment</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    </span><br><span class="line">    Segment() &#123; l = r = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Segment &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == that.r) <span class="keyword">return</span> l &lt; that.l;</span><br><span class="line">        <span class="keyword">return</span> r &lt; that.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; seg[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = x, ans = <span class="number">-2147482333</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (seg[mid].r &lt; seg[x].l) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            ans = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; seg[i].l &gt;&gt; seg[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(seg + <span class="number">1</span>, seg + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> pre = BinarySearch(i);</span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="number">-2147482333</span>) dp[i] = <span class="built_in">std</span>::max(dp[i - <span class="number">1</span>], seg[i].r - seg[i].l + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> dp[i] = <span class="built_in">std</span>::max(dp[i - <span class="number">1</span>], dp[pre] + seg[i].r - seg[i].l + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分查找</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2292《[HNOI2004]L语言》</title>
    <url>/2019-03-09/Luogu-P2292/</url>
    <content><![CDATA[<blockquote>
<p>Trie 的经典应用</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。</p>
<p>一段文章T是由若干小写字母构成。一个单词W也是由若干小写字母构成。一个字典D是若干个单词的集合。我们称一段文章T在某个字典D下是可以被理解的，是指如果文章T可以被分成若干部分，且每一个部分都是字典D中的单词。</p>
<p>例如字典D中包括单词{‘is’, ‘name’, ‘what’, ‘your’}，则文章‘whatisyourname’是在字典D下可以被理解的，因为它可以分成4个单词：‘what’, ‘is’, ‘your’, ‘name’，且每个单词都属于字典D，而文章‘whatisyouname’在字典D下不能被理解，但可以在字典D’=D+{‘you’}下被理解。这段文章的一个前缀‘whatis’，也可以在字典D下被理解，而且是在字典D下能够被理解的最长的前缀。</p>
<p>给定一个字典D，你的程序需要判断若干段文章在字典D下是否能够被理解。并给出其在字典D下能够被理解的最长前缀的位置。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件第一行是两个正整数n和m，表示字典D中有n个单词，且有m段文章需要被处理。之后的n行每行描述一个单词，再之后的m行每行描述一段文章。</p>
<p>其中1&lt;=n, m&lt;=20，每个单词长度不超过10，每段文章长度不超过1M。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于输入的每一段文章，你需要输出这段文章在字典D可以被理解的最长前缀的位置。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 </span><br><span class="line">is</span><br><span class="line">name</span><br><span class="line">what</span><br><span class="line">your</span><br><span class="line">whatisyourname</span><br><span class="line">whatisyouname</span><br><span class="line">whaisyourname</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14  （整段文章’whatisyourname’都能被理解）</span><br><span class="line">6  （前缀’whatis’能够被理解）</span><br><span class="line">0  （没有任何前缀能够被理解）</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这里选用 Trie 来做</p>
<hr>
<p>首先把所有的单词扔进树里，记一下最长单词的长度</p>
<p>枚举字符串的右端点 $r \in [0, \text{The string’s length} - 1]$<br>字符串的左端点 $l \in [max(r - \text{Max Length}, -1), r]$</p>
<p>判断一下这个子串$s[l + 1, r]$在 Trie 里是不是一个完整的单词，是的话就把答案更新为 $r + 1$ 并退出枚举左端点的循环</p>
<p>判断单词是否完整只要对每个单词的结尾字母打个标记就行</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TREE_ROOT 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXCHAR = <span class="number">1024</span> * <span class="number">1024</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxlength;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="comment">// 日常封装</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">int</span> linkson[<span class="number">26</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 直接用它来记子节点的位置，类似于链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> last;</span><br><span class="line">        </span><br><span class="line">        Node() &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            last = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">memset</span>(linkson, <span class="number">0</span>, <span class="keyword">sizeof</span> linkson);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; tree[MAXCHAR];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    Trie() &#123; cnt = <span class="number">0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// pos = root</span></span><br><span class="line">        maxlength = <span class="built_in">std</span>::max(maxlength, length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ins = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[pos].linkson[ins] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// insert</span></span><br><span class="line">                tree[pos].linkson[ins] = ++cnt;</span><br><span class="line">                ++tree[pos].size;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = tree[pos].linkson[ins];</span><br><span class="line">        &#125;</span><br><span class="line">        tree[pos].last = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// pos = root</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> que = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[pos].linkson[que] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            pos = tree[pos].linkson[que];</span><br><span class="line">            <span class="comment">// 这里也是和上边插入一模一样</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree[pos].last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> dp[MAXCHAR];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        T.Insert(s.c_str(), (<span class="keyword">int</span>) s.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>) s.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; len; ++r) &#123;</span><br><span class="line">            <span class="comment">// 枚举右端点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="built_in">std</span>::max(r - maxlength, <span class="number">-1</span>); l &lt;= r; ++l) &#123;</span><br><span class="line">                <span class="comment">// 枚举左端点</span></span><br><span class="line">                <span class="keyword">if</span> ((l == <span class="number">-1</span> || dp[l]) &amp;&amp; T.Find(s.c_str(), l + <span class="number">1</span>, r)) &#123;</span><br><span class="line">                    dp[r] = <span class="literal">true</span>;</span><br><span class="line">                    ans = r + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>各省省选</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>Trie 树学习笔记</title>
    <url>/2019-03-02/Trie/</url>
    <content><![CDATA[<blockquote>
<p>很简单的树形字符串结构</p>
</blockquote>
<a id="more"></a>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在计算机科学中，Trie，又称字典树、单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</p>
<p style="text-align: right">——百度百科</p>

<p>简单地说，Trie 树就是以字符串的字母为结构建立起来的一棵<strong>多根树</strong><br>画出来大概是这样的</p>
<p><img src="/images/Trie/1.png" alt></p>
<p>其中，这棵树有这些字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">AK</span><br><span class="line">AKN</span><br><span class="line">AKO</span><br><span class="line">AKI</span><br><span class="line">AC</span><br><span class="line">ACE</span><br></pre></td></tr></table></figure>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>都很简单。</p>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>给你一个字符串，要求把这个字符串插入到树中</p>
<p>首先指定树根为0，当前位置为树根<br>枚举字符串的每个字符，看一下当前字符在当前深度有没有，有的话就直接把「当前位置」切换为这个字符所处的位置，没有的话就往里插入这个字符再切换</p>
<p>建议配合代码理解</p>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>这里以查询是否被查询过为例</p>
<p>对于每一个字符，记一下以它为结尾的字符串是否被查询过<br>还是像插入一样切换当前位置，如果中间某一字符在那个深度没有，就直接返回字符串不存在<br>切换到字符串最后一个字符之后，看一下刚才记的那个变量是否为真即可</p>
<p>也还是建议配合代码理解</p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>这里以<a href="https://www.luogu.org/problemnew/show/P2580" target="_blank" rel="noopener">洛谷 P2580 于是他错误的点名开始了</a>为例</p>
<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>就是给你一堆字符串和一堆询问<br>对于每个询问，输出是否存在这个字符串<br>如果存在，输出它有没有被询问过</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本来这是一道<code>std::map</code>的模板题<br>但是我们是来学 Trie 的<br>那么当然要用 Trie 做啊（逃</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>也是上面那一题的代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line">    <span class="comment">// 日常封装</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">int</span> linkson[<span class="number">26</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 直接用它来记子节点的位置，类似于链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> rep;</span><br><span class="line">        </span><br><span class="line">        Node() &#123;</span><br><span class="line">            size = <span class="number">0</span>;</span><br><span class="line">            rep = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">memset</span>(linkson, <span class="number">0</span>, <span class="keyword">sizeof</span> linkson);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; tree[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    Trie() &#123; cnt = <span class="number">0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入</span></span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// pos = root</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ins = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[pos].linkson[ins] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// insert</span></span><br><span class="line">                tree[pos].linkson[ins] = ++cnt;</span><br><span class="line">                ++tree[pos].size;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = tree[pos].linkson[ins];</span><br><span class="line">            <span class="comment">// 前面提到的切换位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回值就0, 1, 2，用不着 int</span></span><br><span class="line">    <span class="function"><span class="keyword">short</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// pos = root</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> que = s[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[pos].linkson[que] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">2</span>; </span><br><span class="line">            <span class="comment">// 没找到这个名字</span></span><br><span class="line">            pos = tree[pos].linkson[que];</span><br><span class="line">            <span class="comment">// 这里也是和上边插入一模一样</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[pos].rep) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 重复点名</span></span><br><span class="line">        tree[pos].rep = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 炉石传说真好玩（逃</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        T.Insert(s.c_str(), (<span class="keyword">int</span>) s.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">switch</span>(T.Find(s.c_str(), (<span class="keyword">int</span>) s.size())) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"OK\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"REPEAT\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"WRONG\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3067《[USACO12OPEN]平衡的奶牛群Balanced Cow Subsets》</title>
    <url>/2019-03-02/Luogu-P3067/</url>
    <content><![CDATA[<blockquote>
<p>Meet in the middle + 状态压缩</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Farmer John’s owns N cows (2 &lt;= N &lt;= 20), where cow i produces M(i) units of milk each day (1 &lt;= M(i) &lt;= 100,000,000). FJ wants to streamline the process of milking his cows every day, so he installs a brand new milking machine in his barn. Unfortunately, the machine turns out to be far too sensitive: it only works properly if the cows on the left side of the barn have the exact same total milk output as the cows on the right side of the barn!</p>
<p>Let us call a subset of cows “balanced” if it can be partitioned into two groups having equal milk output. Since only a balanced subset of cows can make the milking machine work, FJ wonders how many subsets of his N cows are balanced. Please help him compute this quantity.</p>
<p>给n个数，从中任意选出一些数，使这些数能分成和相等的两组。</p>
<p>求有多少种选数的方案。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p>输入格式：</p>
<ul>
<li><p>Line 1: The integer N.</p>
</li>
<li><p>Lines 2..1+N: Line i+1 contains M(i).</p>
</li>
</ul>
<p>输出格式：</p>
<ul>
<li>Line 1: The number of balanced subsets of cows.</li>
</ul>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>There are 4 cows, with milk outputs 1, 2, 3, and 4.</p>
<p>There are three balanced subsets: the subset {1,2,3}, which can be partitioned into {1,2} and {3}, the subset {1,3,4}, which can be partitioned into {1,3} and {4}, and the subset {1,2,3,4} which can be partitioned into {1,4} and {2,3}.</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先看一眼数据范围</p>
<hr>
<p>对于每一个数，有三种状态：</p>
<ul>
<li>放在左边的集合里</li>
<li>放在右边的集合里</li>
<li>不选</li>
</ul>
<p>好，一个 $O(3^n)$ 的算法就出来了<br>但是过不去</p>
<hr>
<p>考虑优化<br>可用 Meet in the middle 进行优化</p>
<p>对两个区间 $[1, \frac{n}{2}]$ 和 $[\frac{n}{2} + 1, n]$ 分别搜索，时间复杂度降为 $O(3^{\frac{n}{2}})$ ，或者说 $O(\sqrt{(3^n)})$</p>
<p><del>合并答案这部分我在学的时候也不大理解</del></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">" = "</span> &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FIXED_N = <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    </span><br><span class="line">    S() &#123; sum = status = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; cca[(<span class="number">1</span> &lt;&lt; FIXED_N)], ccb[(<span class="number">1</span> &lt;&lt; FIXED_N)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[MAXN], cnta, cntb, ans;</span><br><span class="line"><span class="keyword">bool</span> uniq[(<span class="number">1</span> &lt;&lt; FIXED_N)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> sum, <span class="keyword">int</span> stat, S cc[], <span class="keyword">int</span> &amp;cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        cc[++cnt].sum = sum;</span><br><span class="line">        cc[cnt].status = stat;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Search(l + <span class="number">1</span>, r, sum, stat, cc, cnt); <span class="comment">// don't choose</span></span><br><span class="line">    Search(l + <span class="number">1</span>, r, sum - a[l], stat + (<span class="number">1</span> &lt;&lt; (l - <span class="number">1</span>)), cc, cnt); <span class="comment">// put the cow to set1</span></span><br><span class="line">    Search(l + <span class="number">1</span>, r, sum + a[l], stat + (<span class="number">1</span> &lt;&lt; (l - <span class="number">1</span>)), cc, cnt); <span class="comment">// put the cow to set2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeAnswer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// double-pointer</span></span><br><span class="line">    <span class="keyword">int</span> p1 = <span class="number">1</span>, p2 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= cnta &amp;&amp; p2 &lt;= cntb) &#123;</span><br><span class="line">        <span class="keyword">while</span> (-cca[p1].sum &lt; ccb[p2].sum &amp;&amp; p2 &lt;= cntb) ++p2;</span><br><span class="line">        <span class="keyword">int</span> originalp2 = p2;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= cntb &amp;&amp; -cca[p1].sum == ccb[p2].sum) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uniq[cca[p1].status | ccb[p2].status] == <span class="literal">false</span>) &#123;</span><br><span class="line">                uniq[cca[p1].status | ccb[p2].status] = <span class="literal">true</span>;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">            ++p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 + <span class="number">1</span> &lt;= cnta &amp;&amp; -cca[p1].sum == -cca[p1 + <span class="number">1</span>].sum) p2 = originalp2;</span><br><span class="line">        ++p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpa</span><span class="params">(S x, S y)</span> </span>&#123; <span class="keyword">return</span> x.sum &lt; y.sum; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpb</span><span class="params">(S x, S y)</span> </span>&#123; <span class="keyword">return</span> x.sum &gt; y.sum; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    Read();</span><br><span class="line">    Search(<span class="number">1</span>, n / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, cca, cnta);</span><br><span class="line">    Search(n / <span class="number">2</span> + <span class="number">1</span>, n , <span class="number">0</span>, <span class="number">0</span>, ccb, cntb);</span><br><span class="line">    <span class="built_in">std</span>::sort(cca + <span class="number">1</span>, cca + <span class="number">1</span> + cnta, cmpa);</span><br><span class="line">    <span class="built_in">std</span>::sort(ccb + <span class="number">1</span>, ccb + <span class="number">1</span> + cntb, cmpb);</span><br><span class="line">    mergeAnswer();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>USACO</tag>
        <tag>搜索</tag>
        <tag>Meet in the middle</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4799《[CEOI2015 Day2]世界冰球锦标赛》</title>
    <url>/2019-03-02/Luogu-P4799/</url>
    <content><![CDATA[<blockquote>
<p><strong>稍微</strong>简单的Meet in the middle题目</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先来介绍一下「Meet in the middle」是个啥</p>
<p>顾名思义，Meet in the middle 就是「在中间相遇」，也就是对前一半状态和后一半状态分别进行搜索，最后合并两次搜索产生的答案</p>
<p>这样的搜索优化（我个人认为这是优化）可以把时间复杂度开一个二次根号</p>
<p>思想和实现都很简单，难度主要是在合并答案这一块，一般是利用单调性进行合并</p>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>译自 CEOI2015 Day2 T1「Ice Hockey World Championship」</p>
<p>今年的世界冰球锦标赛在捷克举行。Bobek 已经抵达布拉格，他不是任何团队的粉丝，也没有时间观念。他只是单纯的想去看几场比赛。如果他有足够的钱，他会去看所有的比赛。不幸的是，他的财产十分有限，他决定把所有财产都用来买门票。</p>
<p>给出 Bobek 的预算和每场比赛的票价，试求：如果总票价不超过预算，他有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行，两个正整数 $N$ 和 $M(1 \leq N \leq 40,1 \leq M \leq 10^{18})$，表示比赛的个数和 Bobek 那家徒四壁的财产。</p>
<p>第二行，$N$ 个以空格分隔的正整数，均不超过 $10^{16}$，代表每场比赛门票的价格。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出一行，表示方案的个数。由于 $N$ 十分大，注意：答案 $\le 2^{40}$。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 1000</span><br><span class="line">100 1500 500 500 1000</span><br></pre></td></tr></table></figure>
<h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>八种方案分别是：</p>
<ul>
<li>一场都不看，溜了溜了</li>
<li>价格 100 的比赛</li>
<li>第一场价格 500 的比赛</li>
<li>第二场价格 500 的比赛</li>
<li>价格 100 的比赛和第一场价格 500 的比赛</li>
<li>价格 100 的比赛和第二场价格 500 的比赛</li>
<li>两场价格 500 的比赛</li>
<li>价格 1000 的比赛</li>
</ul>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一个很显然的思路就是暴力搜索<br>枚举所有的状态<br>最高要搜索 $2^{40}$ 次</p>
<p>这时候 Meet in the middle 就上场了。<br>我们把整个区间分成 $[1, \frac{n}{2}]$ 和 $[\frac{n}{2} + 1, n]$<br>对这两个区间进行分别搜索，得到<strong>两个区间可选的所有方案</strong>，分别存在两个数组 $f[i]$ 和 $b[i]$ 中</p>
<p>如何合并答案？</p>
<hr>
<p>首先你需要知道 <code>upper_bound()</code></p>
<p><code>upper_bound()</code>返回一个 iterator 它指向在<code>[first,last)</code>标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个大于value的值</p>
<p>通俗的讲，<code>upper_bound()</code>函数就是用来求第一个<strong>大于</strong>val的值的<strong>下标</strong>，内部使用二分查找实现<br>那排序肯定是没跑了（但是只需要对一个序列排序）（当然如果你两个序列都排序的话也没事，<code>upper_bound()</code>这里只用来查找一个序列）</p>
<p>枚举未排序序列的每一个元素（这里记为 $f[i]$，另一个序列中的元素记为 $b[i]$），显然 $m - f[i]$ 为「选择当前方案后剩下的钱数」，记为 $fafa$<br>对另一个序列 $b[i]$ 进行 <code>upper_bound()</code> 查找，找到第一个大于等于它的数的下标（这个数即为在另一个区间搜出来的「当前方案的花费」）<br>又因为这个区间是有序的，那么显然 <code>upper_bound()</code> 出来的下标<strong>之前</strong>的所有方案都是可选的（所有在它之前的方案花费都是小于等于 $fafa$ 的，自然是可选的），更新一下答案即可</p>
<p>写成代码是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(b + <span class="number">1</span>, b + <span class="number">1</span> + cntb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnta; ++i) &#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ext = m - f[i]; <span class="comment">// 对应之前的 fafa</span></span><br><span class="line">    ans += ((<span class="built_in">std</span>::upper_bound(b + <span class="number">1</span>, b + <span class="number">1</span> + cntb, ext) - b) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>至此这道题就做完了。<br>还有一个小的细节：<strong>三年 OI 一场空，不开 long long 见祖宗</strong></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">40</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FIXED_MAX = <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> suma[(<span class="number">1</span> &lt;&lt; FIXED_MAX) + <span class="number">10</span>], sumb[(<span class="number">1</span> &lt;&lt; FIXED_MAX) + <span class="number">10</span>], cnta, cntb;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> seq[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> &amp;cnt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; m) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">        a[++cnt] = sum;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Search(l + <span class="number">1</span>, r, sum, a, cnt); <span class="comment">// don't choose</span></span><br><span class="line">    Search(l + <span class="number">1</span>, r, sum + seq[l], a, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">mergeAnswer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">0l</span>l;</span><br><span class="line">    <span class="built_in">std</span>::sort(sumb + <span class="number">1</span>, sumb + <span class="number">1</span> + cntb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnta; ++i) &#123;</span><br><span class="line">        ret += (<span class="built_in">std</span>::upper_bound(sumb + <span class="number">1</span>, sumb + <span class="number">1</span> + cntb, m - suma[i]) - sumb) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// m - suma[i]: the money left when I choose suma[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; seq[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="keyword">int</span>) n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Search(<span class="number">1</span>, mid, <span class="number">0l</span>l, suma, cnta);</span><br><span class="line">    Search(mid + <span class="number">1</span>, (<span class="keyword">int</span>) n, <span class="number">0l</span>l, sumb, cntb);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mergeAnswer() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
        <tag>Meet in the middle</tag>
      </tags>
  </entry>
  <entry>
    <title>「文章」百名学生参训 礼堂“变身”教室</title>
    <url>/2019-02-16/SDWC-Article/</url>
    <content><![CDATA[<blockquote>
<p><strong>本文纯属胡扯</strong><br><strong>请勿当真</strong></p>
<p><big><big>正</big>&lt;/big&gt;月初八，年味儿正浓。但是，不少全国各地的中学生却来到了泰安。他们不是利用假期前来观光旅游的，而是进城参加竞赛培训。记者暗访发现，某未经教育部批准的机构培训机构打着“竞赛培训”“自主招生”的旗号，开设冬令营，面向全国各地中学招生。这个机构组织学生进行竞赛辅导、模拟考试。七天的培训，学费竟然高达3000元左右。</big></p>
</blockquote>
<a id="more"></a>
<p><img src="/images/SDWC-Article/1.jpg" alt="1"></p>
<p>记者了解到，不少高一、高二甚至初中学生参加这样的冬令营，目的是希望能够获得各类学科竞赛的奖项，从而在高校自主招生、保送生选拔录取中占得先机。为此，记者向多所“双一流”高校招生负责人求证，得到的一致答复是，获得自主招生认定与是否参加过竞赛培训没有任何关系，学生申请自主招生可以通过各种材料证明自己的特长，竞赛获奖证书只是其中很小一部分，并且自主招生最终认定结果，必须经由申请高校考核后确定。</p>
<big><big>四名学生一个宿舍
教学、食宿均安排在学校之内</big></big>

<p>正月初八，一辆又一辆大巴车开进泰安一中。一批批满脸稚气的中学生，拉着行李走进学校。工作人员协助学生们办理报到、入住、领取餐券等手续。不少学生家长陪同前来，但是，办完手续后，家长被告知“可以离开了”。工作人员的解释是，这里是封闭式管理，谢绝家长陪住。</p>
<p><img src="/images/SDWC-Article/3.jpg" alt="3"></p>
<p>此时，这所学校已经摇身变成一家培训教育机构寒假冬令营的营区。工作人员介绍，营区主要开设普通班、高级班两个班级，其中，普通班有学生200人，高级班有学生240人左右。这意味着来自全国各地的百余名学生参加这家机构的培训。</p>
<p>据介绍，营区的教学、食宿均安排在学校之内。每名学生的学费为2400元，另外不需缴纳食宿费。“四名学生一个宿舍。”工作人员说。</p>
<p>学校工作人员告诉记者，培训机构几乎包下了所有的宿舍房间。</p>
<big><big>从早八点半学到晚九点
后排学生只能看“现场直播”</big></big>

<p><img src="/images/SDWC-Article/2.jpg" alt="2"></p>
<p>培训课程已开课几天。营区占用一间大礼堂作为教室，学生们被分成了多个座位区，对应一个投影幕布。因为“教室”里的学生太多，在最后一排已经几乎看不见老师，只能通过听声音、看课件来听老师讲题。到下午4点，后方座位区已经有学生难以专注听课，趴到了桌子上。</p>
<p>记者探访营区，感受到了学生们高强度的学习节奏。现场公布的一份营地作息时间表显示，学生们每天的起床时间为6点至7点，之后有40分钟的早餐时间。8点开始上课，一直到11点半。中午学生有两小时左右的中餐和午休时间，之后又是3个半小时的课程。</p>
<p>入夜后，学生们也不能歇着。记者在营区看到，晚上6点刚过，吃过晚餐的学生陆陆续续回到机房开始自习。工作人员透露，晚上6点到9点是学生的答疑、考试和讲评时间。晚上10点查寝，11点熄灯。</p>
<big><big>拼竞赛争取进名校
任课教师多是竞赛金牌选手</big></big>

<p>小王是华北地区一所中学的初二学生。这次，他是由学校老师带队，与同学们一起参加竞赛的培训。小王很明确地告诉记者，上辅导班就是为了拼竞赛，获得进名校的“敲门砖”。“如果能在省赛区拿到一等奖，那么，申请211、985院校自主招生的通过概率就很大。全国学科竞赛夺金牌进国家集训队，就可以直接保送了。”</p>
<p>小王坦言，在老家学校里，大家主要的任务都在应对高考。老师讲课、考试都是围绕高考进行，竞赛生“吃不饱”。因为没有专门的竞赛指导老师，训练主要是靠从网上找习题。“来这里学，确实收获很大，这边老师讲的好几个知识点，一下子打通了我之前一年的困惑。”</p>
<p>培训机构市场部的一位工作人员告诉记者，如果只凭高中课堂学习的知识积累，去拼名校的自主招生，没有多大意义。因此，必须走一轮竞赛，材料才过硬。他透露，竞赛培训的主讲老师大部分是当年竞赛的金牌选手，培训中会有竞赛例题的讲解，还有模拟竞赛考试，学生可以充分熟悉考试的流程。</p>
<big><big>多所高校招办答复
自招认定与竞赛培训无关</big></big>

<p>今年1月，教育部印发了《关于做好2019年高校自主招生工作的通知》，从招生政策、招生程序、加强监管等方面提出规范高校自主招生的“十严格”要求。“十严格”中明确高校不得简单以论文、专利、中介机构举办的竞赛活动等作为报考条件和初审通过依据。此外，要严格审核申请材料，高校成立专门自主招生审核专家组，采用多名专家“背靠背”分别独立审核、复核等方式，对考生提交的证明材料进行全覆盖核查。</p>
<p>昨晚，本市多所“双一流”高校的招办负责人向记者表示，绝大多数考生最终能否获得自主招生的认定，与是否参加过竞赛、拿过奖没有必然联系，与竞赛培训更是无关。“我们严格遵守教育部相关规定，学生申请自主招生可以根据自己的兴趣和特长提交相关材料，竞赛成绩只是其中很小一部分。此外学生通过材料初审后，也必须要参加学校组织的自主招生初试和复试，通过并完成公示后才能获得认定。这些流程都与校外培训机构无关，希望学生能展现真实的才华。”一所“双一流”大学招办主任说道。</p>
<p>来源：泰安Fa♂︎报<br>供图：abc1763613206</p>
]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>记录</tag>
        <tag>OI相关</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1122《最大子树和》</title>
    <url>/2019-02-16/Luogu-P1122/</url>
    <content><![CDATA[<blockquote>
<p>ProjectDP - 35</p>
<p>最简单的树形DP问题</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：</p>
<p>一株奇怪的花卉，上面共连有N N朵花，共有N-1N−1条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。</p>
<p>老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数N(1 ≤ N ≤ 16000)。表示原始的那株花卉上共N朵花。</p>
<p>第二行有N个整数，第I个整数表示第I朵花的美丽指数。</p>
<p>接下来N-1行每行两个整数a,b，表示存在一条连接第a朵花和第b朵花的枝条。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过2147483647。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">-1 -1 -1 1 1 1 0</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">3 6</span><br><span class="line">4 7</span><br><span class="line">5 7</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1："><a href="#输出样例-1：" class="headerlink" title="输出样例#1："></a>输出样例#1：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模与约定】</p>
<p>对于60%的数据，有N≤1000；</p>
<p>对于100%的数据，有N≤16000。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>只需要一维</p>
<hr>
<p>设 $f[i]$ 表示以 $i$ 为根的子树的最大值</p>
<p>初始化：$f[i]$ 为结点 $i$ 的权值</p>
<p>转移：</p>
<script type="math/tex; mode=display">f[u] = f[u] + max(f[v], 0)</script><p>其中 $v$ 是 $u$ 的儿子</p>
<p>答案：$f$ 数组的最大值</p>
<hr>
<big><big><big>简单吧！</big></big></big>

<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  35.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/2/16.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="keyword">int</span> flower[MAXN], dp[MAXN], n, id[MAXN], ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[u] += std::max(0, dp[v]);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    dp[u] = flower[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = head[u].begin(); it != head[u].end(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*it) == fa) <span class="keyword">continue</span>;</span><br><span class="line">        DFS((*it), u);</span><br><span class="line">        dp[u] += <span class="built_in">std</span>::max(<span class="number">0</span>, dp[(*it)]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">std</span>::max(ans, dp[u]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; flower[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, next = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; prev &gt;&gt; next;</span><br><span class="line">        <span class="keyword">if</span> (prev &gt; next) <span class="built_in">std</span>::swap(prev, next);</span><br><span class="line">        head[prev].push_back(next);</span><br><span class="line">        head[next].push_back(prev);</span><br><span class="line">        ++id[next];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (root = <span class="number">1</span>; root &lt;= n; ++root)</span><br><span class="line">        <span class="keyword">if</span> (id[root] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    DFS(root, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
        <tag>ProjectDP</tag>
      </tags>
  </entry>
  <entry>
    <title>ST算法学习笔记</title>
    <url>/2019-02-15/RMQ-SparseTable/</url>
    <content><![CDATA[<blockquote>
<p>$O(1)$查询区间最值</p>
</blockquote>
<a id="more"></a>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>RMQ (Range Minimum/Maximum Query)问题是指：对于长度为n的数列A，回答若干询问RMQ(A,i,j)(i,j&lt;=n)，返回数列A中下标在i,j里的最小(大）值，也就是说，RMQ问题是指求区间最值的问题。</p>
<p style="text-align:right"> ——百度百科 </p>

<p>ST（Sparse Table，稀疏表）算法是求解RMQ问题的经典在线算法，以O(nlogn)时间预处理，然后在O(1)时间内回答每个查询。</p>
<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>ST算法实际上采用了DP的思想</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>定义 $F(i,j)$ 表示区间 $[i, i + 2^j - 1]$ 内的最小值，$P[i]$ 为原序列</p>
<p>那么显然</p>
<script type="math/tex; mode=display">F(i,0) = P[i]</script><p>状态转移方程？</p>
<hr>
<p>首先，任意一个区间的最小值等于 $min($这个区间前一半的最小值$,$ 这个区间后一半点最小值$)$<br>这个很好理解吧<br>把$F(\ )$结合进去，就是</p>
<script type="math/tex; mode=display">F(i,j) = min(F(i,j-1),F(i + 2^{j-1}, j - 1))</script><hr>
<p>还有什么细节？<br>上面的式子看的你很想递归是吧（反正我是）<br>如果你不想递归的话，你八成会：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ...)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; ...)</span><br><span class="line">        F[i][j] = ...</span><br></pre></td></tr></table></figure>
<p>其实……这样都是<strong>错</strong>的，这样会导致有几个状态被过早地枚举</p>
<p>我们要把枚举 $j$ 的循环<strong>放在外层</strong>，至于为什么……你模<small><small>拟</small>&lt;/small&gt;一下就行了</small></p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>此处的内容可能有点<strong>难以理解</strong>，请消化不了的同学多看几遍</p>
<hr>
<p>上面说了查询是 $O(1)$ 的<del>听起来就好简单啊</del></p>
<p>实现确实是很简单，但是原理就……<del>也是很简单</del></p>
<hr>
<p>首先给你一个定理：<br>对于任意 $x \in \mathbb{N^*}$ ，都有 $ 2^{\lfloor log_2(x) \rfloor} &gt; \lfloor \frac{x}{2} \rfloor $</p>
<p>然后令查询区间$[l,r]$的长度 $\text{len} = r - (l - 1),\ \text{ll} = log_2(\text{len})$<br>那么根据上边可得 $ 2^{\text{ll}} &gt; \lfloor \frac{len}{2} \rfloor $<br>这意味着什么？<br>这意味着查询的区间有重叠！<br>不过这并不能意味啥，重叠又怎么样，只是查询的区间变了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原来我们查询区间，都是查询这个区间的一半</span><br><span class="line">比如更新[l,r]之间的最小值就是</span><br><span class="line">f[l][r] = std::min(f[l][mid], f[mid + 1][r]);</span><br><span class="line"></span><br><span class="line">但是这次不一样，这次的mid超过了区间的一半</span><br><span class="line">那就可以这么写：</span><br><span class="line"></span><br><span class="line">int Query(int l, int r) &#123;</span><br><span class="line">    int k = std::log(r - (l - 1)) / std::log(2);</span><br><span class="line">    return std::min(f[l][k], f[r - ((1 &lt;&lt; k) -1)][k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>是 $O(1)$ 的吧</p>
<p>它查询的区间相当于是这样的：<br><strong>（画的不准确，仅供参考）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ _ _ _ _ _ _ _ _ </span><br><span class="line">-------====       f[l][k]</span><br><span class="line">       ====------ f[r - ((1 &lt;&lt; k) - 1)][k]</span><br><span class="line">       </span><br><span class="line">等号就是两个查询区间的并集</span><br></pre></td></tr></table></figure>
<p>这也就是它为什么不能查询区间和的原因<br><del>前缀和足够了</del></p>
<p><img src="https://cdn.luogu.org/upload/pic/5010.png" alt="qwq"></p>
<h1 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h1><p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ \text{Algorithm 1: Sparse Table} $<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ \text{Init(The Sparse Table } f, \text{The original sequence } a, \text{no return value})$<br>&nbsp;&nbsp;$ 1. \text{For } i \text{ from 1 to n do}$<br>&nbsp;&nbsp;$ 2. \ \ \ \ f[i][0] = a[i] $<br>&nbsp;&nbsp;$ 3. \text{End For} $<br>&nbsp;&nbsp;$ 4. \ j \leftarrow 1, i \leftarrow 1$<br>&nbsp;&nbsp;$ 5. \text{While } 2^j \leq n \text{ do} $<br>&nbsp;&nbsp;$ 6. \ \ \ \ \text{While } i + 2^j - 1 \leq n \text{ do} $<br>&nbsp;&nbsp;$ 7. \ \ \ \ \ \ \ \ f[i][j] = min(f[i][j-1], f[i + 2^{j-1}][j-1]) $<br>&nbsp;&nbsp;$ 8. \ \ \ \ \ \ \ \ i \leftarrow i + 1 $<br>&nbsp;&nbsp;$ 9. \ \ \ \ \text{End While}$<br>$ 10. \ \ \ \ j \leftarrow j + 1 $<br>$ 11. \text{End While} $ </p>
<p>$ \text{Query(}l,r\text{,return a value x}) $<br>$ 1. k \leftarrow log_2(r - l + 1)$<br>$ 2. \text{return } x = min(f[l][k], f[r - (2^k - 1)][k]$<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// luogu-judger-enable-o2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">100000</span> + <span class="number">10</span>) * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLOG = <span class="number">17</span> + <span class="number">10</span>; <span class="comment">// floor(log2(100000 + 10))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"><span class="keyword">int</span> Table[MAXN][MAXLOG];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; j) &lt;= n; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; ++i) &#123;</span><br><span class="line">            Table[i][j] = <span class="built_in">std</span>::max(Table[i][j<span class="number">-1</span>], Table[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="built_in">std</span>::<span class="built_in">log</span>(r - (l - <span class="number">1</span>)) / <span class="built_in">std</span>::<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::max(Table[l][k], Table[r - ((<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>)][k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;Table[i][<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 这里可以省去seq[i]，对Table[i][0]进行直接写入</span></span><br><span class="line">    BuildTable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Query(l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problemnew/show/P3865" target="_blank" rel="noopener">洛谷P3865【模板】ST表</a></p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法</tag>
        <tag>ST表</tag>
        <tag>RMQ问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Handwer's Blog 突破100篇文章</title>
    <url>/2019-02-14/100-articles/</url>
    <content><![CDATA[<p>2019年2月14日22点，在键盘的敲击声中，Handwer’s Blog的第100篇博客诞生了。</p>
<p>第一个里程碑已经达成，下一个里程碑：200篇</p>
<p>2019也要加油啊</p>
]]></content>
      <tags>
        <tag>博客相关</tag>
        <tag>只有经历过的人才知道的世界</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2504《[HAOI2006]聪明的猴子》</title>
    <url>/2019-02-14/Luogu-P2504/</url>
    <content><![CDATA[<blockquote>
<p>最小生成树板子题</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。</p>
<p>现在，在这个地区露出水面的有N棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。</p>
<p>在这个地区住着的猴子有M个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。</p>
<p>【问题】现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件monkey.in包括：</p>
<p>第1行为一个整数，表示猴子的个数M(2&lt;=M&lt;=500)；</p>
<p>第2行为M个整数，依次表示猴子的最大跳跃距离（每个整数值在1—1000之间）；</p>
<p>第3行为一个整数表示树的总棵数N(2&lt;=N&lt;=1000)；</p>
<p>第4行至第N+3行为N棵树的坐标（横纵坐标均为整数，范围为：-1000—1000）。</p>
<p>（同一行的整数间用空格分开）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件monkey.out包括一个整数，表示可以在这个地区的所有树冠上觅食的猴子数。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line"> 1 2 3 4</span><br><span class="line">6</span><br><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">1 2</span><br><span class="line">-1 -1</span><br><span class="line">-2 0</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模】</p>
<p>对于40%的数据，保证有2&lt;=N &lt;=100，1&lt;=M&lt;=100</p>
<p>对于全部的数据，保证有2&lt;=N &lt;= 1000，1&lt;=M=500</p>
<p>感谢@charlie003 修正数据</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先构造完全图（边数为初二数学内容），再跑一遍最小生成树</p>
<p>之后枚举每一个猴子，判断它的跳跃距离是否大于等于生成树的最大边权即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span>                  + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">500</span>                   + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXE = (MAXN - <span class="number">1</span>) * MAXN / <span class="number">2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    Node() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> previd, nextid;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    </span><br><span class="line">    Edge() &#123; previd = nextid = <span class="number">0</span>; weight = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; that.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edge[MAXE];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">    </span><br><span class="line">    UnionFind() &#123; <span class="built_in">memset</span>(seq, <span class="number">0</span>, <span class="keyword">sizeof</span> seq); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> !seq[x] ? x : (seq[x] = Find(seq[x])); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = Find(x); y = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        seq[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; U;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetDist</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> idy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> absx = <span class="built_in">std</span>::<span class="built_in">abs</span>(node[idx].x - node[idy].x);</span><br><span class="line">    <span class="keyword">int</span> absy = <span class="built_in">std</span>::<span class="built_in">abs</span>(node[idx].y - node[idy].y);</span><br><span class="line">    ret = <span class="built_in">sqrt</span>(absx * absx + absy * absy);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;</span><br><span class="line"><span class="keyword">int</span> monkey[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> maxWeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (U.Union(edge[i].previd, edge[i].nextid)) &#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            maxWeight = <span class="built_in">std</span>::max(maxWeight, edge[i].weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tot == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxWeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">cin</span> &gt;&gt; monkey[i];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">    <span class="comment">// initialize edges</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            edge[++cnt].previd = i;</span><br><span class="line">            edge[cnt].nextid = j;</span><br><span class="line">            edge[cnt].weight = GetDist(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> maxW = Kruskal();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (monkey[i] &gt;= maxW) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
        <tag>各省省选</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3243《[HNOI2015]菜肴制作》</title>
    <url>/2019-02-14/Luogu-P3243/</url>
    <content><![CDATA[<blockquote>
<p>反向建图 + 反向输出</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>知名美食家小 A被邀请至ATM 大酒店，为其品评菜肴。 ATM 酒店为小 A 准备了 N 道菜肴，酒店按照为菜肴预估的质量从高到低给予1到N的顺序编号，预估质量最高的菜肴编号为1。</p>
<p>由于菜肴之间口味搭配的问题，某些菜肴必须在另一些菜肴之前制作，具体的，一共有 M 条形如”i 号菜肴’必须’先于 j 号菜肴制作“的限制，我们将这样的限制简写为<i,j>。</i,j></p>
<p>现在，酒店希望能求出一个最优的菜肴的制作顺序，使得小 A能尽量先吃到质量高的菜肴：</p>
<p>也就是说，</p>
<p>(1)在满足所有限制的前提下，1 号菜肴”尽量“优先制作；</p>
<p>(2)在满足所有限制，1号菜肴”尽量“优先制作的前提下，2号菜肴”尽量“优先制作；</p>
<p>(3)在满足所有限制，1号和2号菜肴”尽量“优先的前提下，3号菜肴”尽量“优先制作</p>
<p>；(4)在满足所有限制，1 号和 2 号和 3 号菜肴”尽量“优先的前提下，4 号菜肴”尽量“优先制作；</p>
<p>(5)以此类推。</p>
<p>例1：共4 道菜肴，两条限制<3,1>、<4,1>，那么制作顺序是 3,4,1,2。</4,1></3,1></p>
<p>例2：共5道菜肴，两条限制<5,2>、 <4,3>，那么制作顺序是 1,5,2,4,3。</4,3></5,2></p>
<p>例1里，首先考虑 1，因为有限制<3,1>和<4,1>，所以只有制作完 3 和 4 后才能制作 1，而根据(3)，3 号又应”尽量“比 4 号优先，所以当前可确定前三道菜的制作顺序是 3,4,1；接下来考虑2，确定最终的制作顺序是 3,4,1,2。</4,1></3,1></p>
<p>例 2里，首先制作 1是不违背限制的；接下来考虑 2 时有<5,2>的限制，所以接下来先制作 5 再制作 2；接下来考虑 3 时有<4,3>的限制，所以接下来先制作 4再制作 3，从而最终的顺序是 1,5,2,4,3。 现在你需要求出这个最优的菜肴制作顺序。无解输出”Impossible!“ （不含引号，首字母大写，其余字母小写）</4,3></5,2></p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个正整数D，表示数据组数。 接下来是D组数据。 对于每组数据： 第一行两个用空格分开的正整数N和M，分别表示菜肴数目和制作顺序限制的条目数。 接下来M行，每行两个正整数x,y，表示”x号菜肴必须先于y号菜肴制作“的限制。（注意：M条限制中可能存在完全相同的限制）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件仅包含 D 行，每行 N 个整数，表示最优的菜肴制作顺序，或者“Impossible!“表示无解（不含引号）。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">5 4</span><br><span class="line">5 4</span><br><span class="line">5 3</span><br><span class="line">4 2</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">5 2</span><br><span class="line">5 2</span><br><span class="line">4 3</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 5 3 4 2 </span><br><span class="line">Impossible! </span><br><span class="line">1 5 2 4 3</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【样例解释】</p>
<p>第二组数据同时要求菜肴1先于菜肴2制作，菜肴2先于菜肴3制作，菜肴3先于</p>
<p>菜肴1制作，而这是无论如何也不可能满足的，从而导致无解。</p>
<p>100%的数据满足N,M&lt;=100000,D&lt;=3。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目要求「“尽量”优先」<br>那么跑字典序最小拓扑肯定是不行的</p>
<p>那么……<br>考虑反向建图。<br>反向建图跑字典序最大拓扑，这时的拓扑序是「一直选择大的，不行再选择小的」，那么反向输出即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXNM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; rtop;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rhead[MAXNM];</span><br><span class="line"><span class="keyword">int</span> id[MAXNM], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!id[i]) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        rtop.push(u);</span><br><span class="line">        <span class="keyword">int</span> siz = (<span class="keyword">int</span>) rhead[u].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = rhead[u][i];</span><br><span class="line">            --id[v];</span><br><span class="line">            <span class="keyword">if</span> (id[v]) <span class="keyword">continue</span>;</span><br><span class="line">            q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(id, <span class="number">0</span>, <span class="keyword">sizeof</span> id);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, next = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; next &gt;&gt; prev; <span class="comment">// reverse</span></span><br><span class="line">        rhead[prev].push_back(next);</span><br><span class="line">        ++id[next];</span><br><span class="line">    &#125;</span><br><span class="line">    Topsort();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        rhead[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rtop.size() &lt; n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span> (!rtop.empty()) rtop.pop();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!rtop.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; rtop.top() &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        rtop.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="keyword">int</span> T = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Solve();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>拓扑序</tag>
        <tag>图论</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4047《[JSOI2010]部落划分》</title>
    <url>/2019-02-14/Luogu-P4047/</url>
    <content><![CDATA[<blockquote>
<p>最小生成树后删边</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。</p>
<p>不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了N个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了K个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法：</p>
<p>对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。</p>
<p>例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件第一行包含两个整数N和K(1&lt;=N&lt;=1000,1&lt;K&lt;=N)，分别代表了野人居住点的数量和部落的数量。</p>
<p>接下来N行，每行包含两个正整数x,y，描述了一个居住点的坐标(0&lt;=x, y&lt;=10000)。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，为最优划分时，最近的两个部落的距离，精确到小数点后两位。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">0 0</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.00</span><br></pre></td></tr></table></figure>
<h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 3</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">3 2</span><br><span class="line">3 3</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br><span class="line">4 6</span><br><span class="line">6 2</span><br><span class="line">6 3</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.00</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们首先对这几个点构建一个完全图</p>
<p>边数的计算属于初中数学内容（$\frac{n(n-1)}{2}$）</p>
<p>然后对这个图跑一遍最小生成树</p>
<p>删去生成树中最大的 $k-1$ 条边，这时候整个图就变成了 $k$ 个联通块，即为题目要求的部落</p>
<p>输出删去边的最小边权即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = (MAXN * (MAXN - <span class="number">1</span>)) / <span class="number">2</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    </span><br><span class="line">    Node() &#123; x = y = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prev;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    </span><br><span class="line">    Edge() &#123; prev = next = <span class="number">0</span>; weight = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; that.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">    </span><br><span class="line">    UnionFind() &#123; <span class="built_in">memset</span>(seq, <span class="number">0</span>, <span class="keyword">sizeof</span> seq); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> !seq[x] ? x : (seq[x] = Find(seq[x])); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = Find(x); y = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        seq[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; U;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetPath</span><span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="built_in">std</span>::<span class="built_in">abs</span>(x.x - y.x);</span><br><span class="line">    <span class="keyword">int</span> Y = <span class="built_in">std</span>::<span class="built_in">abs</span>(x.y - y.y);</span><br><span class="line">    ret = <span class="built_in">sqrt</span>(X * X + Y * Y);</span><br><span class="line">    <span class="comment">// 勾股定理，初中数学</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + cnt);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">bool</span> routput = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (tot == n - k) routput = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 这里用了一个小技巧，加到 (n - k + 1) 条边的时候就可以输出，</span></span><br><span class="line">        <span class="comment">// 而不用到最后删边，因为边权是经过排序的</span></span><br><span class="line">        <span class="keyword">if</span> (U.Union(edge[i].prev, edge[i].next)) &#123;</span><br><span class="line">            ++tot;</span><br><span class="line">            <span class="keyword">if</span> (routput) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">2</span>) &lt;&lt; edge[i].weight &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; node[i].x &gt;&gt; node[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造完全图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            edge[++cnt].prev = i;</span><br><span class="line">            edge[cnt].next = j;</span><br><span class="line">            edge[cnt].weight = GetPath(node[i], node[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>各省省选</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1108《低价购买》</title>
    <url>/2019-02-14/Luogu-P1108/</url>
    <content><![CDATA[<blockquote>
<p>最长下降子序列套一个玄学计数</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价($2^{16}$范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。</p>
<p>这里是某支股票的价格清单：</p>
<p>日期 1,2,3,4,5,6,7,8,9,10,11,12<br>价格 68,69,54,64,68,64,70,67,78,62,98,87<br>最优秀的投资者可以购买最多44次股票，可行方案中的一种是：</p>
<p>日期 2,5,6,10<br>价格 69,68,64,62</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1行: N(1≤N≤5000)，股票发行天数</p>
<p>第2行: N个数，是每天的股票价格。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>两个数:<br>最大购买次数和拥有最大购买次数的方案数( $\le 2^{31}$ )当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这22种方案被认为是相同的。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">68 69 54 64 68 64 70 67 78 62 98 87</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先第一问肯定谁都会求<br>跑一遍最长下降子序列算完</p>
<p>关键是第二问</p>
<hr>
<p>令 $ dp[i] $ 表示以 $i$ 结尾的最长下降子序列的长度，$cdp[i]$ 表示以 $i$ 结尾的最长下降子序列的个数<br>规定 $s[\ ]$ 为「原序列」</p>
<p>那么就有</p>
<ul>
<li>当 $dp[i] = dp[j]$ 且 $s[i] = s[j]$ 时，就直接把 $cdp[j]$ 记为 $0$，防止重复计数</li>
<li>当 $dp[i] = dp[j] + 1$ 且 $s[i] &lt; s[j]$ 时，说明数列能接上了，$cdp[i] = cdp[i] + cdp[j]$</li>
</ul>
<p>最后答案输出 </p>
<script type="math/tex; mode=display">\sum_{i = 1}^{n} cdp[i] \ (dp[i] = \text{The max value of array } dp[i] )</script><p>即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[MAXN], dp[MAXN], cdp[MAXN], maxLen;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[j]) dp[i] = <span class="built_in">std</span>::max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == <span class="number">0</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">        maxLen = <span class="built_in">std</span>::max(maxLen, dp[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == dp[j] &amp;&amp; a[i] == a[j]) cdp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dp[i] == dp[j] + <span class="number">1</span> &amp;&amp; a[i] &lt; a[j]) cdp[i] += cdp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cdp[i] == <span class="number">0</span>) cdp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == maxLen) ans += cdp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxLen &lt;&lt; <span class="string">' '</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>「序列」DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1896《[SCOI2005]互不侵犯》</title>
    <url>/2019-02-14/Luogu-P1896/</url>
    <content><![CDATA[<blockquote>
<p>ProjectDP - 27</p>
<p>最基础的状压DP</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。</p>
<p>注：数据有加强（2018/4/25）</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>所得的方案数</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑状压DP</p>
<p>我们设 $ dp[i][j][k] $ 表示第 $i$ 行的状态的编号为 $j$，放了 $k$ 个国王</p>
<p>转移方程显然</p>
<script type="math/tex; mode=display">dp[i][j][pct(stat[j]) + l] = dp[i][j][pct(stat[j]) + l] +  dp[i-1][k][l]</script><p>其中 $pct(x)$ 表示 $x$ 的二进制1的个数</p>
<p>边界条件：</p>
<script type="math/tex; mode=display">dp[1][nowStat][pct(nowStat)] = 1</script><p>其中 $nowStat$ 表示当前枚举到的<strong>合法的</strong>状态</p>
<p>剩下的……就没啥好说的了（</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPIO() std::ios::sync_with_stdio(false);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__file) freopen(__file, <span class="meta-string">'r'</span>, stdin);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__file) freopen(__file, <span class="meta-string">'w'</span>, stdout);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">9</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXK = MAXN * MAXN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> stats[(<span class="number">1</span> &lt;&lt; MAXN) - <span class="number">1</span> + <span class="number">10</span>], popc[(<span class="number">1</span> &lt;&lt; MAXN) - <span class="number">1</span> + <span class="number">10</span>], cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> dp[MAXN][(<span class="number">1</span> &lt;&lt; MAXN) - <span class="number">1</span> + <span class="number">10</span>][MAXK];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[i][stat][k]: line i, status stat, k kings</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Popcount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &amp; <span class="number">1</span>) ++ret;</span><br><span class="line">		x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckFailed</span><span class="params">(<span class="keyword">int</span> stat1, <span class="keyword">int</span> stat2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((stat1 &amp; stat2) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> ((stat1 &amp; (stat2 &lt;&lt; <span class="number">1</span>)) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (((stat1 &lt;&lt; <span class="number">1</span>) &amp; stat2) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	IMPIO();</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((i &amp; (i &lt;&lt; <span class="number">1</span>)) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">		stats[++cnt] = i;</span><br><span class="line">		dp[<span class="number">1</span>][cnt][Popcount(i)] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> idj = <span class="number">1</span>; idj &lt;= cnt; ++idj) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> idk = <span class="number">1</span>; idk &lt;= cnt; ++idk) &#123;</span><br><span class="line">				<span class="keyword">if</span> (CheckFailed(stats[idj], stats[idk])) <span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= k; ++l) &#123;</span><br><span class="line">					   dp[i][idj][Popcount(stats[idj]) + l]</span><br><span class="line">					+= dp[i - <span class="number">1</span>][idk][l];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">		ans += dp[n][i][k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>关于新开的「Handwer's Problems」</title>
    <url>/2019-02-13/MathProblems-NewSite/</url>
    <content><![CDATA[<p>「Handwer’s Problems」主要转载一些经过挑选的文化课题目。</p>
<p>每一道题都会在不久之后更新题解，同时会更新下一道题。</p>
<p>现在主要上数学题，预计不久之后会更新物理以及英语题目。</p>
<p>面向任何人开放，如无特殊情况（包括但不限于考试）不会设置密码。</p>
<p>链接：<a href="https://problem.handwer-std.top" target="_blank" rel="noopener">Handwer’s Problems</a></p>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>文化课</tag>
        <tag>简介</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2704《[NOI2001]炮兵阵地》</title>
    <url>/2019-02-04/Luogu-P2704/</url>
    <content><![CDATA[<blockquote>
<p>ProjectDP - 29</p>
<p>需要维护两行状态的状压DP</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>司令部的将军们打算在N*M的网格地图上部署他们的炮兵部队。一个N*M的地图由N行M列组成，地图的每一格可能是山地（用“H” 表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<p><img src="https://cdn.luogu.org/upload/pic/1881.png" alt="description1"></p>
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个由空格分割开的正整数，分别表示N和M；</p>
<p>接下来的N行，每一行含有连续的M个字符（‘P’或者‘H’），中间没有空格。按顺序表示地图中每一行的数据。N≤100；M≤10。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">PHPP</span><br><span class="line">PPHH</span><br><span class="line">PPPP</span><br><span class="line">PHPP</span><br><span class="line">PHHP</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>看到这个玄学的数据范围，第一反应就是状压DP</p>
<p>我们设 $ dp[i][j][k] $ 表示当前正在摆放第 $i$ 行，当前行的状态<strong>编号</strong>为 $j$，上一行的状态编号为 $k$ 时的最大数量</p>
<p>我们先把所有的可能状态预处理出来，记为 <code>stats[]</code></p>
<p>初始状态时所有的<code>dp[1][i][1] = Popcount(stats[i])</code>，其中 <code>Popcount(x)</code>表示<code>x</code>的二进制1的个数</p>
<p>转移方程显然，<br>$ dp[i][j][k] = max(dp[i][j][k], dp[i-1][k][l] + $ <code>Popcount(stats[j])</code> $ ) $，<br>其中 $j$ 表示当前行的状态编号，$k$ 表示上一行的，$l$ 表示再上一行的</p>
<p>注意判一下地形是否符合，方法参见<a href="/2019-01-29/Luogu-P1879/">洛谷P1879</a></p>
<hr>
<p>我要开<big><big>滚动数组</big>&lt;/big&gt;</big></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  29.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/1/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) - <span class="number">1</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> status[MAX], dp[<span class="number">2</span>][MAX][MAX], can[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt, n, m;</span><br><span class="line"><span class="keyword">char</span> str[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &amp; <span class="number">1</span>) ret++;</span><br><span class="line">        x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &amp; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Check3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Check(a,b) || Check(a,c) || Check(b,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,str + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">if</span>(str[j] == <span class="string">'H'</span>)can[i] = (can[i] &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> can[i] = can[i] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>((!(i &amp; (i &lt;&lt; <span class="number">2</span>))) &amp;&amp; (!(i &amp; (i &lt;&lt; <span class="number">1</span>))))</span><br><span class="line">            status[++cnt] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        dp[<span class="number">1</span> % <span class="number">2</span>][i][<span class="number">1</span>] = pop(status[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(status[j] &amp; can[i])) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; ++k) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((!(status[k] &amp; can[i - <span class="number">1</span>])) &amp;&amp; (!Check(status[j],status[k]))) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= cnt; ++l)&#123;</span><br><span class="line">                            <span class="keyword">if</span> ((!(status[l] &amp; can[i - <span class="number">2</span>])) &amp;&amp; (!Check3(status[j], status[k], status[l])))</span><br><span class="line">                                dp[i % <span class="number">2</span>][j][k] = <span class="built_in">std</span>::max(dp[i % <span class="number">2</span>][j][k], dp[(i - <span class="number">1</span>) % <span class="number">2</span>][k][l] + pop(status[j]));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt; ++j)</span><br><span class="line">            ans = <span class="built_in">std</span>::max(ans, dp[n % <span class="number">2</span>][i][j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
        <tag>状压DP</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3183《[HAOI2016]食物链》</title>
    <url>/2019-02-04/Luogu-P3183/</url>
    <content><![CDATA[<center> 本题与[洛谷P4017](https://www.luogu.org/problemnew/show/P4017) 重复 </center>

<center>代码通用</center>

<center>题解[传送门](/2019-02-04/Luogu-P4017/)</center>
]]></content>
      <tags>
        <tag>拓扑序</tag>
        <tag>图论</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4017《最大食物链计数》</title>
    <url>/2019-02-04/Luogu-P4017/</url>
    <content><![CDATA[<blockquote>
<p>七年级上册生物题目</p>
</blockquote>
<a id="more"></a>
<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>你知道食物链吗？Delia生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个食物网，你要求出这个食物网中最大食物链的数量。</p>
<p>（这里的“最大食物链”，指的是生物学意义上的食物链，即最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者。）</p>
<p>Delia非常急，所以你只有1秒的时间。</p>
<p>由于这个结果可能过大，你只需要输出总数模上80112002的结果。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个正整数n、m，表示生物种类n和吃与被吃的关系数m。</p>
<p>接下来m行，每行两个正整数，表示被吃的生物A和吃A的生物B。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，为最大食物链数量模上80112002的结果。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">3 5</span><br><span class="line">2 5</span><br><span class="line">4 5</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>各测试点满足以下约定：</p>
<p><img src="https://cdn.luogu.org/upload/pic/12011.png" alt="图源洛谷"></p>
<p>【补充说明】</p>
<p>数据中不会出现环，满足生物学的要求。（感谢@AKEE ）</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>有向无环？拓扑序啊！<br>仔细想一下发现思路可能是对的</p>
<hr>
<p>正向建一个图，反向建一个图</p>
<p>先把正向图的拓扑序跑出来，放到一个<code>vector&lt;int&gt;</code>里<br>再按照拓扑序来枚举点，这样就保证了枚举的顺序</p>
<p>我们设 <code>dp[node]</code> 表示以编号 <code>node</code> 为结尾的食物链个数<br>那么对于节点 <code>Node</code>，</p>
<ul>
<li>如果它没有出边，那么<code>dp[node] = 1</code></li>
<li>如果它有出边，那么枚举每一条出边的邻接点<code>nv</code>，<code>dp[node] += dp[nv]</code></li>
</ul>
<p>最后答案是$\sum$<code>dp[所有没有出边的点]</code></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD(__x) <span class="meta-keyword">if</span> (__x &gt;= HA) __x -= HA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(__Args,...) printf(__Args,##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">80112002</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reallink[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; top;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id[MAXN]; <span class="comment">// id -&gt; in degree</span></span><br><span class="line"><span class="keyword">int</span> n, m, ans; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN]; </span><br><span class="line"><span class="comment">// dp[i][j] -&gt; the amount of links that the end-node = i</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Topsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!id[i]) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">            top.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> amt = head[u].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; amt; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">            --id[v];</span><br><span class="line">            <span class="keyword">if</span> (!id[v]) &#123;</span><br><span class="line">                top.push_back(v);</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    	<span class="keyword">int</span> A = <span class="number">0</span>, B = <span class="number">0</span>;</span><br><span class="line">    	<span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B;</span><br><span class="line">    	head[A].push_back(B);</span><br><span class="line">    	reallink[B].push_back(A);</span><br><span class="line">    	++id[B];</span><br><span class="line">    &#125;</span><br><span class="line">    Topsort();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// enumerate Topsorted-Nodes</span></span><br><span class="line">        <span class="keyword">int</span> nnode = top[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (reallink[nnode].size() == <span class="number">0</span>) dp[nnode] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// no out-edges connected</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; reallink[nnode].size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> nenode = reallink[nnode][j];</span><br><span class="line">            dp[nnode] += dp[nenode];</span><br><span class="line">            ADD(dp[nnode]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!head[nnode].size()) ans += dp[nnode];</span><br><span class="line">        ADD(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ3060《Tour de Byteotia》</title>
    <url>/2019-02-04/BZOJ3060/</url>
    <content><![CDATA[<blockquote>
<p>并查集板子题（雾</p>
</blockquote>
<a id="more"></a>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>权限题，题面请自行寻找<br><del>用小刀刮开涂层来获取题目地址</del><br><span style="background-color:black">访问 DarkBZOJ 来获取题面</span></p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>用并查集维护一下连通性</p>
<p>下文我们称「编号小于等于k的点」为「奇特点」</p>
<hr>
<p>显然和奇特点没有关系的边删不删都无所谓，不影响答案，所以我们可以放心地把这些边加入并查集。</p>
<p>然后我们枚举所有的与奇特点相连的边，尝试将这条边加入并查集。<br>如果这条边的两个点不连通，就可以放心地将这条边加入并查集，否则<code>++ans</code></p>
<p>最后输出<code>ans</code>即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">    </span><br><span class="line">    UnionFind() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(seq, <span class="number">0</span>, <span class="keyword">sizeof</span> seq);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (seq[x] == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> seq[x] = Find(seq[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = Find(x);</span><br><span class="line">        y = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        seq[x] = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; U;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> f, t;</span><br><span class="line">    <span class="comment">// from to</span></span><br><span class="line">    </span><br><span class="line">    Edge() &#123; f = t = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; edge[MAXM &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    edge[++cnt].f = u;</span><br><span class="line">    edge[cnt].t = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, next = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; prev &gt;&gt; next;</span><br><span class="line">        addEdge(prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">1</span>; e &lt;= m; ++e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(edge[e].f &lt;= k || edge[e].t &lt;= k)) &#123;</span><br><span class="line">            U.Union(edge[e].f, edge[e].t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">1</span>; e &lt;= m; ++e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[e].f &lt;= k || edge[e].t &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!U.Union(edge[e].f, edge[e].t)) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2619《[国家集训队2]Tree I》</title>
    <url>/2019-02-04/Luogu-P2619/</url>
    <content><![CDATA[<blockquote>
<p><del>年轻人的第一道国家集训队</del><br>二分答案 + 最小生成树</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有need条白色边的生成树。</p>
<p>题目保证有解。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行V,E,need分别表示点数，边数和需要的白色边数。</p>
<p>接下来E行</p>
<p>每行s,t,c,col表示这边的端点(点从0开始标号)，边权，颜色(0白色1黑色)。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行表示所求生成树的边权和。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2 1</span><br><span class="line">0 1 1 1</span><br><span class="line">0 1 2 0</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>0:V&lt;=10</p>
<p>1,2,3:V&lt;=15</p>
<p>0,..,19:V&lt;=50000,E&lt;=100000</p>
<p>所有数据边权为[1,100]中的正整数。</p>
<p>By WJMZBMR</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p><del>年轻人的第一道国家集训队题目</del></p>
<hr>
<p>如果我们不做任何处理，直接跑MST（Minimum Spanning Tree，最小生成树），结果会有三种：</p>
<ul>
<li><p>正好跑出 $\text{Need}$ 条白边</p>
</li>
<li><p>白边多了</p>
</li>
<li><p>白边少了</p>
</li>
</ul>
<p>第一种情况自然是最好的</p>
<p>剩下两种情况如何解决？</p>
<hr>
<p>引起白边少的原因：黑边的边权相对较小，程序贪心地选择了更多的黑边</p>
<p>引起白边多的原因：白边的边权相对较小，程序贪心地选择了更多的白边</p>
<p>那么如果我们给白边相应地减去/加上一些边权，不就可以达成目标了？</p>
<hr>
<p>考虑二分答案。</p>
<p>我们二分一个 $add$ 表示我们当前要给白边加上 $add$ 来达成目标</p>
<p>边界分别是边权最小值（-100）和边权最大值（100）</p>
<p>由于题面保证有答案，所以直接输出 $ ans - add \times \text{Need} $<br> 即可，其中 $ans$ 为（加上边权后）最小生成树的权值和</p>
<p><code>Check(mid)</code> 怎么写？</p>
<hr>
<p>我们将所有白边的边权加上$add$（即$mid$），跑一遍最小生成树，判断一下拿到的白色边数量是否大于等于要求的数量，如果是就更新一下左边界并记当前的$mid$为$tans$，否则就更新一下右边界</p>
<p>注意不要忘了把边权减回来</p>
<p>（不要在意 $tans$ 是什么意思）</p>
<hr>
<p>刚才我们不是记录了一下$tans$吗，这个$tans$就相当于是一个正确的、能选出正好 $\text{Need}$ 条白边的 $add$ 值，再将所有白边的边权都加上这个 $tans$，跑一遍最小生成树即可</p>
<p>答案不要忘了减去加上的边权（也就是 $ \text{Need} \times tans $）</p>
<p>那么最后的答案就是 $ \text{Kruskal()} - \text{Need} \times tans $</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WHITE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXE = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXW = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prev, next, weight, add;</span><br><span class="line">    <span class="keyword">bool</span> color;</span><br><span class="line">    <span class="comment">// 1 -&gt; black, 0 -&gt; white</span></span><br><span class="line">    </span><br><span class="line">    Edge() &#123; prev = next = weight = color = add = <span class="number">0</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weight == that.weight) <span class="keyword">return</span> color &lt; that.color;</span><br><span class="line">        <span class="keyword">return</span> weight &lt; that.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; edge[MAXE &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> V, E, Need, cnt, ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXV &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> U[x];</span><br><span class="line">    <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = Find(x), y = Find(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    U[x] = y;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> whiteEdge = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= V; ++i) U[i] = i;</span><br><span class="line">    <span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + E);</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Union(edge[i].prev, edge[i].next)) </span><br><span class="line">            ans += edge[i].weight, ++tot, whiteEdge += (edge[i].color == WHITE);</span><br><span class="line">        <span class="keyword">if</span> (tot == V - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> whiteEdge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> add)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].color == WHITE) edge[i].weight += add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> Ans = (Kruskal() &gt;= Need);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[i].color == WHITE) edge[i].weight -= add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; V &gt;&gt; E &gt;&gt; Need;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= E; ++i) &#123;</span><br><span class="line">    	<span class="built_in">cin</span> &gt;&gt; edge[i].prev &gt;&gt; edge[i].next &gt;&gt; edge[i].weight &gt;&gt; edge[i].color;</span><br><span class="line">    	++edge[i].prev;</span><br><span class="line">        ++edge[i].next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = -MAXW, r = MAXW;</span><br><span class="line">    <span class="keyword">int</span> Run = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((l + r) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (Check(mid)) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">            Run = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Check(Run);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans - Need * Run &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>二分答案</tag>
        <tag>生成树</tag>
        <tag>国家集训队</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1621《集合》</title>
    <url>/2019-02-04/Luogu-P1621/</url>
    <content><![CDATA[<blockquote>
<p>素数筛 + 并查集</p>
</blockquote>
<a id="more"></a>
<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>John的农场缺水了！！！</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Farmer John has decided to bring water to his N (1 &lt;= N &lt;= 300) pastures which are conveniently numbered 1..N. He may bring water to a pasture either by building a well in that pasture or connecting the pasture via a pipe to another pasture which already has water.</p>
<p>Digging a well in pasture i costs W_i (1 &lt;= W_i &lt;= 100,000).</p>
<p>Connecting pastures i and j with a pipe costs P_ij (1 &lt;= P_ij &lt;= 100,000; P_ij = P_ji; P_ii=0).</p>
<p>Determine the minimum amount Farmer John will have to pay to water all of his pastures.</p>
<p>POINTS: 400</p>
<p>农民John 决定将水引入到他的n(1&lt;=n&lt;=300)个牧场。他准备通过挖若</p>
<p>干井，并在各块田中修筑水道来连通各块田地以供水。在第i 号田中挖一口井需要花费W_i(1&lt;=W_i&lt;=100,000)元。连接i 号田与j 号田需要P_ij (1 &lt;= P_ij &lt;= 100,000 , P_ji=P_ij)元。</p>
<p>请求出农民John 需要为使所有农场都与有水的农场相连或拥有水井所需要的钱数。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1 行为一个整数n。</p>
<p>第2 到n+1 行每行一个整数，从上到下分别为W_1 到W_n。</p>
<p>第n+2 到2n+1 行为一个矩阵，表示需要的经费（P_ij）。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一行，为一个整数，表示所需要的钱数。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">0 2 2 2</span><br><span class="line">2 0 3 3</span><br><span class="line">2 3 0 4</span><br><span class="line">2 3 4 0</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>John等着用水，你只有1s时间！！！</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>题目中“质数”两个字很是显眼啊</p>
<p>还等啥啊</p>
<big><big><big><strong>筛啊</strong></big></big></big>

<p>素数筛很好写吧</p>
<hr>
<p>筛完了，然后呢？</p>
<p>题目让我们找两个公共质因数 $ \geq P $ 的，不在一个集合里的数，并合并它们。我们不这样找</p>
<hr>
<p>枚举每一个质数<code>primes[i]</code>，计算出<code>第一个</code> <code>大于A</code>的<code>primes[i]的倍数</code>（题目要求的）记为$t$，然后从$t+\text{primes[i]}$一直枚举到$B$（每次增长一个$\text{primes[i]}$，毕竟要求必须有$\text{primes[i]}$这个数作为质因数），每次用并查集合并$t$和当前枚举到的这个数</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXB = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A, B, P;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> primes[MAXB], cnt, ans;</span><br><span class="line"><span class="keyword">bool</span> npm[MAXB]; <span class="comment">// n(ot a )p(ri)m(e) -&gt; not a prime</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXB];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	x = Find(x), y = Find(y);</span><br><span class="line">	<span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">	--ans; <span class="comment">// 两个集合变成了一个，答案减一</span></span><br><span class="line">	U[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B &gt;&gt; P;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= B; ++i) U[i] = i; <span class="comment">// 并查集初始化</span></span><br><span class="line">    <span class="comment">// 筛一波素数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= B; ++i) &#123;</span><br><span class="line">    	<span class="keyword">if</span> (!npm[i]) primes[++cnt] = i;</span><br><span class="line">    	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; primes[j] * i &lt;= B; ++j) &#123;</span><br><span class="line">    		npm[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">    		<span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans = B - A + <span class="number">1</span>; <span class="comment">// r - l + 1</span></span><br><span class="line">    <span class="comment">// 原来的答案总数是（右边界 - 左边界 + 1）</span></span><br><span class="line">    <span class="comment">//（即 B - A + 1），每次合并集合的时候两个集合变成了一个，--ans</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (primes[i] &lt; P) <span class="keyword">continue</span>; <span class="comment">// 质因数要求大于等于P</span></span><br><span class="line">		<span class="keyword">int</span> np = (A + primes[i] - <span class="number">1</span>) / primes[i] * primes[i];</span><br><span class="line">		<span class="comment">// np -&gt; The smallest multiple of primes[i] larger than A</span></span><br><span class="line">        <span class="comment">// np -&gt; 最小的 比A大的 primes[i]的倍数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = np + primes[i]; j &lt;= B; j += primes[i]) &#123;</span><br><span class="line">			Union(np, j); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1879《[USACO06NOV]玉米田Corn Fields》</title>
    <url>/2019-01-29/Luogu-P1879/</url>
    <content><![CDATA[<blockquote>
<p>ProjectDP - 28</p>
<p>状压DP入门题</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant.</p>
<p>Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant.</p>
<p>农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。</p>
<p>遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。</p>
<p>John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：两个整数M和N，用空格隔开。</p>
<p>第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即牧场分配总方案数除以100,000,000的余数。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3</span><br><span class="line">1 1 1</span><br><span class="line">0 1 0</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一道状压DP入门题</p>
<p>首先我们发现对于每一行，有 N 个状态<br>那么就意味着这是一个N + 1维DP……</p>
<p>但是我们发现从第二维到第N维都只需要0（不种玉米）和1（种玉米）两个值<br>那么……二进制！<br>比如 1010 就表示第1、3个格种玉米，第2、4个格不种玉米</p>
<hr>
<p>设 $ f[i][\text{status}] $ 表示第 $i$ 行种玉米的状态是 $\text{status}$<br>转移方程很显然吧</p>
<script type="math/tex; mode=display">f[i][\text{status}] = f[i][\text{status}] + f[i - 1][
\text{pre_status}]</script><p>如何判断 $ \text{status} $ 和 $ \text{pre_status} $ 是不是互相合法？</p>
<hr>
<p>我们先来看看如何判断两行互相合法。</p>
<p>「合法」指两行种玉米的地方不相邻，也就是两个1不相邻。<br>我们来想想位运算 $and$ 的性质</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运算法则：</span><br><span class="line">1 &amp; 1 = 1</span><br><span class="line">1 &amp; 0 = 0</span><br><span class="line">0 &amp; 0 = 0</span><br><span class="line"></span><br><span class="line">and (aka &amp;) 是按位运算的</span><br><span class="line">例如：</span><br><span class="line">  10101101   10100100</span><br><span class="line">&amp; 10110100 &amp; 01010001</span><br><span class="line">---------- ----------</span><br><span class="line">  10100100   00000000</span><br></pre></td></tr></table></figure>
<p>我们发现，第二个例子放在题目中是合法的，它们进行 $and$ 运算的值为 $0$<br>那么方法不就出来了吗！</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> stat1, <span class="keyword">int</span> stat2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (stat1 &amp; stat2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单行的状态也可能不合法，<del>如何对敌</del>怎么解决？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stat1 = 01001101 就是一个不合法的状态</span><br><span class="line">我们把 stat1 左移一位（ stat1 = stat1 &lt;&lt; 1 ）</span><br><span class="line">得到了 stat2 = 10011010</span><br><span class="line"></span><br><span class="line">我们把他们 and 一下</span><br><span class="line"></span><br><span class="line">  01001101</span><br><span class="line">&amp; 10011010</span><br><span class="line">----------</span><br><span class="line">  00001000 &gt; 0</span><br></pre></td></tr></table></figure>
<p>那么方法就出来了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CheckSingleLine</span><span class="params">(<span class="keyword">int</span> stat)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Check(stat, stat &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后处理一下土地的状态</p>
<p>我们将一行土地的利用情况记为二进制<br>0表示荒地，1表示耕地</p>
<p>我们判断一下当前状态与利用情况 and 起来是否还等于当前状况即可<br><del>正确性证明留作习题</del></p>
<hr>
<p>那么我们枚举所有的可能状态，挨个判断即可。<br>注意边界条件 $ f[0][0] = 1 $</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  28.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/1/29.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Stat(__x) FIXED_STATUS[__x]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXSTATUS = (<span class="number">1</span> &lt;&lt; <span class="number">12</span>) - <span class="number">1</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXMN = <span class="number">12</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> farm[MAXMN][MAXMN];</span><br><span class="line"><span class="keyword">int</span> dp[MAXMN][MAXSTATUS], FIXED_STATUS[MAXSTATUS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[i][stat]: line = i, status = stat (binary)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; farm[i][j];</span><br><span class="line">            Stat(i) = (Stat(i) &lt;&lt; <span class="number">1</span>) + farm[i][j]; <span class="comment">// 预处理一下土地的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> status = <span class="number">0</span>; status &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; ++status) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((status &amp; (status &lt;&lt; <span class="number">1</span>)) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// some grass are close to each other</span></span><br><span class="line">            <span class="keyword">if</span> ((status &amp; Stat(i)) != status) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// at least one grass planted on a barren place</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> pre_stat = <span class="number">0</span>; pre_stat &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; ++pre_stat) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((status &amp; pre_stat) == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][status] += dp[i - <span class="number">1</span>][pre_stat];</span><br><span class="line">                    dp[i][status] %= HA;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        ans += dp[m][i];</span><br><span class="line">        ans %= HA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
        <tag>进制</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1352《没有上司的舞会》</title>
    <url>/2019-01-28/Luogu-P1352/</url>
    <content><![CDATA[<blockquote>
<p>ProjectDP - 8</p>
<p>树形DP入门题</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数N。(1&lt;=N&lt;=6000)</p>
<p>接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128&lt;=Ri&lt;=127)</p>
<p>接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。</p>
<p>最后一行输入0 0</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出最大的快乐指数。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">6 4</span><br><span class="line">7 4</span><br><span class="line">4 5</span><br><span class="line">3 5</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是一道树形DP板子题。</p>
<p>设 $ f[u][0] $ 表示不选择 $u$ 这个结点时的最大价值，$ f[u][1] $ 表示选择 $u$ 这个结点时的最大价值<br>令 $v$ 为 $u$ <strong>除父节点以外</strong>的邻接点，那么我们就能写出这样的伪代码</p>
<p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ \text{Algorithm 1: DFS(u)} $<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ 1: f[u][0] = 0 $<br>$ 2: f[u][1] = value[u] $<br>$ 3: \text{while u}$ 有未被遍历的<strong>出</strong>边 $ (u,v)  \text{ do} $<br>$ 4: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{DFS}(v) $<br>$ 5: $ &nbsp;&nbsp;&nbsp;&nbsp; $ f[u][0] = f[u][0] + \text{max}(f[v][0], f[v][1]) $<br>$ 6: $ &nbsp;&nbsp;&nbsp;&nbsp; $ f[u][1] = f[u][1] + f[v][0] $<br>$ 7: \text{end while}$<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p>
<p>最后答案即为 $ \text{max}(f[root][0], f[root][1]) $</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  8.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/1/28.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[u][true]: Choose Node[u]</span></span><br><span class="line"><span class="comment"> * dp[u][false]: Don't choose Node[u]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> val[MAXN], n;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">2</span>], inDegree[MAXN];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    dp[u][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[u][<span class="number">1</span>] = val[u];</span><br><span class="line">    <span class="keyword">int</span> siz = (<span class="keyword">int</span>) head[u].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = head[u][i];</span><br><span class="line">        DFS(v);</span><br><span class="line">        dp[u][<span class="number">1</span>] += dp[v][<span class="number">0</span>];</span><br><span class="line">        dp[u][<span class="number">0</span>] += <span class="built_in">std</span>::max(dp[v][<span class="number">0</span>], dp[v][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; val[i];</span><br><span class="line">    <span class="keyword">int</span> maxNode = <span class="number">-1</span>, minNode = MAXN + <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> father = <span class="number">0</span>, child = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; child &gt;&gt; father;</span><br><span class="line">        head[father].push_back(child);</span><br><span class="line">        ++inDegree[child];</span><br><span class="line">        maxNode = <span class="built_in">std</span>::max(maxNode, <span class="built_in">std</span>::max(father, child));</span><br><span class="line">        minNode = <span class="built_in">std</span>::min(minNode, <span class="built_in">std</span>::min(father, child));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = minNode; i &lt;= maxNode; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="literal">false</span>) root = i;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::max(dp[root][<span class="number">0</span>], dp[root][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
        <tag>ProjectDP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU2089《不要62》</title>
    <url>/2019-01-28/HDU2089/</url>
    <content><![CDATA[<blockquote>
<p>ProjectDP - 26</p>
<p>数位DP板子题</p>
</blockquote>
<a id="more"></a>
<h1 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h1><p>杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。<br>杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。<br>不吉利的数字为所有含有4或62的号码。例如：<br>62315 73418 88914<br>都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。<br>你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。</p>
<h1 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 100</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure>
<h1 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">80</span><br></pre></td></tr></table></figure>
<h1 id="Author"><a href="#Author" class="headerlink" title="Author"></a>Author</h1><p>qianneng</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><!--
这是一道数位DP板子题

我们令 $ A(x) $ 表示 $[0,x)$ 之间数字的答案数，那么答案就是 $ A(m) - A(n) $ 加上对 $n$ 的特判，这个很显然𝟠

如何写这个函数 $A(x)$？

---

我们设 $ f[i][j] $ 表示 i 位数中开头数字为 j 的，不含4和62的数字有多少
转移方程显然

$$ f[i][j] = f[i][j] + f[i - 1][k]\ (j \neq 4, k \neq 2 \text{ when } j = 6) $$
-->
<p>不会讲啊QAQ</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  26.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/1/28.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXLENGTH = <span class="number">8</span> + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * dp[i][j]: length = i, the start number = j</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXLENGTH][MAXLENGTH];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// enumeration length</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">4</span>) dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; ++k) &#123;</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">6</span>) dp[i][j] -= dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// returns the amount in [0, x)</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> num[MAXLENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// num[0] &lt;=&gt; cnt</span></span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        num[++num[<span class="number">0</span>]] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num[<span class="number">0</span>]; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; num[i]; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">4</span> || (num[i + <span class="number">1</span>] == <span class="number">6</span> &amp;&amp; j == <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">            ans += dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num[i] == <span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[i + <span class="number">1</span>] == <span class="number">6</span> &amp;&amp; num[i] == <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Solve((m) + <span class="number">1</span>) - Solve((n - <span class="number">1</span>) + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1006《传纸条》</title>
    <url>/2019-01-28/Luogu-P1006/</url>
    <content><![CDATA[<blockquote>
<p>ProjectDP - 4</p>
<p>从下往上传 $ \iff $ 从上往下传</p>
</blockquote>
<a id="more"></a>
<p>诶这里好像没有东西。。。</p>
]]></content>
      <tags>
        <tag>ProjectDP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1434《[SHOI2010]滑雪》</title>
    <url>/2019-01-27/Luogu-P1434/</url>
    <content><![CDATA[<blockquote>
<p>记忆化搜索好题</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Michael喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1   2   3   4   5</span><br><span class="line">16  17  18  19  6</span><br><span class="line">15  24  25  20  7</span><br><span class="line">14  23  22  21  8</span><br><span class="line">13  12  11  10  9</span><br></pre></td></tr></table></figure>
<p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可行的滑坡为24－17－16－1（从24开始，在1结束）。当然25－24－23－…－3－2－1更长。事实上，这是最长的一条。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为表示区域的二维数组的行数R和列数C（1≤R，C≤100）。下面是R行，每行有C个数，代表高度(两个数字之间用1个空格间隔)。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出区域中最长滑坡的长度。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一眼就能看出这是搜索题</p>
<p>方法很显然，枚举所有的点，从当前点开始 DFS，每次往四个方向搜索，直到不能搜为止，这时候答案就出来了一个，更新一下。</p>
<hr>
<p>考虑一下优化。<br>在每次搜索的过程中，我们有很多点是重复走过的，那么就可以把暴搜升级为记忆化搜索。<br>用 $ \text{mem}(x,y) $ 表示从点 $ (x,y) $ 出发的最长路径，在每一次搜索完成之后更新一下当前的答案，记录到 $ \text{mem}(x,y) $ 中即可。等到下一次搜到这个点（记为 $ (x’,y’) $ ），如果 $ \text{mem}(x’,y’) \geq 0 $ （也就是被更新过了），直接返回 $ \text{mem}(x’,y’) $ 就行。</p>
<hr>
<p>我们也可以把记忆化搜索升级为 DP <del>不过据说比记忆化搜索还慢</del><br>DP 做法题解已提上日程。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>,  <span class="number">0</span>, <span class="number">-1</span>,  <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">-1</span>,  <span class="number">0</span>,  <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXRC = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> snow[MAXRC][MAXRC];</span><br><span class="line"><span class="keyword">int</span> r, c, ans;</span><br><span class="line"><span class="keyword">int</span> mem[MAXRC][MAXRC];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mem[x][y]) t = mem[x][y];</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (nx &gt; <span class="number">0</span> &amp;&amp; ny &gt; <span class="number">0</span> &amp;&amp; nx &lt;= r &amp;&amp; ny &lt;= c &amp;&amp; snow[x][y] &lt; snow[nx][ny]) &#123;</span><br><span class="line">                t = <span class="built_in">std</span>::max(t, Search(nx, ny) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mem[x][y] = t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; r &gt;&gt; c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; snow[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = Search(i, j);</span><br><span class="line">            mem[i][j] = now;</span><br><span class="line">            ans = <span class="built_in">std</span>::max(ans, mem[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>省选</tag>
        <tag>DFS</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2320《[HNOI2006]鬼谷子的钱袋》</title>
    <url>/2019-01-27/Luogu-P2320/</url>
    <content><![CDATA[<blockquote>
<p>不断拆分</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。</p>
<p>有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。</p>
<p>但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。</p>
<p>鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1 ≤ m ≤ 1000000000。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>两行，第一行一个整数h，表示所用钱袋个数</p>
<p>第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>本文已发布于<a href="https://www.luogu.org/blog/handwer-blog/solution-p2320" target="_blank" rel="noopener">Handwer’s 洛谷博客</a></p>
<p>本蒟蒻怒写一发题解</p>
<p>收到本校神犇<a href="https://www.luogu.org/space/show?uid=148343" target="_blank" rel="noopener">@Herself32</a> 的邀请，过来做这道题</p>
<p><del>结果被题怒切</del></p>
<p>不扯了</p>
<hr>
<p>首先考虑一个弱化版的题目，只输出最小袋子数<br>稍微找一下规律就知道是总钱数的二进制位数</p>
<p>好 那么数据范围就出来了</p>
<hr>
<p>本题我们还是手动模拟一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 -&gt; 1</span><br><span class="line">2 -&gt; 1, 1</span><br><span class="line">3 -&gt; 1, 2</span><br><span class="line">4 -&gt; 1, 1, 2</span><br><span class="line">5 -&gt; 1, 1, 3</span><br><span class="line">6 -&gt; 1, 2, 3</span><br><span class="line">7 -&gt; 1, 2, 4</span><br><span class="line">8 -&gt; 1, 1, 2, 4</span><br></pre></td></tr></table></figure>
<p>我们再把7和8的过程单独拿出来看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 -&gt; 3, 4 -&gt; 1, 2, 4</span><br><span class="line">8 -&gt; 4, 4 -&gt; 2, 2, 4 -&gt; 1, 1, 2, 4</span><br></pre></td></tr></table></figure>
<p>我们能发现什么？<br>对于一个数 $n$，我们可以把它用 $ \lceil \frac{n}{2} \rceil + \lfloor \frac{n}{2} \rfloor $ 表示，同时依照题意，$ \lfloor \frac{n}{2} \rfloor $ 也是可以用 $ \lceil \frac{\lfloor \frac{n}{2} \rfloor}{2} \rceil + \lfloor \frac{\lfloor \frac{n}{2} \rfloor}{2} \rfloor $ 进行表示的，这么一直递归下去，直到两个式中至少有一个为 1 ，此时反向（即从小到大）输出答案即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXANS = <span class="number">30</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[MAXANS], cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (now == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = now / <span class="number">2</span>, mid2 = now / <span class="number">2</span> + (now % <span class="number">2</span>);</span><br><span class="line">    ans[++cnt] = mid2;</span><br><span class="line">    Search(mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line">    Search(m);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i &gt;= <span class="number">1</span>; --i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>各省省选</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1541「NOIP2010」《乌龟棋》</title>
    <url>/2019-01-26/Luogu-P1541/</url>
    <content><![CDATA[<blockquote>
<p>ProjectDP - 3</p>
<p>枚举转移</p>
</blockquote>
<a id="more"></a>
<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>乌龟棋的棋盘是一行$N$个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第$N$格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。</p>
<p>乌龟棋中$M$张爬行卡片，分成4种不同的类型（$M$张卡片中不一定包含所有4种类型的卡片，见样例），每种类型的卡片上分别标有$1,2,3,4$四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。</p>
<p>游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。</p>
<p>很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。</p>
<p>现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>每行中两个数之间用一个空格隔开。</p>
<p>第1行2个正整数$N,M$，分别表示棋盘格子数和爬行卡片数。</p>
<p>第2行$N$个非负整数，$a_1,a_2,…,a_N$，其中$a_i$表示棋盘第$i$个格子上的分数。</p>
<p>第3行$M$个整数，$b_1,b_2,…,b_M$，表示M张爬行卡片上的数字。</p>
<p>输入数据保证到达终点时刚好用光$M$张爬行卡片。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>11个整数，表示小明最多能得到的分数。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 5</span><br><span class="line">6 10 14 2 8 8 18 5 17</span><br><span class="line">1 3 1 2 1</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">73</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先来想想五维的 DP</p>
<p>我们设 $ f(i,j,k,l,m) $ 表示当前用了 $i$ 个卡片1， $j$ 个卡片2， $k$ 个卡片3， $l$ 个卡片4，走了 $m$ 步时的最大得分</p>
<p>分别对四种卡片进行转移</p>
<script type="math/tex; mode=display">Max = f[i-1][j][k][l][m - 1] (i \geq 1)</script><script type="math/tex; mode=display">Max = max(Max,f[i][j-1][k][l][m - 2]) (j \geq 1, m \geq 3)</script><script type="math/tex; mode=display">Max = max(Max,f[i][j][k-1][l][m - 3]) (k \geq 1, m \geq 4)</script><script type="math/tex; mode=display">Max = max(Max,f[i][j][k][l-1][m - 4]) (l \geq 1, m \geq 5)</script><script type="math/tex; mode=display">f[i][j][k][l][m] = Max + Score[m]</script><hr>
<p>考虑一下优化。<br>显然 $m$ 是可以通过计算得出的，$ m = i + 2j + 3k + 4l + 1 $ （注意后面的+1，因为是从第一个格开始的），那么就能省去一维</p>
<p>转移方程就变为了</p>
<script type="math/tex; mode=display">m = i + 2j + 3k + 4l + 1</script><script type="math/tex; mode=display">Max = f[i-1][j][k][l] (i \geq 1)</script><script type="math/tex; mode=display">Max = max(Max,f[i][j-1][k][l]) (j \geq 1)</script><script type="math/tex; mode=display">Max = max(Max,f[i][j][k-1][l]) (k \geq 1)</script><script type="math/tex; mode=display">Max = max(Max,f[i][j][k][l-1]) (l \geq 1)</script><script type="math/tex; mode=display">f[i][j][k][l] = Max + Score[m]</script><p>最终答案<del>留做习题</del>见代码</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  3.cpp</span></span><br><span class="line"><span class="comment">//  ProjectDP</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by HandwerSTD on 2019/1/25.</span></span><br><span class="line"><span class="comment">//  Copyright © 2019 Handwer STD. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CARD1 means the card that can make the turtle go 1 block.</span></span><br><span class="line"><span class="comment"> * CARD2, CARD3 and CARD4 too.</span></span><br><span class="line"><span class="comment"> * dp[i][j][k][l] records the max score when there are i CARD1(s), j CARD2(s), k CARD3(s) and l CARD4(s) have been used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Formula:</span></span><br><span class="line"><span class="comment"> *     Step = i * 1 + j * 2 + k * 3 + l * 4 + 1</span></span><br><span class="line"><span class="comment"> *     Max = dp[i][j][k][k]</span></span><br><span class="line"><span class="comment"> *     Max = max(Max, dp[i-1][j][k][l]) (i &gt;= 1)</span></span><br><span class="line"><span class="comment"> *     Max = max(Max, dp[i][j-1][k][l]) (j &gt;= 1)</span></span><br><span class="line"><span class="comment"> *     Max = max(Max, dp[i][j][k-1][l]) (k &gt;= 1)</span></span><br><span class="line"><span class="comment"> *     Max = max(Max, dp[i][j][k][l-1]) (l &gt;= 1)</span></span><br><span class="line"><span class="comment"> *     dp[i][j][k][l] = Max + score[Step]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Answer:</span></span><br><span class="line"><span class="comment"> *     dp[a][b][c][d],</span></span><br><span class="line"><span class="comment"> *     a -&gt; the amount of CARD1, b, c, and d too.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">350</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">120</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXCARD = <span class="number">40</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, sc[MAXN], cds[MAXM];</span><br><span class="line"><span class="keyword">int</span> a, b, c, d;</span><br><span class="line"><span class="keyword">int</span> dp[MAXCARD][MAXCARD][MAXCARD][MAXCARD];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IMPROVE_IO();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; sc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cds[i];</span><br><span class="line">        <span class="keyword">if</span> (cds[i] == <span class="number">1</span>) ++a;</span><br><span class="line">        <span class="keyword">if</span> (cds[i] == <span class="number">2</span>) ++b;</span><br><span class="line">        <span class="keyword">if</span> (cds[i] == <span class="number">3</span>) ++c;</span><br><span class="line">        <span class="keyword">if</span> (cds[i] == <span class="number">4</span>) ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= b; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= c; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= d; ++l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> walked = <span class="number">1</span> + i * <span class="number">1</span> + j * <span class="number">2</span> + k * <span class="number">3</span> + l * <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">if</span> (walked &gt; n) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">int</span> Max = dp[i][j][k][l];</span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) Max = max(Max, dp[i<span class="number">-1</span>][j][k][l]);</span><br><span class="line">                    <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) Max = max(Max, dp[i][j<span class="number">-1</span>][k][l]);</span><br><span class="line">                    <span class="keyword">if</span> (k - <span class="number">1</span> &gt;= <span class="number">0</span>) Max = max(Max, dp[i][j][k<span class="number">-1</span>][l]);</span><br><span class="line">                    <span class="keyword">if</span> (l - <span class="number">1</span> &gt;= <span class="number">0</span>) Max = max(Max, dp[i][j][k][l<span class="number">-1</span>]);</span><br><span class="line">                    dp[i][j][k][l] = Max + sc[walked];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[a][b][c][d] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
      </tags>
  </entry>
  <entry>
    <title>ProjectDP</title>
    <url>/2019-01-24/ProjectDP/</url>
    <content><![CDATA[<blockquote>
<p>DP计划</p>
</blockquote>
<p>为提高自己的DP水平，我创建了一个名为「DP计划」的工程，用它来记录自己的题目完成情况，同时编程、调试、代码储存也使用此工程。</p>
<p>项目地址：<a href="https://github.com/HandwerSTD/ProjectDP" target="_blank" rel="noopener">View ProjectDP on GitHub</a></p>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1083《借教室》</title>
    <url>/2019-01-24/Luogu-P1083/</url>
    <content><![CDATA[<blockquote>
<p>前缀和 + 二分答案</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p>
<p>面对海量租借教室的信息，我们自然希望编程解决这个问题。</p>
<p>我们需要处理接下来$n$天的借教室信息，其中第$i$天学校有$r_i$个教室可供租借。共有$m$份订单，每份订单用三个正整数描述，分别为$d_j,s_j,t_j$，表示某租借者需要从第$s_j$天到第$t_j$天租借教室（包括第$s_j$天和第$t_j$天），每天需要租借$d_j$个教室。</p>
<p>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$d_j$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p>
<p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$s_j$天到第$t_j$天中有至少一天剩余的教室数量不足$d_j$个。</p>
<p>现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p>
<p>输入输出格式<br>输入格式：<br>第一行包含两个正整数$n,m$，表示天数和订单的数量。</p>
<p>第二行包含$n$个正整数，其中第$i$个数为$r_i$，表示第$i$天可用于租借的教室数量。</p>
<p>接下来有$m$行，每行包含三个正整数$d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。</p>
<p>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从$1$开始的整数编号。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果所有订单均可满足，则输出只有一行，包含一个整数 $0$。否则（订单无法完全满足）</p>
<p>输出两行，第一行输出一个负整数$−1$，第二行输出需要修改订单的申请人编号。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 3 </span><br><span class="line">2 5 4 3 </span><br><span class="line">2 1 3 </span><br><span class="line">3 2 4 </span><br><span class="line">4 2 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 </span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【输入输出样例说明】</p>
<p>第 $1$份订单满足后，$4$天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2$天到第 $4$ 天每天提供 $3$个教室，而第 $3$ 天剩余的教室数为 $2$，因此无法满足。分配停止，通知第$2$ 个申请人修改订单。</p>
<p>【数据范围】</p>
<p>对于10%的数据，有$1≤ n,m≤ 10$；</p>
<p>对于30%的数据，有$1≤ n,m≤1000$；</p>
<p>对于 70%的数据，有$1 ≤ n,m ≤ 10^5$；</p>
<p>对于 100%的数据，有 $ 1 ≤ n,m ≤ 10^6,0 ≤ r_i,d_j≤ 10^9,1 ≤ s_j≤ t_j≤ n​ $。</p>
<p>NOIP 2012 提高组 第二天 第二题</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑二分答案</p>
<p>首先我们知道，对于一个订单 $i$，如果它能被批准，那么 $[1,i]$ 都能被批准；如果它不能被批准，那么 $[i,m]$ 都不能被批准（单调性）</p>
<p>那么我们二分订单的编号 $\text{mid}$，每次判一下$[1,\text{mid}]$是否全都能满足，最后如果右边界不是 $m$ 了，说明有订单不能满足，输出右边界即可</p>
<hr>
<p>如何判断是否能满足？<br>首先我们要$O(1)$实现区间修改（？？？）<br>用前缀和就可以实现！</p>
<p>想想下面的过程$\downarrow$</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原数列:   0  0  0  0  0  0</span><br><span class="line">       [ 1  2  3  4  5  6 ]</span><br><span class="line">前缀和：  0  0  0  0  0  0</span><br><span class="line">       [ 1  2  3  4  5  6 ]</span><br><span class="line">       </span><br><span class="line">我们让[1,3]都增加2</span><br><span class="line">于是我们选择让[1]增加2，让[4]（即[3+1]）减去2</span><br><span class="line">那么上面的数列就变成了：</span><br><span class="line"></span><br><span class="line">原数列:   2  0  0 -2  0  0</span><br><span class="line">       [ 1  2  3  4  5  6 ]</span><br><span class="line">前缀和：  2  2  2  0  0  0</span><br><span class="line">       [ 1  2  3  4  5  6 ]</span><br><span class="line"></span><br><span class="line">这个时候前缀和数组就实现了区间加！</span><br></pre></td></tr></table></figure>
<p>那么依照上面的思想，我们就能写出<code>Check(int mid)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Order</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> amount, l, r;</span><br><span class="line">    </span><br><span class="line">    Order() &#123; amount = l = r = <span class="number">0</span>; &#125;</span><br><span class="line">&#125; order[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], sum[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> __i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __i; ++i) &#123;</span><br><span class="line">        <span class="comment">// 像上面一样处理前缀和</span></span><br><span class="line">        sum[order[i].l] += order[i].amount;</span><br><span class="line">        sum[order[i].r] -= order[i].amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 将前缀和处理一遍</span></span><br><span class="line">        <span class="comment">// 判一下是否有超过当天可用教室的值</span></span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (sum[i] &gt; a[i]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不合法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXNM = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Order</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        </span><br><span class="line">        Order() &#123; num = l = r = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125; order[MAXNM];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m, seq[MAXNM];</span><br><span class="line">    <span class="keyword">int</span> sum[MAXNM];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span> sum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i) &#123;</span><br><span class="line">            sum[order[i].l] += order[i].num;</span><br><span class="line">            sum[order[i].r + <span class="number">1</span>] -= order[i].num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (sum[i] &gt; seq[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, n) seq[i] = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        order[i].num = getint();</span><br><span class="line">        order[i].l = getint();</span><br><span class="line">        order[i].r = getint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>, R = m;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid)) L = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (R != m) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n%d\n"</span>, R);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图匹配学习笔记 & HDU2063 题解</title>
    <url>/2019-01-24/BipartiteGraph/</url>
    <content><![CDATA[<p>原创建时间：2018-07-06 21:36:45</p>
<!--本文包含[《HDU2063 过山车》](https://acm.hdu.edu.cn/showproblem.php?pid=2063)题解-->
<!--**本文部分内容有误（因为作者太弱），等待修正**-->
<!--已修正完毕-->
<h1 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>设图$G=(V,E)$是一个无向图，若顶点集合$V$可分割为两个互不相交的子集$X$和$Y$，且图中每条边连接的顶点一个在$X$中，一个在$Y$中，则称$G$是一个二分图。</p>
<a id="more"></a>
<h2 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h2><p>若某一图是联通的，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 任选一个点V作为顶点，定义距离标号为0</span><br><span class="line">2. 将V的邻接点标号设为1，接着将它的未标号的邻接点的标号设为2，以此类推 </span><br><span class="line">3. 将所有标号为奇数的点归为X，标号为偶数的点归为Y</span><br></pre></td></tr></table></figure>
<p>以上内容可以采用BFS完成</p>
<p>依次检查每一条边，看看是否满足顶点一个在$X$中，一个在$Y$中</p>
<hr>
<p>若某一图不连通，就在每个联通块里进行判定</p>
<h1 id="二分图匹配"><a href="#二分图匹配" class="headerlink" title="二分图匹配"></a>二分图匹配</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定一个二分图$G$，在$G$的子图$M$中，$M$的边集${E}$中的任意两条边都不依附于同一个顶点，则称$M$是一个匹配。</p>
<p>图中蓝色的边是数量为2的匹配</p>
<p><img src="https://s1.ax2x.com/2018/07/06/oQPHl.png" alt="oQPHl.png"></p>
<h2 id="最大匹配-amp-完全匹配"><a href="#最大匹配-amp-完全匹配" class="headerlink" title="最大匹配 &amp; 完全匹配"></a>最大匹配 &amp; 完全匹配</h2><p>选择边数最大的子图称为「二分图的最大匹配问题」</p>
<p>如果一个匹配中图的每一个顶点都和某条边相关联，则称此匹配为「完全匹配」（或「完备匹配」）</p>
<p>图中为一个完全匹配</p>
<p><img src="https://s1.ax2x.com/2018/07/06/oQa4J.png" alt="oQa4J.png"></p>
<h2 id="增广路径"><a href="#增广路径" class="headerlink" title="增广路径"></a>增广路径</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>设$M$为二分图$G$已匹配边的集合，若$P$是$G$上其中一条联通两个未匹配顶点的路径（起点在$X$部，终点在$Y$部），且属$M$的边和不属$M$的边在$P$上交替出现，则称$P$为相对于$M$的一条增广路径</p>
<h3 id="寻找增广路"><a href="#寻找增广路" class="headerlink" title="寻找增广路"></a>寻找增广路</h3><p>设$M$为二分图$G$所有已匹配边的集合，</p>
<p>如图，蓝色为在$M$里的边，黄色为不在$M$里的边</p>
<p><img src="https://s1.ax2x.com/2018/07/06/oW9gr.png" alt="oW9gr.png"></p>
<p>从$x_4$到$y_2$找一条路径：</p>
<p>$<br>x_4 \rightarrow y_3 \rightarrow x_2 \rightarrow y1 \rightarrow x1 \rightarrow y2<br>$</p>
<p>这条路径就是<strong>「增广路径」</strong></p>
<p>其中属于$M$的边有：<br>${x2,y3}, {x1,y1}$</p>
<p>不属于$M$的边有：<br>${x4,y3}, {x2,y1},{x1,y2}$</p>
<p>显然，<i><b>不属于$M$的边比属于$M$的边要多一条</b></i></p>
<hr>
<p>将这条增广路上的边全都「反色」，如图</p>
<p><img src="https://s1.ax2x.com/2018/07/06/oWBQY.png" alt="oWBQY.png"></p>
<p>可以发现，匹配仍然合法，但是匹配数多了一对</p>
<pre><code>另外，单独的一条连接两个未匹配点的边显然也是增广路   
</code></pre><p>那么可知，当不能再找到增广轨时，就得到了一个「最大匹配」，这就是匈牙利算法的基本思路</p>
<h3 id="增广路径性质"><a href="#增广路径性质" class="headerlink" title="增广路径性质"></a>增广路径性质</h3><p>由增广路的定义可以推出下述三个结论：</p>
<ol>
<li>P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。</li>
<li>P经过取反操作可以得到一个更大的匹配M’。</li>
<li>M为G的最大匹配当且仅当不存在相对于M的增广路径。</li>
</ol>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>用增广路求最大匹配（称作匈牙利算法，匈牙利数学家Edmonds于1965年提出）</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li>置$M$为空</li>
<li>找出一条增广路$P$，通过取反操作获得更大的匹配$M‘$代替$M$</li>
<li>重复2直到找不出增广路</li>
</ol>
<h3 id="找增广路径的算法"><a href="#找增广路径的算法" class="headerlink" title="找增广路径的算法"></a>找增广路径的算法</h3><p>我们采用DFS的办法找一条增广路径： </p>
<p>从X部一个未匹配的顶点u开始，找一个未访问的邻接点v（v一定是Y部顶点）。</p>
<p>对于$v$，分两种情况：</p>
<ol>
<li>如果$v$未匹配，则已经找到一条增广路</li>
<li>如果$v$已经匹配，则取出$v$的匹配顶点$w$($w$一定是$X$部顶点)，边$(w,v)$目前是匹配的，根据“取反”的想法，要将$(w,v)$改为未匹配，$(u,v)$设为匹配，能实现这一点的条件是看从$w$为起点能否新找到一条增广路径$P’$。如果行，则$u \rightarrow v \rightarrow P’$就是一条以$u$为起点的增广路径。</li>
</ol>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ \text{Algorithm 1: } $ 寻找从 $ u $ 出发的增广路径 $ DFS(u) $<br>返回 $ \text{True} $ 表示成功匹配，$ \text{False} $ 反之<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>&nbsp;&nbsp;$ 1: \text{For each } v \in u$的邻接点<br>&nbsp;&nbsp;$ 2: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{If } v $ 未访问过<br>&nbsp;&nbsp;$ 3: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 标记 $ v $ 被访问过<br>&nbsp;&nbsp;$ 4: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{If } v $ 未被匹配 或者 $ \text{DFS(}v$的匹配点$\text{)}$<br>&nbsp;&nbsp;$ 5: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 标记 $v$ 的匹配点为 $u$，$u$ 的匹配点为 $v$<br>&nbsp;&nbsp;$ 6: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{Return True} $<br>&nbsp;&nbsp;$ 7: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{End If}$<br>&nbsp;&nbsp;$ 8: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{End If}$<br>&nbsp;&nbsp;$ 9: \text{End For} $<br>$ 10: \text{Return False} $<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans[MAXN];</span><br><span class="line"><span class="comment">// ans 表示 Y 集合中每个顶点的匹配点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(px, <span class="number">-1</span>, <span class="keyword">sizeof</span> px);</span><br><span class="line"><span class="comment">// 用 -1 表示没有匹配</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[u]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = edge[e].now;</span><br><span class="line">        <span class="keyword">if</span> (!vis[now]) &#123;</span><br><span class="line">            vis[now] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (px[now] == <span class="number">-1</span> || DFS(px[now])) &#123;</span><br><span class="line">                px[u] = now;</span><br><span class="line">                <span class="comment">// 为了方便，可以只标记 Y 到 X</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="《HDU2063-过山车》题解"><a href="#《HDU2063-过山车》题解" class="headerlink" title="《HDU2063 过山车》题解"></a>《HDU2063 过山车》题解</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？</p>
<h2 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h2><p><strong>Input</strong></p>
<p>输入数据的第一行是三个整数$K , M , N$，分别表示可能的组合数目，女生的人数，男生的人数。$0&lt;K&lt;=1000,<br>1&lt;=N,M&lt;=500$.接下来的$K$行，每行有两个数，分别表示女生$A_i$愿意和男生$B_j$做partner。最后一个$0$结束输入。</p>
<p><strong>Output</strong></p>
<p>对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3 3</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>「每个女生必须找个个男生做partner和她同坐」</p>
<p>好了，可以看出这是匹配问题，问你如何匹配</p>
<p>「Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner」</p>
<p>这句话告诉了我们如何建边：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把所有女生的顶点放到集合X中，所有男生的顶点放到集合Y中，</span><br><span class="line">从Rabbit分别建一条到XHD的边和一条到PQK的边，</span><br><span class="line">从Grass分别建一条到linle的边和一条到LL的边……</span><br></pre></td></tr></table></figure>
<p>那么显然这就是一个二分图，而本题要求的就是这个二分图的最大匹配</p>
<p>又是一道模板题</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t[MAXN][MAXN], <span class="built_in">map</span>[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[u][i] &amp;&amp; !vis[i]) &#123;</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>[i] || dfs(<span class="built_in">map</span>[i])) &#123;</span><br><span class="line">                <span class="built_in">map</span>[i] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;k, &amp;m, &amp;n), k != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(t));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">map</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">map</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            t[x][y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">            <span class="keyword">if</span> (dfs(i)) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>学习笔记</tag>
        <tag>二分图</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P5019「NOIP 2013 / 2018」《铺设道路》</title>
    <url>/2019-01-23/Luogu-P5019/</url>
    <content><![CDATA[<blockquote>
<p>CCF：<strong>我&nbsp;抄&nbsp;我&nbsp;自&nbsp;己</strong></p>
</blockquote>
<a id="more"></a>
<center>本题与[洛谷P1969](https://www.luogu.org/problemnew/show/P1969)重复</center>
<center>代码通用</center>
<center>题解[传送门](/2019-01-22/Luogu-P1969)</center>
]]></content>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>Luogu-P5020</title>
    <url>/2019-01-23/Luogu-P5020/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>洛谷P1330《封锁阳光大学》</title>
    <url>/2019-01-23/Luogu-P1330/</url>
    <content><![CDATA[<blockquote>
<p>对子连通图的染色</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。</p>
<p>阳光大学的校园是一张由N个点构成的无向图，N个点之间由M条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在与这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。</p>
<p>询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：两个整数N，M</p>
<p>接下来M行：每行两个整数A，B，表示点A到点B之间有道路相连。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一行：如果河蟹无法封锁所有道路，则输出“Impossible”，否则输出一个整数，表示最少需要多少只河蟹。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例#1"></a>输入样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例#1"></a>输出样例#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Impossible</span><br></pre></td></tr></table></figure>
<h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例#2"></a>输入样例#2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例#2"></a>输出样例#2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模】</p>
<p>1&lt;=N&lt;=10000，1&lt;=M&lt;=100000，任意两点之间最多有一条道路。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><big>本题的图可能不为连通图（注意这个坑）</big>

<p>阅读题目，我们得到了这样几条信息：<br>「当某个点被封锁后，与这个点相连的道路就被封锁了」<br>「当两只河蟹封锁了相邻的两个点时，他们会发生冲突」<br>「封锁所有道路并且不发生冲突」</p>
<p>总结一下就是：<br>「要求每一条边有且仅有一个点被选择，求最少能选择多少点」</p>
<p>然后我们就可以考虑用染色的方法做这一题</p>
<p>我们枚举每一个点，以当前枚举到的起点为根对这个子连通图进行 DFS 染色（因为图可能不联通），答案累加每次染色的最小数量（黑色点数量和白色点数量中最小的）</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> head(a) Head[a].id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nowcolor(a) Head[a].color</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> visited(a) Head[a].used</span></span><br><span class="line"><span class="comment">// 这样 define 有助于简化代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, ans;</span><br><span class="line">    <span class="keyword">int</span> sum0, sum1;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> color, used, id;</span><br><span class="line">            <span class="comment">// 在一个数组中存储三个数量</span></span><br><span class="line">            </span><br><span class="line">            Node() &#123; color = used = id = <span class="number">0</span>; &#125;</span><br><span class="line">        &#125; Head[MAXN];</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> now, next;</span><br><span class="line">        &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">bool</span> isR = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isR) &#123; addEdge(next, prev, <span class="literal">false</span>); &#125;</span><br><span class="line">            edge[++cnt].now = next;</span><br><span class="line">            edge[cnt].next = head(prev);</span><br><span class="line">            head(prev) = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Color</span><span class="params">(<span class="keyword">int</span> __id, <span class="keyword">int</span> nowColor)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 返回 true 为成功染色， false 反之</span></span><br><span class="line">            <span class="keyword">if</span> (visited(__id)) &#123;</span><br><span class="line">                <span class="keyword">return</span> nowcolor(__id) == nowColor;</span><br><span class="line">                <span class="comment">// 如果当前被染过不同的颜色，就失败</span></span><br><span class="line">            &#125;</span><br><span class="line">            visited(__id) = <span class="literal">true</span>;</span><br><span class="line">            nowcolor(__id) = nowColor;</span><br><span class="line">            <span class="keyword">if</span> (nowColor) ++sum1;</span><br><span class="line">            <span class="keyword">else</span> ++sum0;</span><br><span class="line">            <span class="keyword">bool</span> __ans = <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = head(__id); e &amp;&amp; __ans; e = edge[e].next) &#123;</span><br><span class="line">                <span class="keyword">int</span> now = edge[e].now;</span><br><span class="line">                __ans = __ans &amp; Color(now, nowColor ^ <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 遍历与当前点相连的每一条边并 DFS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> __ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> __EXIT() &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        g1.addEdge(prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g1.visited(i)) <span class="keyword">continue</span>;</span><br><span class="line">        sum0 = sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!g1.Color(i, <span class="number">0</span>)) __EXIT();</span><br><span class="line">        ans += <span class="built_in">std</span>::min(sum0, sum1);</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO::putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1969「NOIP 2013 / 2018」《积木大赛》</title>
    <url>/2019-01-22/Luogu-P1969/</url>
    <content><![CDATA[<blockquote>
<p><strong>原&nbsp;题&nbsp;警&nbsp;告</strong></p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，大厦可以看成由$n$块宽度为1的积木组成，第$i$块积木的最终高度需要是$h_i$。</p>
<p>在搭建开始之前，没有任何积木（可以看成$n$块高度为$0$的积木）。接下来每次操作，小朋友们可以选择一段连续区间$[l, r]$，然后将第 $L$块到第 $R$ 块之间（含第 $L$ 块和第 $R$块）所有积木的高度分别增加$1$。</p>
<p>小 $M$是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>包含两行，第一行包含一个整数nn，表示大厦的宽度。</p>
<p>第二行包含$n$个整数，第i个整数为$h_i$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>建造所需的最少操作数。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">2 3 4 1 2</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【样例解释】</p>
<p>其中一种可行的最佳方案，依次选择</p>
<p>$[1,5]$ $[1,3]$ $[2,3]$ $[3,3]$ $[5,5]$</p>
<p>【数据范围】</p>
<p>对于 30\%30%的数据，有$1 ≤ n ≤ 10$；</p>
<p>对于 70\%70%的数据，有$1 ≤ n ≤ 1000$；</p>
<p>对于 100\%100%的数据，有$1 ≤ n ≤ 100000,0 ≤ h_i≤ 10000$。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>真不敢相信 CCF 居然用了原题</p>
<hr>
<p>单独把 $h_1$ 读进来，存在 $ans$ 里。</p>
<p>在读剩下的 $n - 1$ 个数的时候，每次判一下当前数与上一个数的关系：</p>
<ul>
<li>如果比上一个数大，就说明我们还需要再放积木，答案累加当前数与上一个数的差；</li>
<li>如果没有上个数大，就说明我们之前搭积木已经能够把这摞积木放好了，自然就不需要更新了。</li>
</ul>
<p>然后把「上一个数」更新为当前数即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> lastOne = ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> now;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; now;</span><br><span class="line">        <span class="keyword">if</span> (now &gt; lastOne) ans += (now - lastOne);</span><br><span class="line">        lastOne = now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1119《灾后重建》</title>
    <url>/2019-01-22/Luogu-P1119/</url>
    <content><![CDATA[<blockquote>
<p>让人加深对 Floyd 的理解</p>
</blockquote>
<a id="more"></a>
<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>B地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出B地区的村庄数$N$，村庄编号从$0$到$N−1$，和所有$M$条公路的长度，公路是双向的。并给出第$i$个村庄重建完成的时间$t_i$，你可以认为是同时开始重建并在第$t_i$​    天重建完成，并且在当天即可通车。若$t_i$​为$0$则说明地震未对此地区造成损坏，一开始就可以通车。之后有$Q$个询问$(x, y, t)$，对于每个询问你要回答在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄$x$或村庄$y$在第$t$天仍未重建完成 ，则需要返回$-1$。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数$N,M$，表示了村庄的数目与公路的数量。</p>
<p>第二行包含$N$个非负整数$t<em>0, t_1,…, t</em>{N-1}$，表示了每个村庄重建完成的时间，数据保证了$t<em>0 ≤ t_1 ≤ … ≤ t</em>{N-1}$。</p>
<p>接下来$M$行，每行$3$个非负整数$i, j, w$，$w$为不超过$10000$的正整数，表示了有一条连接村庄$i$与村庄$j$的道路，长度为$w$，保证$i≠j$，且对于任意一对村庄只会存在一条道路。</p>
<p>接下来一行也就是$M+3$行包含一个正整数$Q$，表示$Q$个询问。</p>
<p>接下来$Q$行，每行$3$个非负整数$x, y, t$，询问在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少，数据保证了$t$是不下降的。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共$Q$行，对每一个询问$(x, y, t)$输出对应的答案，即在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果在第$t$天无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄$x$或村庄$y$在第$t$天仍未修复完成，则输出$-1$。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 3 4</span><br><span class="line">0 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 2</span><br><span class="line">2 1 4</span><br><span class="line">0 3 5</span><br><span class="line">4</span><br><span class="line">2 0 2</span><br><span class="line">0 1 2</span><br><span class="line">0 1 3</span><br><span class="line">0 1 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">-1</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>对于$30\%$的数据，有$N≤50$；</p>
<p>对于$30\%$的数据，有$t_i= 0$​，其中有$20\%$的数据有$t_i = 0$且$N&gt;50$；</p>
<p>对于$50\%$的数据，有$Q≤100$；</p>
<p>对于$100\%$的数据，有 $N≤200$，$M≤N \times (N-1)/2$，$Q≤50000$，所有输入数据涉及整数均不超过$100000$。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先 $ N \leq 200 $，那么肯定是用 Floyd</p>
<p>Floyd 算法的本质是 DP，转移方程为 </p>
<script type="math/tex; mode=display">f_{i,j} = min(f_{i,j},\ f_{i,k} + f_{k,j})</script><p>其中的这个 $k$ 就是「中转点」，表示当前最大能经过编号为 $k$ 的点。</p>
<p>明确了这些，我们再来看题。</p>
<hr>
<p>给出每一个点状态转为「可用」的时间和所有的边，让你求任意点到点的距离。<br>我们跑 Floyd 时，$k$ 限制了我们当前能走的点，就相当于是题目中点的「不可用」状态！再加上所有的询问都是按照时间顺序给出的，所以我们就可以利用 Floyd 的性质来做这题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- 全局变量 -- */</span></span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>; <span class="comment">// 当前最多能走第 now 个点，也就是 Floyd 中的 k</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- 在函数 main() 里 -- */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; start &gt;&gt; end &gt;&gt; ti<span class="comment">// 读入起止点 start end 和当前时间 ti</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (Time[now] &lt;= ti) &#123;</span><br><span class="line">	<span class="comment">// 当前的点转为「可用」的时间没有超过当前时间</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> k = now; <span class="comment">// 方便理解</span></span><br><span class="line">	<span class="comment">// 以下为标准的 Floyd</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; n; ++x) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; n; ++y) &#123;</span><br><span class="line">			dis[x][y] = <span class="built_in">std</span>::min(dis[x][y], dis[x][k] + dis[k][y]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	++now; <span class="comment">// 这个点更新完了，往后继续更新，直到超过当前时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">	dis[start][end] == __INF <span class="comment">/* 无法到达 */</span> </span><br><span class="line">	|| Time[start] &gt; ti </span><br><span class="line">	|| Time[end] &gt; ti <span class="comment">/* 没有转为「可用」 */</span></span><br><span class="line">) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[start][end]); <span class="comment">// 输出答案</span></span><br></pre></td></tr></table></figure>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> dis[MAXN][MAXN], k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, q;</span><br><span class="line">    <span class="keyword">int</span> ttime[MAXN];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    <span class="built_in">memset</span>(ttime, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> ttime);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ttime[i] = getint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        <span class="keyword">int</span> weight = getint();</span><br><span class="line">        dis[prev][next] = dis[next][prev] = weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    q = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> s = getint();</span><br><span class="line">        <span class="keyword">int</span> t = getint();</span><br><span class="line">        <span class="keyword">int</span> timee = getint();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ttime[k] &lt;= timee) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; n; ++a) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt; n; ++b) &#123;</span><br><span class="line">                    dis[a][b] = <span class="built_in">std</span>::min(dis[a][b], dis[a][k] + dis[k][b]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dis[s][t] == <span class="number">0x3f3f3f3f</span> || ttime[s] &gt; timee || ttime[t] &gt; timee) ans = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> ans = dis[s][t];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1341《无序字母对》</title>
    <url>/2019-01-21/Luogu-P1341/</url>
    <content><![CDATA[<blockquote>
<p>欧拉图板子题</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定n个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有n+1个字母的字符串使得每个字母对都在这个字符串中出现。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数n。</p>
<p>以下n行每行两个字母，表示这两个字母需要相邻。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出满足要求的字符串。</p>
<p>如果没有满足要求的字符串，请输出“No Solution”。</p>
<p>如果有多种方案，请输出前面的字母的ASCII编码尽可能小的（字典序最小）的方案</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">aZ</span><br><span class="line">tZ</span><br><span class="line">Xt</span><br><span class="line">aX</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XaZtX</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【数据规模与约定】</p>
<p>不同的无序字母对个数有限，n的规模可以通过计算得到。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们考虑把每一对字母视为一条边<br>那么这个图就是无向的（因为字母对是无序的）</p>
<p>题目让你求一个串，使得这个串里出现了所有的字母对，实际上就是让你求一条路径，使得所有的边都出现过</p>
<p><b><big><big><big><big>那这不就是求欧拉路吗！</big>&lt;/big&gt;&lt;/big&gt;&lt;/big&gt;</big></big></big></b></p>
<p>所以这道题就完美地被转换为了欧拉路板子题</p>
<p>没学过欧拉路的看<a href="/2019-01-18/EulerPath-EulerCircuit/">这里</a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">256</span> + <span class="number">233</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> G[MAXN][MAXN], deg[MAXN];</span><br><span class="line">    <span class="keyword">char</span> __MIN_NODE = <span class="number">127</span>, __MAX_NODE = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">char</span> prev, <span class="keyword">char</span> next, <span class="keyword">bool</span> Undirected = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">        ++G[prev][next];</span><br><span class="line">        <span class="keyword">if</span> (Undirected) addEdge(next, prev, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">deleteEdge</span><span class="params">(<span class="keyword">char</span> prev, <span class="keyword">char</span> next, <span class="keyword">bool</span> Undirected = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">        --G[prev][next];</span><br><span class="line">        <span class="keyword">if</span> (Undirected) deleteEdge(next, prev, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Hierholzer</span><span class="params">(<span class="keyword">char</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> i = __MIN_NODE; i &lt;= __MAX_NODE; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G[s][i]) &#123;</span><br><span class="line">                deleteEdge(s, i);</span><br><span class="line">                Hierholzer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stk.push(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">char</span> prev, next;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; prev;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; next;</span><br><span class="line">        addEdge(prev, next);</span><br><span class="line">        ++deg[prev];</span><br><span class="line">        ++deg[next];</span><br><span class="line">        __MIN_NODE = <span class="built_in">std</span>::min(__MIN_NODE, <span class="built_in">std</span>::min(prev, next));</span><br><span class="line">        __MAX_NODE = <span class="built_in">std</span>::max(__MAX_NODE, <span class="built_in">std</span>::max(prev, next));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> i = __MIN_NODE; i &lt;= __MAX_NODE; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deg[i] != <span class="number">0</span> &amp;&amp; deg[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) start = i;</span><br><span class="line">            ++odd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!start) start = __MIN_NODE;</span><br><span class="line">    <span class="keyword">if</span> (odd &amp;&amp; odd != <span class="number">2</span>) &#123;</span><br><span class="line">    	<span class="comment">// 注意不要忘了判无解</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"No Solution"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Hierholzer(start);</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stk.top();</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2731《骑马修栅栏 Riding the Fences》</title>
    <url>/2019-01-20/Luogu-P2731/</url>
    <content><![CDATA[<blockquote>
<p>欧拉图板子题</p>
</blockquote>
<a id="more"></a>
<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>Farmer John每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>John是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。你必须编一个程序，读入栅栏网络的描述，并计算出一条修栅栏的路径，使每个栅栏都恰好被经过一次。John能从任何一个顶点(即两个栅栏的交点)开始骑马，在任意一个顶点结束。</p>
<p>每一个栅栏连接两个顶点，顶点用1到500标号(虽然有的农场并没有500个顶点)。一个顶点上可连接任意多(&gt;=1)个栅栏。两顶点间可能有多个栅栏。所有栅栏都是连通的(也就是你可以从任意一个栅栏到达另外的所有栅栏)。</p>
<p>你的程序必须输出骑马的路径(用路上依次经过的顶点号码表示)。我们如果把输出的路径看成是一个500进制的数，那么当存在多组解的情况下，输出500进制表示法中最小的一个 (也就是输出第一位较小的，如果还有多组解，输出第二位较小的，等等)。</p>
<p>输入数据保证至少有一个解。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1行: 一个整数F(1 &lt;= F &lt;= 1024)，表示栅栏的数目</p>
<p>第2到F+1行: 每行两个整数i, j(1 &lt;= i,j &lt;= 500)表示这条栅栏连接i与j号顶点。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出应当有F+1行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 2</span><br><span class="line">4 5</span><br><span class="line">2 5</span><br><span class="line">5 6</span><br><span class="line">5 7</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>题目翻译来自NOCOW。</p>
<p>USACO Training Section 3.3</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>「使每个栅栏都恰好被经过一次」</p>
<p>妥妥的欧拉路板子题啊</p>
<p>没学过的看<a href="/2019-01-18/EulerPath-EulerCircuit/">这里</a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">500</span> + <span class="number">10</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> G[MAXN][MAXN], n, degree[MAXN];</span><br><span class="line">    <span class="keyword">int</span> __MAX_NODE = <span class="number">-1</span>, __MIN_NODE = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        ++G[from][to];</span><br><span class="line">        ++G[to][from];</span><br><span class="line">        ++degree[from];</span><br><span class="line">        ++degree[to];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Hierholzer</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t = __MIN_NODE; t &lt;= __MAX_NODE; ++t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (G[s][t]) &#123;</span><br><span class="line">                --G[s][t];</span><br><span class="line">                --G[t][s];</span><br><span class="line">                Hierholzer(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.push(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    n = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        addEdge(prev, next);</span><br><span class="line">        __MAX_NODE = <span class="built_in">std</span>::max(__MAX_NODE, <span class="built_in">std</span>::max(prev, next));</span><br><span class="line">        __MIN_NODE = <span class="built_in">std</span>::min(__MIN_NODE, <span class="built_in">std</span>::min(prev, next));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= __MAX_NODE; ++i, ++start) &#123;</span><br><span class="line">        <span class="keyword">if</span> (degree[i] != <span class="number">0</span> &amp;&amp; degree[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) Hierholzer(start);</span><br><span class="line">    <span class="keyword">else</span> Hierholzer(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (!ans.empty()) &#123;</span><br><span class="line">        putint(ans.top(), <span class="string">'\n'</span>);</span><br><span class="line">        ans.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>USACO</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉图学习笔记</title>
    <url>/2019-01-18/EulerPath-EulerCircuit/</url>
    <content><![CDATA[<blockquote>
<p>从一个点出发走一走</p>
</blockquote>
<a id="more"></a>
<h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><ol>
<li>定义 $ (A,B) $ 表示从 $ A \rightarrow B $ 的一条边（若无特别说明，即为无向边）</li>
<li>定义 $ (A,B) \rightarrow (C,D) $ 表示从 $ A \rightarrow D $ ，经过 $ (A,B), (C,D) $ 两条边的路径</li>
<li>定义「孤立点」表示一个度为 0 的点</li>
<li>定义「奇顶点」表示一个度数为奇数的点</li>
<li>定义对于有向图 G ，将所有的有向边替换为无向边得到图 G 的基图，若图 G 的基图是连通的，则称图 G 是「弱连通图」。</li>
<li>$ Stack_a $ 表示标号为 $ a $ 的栈。</li>
<li>用 $ Stack_x = a]b]c] $ 表示 $ Stack_x $ 的层级结构，其中 $ a $ 为栈顶， $ c $ 为栈底。</li>
<li>$ \text{Foo} \rightarrow \text{Bar} $ 表示 $ \text{Foo} $ 里的元素 $ \text{Bar} $ （表特指）</li>
</ol>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>如果图G中的一个路径包括每个边恰好一次，则该路径称为欧拉路径(Euler path)。<br>如果一个回路是欧拉路径，则称为欧拉回路(Euler circuit)。<br>具有欧拉回路的图称为欧拉图（简称E图）。具有欧拉路径但不具有欧拉回路的图称为半欧拉图。</p>
<p style="text-align: right">——百度百科</p>

<hr>
<p>通俗地说，</p>
<p>对于一个图的某条路径，如果能从一个点出发将这个图的所有边都不重复地走一遍，那么这条路径就被称为欧拉路；对于一个图的某条路径，如果能从一个点出发将这个图的所有边都不重复地走一遍并回到起点，那么这条路径就被称为欧拉回路。</p>
<p>比如下图中的</p>
<script type="math/tex; mode=display">(A,B) \rightarrow (B,C) \rightarrow (C,D) \rightarrow (D,B)</script><p>就是一条欧拉路。<br><img src="/images/EulerPath-EulerCircuit/0.png" alt="0"></p>
<p>比如下图中的</p>
<script type="math/tex; mode=display">(A,B) \rightarrow (B,C) \rightarrow (D,C) \rightarrow (C,A)</script><p>就是一条欧拉回路。<br><img src="/images/EulerPath-EulerCircuit/1.png" alt="1"></p>
<h1 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h1><h2 id="无向图判定"><a href="#无向图判定" class="headerlink" title="无向图判定"></a>无向图判定</h2><ol>
<li><p>无孤立点的无向图 G 为欧拉图，当且仅当图 G 连通且所有顶点的度都是偶数。</p>
</li>
<li><p>如果无向连通图有 2k 个奇顶点，则图 G 可以用 k 条路径将图 G 的每一条边经过 一次，且至少要使用 k 条路径。</p>
</li>
<li><p>无孤立点的无向图 G 为半欧拉图，当且仅当图 G 连通且 G 的奇顶点个数为 2 。 此时两个奇顶点分别为欧拉路径的起点和终点。 </p>
</li>
</ol>
<h2 id="有向图判定"><a href="#有向图判定" class="headerlink" title="有向图判定"></a>有向图判定</h2><ol>
<li><p>无孤立点的有向图 G 为欧拉图，当且仅当图 G 弱连通且所有顶点的入度等于出度。</p>
</li>
<li><p>对于连通有向图，所有顶点入度与出度差的绝对值之和为 2k ，则图 G 可以用 k 条路径将图 G 的每一条边经过一次，且至少要使用 k 条路径。</p>
</li>
<li><p>无孤立点的有向图 G 为半欧拉图，当且仅当图 G 弱连通，且恰有一个顶点 u 入度比出度小 1 ，一个顶点 v 入度比出度大 1 ，其余顶点入度等于出度。此时存在 u 作为起点， v 作为终点的欧拉路径。</p>
</li>
</ol>
<h1 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h1><h2 id="Hierholzier-算法"><a href="#Hierholzier-算法" class="headerlink" title="Hierholzier 算法"></a>Hierholzier 算法</h2><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>任选一起点，沿任意未访问的边走到相邻节点，直至无路可走。此时必然回到起点形成了一个回路，此时图中仍有部分边未被访问。在退栈的时候找到仍有未访问边的点，从该点为起点求出另一个回路，将该回路与之前求出的回路拼接。如此反复，直至所有的边都被访问。</p>
<hr>
<p>比如说我们有这样一张图：</p>
<p><img src="/images/EulerPath-EulerCircuit/2.png" alt="2"></p>
<p>我们随便取一个点，比如说 $ 1 $，把它加入一个<strong>栈</strong>。</p>
<script type="math/tex; mode=display">Stack_1 = 1]</script><script type="math/tex; mode=display">Path_1 = [\ ]</script><p>我们用 $ u $ 表示 $ Stack_1 \rightarrow Top $<br>如果当前的 $ u $ 点已没有未访问的出边，就将 $ u $ 从 $ Stack_1 $ 里弹出来，加入到 $ Path_1 $ 的<strong>前端</strong></p>
<p>重复上面的过程，直到 $ Stack_1 $ 为空。</p>
<p><img src="/images/EulerPath-EulerCircuit/3.png" alt="3"><br>在这个过程中，</p>
<script type="math/tex; mode=display">Stack_1 = 2]1],\ Path_1 = [\ ]</script><script type="math/tex; mode=display">Stack_1 = 4]2]1],\ Path_1 = [\ ]</script><script type="math/tex; mode=display">Stack_1 = 1]4]2]1],\ Path_1 = [\ ]</script><script type="math/tex; mode=display">Stack_1 = 5]4]2]1],\ Path_1 = [1]</script><script type="math/tex; mode=display">Stack_1 = 6]5]4]2]1],\ Path_1 = [1]</script><script type="math/tex; mode=display">Stack_1 = 4]6]5]4]2]1],\ Path_1 = [1]</script><script type="math/tex; mode=display">Stack_1 = 2]5]4]2]1],\ Path_1 = [6,4,1]</script><script type="math/tex; mode=display">Stack_1 = 3]2]5]4]2]1],\ Path_1 = [6,4,1]</script><script type="math/tex; mode=display">Stack_1 = 5]3]2]5]4]2]1],\ Path_1 = [6,4,1]</script><hr>
<p>所有的边都访问了，开始回溯存路径</p>
<script type="math/tex; mode=display">Stack_1 = \ ],\ Path_1 = [1,2,4,5,2,3,6,4,1]</script><p>最终答案即为 $ Path_1 $</p>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>假装自己写的是真正的 $ \LaTeX $</p>
<hr>
<p>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p>
<p>$ \text{Algorithm 1: Hierholzer(s)} $<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯<br>$ 1: \text{while s} $ 存在未被删除的无向边 $ (s,t)\  \text{do} $<br>$ 2: $ &nbsp;&nbsp;&nbsp;&nbsp;删除无向边 $ (s,t) $<br>$ 3: $ &nbsp;&nbsp;&nbsp;&nbsp;$ \text{Hierholzer(t)} $<br>$ 4: \text{End while} $<br>$ 5: cnt \leftarrow cnt + 1$<br>$ 6: Path[cnt] \leftarrow s$<br>⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>真正的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN_M = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> G[MAXN_M][MAXN_M], ans[MAXN_M], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hierholzer</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = __MIN_NODE; t &lt;= __MAX_NODE; ++t) &#123;</span><br><span class="line">        <span class="comment">// 预防数据中不出现标号为 1 的节点的情况</span></span><br><span class="line">        <span class="comment">// __MIN_NODE 指数据中标号最小的节点的标号</span></span><br><span class="line">        <span class="comment">// __MAX_NODE 同上</span></span><br><span class="line">        <span class="keyword">if</span> (G[s][t]) &#123;</span><br><span class="line">            <span class="comment">// 使用邻接矩阵存图，更加易懂</span></span><br><span class="line">            --G[s][t];</span><br><span class="line">            --G[t][s];</span><br><span class="line">            Hierholzer(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[++cnt] = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Fluery-算法"><a href="#Fluery-算法" class="headerlink" title="Fluery 算法"></a>Fluery 算法</h2><p><del>挖坑待填</del></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problemnew/show/P2731" target="_blank" rel="noopener">洛谷 P2731</a> 模板题</p>
<p>题解将会在不久后上传</p>
<h1 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>IOI2018 中国国家候选队论文集</li>
<li>洛谷 P2731 题解</li>
</ol>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>学习笔记</tag>
        <tag>DFS</tag>
        <tag>图论算法</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title>BZOJ1601《[Usaco2008 Oct]灌水》</title>
    <url>/2019-01-12/BZOJ1601/</url>
    <content><![CDATA[<blockquote>
<p>最小生成树板子</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Farmer John已经决定把水灌到他的n(1&lt;=n&lt;=300)块农田，农田被数字1到n标记。把一块土地进行灌水有两种方法，从其他农田饮水，或者这块土地建造水库。 建造一个水库需要花费wi(1&lt;=wi&lt;=100000),连接两块土地需要花费Pij(1&lt;=pij&lt;=100000,pij=pji,pii=0). 计算Farmer John所需的最少代价。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>*第一行：一个数n</p>
<p>*第二行到第n+1行：第i+1行含有一个数wi</p>
<p>*第n+2行到第2n+1行：第n+1+i行有n个被空格分开的数，第j个数代表pij。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>*第一行：一个单独的数代表最小代价.</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">0 2 2 2</span><br><span class="line">2 0 3 3</span><br><span class="line">2 3 0 4</span><br><span class="line">2 3 4 0</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure>
<p>输出详解：</p>
<p>Farmer John在第四块土地上建立水库，然后把其他的都连向那一个，这样就要花费3+2+2+2=9</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>很显然这道题需要最小生成树</p>
<p>那么是不是我们生成树之后加上根节点的$w$值就可以了？</p>
<big><big>显然不！</big></big>

<p>很容易就能举出反例：<br>最小生成树的根节点$w_1=99999$，次小生成树的根节点$w_2=1$，两个生成树答案之差$ans_1 - ans_2 = 1$</p>
<p>那么我们就可以考虑建一个虚拟的编号为$n + 1$的点，对于所有的点$i$以$w_i$为边权进行连接<br>最后直接跑最小生成树即可。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZ = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> U[MAX_SIZ];</span><br><span class="line">        </span><br><span class="line">        UnionFind() &#123;</span><br><span class="line">            For (i, <span class="number">1</span>, MAX_SIZ) U[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> U[x];</span><br><span class="line">            <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> xx = Find(x);</span><br><span class="line">            <span class="keyword">int</span> yy =  Find(y);</span><br><span class="line">            <span class="keyword">if</span> (xx == yy) <span class="keyword">return</span>;</span><br><span class="line">            U[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> nweight, now;</span><br><span class="line">            </span><br><span class="line">            Node() &#123; nweight = now = <span class="number">0</span>; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nweight &gt; that.nweight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> now, weight, next;</span><br><span class="line">            <span class="keyword">int</span> raw_now, raw_next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> weight &lt; that.weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head[MAXN], dis[MAXN], cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight, <span class="keyword">bool</span> isR = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isR) &#123; addEdge(next, prev, weight, <span class="literal">false</span>); &#125;</span><br><span class="line">            edge[++cnt].now = next;</span><br><span class="line">            edge[cnt].weight = weight;</span><br><span class="line">            edge[cnt].next = head[prev];</span><br><span class="line">            head[prev] = cnt;</span><br><span class="line">            </span><br><span class="line">            edge[cnt].raw_next = next;</span><br><span class="line">            edge[cnt].raw_now = prev;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> Node <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> nowWeight, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">            Node tmp;</span><br><span class="line">            tmp.nweight = nowWeight;</span><br><span class="line">            tmp.now = now;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">            <span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line">            q.push(NewNode(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                Node NowNode = q.top();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> now = NowNode.now;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">                    <span class="keyword">if</span> (dis[to] &gt; dis[now] + edge[e].weight) &#123;</span><br><span class="line">                        dis[to] = dis[now] + edge[e].weight;</span><br><span class="line">                        q.push(NewNode(dis[to], to));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>, tot = <span class="number">0</span>;</span><br><span class="line">            UnionFind u;</span><br><span class="line">            <span class="built_in">std</span>::sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + cnt);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> eu = u.Find(edge[i].raw_now);</span><br><span class="line">                <span class="keyword">int</span> ev = u.Find(edge[i].raw_next);</span><br><span class="line">                <span class="keyword">if</span> (eu == ev) <span class="keyword">continue</span>;</span><br><span class="line">                u.Union(eu, ev);</span><br><span class="line">                ans += edge[i].weight;</span><br><span class="line">                </span><br><span class="line">                ++tot;</span><br><span class="line">                <span class="keyword">if</span> (tot == cnt - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, n) g1.addEdge(i, n + <span class="number">1</span>, getint());</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        For (j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">int</span> p = getint();</span><br><span class="line">            g1.addEdge(i, j, p, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO::putint(g1.Kruskal(), <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>BZOJ</tag>
        <tag>USACO</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1144《最短路计数》</title>
    <url>/2019-01-12/Luogu-P1144/</url>
    <content><![CDATA[<blockquote>
<p>最短路“板子”</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一个$N$个顶点$M$条边的无向无权图，顶点编号为$1-N$。问从顶点$1$开始，到其他每个点的最短路有几条。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含$2$个正整数$N,M$，为图的顶点数与边数。</p>
<p>接下来$M$行，每行$2$个正整数$x,y$，表示有一条顶点$x$连向顶点$y$的边，请注意可能有自环与重边。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共$N$行，每行一个非负整数，第$i$行输出从顶点$1$到顶点$i$有多少条不同的最短路，由于答案有可能会很大，你只需要输出 $ans \bmod 100003$后的结果即可。如果无法到达顶点$i$则输出$0$。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>$1$到$5$的最短路有$4$条，分别为$2$条$1-2-4-5$和$2$条$1-3-4-5$（由于$4−5$的边有$2$条）。</p>
<p>对于$20\%$的数据，$N ≤ 100$；</p>
<p>对于$60\%$的数据，$N ≤ 1000$；</p>
<p>对于$100\%$的数据，$N&lt;=1000000,M&lt;=2000000$。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>稍微改一下最短路板子即可</p>
<p>具体就是用 <code>ans[i]</code> 数组记录一下到<code>i</code>点的最短路个数，在更新路径长度的时候判一下两条路径长度的关系即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">100006</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">    <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">    <span class="keyword">if</span> (dis[to] &gt; dis[now] + edge[e].weight) &#123;</span><br><span class="line">    <span class="comment">// 两条路径长度不等，更新答案</span></span><br><span class="line">        dis[to] = dis[now] + edge[e].weight;</span><br><span class="line">        ans[to] = ans[now];</span><br><span class="line">        q.push(NewNode(dis[to], to));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis[to] == dis[now] + edge[e].weight) &#123;</span><br><span class="line">    	<span class="comment">// 两条路径长度相等，将答案相加</span></span><br><span class="line">        ans[to] += ans[now];</span><br><span class="line">        ans[to] %= HA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">100003</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2000000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> nweight, now;</span><br><span class="line">            </span><br><span class="line">            Node() &#123; nweight = now = <span class="number">0</span>; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nweight &gt; that.nweight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> now, weight, next;</span><br><span class="line">        &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head[MAXN], dis[MAXN], ans[MAXN], cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight, <span class="keyword">bool</span> isR = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isR) &#123; addEdge(next, prev, weight, <span class="literal">false</span>); &#125;</span><br><span class="line">            edge[++cnt].now = next;</span><br><span class="line">            edge[cnt].weight = weight;</span><br><span class="line">            edge[cnt].next = head[prev];</span><br><span class="line">            head[prev] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> Node <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> nowWeight, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">            Node tmp;</span><br><span class="line">            tmp.nweight = nowWeight;</span><br><span class="line">            tmp.now = now;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">            <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="keyword">sizeof</span> ans);</span><br><span class="line">            <span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line">            q.push(NewNode(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            ans[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                Node NowNode = q.top();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> now = NowNode.now;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">                    <span class="keyword">if</span> (dis[to] &gt; dis[now] + edge[e].weight) &#123;</span><br><span class="line">                        dis[to] = dis[now] + edge[e].weight;</span><br><span class="line">                        ans[to] = ans[now];</span><br><span class="line">                        q.push(NewNode(dis[to], to));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis[to] == dis[now] + edge[e].weight) &#123;</span><br><span class="line">                        ans[to] += ans[now];</span><br><span class="line">                        ans[to] %= HA;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        g1.addEdge(prev, next, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    g1.SPFA();</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        FastIO::putint(g1.ans[i], <span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1126《机器人搬重物》</title>
    <url>/2019-01-10/Luogu-P1126/</url>
    <content><![CDATA[<blockquote>
<p><strong>有直径</strong>还写个锤</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径$1.6$米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个$N \times M$的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：向前移动$1$步（Creep）；向前移动$2$步（Walk）；向前移动$3$步（Run）；向左转（Left）；向右转（Right）。每个指令所需要的时间为$1$秒。请你计算一下机器人完成任务所需的最少时间。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为两个正整数$N,M(N,M \le 50)$，下面$N$行是储藏室的构造，$0$表示无障碍，$1$表示有障碍，数字之间用一个空格隔开。接着一行有$4$个整数和$1$个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东$E$，南$S$，西$W$，北$N$），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。</p>
<p>输出格式：<br>一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出$−1$。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 10</span><br><span class="line">0 0 0 0 0 0 1 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 1 0</span><br><span class="line">0 0 0 1 0 0 0 0 0 0</span><br><span class="line">0 0 1 0 0 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 1 0 0 0</span><br><span class="line">0 0 0 0 0 1 0 0 0 0</span><br><span class="line">0 0 0 1 1 0 0 0 0 0</span><br><span class="line">0 0 0 0 0 0 0 0 0 0</span><br><span class="line">1 0 0 0 0 0 0 0 1 0</span><br><span class="line">7 2 2 7 S</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>1.&nbsp;将格子图转为点图 &amp; 障碍物判断<br><br>要注意这个机器人是<strong>有直径</strong>的，所以边界和障碍物的四周都不能走</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        <span class="keyword">int</span> ttt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ttt);</span><br><span class="line">        <span class="keyword">if</span> (ttt) &#123;</span><br><span class="line">            <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][j - <span class="number">1</span>] = <span class="built_in">map</span>[i - <span class="number">1</span>][j] = <span class="built_in">map</span>[i - <span class="number">1</span>][j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.单向 BFS<br>枚举所有的步数和方向</p>
<p>3.三维数组判重<br>要注意本题是<strong>有方向</strong>的，所以vis数组需要开三维（<code>vis[N][M][方向]</code>）</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN_M = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Robot</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">int</span> dir;</span><br><span class="line">        <span class="keyword">int</span> step;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Robot&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN_M][MAXN_M][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">bool</span> <span class="built_in">map</span>[MAXN_M][MAXN_M];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> startx, starty, endx, endy, sd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> startdir;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> ttt;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;ttt);</span><br><span class="line">            <span class="keyword">if</span> (ttt) &#123;</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="built_in">map</span>[i][j - <span class="number">1</span>] = <span class="built_in">map</span>[i - <span class="number">1</span>][j] = <span class="built_in">map</span>[i - <span class="number">1</span>][j - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %c"</span>, &amp;startx, &amp;starty, &amp;endx, &amp;endy, &amp;startdir);</span><br><span class="line">    <span class="keyword">switch</span>(startdir) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'E'</span>: &#123;</span><br><span class="line">            sd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'S'</span>: &#123;</span><br><span class="line">            sd = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'W'</span>: &#123;</span><br><span class="line">            sd = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">            sd = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 对方向进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (startx &gt;= n || startx &lt; <span class="number">1</span> || starty &gt;= m || starty &lt; <span class="number">1</span> || <span class="built_in">map</span>[startx][starty]) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Robot rb;</span><br><span class="line">    rb.x = startx;</span><br><span class="line">    rb.y = starty;</span><br><span class="line">    rb.dir = sd;</span><br><span class="line">    rb.step = <span class="number">0</span>;</span><br><span class="line">    vis[startx][starty][sd] = <span class="literal">true</span>;</span><br><span class="line">    q.push(rb);</span><br><span class="line">    <span class="comment">// 开始 BFS</span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        rb = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> newx = rb.x;</span><br><span class="line">        <span class="keyword">int</span> newy = rb.y;</span><br><span class="line">        <span class="keyword">if</span> (newx == endx &amp;&amp; newy == endy) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, rb.step);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 枚举步数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> steps = <span class="number">1</span>; steps &lt;= <span class="number">3</span>; ++steps) &#123;</span><br><span class="line">            newx += dx[rb.dir];</span><br><span class="line">            newy += dy[rb.dir];</span><br><span class="line">            <span class="keyword">if</span> (newx &lt; <span class="number">1</span> || newx &gt;= n || newy &lt; <span class="number">1</span> || newy &gt;= m || <span class="built_in">map</span>[newx][newy]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!vis[newx][newy][rb.dir]) &#123;</span><br><span class="line">                vis[newx][newy][rb.dir] = <span class="literal">true</span>;</span><br><span class="line">                Robot nown;</span><br><span class="line">                nown.x = newx;</span><br><span class="line">                nown.y = newy;</span><br><span class="line">                nown.dir = rb.dir;</span><br><span class="line">                nown.step = rb.step + <span class="number">1</span>;</span><br><span class="line">                q.push(nown);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新步数</span></span><br><span class="line">        Robot nown = rb;</span><br><span class="line">        ++nown.step;</span><br><span class="line">        --nown.dir;</span><br><span class="line">        <span class="keyword">if</span> (nown.dir == <span class="number">-1</span>) nown.dir = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nown.x][nown.y][nown.dir]) &#123;</span><br><span class="line">            vis[nown.x][nown.y][nown.dir] = <span class="literal">true</span>;</span><br><span class="line">            q.push(nown);</span><br><span class="line">        &#125;</span><br><span class="line">        nown.dir = rb.dir + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nown.dir == <span class="number">4</span>) nown.dir = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nown.x][nown.y][nown.dir]) &#123;</span><br><span class="line">            vis[nown.x][nown.y][nown.dir] = <span class="literal">true</span>;</span><br><span class="line">            q.push(nown);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>BFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1141《01迷宫》</title>
    <url>/2019-01-10/Luogu-P1141/</url>
    <content><![CDATA[<blockquote>
<p>DFS 联通块</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有一个仅由数字$0$与$1$组成的$n \times n$格迷宫。若你位于一格$0$上，那么你可以移动到相邻$4$格中的某一格$1$上，同样若你位于一格$1$上，那么你可以移动到相邻$4$格中的某一格$0$上。</p>
<p>你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第11行为两个正整数$n,m$。</p>
<p>下面$n$行，每行$n$个字符，字符只可能是$0$或者$1$，字符之间没有空格。</p>
<p>接下来$m$行，每行$2$个用空格分隔的正整数$i,j$，对应了迷宫中第$i$行第$j$列的一个格子，询问从这一格开始能移动到多少格。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>$m$行，对于每个询问输出相应答案。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 2</span><br><span class="line">01</span><br><span class="line">10</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>所有格子互相可达。</p>
<p>对于$20\%20$的数据，$n≤10$；</p>
<p>对于$40\%$的数据，$n≤50$；</p>
<p>对于$50\%$的数据，$m≤5$；</p>
<p>对于$60\%$的数据，$n≤100,m≤100$；</p>
<p>对于$100\%$的数据，$n≤1000,m≤100000$。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先我们可以知道一个联通块内的所有格子的答案相同</p>
<p>那么我们就直接找联通块，这个联通块内的所有格子的答案都是这个联通块的格子个数</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> mp[MAXN][MAXN];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN][MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m, nowans;</span><br><span class="line">    <span class="keyword">int</span> xans[MAXN * MAXN], yans[MAXN * MAXN];</span><br><span class="line">    <span class="keyword">int</span> ans[MAXN][MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        ++nowans;</span><br><span class="line">        xans[nowans] = x;</span><br><span class="line">        yans[nowans] = y;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (!(nx &lt;= <span class="number">0</span> || nx &gt; n || ny &lt;= <span class="number">0</span> || ny &gt; n) &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] != mp[x][y]) &#123;</span><br><span class="line">                vis[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                Search(nx, ny);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, mp[i] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        For (j, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[i][j]) &#123;</span><br><span class="line">                vis[i][j] = <span class="literal">true</span>;</span><br><span class="line">                nowans = <span class="number">0</span>;</span><br><span class="line">                Search(i, j);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> no = <span class="number">1</span>; no &lt;= nowans; ++no) &#123;</span><br><span class="line">                    ans[xans[no]][yans[no]] = nowans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[x][y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1629《邮递员送信》</title>
    <url>/2019-01-10/Luogu-P1629/</url>
    <content><![CDATA[<blockquote>
<p>一个正向图，一个反向图</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有一个邮递员要送东西，邮局在节点1.他总共要送N-1样东西，其目的地分别是2~N。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有M条道路，通过每条道路需要一定的时间。这个邮递员每次只能带一样东西。求送完这N-1样东西并且最终回到邮局最少需要多少时间。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包括两个整数N和M。</p>
<p>第2到第M+1行，每行三个数字U、V、W，表示从A到B有一条需要W时间的道路。 满足1&lt;=U,V&lt;=N,1&lt;=W&lt;=10000,输入保证任意两点都能互相到达。</p>
<p>【数据规模】</p>
<p>对于30%的数据，有1≤N≤200;</p>
<p>对于100%的数据，有1≤N≤1000,1≤M≤100000。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出仅一行，包含一个整数，为最少需要的时间。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 10</span><br><span class="line">2 3 5</span><br><span class="line">1 5 5</span><br><span class="line">3 5 6</span><br><span class="line">1 2 8</span><br><span class="line">1 3 8</span><br><span class="line">5 3 4</span><br><span class="line">4 1 8</span><br><span class="line">4 5 3</span><br><span class="line">3 5 6</span><br><span class="line">5 4 2</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">83</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>类似题目：<a href="https://www.luogu.org/problemnew/show/P1821" target="_blank" rel="noopener">洛谷P1821《[USACO07FEB]银牛派对Sliver Cow Party》</a><br>题解：<a href="https://blog.handwer-std.top/2018-07-20/Luogu-P1821/">洛谷P1821 《[USACO07FEB]银牛派对Silver Cow Party》</a></p>
<p>对于这类题目，我们考虑建一个反向（所有边的方向都相反）的图。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> nweight, now;</span><br><span class="line">            </span><br><span class="line">            Node() &#123; nweight = now = <span class="number">0</span>; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nweight &gt; that.nweight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> now, weight, next;</span><br><span class="line">        &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head[MAXN], dis[MAXN], cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            edge[++cnt].now = next;</span><br><span class="line">            edge[cnt].weight = weight;</span><br><span class="line">            edge[cnt].next = head[prev];</span><br><span class="line">            head[prev] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> Node <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> nowWeight, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">            Node tmp;</span><br><span class="line">            tmp.nweight = nowWeight;</span><br><span class="line">            tmp.now = now;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        	<span class="comment">// 最短路</span></span><br><span class="line">        	<span class="comment">// 一块写进去更方便</span></span><br><span class="line">            <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">            <span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line">            q.push(NewNode(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                Node NowNode = q.top();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> now = NowNode.now;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">                    <span class="keyword">if</span> (dis[to] &gt; dis[now] + edge[e].weight) &#123;</span><br><span class="line">                        dis[to] = dis[now] + edge[e].weight;</span><br><span class="line">                        q.push(NewNode(dis[to], to));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>这里我选择一个稍微懒一点的方法，将图存到一个结构体里面，创建的时候只要 <code>Graph g1, g2;</code> 即可。</p>
<p>最后答案即为</p>
<script type="math/tex; mode=display">\sum_{i = 1}^{n} \text{g1.dis}[i] + \text{g2.dis}[i]</script><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Graph</span> &#123;</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> nweight, now;</span><br><span class="line">            </span><br><span class="line">            Node() &#123; nweight = now = <span class="number">0</span>; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> nweight &gt; that.nweight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">            <span class="keyword">int</span> now, weight, next;</span><br><span class="line">        &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> head[MAXN], dis[MAXN], cnt;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            edge[++cnt].now = next;</span><br><span class="line">            edge[cnt].weight = weight;</span><br><span class="line">            edge[cnt].next = head[prev];</span><br><span class="line">            head[prev] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> Node <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> nowWeight, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">            Node tmp;</span><br><span class="line">            tmp.nweight = nowWeight;</span><br><span class="line">            tmp.now = now;</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">            <span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line">            q.push(NewNode(<span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">            dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">                Node NowNode = q.top();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">int</span> now = NowNode.now;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">                    <span class="keyword">if</span> (dis[to] &gt; dis[now] + edge[e].weight) &#123;</span><br><span class="line">                        dis[to] = dis[now] + edge[e].weight;</span><br><span class="line">                        q.push(NewNode(dis[to], to));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; g1, g2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        <span class="keyword">int</span> weight = getint();</span><br><span class="line">        g1.addEdge(prev, next, weight);</span><br><span class="line">        g2.addEdge(next, prev, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    g1.SPFA();</span><br><span class="line">    g2.SPFA();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        ans += g1.dis[i] + g2.dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO::putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2984《[USACO10FEB]给巧克力Chocolate Giving》</title>
    <url>/2019-01-10/Luogu-P2984/</url>
    <content><![CDATA[<blockquote>
<p>此时一位单身🐂路过</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Farmer John有B头奶牛$(1&lt;=B&lt;=25000)$，有$N(2*B&lt;=N&lt;=50000)$个农场，编号$1\rightarrow N$，有$M(N-1&lt;=M&lt;=100000)$条双向边，第$i$条边连接农场$R_i$和$S_i(1&lt;=R_i&lt;=N;1&lt;=S_i&lt;=N)$，该边的长度是$L_i(1&lt;=L_i&lt;=2000)$。居住在农场$P_i$的奶牛$A(1&lt;=P_i&lt;=N)$，它想送一份新年礼物给居住在农场$Q_i(1&lt;=Q_i&lt;=N)$的奶牛$B$，但是奶牛$A$必须先到FJ(居住在编号$1$的农场)那里取礼物，然后再送给奶牛$B$。你的任务是：奶牛$A$至少需要走多远的路程？</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：三个用空格隔开的整数$N$,$M$和$B$。</p>
<p>第二到$M+1$行：第$i+1$行用$R_i$，$S_i$和$L_i$三个用空格隔开的整数描述双向边$i$。</p>
<p>第$M+2$到$M+B+1$行：第$M+i+1$行包含两个用空格隔开的整数$P_i$和$Q_i$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一到$B$行：第$i$行包括一个整数，居住在农场$P_i$的公牛从FJ那里取得情人节巧克力后送给他居住在农场$Q_i$的梦中情牛至少需要走的距离。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 7 3 </span><br><span class="line">1 2 3 </span><br><span class="line">5 4 3 </span><br><span class="line">3 1 1 </span><br><span class="line">6 1 9 </span><br><span class="line">3 4 2 </span><br><span class="line">1 4 4 </span><br><span class="line">3 2 2 </span><br><span class="line">2 4 </span><br><span class="line">5 1 </span><br><span class="line">3 6</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这道题就是给你一张图和多个询问，对于每个询问，求两个点到点$1$的最短路径之和。</p>
<p>由于双向边的最短路可逆，我们可以得出下面的结论：</p>
<p>对于两条边$(i,j)$和$(j,i)$，有</p>
<p>$dis<em>{(i,j)} = dis</em>{(j,i)}$</p>
<p>所以我们只需要预处理出点$1$到其他所有点的最短路，然后对于每个询问$P,Q$输出 $dis<em>{(1,P)} + dis</em>{(1,Q)}$ 即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> now, weight;</span><br><span class="line">        </span><br><span class="line">        Node() &#123; now = weight = <span class="number">0</span>; &#125;</span><br><span class="line">        Node(<span class="keyword">int</span> now, <span class="keyword">int</span> weight) : now(now), weight(weight) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> weight &gt; that.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        Node tmp;</span><br><span class="line">        tmp.now = now;</span><br><span class="line">        tmp.weight = weight;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> now, next, weight;</span><br><span class="line">    &#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m, b, cnt, head[MAXN], dis[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edge[++cnt].now = next;</span><br><span class="line">        edge[cnt].weight = weight;</span><br><span class="line">        edge[cnt].next = head[prev];</span><br><span class="line">        head[prev] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SFPA</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 要注意的是</span></span><br><span class="line">    	<span class="comment">// 据说这题不卡 SPFA</span></span><br><span class="line">    	<span class="comment">// 但为保险起见</span></span><br><span class="line">    	<span class="comment">// 我还是选择 Dijkstra</span></span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x7f7f7f7f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">        dis[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line">        q.push(NewNode(s, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            Node NowNode = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> nownode = NowNode.now;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = head[nownode]; e; e = edge[e].next) &#123;</span><br><span class="line">                <span class="keyword">int</span> now = edge[e].now;</span><br><span class="line">                <span class="keyword">if</span> (dis[now] &gt; dis[nownode] + edge[e].weight) &#123;</span><br><span class="line">                    dis[now] = dis[nownode] + edge[e].weight;</span><br><span class="line">                    q.push(NewNode(now, dis[now]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    b = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        <span class="keyword">int</span> weight = getint();</span><br><span class="line">        addEdge(prev, next, weight);</span><br><span class="line">        addEdge(next, prev, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    SFPA(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 预处理出最短路</span></span><br><span class="line">    For (i, <span class="number">1</span>, b) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = getint();</span><br><span class="line">        <span class="keyword">int</span> b = getint();</span><br><span class="line">        <span class="keyword">int</span> ans = dis[a] + dis[b];</span><br><span class="line">        <span class="comment">// 转化过的问题的答案，也是最终答案</span></span><br><span class="line">        FastIO::putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>USACO</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3879《[TJOI2010]阅读理解》</title>
    <url>/2018-12-26/Luogu-P3879/</url>
    <content><![CDATA[<blockquote>
<p>实在是一道练习 <code>std::map</code> 的好题啊</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P3879" target="_blank" rel="noopener">题目链接</a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>英语老师留了N篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为整数 $N$，表示短文篇数，其中每篇短文只含空格和小写字母。</p>
<p>按下来的 $N$行，每行描述一篇短文。每行的开头是一个整数 $L$，表示这篇短文由 $L$个单词组成。接下来是 $L$个单词，单词之间用一个空格分隔。</p>
<p>然后为一个整数 $M$，表示要做几次询问。后面有 $M$行，每行表示一个要统计的生词。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">9 you are a good boy ha ha o yeah</span><br><span class="line">13 o my god you like bleach naruto one piece and so do i</span><br><span class="line">11 but i do not think you will get all the points</span><br><span class="line">5</span><br><span class="line">you</span><br><span class="line">i</span><br><span class="line">o</span><br><span class="line">all</span><br><span class="line">naruto</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h1 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h1><p>对于30%的数据，1 ≤ M ≤ 1,000</p>
<p>对于100%的数据，1 ≤ M ≤ 10,000，1 ≤ N ≤ 1000</p>
<p>每篇短文长度（含相邻单词之间的空格） ≤ 5,000 字符，每个单词长度 ≤ 20 字符</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>Trie？Hash？KMP？Aho-Corasick Automaton？</p>
<p><strong><big><big><big>统统不要！</big>&lt;/big&gt;&lt;/big&gt;</big></big></strong></p>
<p>这可是练习 <code>std::map</code> 的一道好题啊！</p>
<p>我们考虑开一个 <code>std::map&lt;std::string, std::vector&lt;int&gt; &gt;</code>，其中下标为每个单词，元素为这个单词对应在<strong>哪几个</strong>句子中出现过（所以要用 <code>std::vector&lt;int&gt;</code> 啊）</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; mp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> p;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= p; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            mp[s].push_back(i); <span class="comment">// 记录当前单词在哪几个句子里出现过</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="keyword">int</span> siz = (<span class="keyword">int</span>) mp[s].size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; siz; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span> &amp;&amp; mp[s][j] == mp[s][j<span class="number">-1</span>]) <span class="keyword">continue</span>; <span class="comment">// 手动去重</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; mp[s][j]; <span class="comment">// 输出</span></span><br><span class="line">            <span class="keyword">if</span> (j != siz - <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>; <span class="comment">// 输出行中空格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出回车键</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图染色学习笔记</title>
    <url>/2018-12-08/UVA10004-Bipartite-Graph-Coloring/</url>
    <content><![CDATA[<blockquote>
<p>本质上就是一个 BFS</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/UVA10004" target="_blank" rel="noopener">模板题目地址</a></p>
<h1 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h1><p>二分图是这样一个图：<br>有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！<br>无向图$G$为二分图的充分必要条件是，$G$至少有两个顶点,且其所有回路的长度均为偶数。<br>判断二分图的常见方法是染色法： 开始对任意一未染色的顶点染色，之后判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色， 若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断，bfs和dfs可以搞定！</p>
<p align="right">——百度百科</p>

<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>我一般习惯用 BFS 做二分图染色，因为这样会更好理解。</p>
<ol>
<li>首先我们确定一个搜索的起点<code>start</code>，一般我确定为$1$。</li>
<li>将这个起点<code>Push()</code>进你的广搜队列中，并将它随便指定为一种颜色（即染色），我一般习惯用<code>1</code>和<code>-1</code>。要注意的是尽量不要使用<code>0</code>，因为染色的<code>color[]</code>数组同时兼顾着<code>vis[]</code>数组的作用。</li>
<li>每次在队列中取出队头，并遍历每一条与它相连的边。<br> A. 如果<em>当前邻接点</em> 被染过与它相同的颜色，则直接失败。<br> B. 如果<strong>当前节点</strong>没被染过色，就将它加入队列。<br> C. 不管<em>当前邻接点</em> 染没染过色，将它染上与<strong>当前节点</strong>不同的颜色。</li>
<li>如果整个过程没有失败，则染色成功。</li>
</ol>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><a href="https://uva.onlinejudge.org/external/100/p10004.pdf" target="_blank" rel="noopener">PDF源文件</a></p>
<p><img src="https://cdn.luogu.org/upload/vjudge_pic/UVA10004/09f718cb383e213e651b85dfd47bb80608f88609.png" alt></p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p><big><strong>输入格式：</strong></big><br><img src="https://cdn.luogu.org/upload/vjudge_pic/UVA10004/4d777247a97ad6fb46850227245dfe0ccb1ff2c9.png" alt></p>
<p><big><strong>输出格式：</strong></big><br><img src="https://cdn.luogu.org/upload/vjudge_pic/UVA10004/e4ee823a4583ec36f33f5632f6b2aeb9ca4671f1.png" alt></p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 0</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">0 3</span><br><span class="line">0 4</span><br><span class="line">0 5</span><br><span class="line">0 6</span><br><span class="line">0 7</span><br><span class="line">0 8</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NOT BICOLORABLE.</span><br><span class="line">BICOLORABLE.</span><br><span class="line">BICOLORABLE.</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p><a href="#算法流程">见上</a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED 1;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLUE -1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN * MAXN + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> now, weight;</span><br><span class="line">        </span><br><span class="line">        Node() &#123; now = weight = <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> weight &gt; that.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> now, next;</span><br><span class="line"></span><br><span class="line">        Edge() &#123; now = next = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125; edge[MAXM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> head[MAXN], cnt, n, l;</span><br><span class="line">    <span class="keyword">short</span> color[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">        <span class="built_in">memset</span>(color, <span class="number">0</span>, <span class="keyword">sizeof</span>(color));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt + <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            Edge tmp;</span><br><span class="line">            tmp.now = tmp.next = <span class="number">0</span>;</span><br><span class="line">            edge[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">        edge[++cnt].now = next;</span><br><span class="line">        edge[cnt].next = head[prev];</span><br><span class="line">        head[prev] = cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BoynextdoorFirstSearch</span><span class="params">(<span class="keyword">int</span> start = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(start);</span><br><span class="line">        color[start] = RED;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = head[now]; e; e = edge[e].next) &#123;</span><br><span class="line">                <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">                <span class="keyword">if</span> (color[to] == color[now]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (color[to] == <span class="number">0</span>) q.push(to);</span><br><span class="line">                <span class="keyword">if</span> (color[now] == <span class="number">1</span>) &#123;</span><br><span class="line">                    color[to] = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    color[to] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        n = getint();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        l = getint();</span><br><span class="line">        Init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = getint();</span><br><span class="line">            <span class="keyword">int</span> next = getint();</span><br><span class="line">            addEdge(prev, next);</span><br><span class="line">            addEdge(next, prev);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (BoynextdoorFirstSearch()) <span class="built_in">puts</span>(<span class="string">"BICOLORABLE."</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NOT BICOLORABLE."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>BFS</tag>
        <tag>图论算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 1073B 《Vasya and Books》</title>
    <url>/2018-12-08/CF1073B/</url>
    <content><![CDATA[<blockquote>
<p>很明显是栈了好吧</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/CF1073B" target="_blank" rel="noopener">题目地址</a></p>
<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给定 $n$ 本书,序号分别为$1$到$n$，现在执行$n$个操作， 第$i$个操作需要从栈内取出编号为$b_i$的书，如果该书已经取出，则输出$0$否则将该书从栈内取出，同时取出在栈内比$b_i$靠上的书，并且输出一共取出了几本书</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains one integer $n~(1 \le n \le 2 \cdot 10^5)$ — the number of books in the stack.</p>
<p>The second line contains $n$ integers $a_1, a_2, \dots, a_n~(1 \le a_i \le n)$ denoting the stack of books.</p>
<p>The third line contains n n integers $b_1, b_2, \dots, b_n~(1 \le b_i \le n)$ denoting the steps Vasya is going to perform.</p>
<p>All numbers $a_1 \dots a_n$ are distinct, the same goes for $b_1 \dots b_n$ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Print $n$ integers. The $i$ -th of them should be equal to the number of books Vasya moves to his backpack during the $i$ -th step.</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="1"><a href="#1" class="headerlink" title="#1"></a>#1</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 0 1</span><br></pre></td></tr></table></figure>
<h2 id="2"><a href="#2" class="headerlink" title="#2"></a>#2</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 4 2 5</span><br><span class="line">4 5 1 3 2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 2 0 0 0</span><br></pre></td></tr></table></figure>
<h2 id="3"><a href="#3" class="headerlink" title="#3"></a>#3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">6 5 4 3 2 1</span><br><span class="line">6 5 3 4 2 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 2 0 1 1</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>本文同步发布于<a href="https://www.luogu.org/blog/handwer-blog/solution-cf1073b" target="_blank" rel="noopener">洛谷博客</a></p>
<p>粗略看了一下 貌似没人和我的解法相同</p>
<p>那就来写一发题解吧</p>
<p>在读入的时候 我们用另一个数组<code>lead[i]</code>来存编号为<code>i</code>的书在<strong>读入的数组<code>book[]</code></strong>的下标</p>
<p>这样我们在检测读入的书是否被取出时就不用遍历一遍<code>book[]</code></p>
<hr>
<p>弹出书本的时候，我们首先看一下这个书本是否被取出 </p>
<p>如果是就直接输出<code>0</code></p>
<p>否则就开始弹出书本</p>
<hr>
<p>我们用一个变量<code>now = 0</code>记录当前弹出了几个书本，用一个数组<code>vis[i]</code>记录第<code>i</code>本书是否被弹出</p>
<p>在弹出之前，用一个变量<code>orin</code>记录一下<strong>还没更新</strong>的<code>now</code></p>
<p>接着在每次弹出的时候更新<code>vis[++now]</code>为真，直到遇到当前要弹出的书本编号</p>
<p>最后<code>orin - now</code>即为答案</p>
<hr>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> book[MAXN];</span><br><span class="line"><span class="keyword">int</span> lead[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, book + i);</span><br><span class="line">        lead[book[i]] = i;</span><br><span class="line">        <span class="comment">// 让lead[]作为book[]的索引，查找的时候快一些</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> o;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;o);</span><br><span class="line">        <span class="keyword">if</span> (vis[lead[o]]) <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">        <span class="comment">// 被弹过了，输出0</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> orin = now;</span><br><span class="line">            <span class="keyword">while</span> (book[++now] != o) &#123;</span><br><span class="line">                vis[now] = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// 循环更新vis（弹出书本）</span></span><br><span class="line">            &#125;</span><br><span class="line">            vis[now] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, now - orin);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>总感觉自己的代码能被 Hack</del></p>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P4568《飞行路线》</title>
    <url>/2018-11-25/BZOJ2763-Luogu-P4568-JLOI2011/</url>
    <content><![CDATA[<blockquote>
<p>入门级别的分层图最短路</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P4568" target="_blank" rel="noopener">题目地址</a><br><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=2763" target="_blank" rel="noopener">双倍经验</a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先介绍一下分层图最短路。</p>
<p>分层图最短路是指在可以进行分层图的图上解决最短路问题。<br>一般模型是：<br>在图上，有k次机会可以直接通过一条边，问起点与终点之间的最短路径。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在nn个城市设有业务，设这些城市分别标记为00到n-1n−1，一共有mm种航线，每种航线连接两个城市，并且航线有一定的价格。</p>
<p>Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多kk种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>数据的第一行有三个整数，n,m,k，分别表示城市数，航线数和免费乘坐次数。</p>
<p>第二行有两个整数，s,t，分别表示他们出行的起点城市编号和终点城市编号。</p>
<p>接下来有m行，每行三个整数，a,b,c，表示存在一种航线，能从城市a到达城市b，或从城市b到达城市a，价格为c。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一行，包含一个整数，为最少花费。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><p>输入样例#1： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6 1</span><br><span class="line">0 4</span><br><span class="line">0 1 5</span><br><span class="line">1 2 5</span><br><span class="line">2 3 5</span><br><span class="line">3 4 5</span><br><span class="line">2 3 3</span><br><span class="line">0 2 100</span><br></pre></td></tr></table></figure>
<p>输出样例#1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这就是分层图最短路的<strong>模板</strong><br><del>但为什么是<code>省选/NOI-</code>呢</del></p>
<p>我们用DP的思想来看<br>设<code>dis[i][j]</code>表示起点到<code>i</code>点在<code>j</code>层的最短路</p>
<p>如何分层？<br>理解性记忆。<br>例如本题最多有十层，第<code>k</code>层表示免费了<code>k</code>次的最短路</p>
<p>如何跑最短路？<br>洛谷卡SPFA，BZOJ不卡SPFA，但是都要注意把空间开大10倍，不然是过不去的（5次TLE的惨痛经验）<br>在跑 Dijkstra 的时候，我们用了一个<code>pair</code>来存当前到达的点和已走过的路径；这次我们需要多维护一个东西：当前的层数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> id; <span class="comment">// 当前到达的点</span></span><br><span class="line">	<span class="keyword">int</span> weight; <span class="comment">// 已走过的路径</span></span><br><span class="line">	<span class="keyword">int</span> now; <span class="comment">// 当前的层数</span></span><br><span class="line">	</span><br><span class="line">	Node() &#123;</span><br><span class="line">		id = weight = now = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 重载运算符，用于优先队列</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> weight &gt; that.weight;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在更新<code>dis</code>的时候，我们需要对这一层的点和下一层的点分别进行更新</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vis[to][Floor] &amp;&amp; dis[to][Floor] &gt; dis[now][Floor] + edge[e].weight) &#123;</span><br><span class="line">    dis[to][Floor] = dis[now][Floor] + edge[e].weight;</span><br><span class="line">    q.push(NewNode(to, dis[to][Floor], Floor));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!vis[to][Floor] &amp;&amp; Floor + <span class="number">1</span> &lt;= K &amp;&amp; dis[to][Floor + <span class="number">1</span>] &gt; dis[now][Floor]) &#123;</span><br><span class="line">    dis[to][Floor + <span class="number">1</span>] = dis[now][Floor];</span><br><span class="line">    q.push(NewNode(to, dis[to][Floor + <span class="number">1</span>], Floor + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> id, weight, now;</span><br><span class="line">        Node() &#123;</span><br><span class="line">            id = weight = now = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;that) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> weight &gt; that.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; head[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> now, next, weight;</span><br><span class="line">    &#125; edge[MAXM];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m, k, s, t, K, cnt, dis[MAXN][MAXK];</span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN][MAXK];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edge[++cnt].now = next;</span><br><span class="line">        edge[cnt].weight = weight;</span><br><span class="line">        edge[cnt].next = head[prev].id;</span><br><span class="line">        head[prev].id = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Node <span class="title">NewNode</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> weight, <span class="keyword">int</span> now)</span> </span>&#123;</span><br><span class="line">        Node tmp;</span><br><span class="line">        tmp.id = id;</span><br><span class="line">        tmp.weight = weight;</span><br><span class="line">        tmp.now = now;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">        <span class="built_in">std</span>::priority_queue&lt;Node&gt; q;</span><br><span class="line">        For (i, <span class="number">0</span>, K) dis[s][i] = <span class="number">0</span>;</span><br><span class="line">        q.push(NewNode(s, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            Node NowNode = q.top();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> Floor = NowNode.now;</span><br><span class="line">            <span class="keyword">int</span> now = NowNode.id;</span><br><span class="line">            <span class="keyword">if</span> (vis[now][Floor]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[now][Floor] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = head[now].id; e; e = edge[e].next) &#123;</span><br><span class="line">                <span class="keyword">int</span> to = edge[e].now;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to][Floor] &amp;&amp; dis[to][Floor] &gt; dis[now][Floor] + edge[e].weight) &#123;</span><br><span class="line">                    dis[to][Floor] = dis[now][Floor] + edge[e].weight;</span><br><span class="line">                    q.push(NewNode(to, dis[to][Floor], Floor));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!vis[to][Floor] &amp;&amp; Floor + <span class="number">1</span> &lt;= K &amp;&amp; dis[to][Floor + <span class="number">1</span>] &gt; dis[now][Floor]) &#123;</span><br><span class="line">                    dis[to][Floor + <span class="number">1</span>] = dis[now][Floor];</span><br><span class="line">                    q.push(NewNode(to, dis[to][Floor + <span class="number">1</span>], Floor + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    k = getint();</span><br><span class="line">    s = getint();</span><br><span class="line">    t = getint();</span><br><span class="line">    K = k;</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint();</span><br><span class="line">        <span class="keyword">int</span> next = getint();</span><br><span class="line">        <span class="keyword">int</span> weight = getint();</span><br><span class="line">        addEdge(prev, next, weight);</span><br><span class="line">        addEdge(next, prev, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2147482333</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans, dis[t][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO::putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>省选</tag>
        <tag>最短路</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title>让你的 PC 更加安全</title>
    <url>/2018-11-24/SecureYourPC/</url>
    <content><![CDATA[<blockquote>
<p><code>Password: 🔑</code></p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天（2018.11.24）中午时分<br>我被 Logey 绑住胳膊<br>眼睁睁地看着 RainAir 机惨我<br>RainAir 删除了我的用户密码<br>Shq 修改了我的博客文件<br>折腾了一个中午才恢复过来<br>因为这样 我决定写下这篇文章</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="关于加密"><a href="#关于加密" class="headerlink" title="关于加密"></a>关于加密</h2><p>┌────────────┐<br>│加密，是以某种特殊的算法│<br>│改变原有的信息数据，使得│<br>│未授权的用户即使获得了已│<br>│加密的信息，但因不知解密│<br>│的方法，仍然无法了解信息│<br>│的内容。 ——百度百科&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;│<br>└────────────┘</p>
<h2 id="为什么要加密"><a href="#为什么要加密" class="headerlink" title="为什么要加密"></a>为什么要加密</h2><p>先不谈什么数据泄露、隐私恶意利用等诸如此类的事，我们来看<big>机惨</big></p>
<p>一次机惨，轻则「I AK ***」，重则<code>rm -rf / --no-preserve-root</code></p>
<p>所以锁好自己的电脑是非常重要的</p>
<h1 id="Windows-amp-macOS-通用解决方案"><a href="#Windows-amp-macOS-通用解决方案" class="headerlink" title="Windows &amp; macOS 通用解决方案"></a>Windows &amp; macOS 通用解决方案</h1><p>当然是设好自己的密码。<br>尽量设复杂且好记的密码，并且保证自己打这个密码的速度足够快，不会让人记住。<br>有生物识别系统的可以考虑安全性高的生物识别系统，像目前已经成熟的「指纹识别」和「Windows Hello」。</p>
<h1 id="macOS-独占解决方案"><a href="#macOS-独占解决方案" class="headerlink" title="macOS 独占解决方案"></a>macOS 独占解决方案</h1><h2 id="固件密码"><a href="#固件密码" class="headerlink" title="固件密码"></a>固件密码</h2><p>在开机时按住「⌘+R」，进入恢复模式；<br>点击菜单栏中的「实用工具」，点击「启动安全性实用工具」；<br>输入自己的密码并记牢；<br>最后直接重启即可生效。</p>
<p>用途？<br>设定固件密码之后，进入恢复模式就需要密码了。<br>同样是在恢复模式下，用命令<code>resetpassword</code>可以<strong>更改密码</strong>！</p>
<h2 id="FileVault"><a href="#FileVault" class="headerlink" title="FileVault"></a>FileVault</h2><p>FileVault 会自动直接地对主目录的内容进行加密和解密。真正的安全感来自知道在没有获得允许的时候，没有人可以翻看你的文件。FileVault 使用最新的政府安全标准来保护你的辛勤劳动成果。它保护你主文件夹上的所有信息不被窥测，因此你的商业机密、假期购物单、以及个人财政记录仍然是秘密。FileVault 使用128位高级加密标准 Advanced Encryption Standard 对你主目录下的所有内容进行加密。这个高性能的算法会自动实时加密和解密，因此你甚至不知道它的发生。</p>
<p align="right">——百度百科</p>

<p>打开方式：「系统偏好设置」→「安全性与隐私」→「文件保险箱」</p>
<h2 id="Time-Machine"><a href="#Time-Machine" class="headerlink" title="Time Machine"></a>Time Machine</h2><p>Time Machine 是自动备份功能的一大突破，它内建於 Mac OS X，能为 Mac 上的一切建立最新拷贝，包括数位相片、音乐、家庭影片与文件。现在，只要您有需要，就能轻易回到过去恢复任何资料。</p>
<p></p><p align="right">——百度百科</p><br>这种方法主要是用来预防被机惨后发生的所有特殊情况，例如博客文件被覆盖，重要文件丢失等等。<br>打开方式：「系统偏好设置」→「时间机器」<p></p>
<h2 id="加密映像"><a href="#加密映像" class="headerlink" title="加密映像"></a>加密映像</h2><p>如果有什么东西你想要用密码保护，那加密的映像确实是最好的工具。</p>
<p>方法：「Spotlight Search」<code>Disk Utility.app</code>【文件】【新建映像】【来自文件夹的映像】<br>注意：映像默认只读，如果想让映像可读写，就必须要在「映像格式」里将「压缩」改成「读/写」</p>
<h1 id="Windows-独占解决方案"><a href="#Windows-独占解决方案" class="headerlink" title="Windows 独占解决方案"></a>Windows 独占解决方案</h1><p><a href="https://www.baidu.com" target="_blank" rel="noopener">这里</a><br>其实上面说的东西，Windows 都有替代品。<br>固件密码有 BIOS 里的 Secure Lock，加密映像可以用 UltraISO，磁盘加密可以用 BitLocker ……</p>
]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>只有经历过的人才知道的世界</tag>
        <tag>使用指南</tag>
        <tag>优化</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2010《回文日期》</title>
    <url>/2018-11-10/Luogu-P2010/</url>
    <content><![CDATA[<blockquote>
<p>枚举+判断</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。</p>
<p>牛牛习惯用88位数字表示一个日期，其中，前44位代表年份，接下来22位代表月 份，最后22位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。</p>
<p>牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。现 在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存 在的日期是回文的。</p>
<p>一个88位数字是回文的，当且仅当对于所有的i ( 1 \le i \le 8)i(1≤i≤8)从左向右数的第i个 数字和第9-i9−i个数字（即从右向左数的第ii个数字）是相同的。</p>
<p>例如：</p>
<p>•对于2016年11月19日，用88位数字2016111920161119表示，它不是回文的。</p>
<p>•对于2010年1月2日，用88位数字2010010220100102表示，它是回文的。</p>
<p>•对于2010年10月2日，用88位数字2010100220101002表示，它不是回文的。</p>
<p>每一年中都有1212个月份：</p>
<p>其中，1,3,5,7,8,10,121,3,5,7,8,10,12月每个月有3131天；4,6,9,114,6,9,11月每个月有3030天；而对于22月，闰年时有2929天，平年时有2828天。</p>
<p>一个年份是闰年当且仅当它满足下列两种情况其中的一种：</p>
<p>1.这个年份是44的整数倍，但不是100100的整数倍；</p>
<p>2.这个年份是400400的整数倍。</p>
<p>例如：</p>
<p>•以下几个年份都是闰年：2000,2012,20162000,2012,2016。</p>
<p>•以下几个年份是平年：1900,2011,20141900,2011,2014。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>两行，每行包括一个88位数字。</p>
<p>第一行表示牛牛指定的起始日期。</p>
<p>第二行表示牛牛指定的终止日期。</p>
<p>保证 $date_i$和都是真实存在的日期，且年份部分一定为4位数字，且首位数字不为0。</p>
<p>保证 $date_1$—定不晚于 $date_2$ 。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示在$date_1$和$date_2$之间，有多少个日期是回文的。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20110101</span><br><span class="line">20111231</span><br></pre></td></tr></table></figure>
<p>输出样例#1： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>输入样例#2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20000101</span><br><span class="line">20101231</span><br></pre></td></tr></table></figure>
<p>输出样例#2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【样例说明】</p>
<p>对于样例1，符合条件的日期是20111102。</p>
<p>对于样例2，符合条件的日期是20011002和20100102。</p>
<p>【子任务】</p>
<p>对于$60\%$的数据，满足$date1 = date2$。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们考虑直接枚举月和日。</p>
<p>对于每一个月，我们用<code>M[i]</code>表示第<code>i</code>月有多少天。<br>这里要注意的是不用单独判闰年，2月29对应的是92200229，而9220是闰年。</p>
<p>构建字符串直接参照代码，最后比较一下即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Words -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GetMonth(x) ((x / 100) % 100)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GetDay(x) (x % 100)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GetYear(x) (x / 10000)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> isFullYear(x) ((GetYear(x) % 400 == 0) || (GetYear(x) % 10 == 0 &amp;&amp; GetYear(x) % 4 != 0))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> M[<span class="number">12</span> + <span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> endd;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; endd;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M[i]; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">            now += j;</span><br><span class="line">            now += i * <span class="number">100</span>;</span><br><span class="line">            now += <span class="number">10000000</span> * (j % <span class="number">10</span>);</span><br><span class="line">            now += <span class="number">1000000</span> * (j / <span class="number">10</span>);</span><br><span class="line">            now += <span class="number">100000</span> * (i % <span class="number">10</span>);</span><br><span class="line">            now += <span class="number">10000</span> * (i / <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (start &lt;= now &amp;&amp; now &lt;= endd) ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO::putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>枚举</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>「LYOI初中坑题组」模拟赛#2 题解</title>
    <url>/2018-11-05/LYOI-Mid-KT-Team-Contest2/</url>
    <content><![CDATA[<blockquote>
<p>暴力能过的题目</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题面 &amp; 数据依然来自山河</p>
<p>评测 Powered by 洛谷OnlineJudge</p>
<h1 id="T1-复制-粘贴"><a href="#T1-复制-粘贴" class="headerlink" title="T1. 复制-粘贴"></a>T1. 复制-粘贴</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 y 是一个聪明的程序员，但是他懒到了极致，在输入程序时甚至不愿意多打一行代码。</p>
<p>有一次，小 y 发现他的一个程序需要输入 n 行一模一样的代码，怎么办呢？</p>
<p>他首先输入了第 1 行，然后通过 1 次“复制-粘贴”命令得到了第 2 行，再通过 1 次“复制-粘贴”命令得到了第 3-4 行………..直到完成这 n 行代码的输入。</p>
<p>小 y 懒得得意洋洋，正好遇到初学编程的小 x，他就想考考小 x，顺便为难为难他以炫耀自己的聪明才智和编程水平。于是把“复制-粘贴”的伎俩告诉小 x，并让小 x 编程计算最少通过几次“复制-粘贴”命令可以得到正好 n 行的代码？</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：<br>一行一个正整数 n,</p>
<p>输出格式：<br>一行一个正整数，表示最少的“复制-粘贴”次数</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：<br>4<br>输出样例#1：<br>2</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>简单推一下就可以知道答案是$\lceil log_2n \rceil$</p>
<p>这里要注意的是C++中的$log$是以$e$为底的<br>求$\lceil log_2n \rceil$的代码为<code>ceil(log(n) / log(2))</code></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">ceil</span>(<span class="built_in">log</span>(a) / <span class="built_in">log</span>(<span class="number">2</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-足球联赛"><a href="#T2-足球联赛" class="headerlink" title="T2. 足球联赛"></a>T2. 足球联赛</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个足球联赛由 n 只球队构成。在一个赛季中，每只球队都要与其它球队各比赛两场。</p>
<p>一场比赛在主场，一场在客场。赢一场得 3 分，输一场不得分，平局两支队伍各得 1 分。现在，给你一个 n*n 的矩阵表示比赛情况。第 i 行第 j 列的字母表示在第 i 只队伍主场的比赛情况， W 表示主队赢， L 表示主队输， D 表示平局。</p>
<p>需要你求出得分最高的队伍的编号，如果有分数相同的，在一行中按字典序输出队伍编号。</p>
<h2 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：<br>第一行，一个整数 n 。</p>
<p>接下来 n 行，每行 n 个字符，表示输赢情况。</p>
<p>第 i 行第 i 列为 - ,因为一只队伍不可能与自己比赛。</p>
<p>输出格式：<br>得分最高的队伍编号。如有多个在一行中输出，用一个空格分开</p>
<h2 id="输入输出样例-1"><a href="#输入输出样例-1" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 </span><br><span class="line">-WW</span><br><span class="line">W-W</span><br><span class="line">WW-</span><br></pre></td></tr></table></figure>
<p>输出样例#1： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
<p>输入样例#2： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 </span><br><span class="line">-DWWD</span><br><span class="line">L-WLL</span><br><span class="line">DD-WD</span><br><span class="line">DDL-L</span><br><span class="line">DDLL-</span><br></pre></td></tr></table></figure>
<p>输出样例#2： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>直接照题意模拟即可</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Words -- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> score[MAXN];</span><br><span class="line">    <span class="keyword">char</span> sc[MAXN][MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            For (j, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; sc[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">switch</span>(sc[i][j]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'W'</span>: &#123;</span><br><span class="line">                        score[i] += <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'L'</span>: &#123;</span><br><span class="line">                        score[j] += <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'D'</span>: &#123;</span><br><span class="line">                        score[i] += <span class="number">1</span>;</span><br><span class="line">                        score[j] += <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Max = <span class="number">-2147482333</span>;</span><br><span class="line">        For (i, <span class="number">1</span>, n) Max = <span class="built_in">std</span>::max(Max, score[i]);</span><br><span class="line">        For (i, <span class="number">1</span>, n) <span class="keyword">if</span> (score[i] == Max) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    Read();</span><br><span class="line">    Work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-捕食关系"><a href="#T3-捕食关系" class="headerlink" title="T3. 捕食关系"></a>T3. 捕食关系</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在海洋中，有食肉类的鱼和食草类的鱼，某种食肉类的鱼捕食食草类的鱼当且仅当自己的体重大于对方。</p>
<p>现在给出两类鱼各自的体重，求有多少对捕食关系。</p>
<h2 id="输入输出格式-2"><a href="#输入输出格式-2" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：<br>每组测试数据有三行。</p>
<p>第一行有两个整数 m， n，分别代表食肉类的鱼的种类数和食草类的鱼的种类数。</p>
<p>第二行 m 个数，第三行 n 个数，代表各自的体重。</p>
<p>输出格式：<br>一个整数，表示有多少对捕食关系。</p>
<h2 id="输入输出样例-2"><a href="#输入输出样例-2" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：<br>5 3<br>8 1 7 3 1<br>3 6 1<br>输出样例#1：<br>7</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><big><big><big>正解不会 暴力能过</big></big></big>

<p>我不知道纯暴力能不能过 反正我们要优化一下</p>
<p>首先把食草鱼体重从小到大排个序<br>那么我们在枚举食肉鱼的时候，就可以遇见在第一个体重更大的食草鱼的时候<code>break</code>掉，做法的正确性是显然的</p>
<p>时间复杂度均摊$O(n^2)$</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Words -- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXNM = <span class="number">20000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> bigFish[MAXNM], smallFish[MAXNM];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">        m = getint();</span><br><span class="line">        n = getint();</span><br><span class="line">        For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            bigFish[i] = getint();</span><br><span class="line">        &#125;</span><br><span class="line">        For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            smallFish[i] = getint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        sort(smallFish + <span class="number">1</span>, smallFish + <span class="number">1</span> + n);</span><br><span class="line">        For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            For (j, <span class="number">1</span>, n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (smallFish[j] &gt;= bigFish[i]) <span class="keyword">break</span>;</span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        FastIO::putint(cnt, <span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    Read();</span><br><span class="line">    Work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-幻方"><a href="#T4-幻方" class="headerlink" title="T4. 幻方"></a>T4. 幻方</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道 n 阶奇数幻方吧？如下为一个 5 阶幻方：</p>
<p>17 24 1 8 15</p>
<p>23 5 7 14 16</p>
<p>4 6 13 20 22</p>
<p>10 12 19 21 3</p>
<p>11 18 25 2 9<br>现在，输入奇数 n，输出该奇数幻方最右下角的元素值。</p>
<h2 id="输入输出格式-3"><a href="#输入输出格式-3" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>输入格式：<br>一行一个数 n。</p>
<p>输出格式：<br>一行一个数，表示该奇数幻方右下角的值。</p>
<h2 id="输入输出样例-3"><a href="#输入输出样例-3" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例#1：<br>5<br>输出样例#1：<br>9</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>找规律</p>
<p><a href="https://www.baidu.com/" target="_blank" rel="noopener">指点迷津</a></p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><p><del>不给</del></p>
]]></content>
      <tags>
        <tag>比赛</tag>
        <tag>暴力</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title>「LYOI初中坑题组」模拟赛#1 题解</title>
    <url>/2018-11-03/LYOI-Mid-KT-Team-Contest1/</url>
    <content><![CDATA[<blockquote>
<p>当一个选手比你小，还比你强……</p>
</blockquote>
<a id="more"></a>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>题面 &amp; 测试输入来自山河</p>
<h1 id="T1-求和"><a href="#T1-求和" class="headerlink" title="T1. 求和"></a>T1. 求和</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>小马克今年成为小学生。不久后她将进行她的第一次考试，其中包括数学考试。</p>
<p>她非常认真地复习，她认为自己已经准备好了。她的哥哥通过给她提出问题并解决的方式帮助她。</p>
<p>他的问题是给定一连串整数：依次由 1 个 1，2 个 2，3 个 3 等组成，即1223334444……。</p>
<p>现在他给马克两个整数 A 和 B； 他的任务是求出由第 A 个到第 B 个数的。如果 A 是 1， B是 3， 答案为 1+2+2=5。 给一个问题， 然后计算它们的和， 马克的哥哥能够验证答案正确与否。</p>
<h2 id="输入输出格式-amp-样例"><a href="#输入输出格式-amp-样例" class="headerlink" title="输入输出格式 &amp; 样例"></a>输入输出格式 &amp; 样例</h2><p>输入格式：<br>输入文件 instruckcije.in 只有一行， 包括正整数 A 和 B。</p>
<p>输出格式：<br>输出文件 instruckcije.out 共一行， 为和的值。</p>
<p>输入样例#1：<br>1 3<br>输出样例#1：<br>5</p>
<p>输入样例#2：<br>1 1000<br>输出样例#2：<br>29280</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$1 \leq A,B \leq 1000$</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先这题是一个签到题无误了</p>
<p>数据范围如此之小，我们可以直接把序列初始化出来，再处理出一个前缀和数组，最后输出即可。</p>
<p>时间复杂度……$O(1)$？<del>反正都是常数</del></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXLENGTH_1 = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> seq[MAXLENGTH_1], sum[MAXLENGTH_1];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>, cur = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= <span class="number">1001</span>) &#123;</span><br><span class="line">            ++cur;</span><br><span class="line">            seq[++i] = now;</span><br><span class="line">            <span class="keyword">if</span> (cur == now) &#123;</span><br><span class="line">                cur = <span class="number">0</span>;</span><br><span class="line">                ++now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">            sum[i] = sum[i<span class="number">-1</span>] + seq[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Work1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">        Init();</span><br><span class="line">        <span class="keyword">int</span> x = getint();</span><br><span class="line">        <span class="keyword">int</span> y = getint();</span><br><span class="line">        <span class="keyword">if</span> (x &gt; y) swap(x, y);</span><br><span class="line">        FastIO::putint(sum[y] - sum[x<span class="number">-1</span>], <span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    Work1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-猜歌名"><a href="#T2-猜歌名" class="headerlink" title="T2. 猜歌名"></a>T2. 猜歌名</h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p>“Guess the song” 是一项在年轻程序员中非常流行的游戏。它是一种集技能、智慧、 耐性于一体的游戏。这个游戏给玩游戏的人放音乐， 游戏者的目标是尽可能快地猜这首歌 的歌名。</p>
<p>Mirko 可能不是一个很好的程序员， 但他是一个世界级的猜歌者。</p>
<p>Mirko 总是在专辑里的某首歌播放出至少一半歌词的时候猜出歌名。所有歌名的单词是唯一的（没有一个单词会出现一次或更多次）。</p>
<p>写一个程序， 给出歌名和专辑名， 看看 Mirko 在这首歌的哪个点上（在多少个单词之后）猜出歌名。</p>
<h2 id="输入输出格式-amp-样例-1"><a href="#输入输出格式-amp-样例-1" class="headerlink" title="输入输出格式 &amp; 样例"></a>输入输出格式 &amp; 样例</h2><p>输入格式：<br>第一行：包含一个整数 N， 它是一首歌里的单词数目。<br>接下来的 N 行每一行包含歌名的一个单词。<br>第 N+2 行： 包含一个整数 M， 它是专辑里的单词数目。<br>接下来的 M 行每一行包含专辑里的一个单词。<br>歌名和专辑里的所有单词由 1 到 15 个小写英文字母组成。</p>
<p>输出格式：<br>共一行， 包含一个数， 表示 Mirko 在第几个单词处猜出歌曲名。</p>
<p>输入样例#1：<br>3<br>sedam<br>gladnih<br>patuljaka<br>7<br>sedam<br>dana<br>sedam<br>noci<br>sedam<br>gladnih<br>godina</p>
<p>输出样例#1：<br>6</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>我们称输入的N个单词为WN，输入的M个单词为WM</p>
<p>那么题目就是要求我们找出一个最小ANS，使得在WM中的前ANS个单词满足有至少一半的WN中的单词</p>
<p>那么数据范围依然极小，直接暴力算完</p>
<p>当然我看着貌似能二分答案<del>太懒不写</del><br>单调性显然，当$\text{ANS}$成立的时候，满足$\text{ANS} \leq \text{ANS}_1 \leq \text{M}$的$\text{ANS_1}$都是成立的。</p>
<p>这里要注意的是当N为奇数时，N的一半$=\lfloor\frac{N}{2}\rfloor + 1$，否则N的一半$=\frac{N}{2}$</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> song[MAXN];</span><br><span class="line">    <span class="built_in">string</span> album[MAXM];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, m, most;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        For (i, <span class="number">1</span>, n) <span class="keyword">if</span> (vis[song[i]]) ++ret;</span><br><span class="line">        <span class="keyword">return</span> ret &gt;= most;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Work2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        For(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; song[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        most = ((n % <span class="number">2</span>) == <span class="number">0</span> ? n / <span class="number">2</span> : n / <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        For(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; album[i];</span><br><span class="line">            <span class="comment">//cout &lt;&lt; album[i] &lt;&lt; endl;</span></span><br><span class="line">            vis[album[i]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (Check()) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    Work2();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-黑白棋"><a href="#T3-黑白棋" class="headerlink" title="T3. 黑白棋"></a>T3. 黑白棋</h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><p>Lagno 是一种二人智力游戏。 游戏设有一个黑方和一个白方。游戏桌面是正方形的， 包含 8 行 8 列。</p>
<p>如果黑方玩家走出这样一步棋：将一枚黑子放在任一空格上， 而在这个空格的八个方向（上、下、左、右和 4 个对角线方向）的至少一个方向上有一排白子被夹在这枚新下的黑子和其他黑子之间， 任何方向， 在新黑子和原来黑子之间的所有白子都要变成黑子。为这个游戏设计一个程序， 计算一步棋中黑方能转变的白子数量的最大值。</p>
<h2 id="输入输出格式-amp-样例-2"><a href="#输入输出格式-amp-样例-2" class="headerlink" title="输入输出格式 &amp; 样例"></a>输入输出格式 &amp; 样例</h2><p>输入格式：<br>输入文件 lango.in 共 8 行， 每行 8 个字符；“.”代表一个空格；“B”代表黑子，“W” 代表白子。</p>
<p>输出格式：<br>输出文件 lango.out 共一行， 有一个整数， 表示一步中黑方能吃掉白子的最大数， 如果无法吃掉就输出“0”。</p>
<p>输入输出样例<br>输入样例#1： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">...BW...</span><br><span class="line">...WB...</span><br><span class="line">........</span><br><span class="line">........</span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<p>（这个说实话不等宽不行</p>
<p>输出样例#1： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p><del><big><big><big>暴！力！能！过！</big>&lt;/big&gt;&lt;/big&gt;</big></big></del><br><br><br><del><small><small>输出0拿9分</small>&lt;/small&gt;</small></del></p>
<h3 id="暴力算法"><a href="#暴力算法" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>数据范围如此之小，我们不如直接枚举所有空格点，对这个点进行八向扩展，累加答案，最后取$max$即可</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>当然是DFS<br>我们还是枚举每一个点，只不过这次不暴力扩展了。<br>我们用<code>dx[]</code>和<code>dy[]</code>来记八个方向，根据它来扩展。<br><code>dfs(int now, int x, int y)</code>中的<code>now</code>就表示现在是第<code>now</code>个方向</p>
<p>边界肯定是要判的（<code>x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8</code>），当前是不是空格子也要判（<code>s[i][j] == &#39;.&#39;</code>），如果有任意一个满足就直接<code>return -INF</code><br>如果当前碰到了一个黑格子，说明到头了，<code>return 0</code>即可<br>否则<code>return dfs(now, x + dx[now], y + dy[now]) + 1</code></p>
<p>想是有点难想的，但是代码很好看懂。</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="暴力算法-1"><a href="#暴力算法-1" class="headerlink" title="暴力算法"></a>暴力算法</h3><p>***<b>毒瘤警告</b>***</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">8</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">8</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXX_Y = <span class="number">8</span> + <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">short</span> Map[MAXX_Y][MAXX_Y];</span><br><span class="line">    <span class="comment">// 0: blank</span></span><br><span class="line">    <span class="comment">// 1: Black</span></span><br><span class="line">    <span class="comment">// 2: White</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">char</span> c;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">                <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'.'</span>: &#123;</span><br><span class="line">                        Map[i][j] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'B'</span>: &#123;</span><br><span class="line">                        Map[i][j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'W'</span>: &#123;</span><br><span class="line">                        Map[i][j] = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAnswer</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 获取上下左右的可扩展数量</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ox = x;</span><br><span class="line">        <span class="keyword">int</span> oy = y;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; ++current; ++x; <span class="keyword">if</span> (Map[x][y] == <span class="number">0</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; <span class="keyword">if</span> (Map[x][y] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="keyword">if</span> (x == <span class="number">8</span> &amp;&amp; Map[x][y] == <span class="number">2</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (current &gt; <span class="number">0</span>) --current;</span><br><span class="line">        ret += current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        x = ox;</span><br><span class="line">        y = oy;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; ++current; --x; <span class="keyword">if</span> (Map[x][y] == <span class="number">0</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; <span class="keyword">if</span> (Map[x][y] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; Map[x][y] == <span class="number">2</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (current &gt; <span class="number">0</span>) --current;</span><br><span class="line">        ret += current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        x = ox;</span><br><span class="line">        y = oy;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; ++current; ++y; <span class="keyword">if</span> (Map[x][y] == <span class="number">0</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; <span class="keyword">if</span> (Map[x][y] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="keyword">if</span> (y == <span class="number">8</span> &amp;&amp; Map[x][y] == <span class="number">2</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (current &gt; <span class="number">0</span>) --current;</span><br><span class="line">        ret += current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        x = ox;</span><br><span class="line">        y = oy;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; ++current; --y; <span class="keyword">if</span> (Map[x][y] == <span class="number">0</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; <span class="keyword">if</span> (Map[x][y] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="keyword">if</span> (y == <span class="number">1</span> &amp;&amp; Map[x][y] == <span class="number">2</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (current &gt; <span class="number">0</span>) --current;</span><br><span class="line">        ret += current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        x = ox;</span><br><span class="line">        y = oy;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAnswerAlt</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 获取四个对角线上的可扩展数量</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ox = x;</span><br><span class="line">        <span class="keyword">int</span> oy = y;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; ++current; ++x; ++y; <span class="keyword">if</span> (Map[x][y] == <span class="number">0</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; <span class="keyword">if</span> (Map[x][y] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="keyword">if</span> ((x == <span class="number">8</span> || y == <span class="number">8</span>) &amp;&amp; Map[x][y] == <span class="number">2</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (current &gt; <span class="number">0</span>) --current;</span><br><span class="line">        ret += current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        x = ox;</span><br><span class="line">        y = oy;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; ++current; --x; --y; <span class="keyword">if</span> (Map[x][y] == <span class="number">0</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; <span class="keyword">if</span> (Map[x][y] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="keyword">if</span> ((x == <span class="number">1</span> || y == <span class="number">1</span>) &amp;&amp; Map[x][y] == <span class="number">2</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (current &gt; <span class="number">0</span>) --current;</span><br><span class="line">        ret += current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        x = ox;</span><br><span class="line">        y = oy;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; ++current; --x; ++y; <span class="keyword">if</span> (Map[x][y] == <span class="number">0</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; <span class="keyword">if</span> (Map[x][y] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="keyword">if</span> ((x == <span class="number">1</span> || y == <span class="number">8</span>) &amp;&amp; Map[x][y] == <span class="number">2</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (current &gt; <span class="number">0</span>) --current;</span><br><span class="line">        ret += current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        x = ox;</span><br><span class="line">        y = oy;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123; ++current; ++x; --y; <span class="keyword">if</span> (Map[x][y] == <span class="number">0</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; <span class="keyword">if</span> (Map[x][y] == <span class="number">1</span>) <span class="keyword">break</span>; <span class="keyword">if</span> ((x == <span class="number">8</span> || y == <span class="number">1</span>) &amp;&amp; Map[x][y] == <span class="number">2</span>) &#123; current = <span class="number">0</span>; <span class="keyword">break</span>; &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (current &gt; <span class="number">0</span>) --current;</span><br><span class="line">        ret += current;</span><br><span class="line">        current = <span class="number">0</span>;</span><br><span class="line">        x = ox;</span><br><span class="line">        y = oy;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Map[i][j] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                ans = <span class="built_in">std</span>::max(ans, getAnswer(i, j) + getAnswerAlt(i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    Read();</span><br><span class="line">    Search();</span><br><span class="line">    putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正解-1"><a href="#正解-1" class="headerlink" title="正解"></a>正解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">8</span> + <span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">8</span> + <span class="number">1</span>] = &#123;<span class="number">0</span>,  <span class="number">0</span>,  <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147482333</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">8</span> + <span class="number">2</span>][<span class="number">8</span> + <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans, Max;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; s[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; <span class="number">8</span> || y &lt; <span class="number">1</span> || y &gt; <span class="number">8</span> || s[x][y] == <span class="string">'.'</span>) <span class="keyword">return</span> -INF;</span><br><span class="line">        <span class="keyword">if</span> (s[x][y] == <span class="string">'B'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> DFS(now, x + dx[now], y + dy[now]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">8</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">8</span>; ++k) &#123;</span><br><span class="line">                <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    p = DFS(k, i + dx[k], j + dy[k]);</span><br><span class="line">                    <span class="keyword">if</span> (p &gt; <span class="number">0</span>) ans += p; <span class="comment">// 累计答案</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Max = <span class="built_in">std</span>::max(Max, ans); <span class="comment">// 更新答案</span></span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    putint(Max, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-跳格子"><a href="#T4-跳格子" class="headerlink" title="T4. 跳格子"></a>T4. 跳格子</h1><h2 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h2><p>Nikola 现在已经成为一个游戏里的重要人物。这个游戏是由一行 N 个方格， N个方格 用 1 到 N 的数字表示。 Nikola 开始是在 1 号位置， 然后能够跳到其他的位置， Nikola 的第一跳必须跳到 2 号位置。随后的每一跳必须满足两个条件： 1、如果是向前跳， 必须比前面一跳远一个方格。 2、如果是向后跳， 必须和前面一跳一样远。 比如， 在第一跳之后（当在 2 号位置时）， Nikola 能够跳回 1 号位置， 或者向前跳到 4号位置。 每次他跳入一个位置， Nikola 必须付费。 Nikola 的目标是从一号位置尽可能便宜地跳到 N 号位置。 写一个程序， 看看 Nikola 跳到 N 号位置时最小的花费。</p>
<h2 id="输入输出格式-amp-样例-3"><a href="#输入输出格式-amp-样例-3" class="headerlink" title="输入输出格式 &amp; 样例"></a>输入输出格式 &amp; 样例</h2><p>输入格式：<br>共有 N+1 行。 第一行：包含一个整数 N， 它是位置的编号。 第 2..N+1 行：第 i+1 行表示第 I 个方格的费用， 是一个正整数</p>
<p>输出格式：<br>只有一个数， 表示 Nikola 跳到 N 号位置时最小的花费。</p>
<p>输入输出样例</p>
<p>输入样例#1：<br>6 1 2 3 4 5 6<br>输出样例#1：<br>12</p>
<p>输入样例#2：<br>8 2 3 4 3 1 6 1 4<br>输出样例#2：<br>14</p>
<h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>2≤N≤1000 费用不大于500</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>妥妥的DP</p>
<p>我们设    $\text{f[i][j]}$表示跳到第 $i$ 个格子上，可以向后跳 $j$ 个格子的时候的最小花费</p>
<p>转移方程：</p>
<ul>
<li>$\text{(default) f[i][j] = LESS_INF}$</li>
<li>上一次向前跳，显然上一次跳了 $j$ 格。$\text{f[i][j] = min(f[i][j], f[i-j][j-1]}$</li>
<li>上一次向后跳，显然上一次跳了 $j$ 格。 $\text{f[i][j] = min(f[i][j], f[i+j][j]}$</li>
</ul>
<p>最后加上本格的花费$\text{cost[i]}$就是$\text{f[i][j]}$</p>
<p>需要注意的东西有两个，一个是边界，另一个是答案为$\text{min{f[n][i]} }(i \in [1, n-1])$</p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cost[MAXN];</span><br><span class="line">    <span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> step, <span class="keyword">int</span> ncost)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 写挂了的搜索</span></span><br><span class="line">        <span class="keyword">if</span> (now == n) <span class="keyword">return</span> ncost;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">2147482333</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"now = "</span> &lt;&lt; now &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"ncost = "</span> &lt;&lt; ncost &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (now + step + <span class="number">1</span> &lt;= n) ret = <span class="built_in">std</span>::min(ret, DFS(now + step + <span class="number">1</span>, step + <span class="number">1</span>, ncost + cost[now + step + <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">if</span> (now != <span class="number">1</span> &amp;&amp; step != <span class="number">0</span> &amp;&amp; now - step &gt; <span class="number">0</span>) ret = <span class="built_in">std</span>::min(ret, DFS(now - step, step, ncost + cost[now - step]));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    n = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, n) cost[i] = getint();</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//putint(DFS(1, 0, cost[1]), '\n');</span></span><br><span class="line">    <span class="comment">//for (int i = 1; i &lt; n; ++i) &#123;</span></span><br><span class="line">    <span class="comment">//    int now = 2147482333;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="keyword">int</span> Min = <span class="number">2147482333</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) f[i][<span class="number">0</span>] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            f[i][j] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) f[i][j] = f[i - j][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (i + j &lt;= n) f[i][j] = <span class="built_in">std</span>::min(f[i][j], f[i + j][j]);</span><br><span class="line">            <span class="keyword">if</span> (f[i][j] != <span class="number">0x3f3f3f3f</span>) f[i][j] += cost[i];</span><br><span class="line">            <span class="keyword">if</span> (i == n) Min = <span class="built_in">std</span>::min(Min, f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    putint(Min, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然我还是太弱了 这题并没有A掉 差这题就AK了</p>
]]></content>
      <tags>
        <tag>比赛</tag>
        <tag>暴力</tag>
        <tag>枚举</tag>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title>CCF 钦定评测系统 Arbiter 使用指南</title>
    <url>/2018-11-02/Arbiter/</url>
    <content><![CDATA[<blockquote>
<p>Developed by GAIT</p>
</blockquote>
<a id="more"></a>
<h1 id="什么是-Arbiter"><a href="#什么是-Arbiter" class="headerlink" title="什么是 Arbiter"></a>什么是 Arbiter</h1><p>Arbiter 是NOI信息学竞赛唯一指定评测工具，分为网络版和单机版，支持目前主流的 Linux 发行版本，多种语言支持（C, C++ 和 Free Pascal），功能多样，配置灵活，并具有精确的时间控制。</p>
<h1 id="下载-amp-安装"><a href="#下载-amp-安装" class="headerlink" title="下载 &amp; 安装"></a>下载 &amp; 安装</h1><h2 id="Deb-包"><a href="#Deb-包" class="headerlink" title="Deb 包"></a>Deb 包</h2><p>我没有找到关于 Deb 包的任何信息，可能 CCF 暂时移除了。</p>
<h2 id="NOI-Linux"><a href="#NOI-Linux" class="headerlink" title="NOI Linux"></a>NOI Linux</h2><p>首先，打开<a href="http://www.noi.cn/newsview.html?id=690&amp;hash=9A0662&amp;type=11" target="_blank" rel="noopener">这个网址</a><br>下载 NOI Linux 并安装（实体机虚拟机均可）<br>默认密码 123456</p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="打开程序"><a href="#打开程序" class="headerlink" title="打开程序"></a>打开程序</h2><p>在 NOI Linux 中，你可以在左上角的「应用程序」中找到它。<br><img src="/images/Arbiter/1.png" alt="1"></p>
<p>打开之后，它的主界面是这样的。<br><img src="/images/Arbiter/2.png" alt="2"></p>
<h2 id="新建竞赛"><a href="#新建竞赛" class="headerlink" title="新建竞赛"></a>新建竞赛</h2><p>点击「NEW」按钮，输入比赛名称，选择存储目录，点击确定。</p>
<h2 id="打开竞赛"><a href="#打开竞赛" class="headerlink" title="打开竞赛"></a>打开竞赛</h2><p>如果你已经创建过的话，点击「OPEN」，选择竞赛的配置文件(.cfg)，点击确定即可。</p>
<h2 id="配置竞赛"><a href="#配置竞赛" class="headerlink" title="配置竞赛"></a>配置竞赛</h2><h3 id="试题配置"><a href="#试题配置" class="headerlink" title="试题配置"></a>试题配置</h3><p>打开竞赛之后，它会显示这样的一个界面。<br><img src="/images/Arbiter/3.png" alt="3"><br>我们<strong>右键单击</strong>试题概要<strong>下面的空白处</strong>，选择添加考试，它会添加一场名为「第一场——机试」的考试。<br><img src="/images/Arbiter/4.png" alt="4"><br>如何改名下面会说。</p>
<p>我们右键这场考试，选择添加试题，并点击「+」号展开这场比赛。试题默认的名字是「Unknow1」，可以自己修改。</p>
<p><img src="/images/Arbiter/5.png" alt="5"></p>
<p>在这里，你可以修改针对每一个试题的配置。我个人比较偏好的设置如下图。</p>
<p><img src="/images/Arbiter/6.png" alt="6"></p>
<p>关于其他的「比较方式」，在「<code>/path/to/your/contest/filter/readme.txt</code>」中可以了解，对应的比较方式也有源代码。</p>
<h3 id="数据配置"><a href="#数据配置" class="headerlink" title="数据配置"></a>数据配置</h3><p>所有的数据文件都放在「<code>/path/to/your/contest/evaldata/</code>」里，且无任何子文件夹。</p>
<p>所有的输入数据的名称都应该是「题目名称 + 编号 + <code>.in</code>」，如下图。</p>
<p><img src="/images/Arbiter/7.png" alt="7"></p>
<h1 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h1><h2 id="选手文件"><a href="#选手文件" class="headerlink" title="选手文件"></a>选手文件</h2><p>所有的选手文件夹都放在<code>.../players/</code>里</p>
<p>像 NOIP 一样，所有的选手文件都需要建立子文件夹。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| .../players/</span><br><span class="line">|</span><br><span class="line">||--| SD-66666</span><br><span class="line">||------| ccf</span><br><span class="line">||----------&gt; ccf.cpp</span><br><span class="line">||------| cheat</span><br><span class="line">||----------&gt; cheat.cpp</span><br><span class="line">||------| money</span><br><span class="line">||----------&gt; money.cpp</span><br><span class="line">|</span><br></pre></td></tr></table></figure>
<h2 id="开始评测"><a href="#开始评测" class="headerlink" title="开始评测"></a>开始评测</h2><p>切换到「试题评测」界面，点击「添加选手」，输入姓名和编号，点击确定。<br>点击「导入名单」可以进行批量导入<del>我没试过</del>。</p>
<p><img src="/images/Arbiter/8.png" alt="8"></p>
<p>这里要注意编号是和文件夹名相同的。<br><img src="/images/Arbiter/9.png" alt="9"></p>
<p>首先我们要将「评测第<code>0</code>场」改一下，再点击「全选」，「评定选定选手」就开始评测了。</p>
<h2 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h2><p>评测完之后，程序会自动显示评测的结果。<br><img src="/images/Arbiter/10.png" alt="10"></p>
<p>更加详细的信息可以到「成绩统计」里看。「成绩统计」分为4个模块：总体统计、分组统计、试题统计和等级统计。<br><img src="/images/Arbiter/111.png" alt="111"><br><small><center>总体统计</center></small><br><img src="/images/Arbiter/112.png" alt="112"><br><small><center>分组统计</center></small><br><img src="/images/Arbiter/113.png" alt="113"><br><small><center>试题统计</center></small><br><img src="/images/Arbiter/114.png" alt="114"><br><small><center>等级统计</center></small></p>
<p>不得不说分组统计和等级统计就是专门为 NOIP 系列赛事开发的……</p>
<p>你可以选择导出或打印。</p>
<p>对了，成绩为什么多30pts我也不得而知（</p>
<h1 id="FAQs"><a href="#FAQs" class="headerlink" title="FAQs"></a>FAQs</h1><center>想问的可以在评论里问或发送邮件到我的邮箱<br>我会抽一些整理出来</center>

<p>Q1：如何给考试改名？<br>A1：当然是万能的配置文件。<br>打开day1.info，更改<code>NAME=</code>后面的内容。</p>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>使用指南</tag>
        <tag>比赛</tag>
        <tag>评测系统</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2018游记</title>
    <url>/2018-11-02/NOIP2018-PJ/</url>
    <content><![CDATA[<blockquote>
<p>&amp;GaiGeKaiFang(40)Nian</p>
</blockquote>
<a id="more"></a>
<h1 id="随手一记"><a href="#随手一记" class="headerlink" title="随手一记"></a>随手一记</h1><h2 id="NOIP2018-游记"><a href="#NOIP2018-游记" class="headerlink" title="NOIP2018 游记"></a>NOIP2018 游记</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rp = 0x3f3f3f3f;</span><br><span class="line">rp++;</span><br></pre></td></tr></table></figure>
<p>出征！</p>
<h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h3><p>今天在学生活动中心肝了一个上午<br>又做了几道题 顺便写了一发题解<br>希望能涨涨RP吧</p>
<h3 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h3><p>等待进场的时间真是漫长。<br>看着队伍一点一点地往前走，我的心也开始激动了起来。</p>
<p>进场发现有人居然动鼠标，监考老师还不管<br>考前5min就发了密码</p>
<p>T1水题，上来5min切了<br>不过我居然奶中了，T1就是求一个字符串中有多少字符</p>
<p>T2是个暴力，最开始想出了$O(n^2)$的做法，后来改了一下就成了一个$O(n)$的做法，没意外应该能拿满</p>
<p>T3……我被T3切了<br>打了个最大计算量$10^{10}$的算法，结果极限大样例答案不对！心态崩了</p>
<p>T4随便判了几个情况，希望能骗一点分</p>
<p>顺便表扬CCF终于换评测机了</p>
<h1 id="正经的"><a href="#正经的" class="headerlink" title="正经的"></a>正经的</h1><p>Day0</p>
<p>成堆的人在开包，成堆的人出橙了，成堆的人掉rp。</p>
<p>不得不说去昌邑的路真漫长，貌似SDSC的时候都没这么长时间。</p>
<p>下了车第一件事就是拍照，补上SDSC没有拍照的遗憾，毕竟昌邑一中的绿化面积和水系的面积是极大的！这就是我戏称昌邑一中为“昌邑第一自然保护区”的原因。</p>
<p>晚上去试机，不得不说习惯了 Macbook Pro 2017 的蝶式键盘就真的回不来了。还有对应 Alt 键的 ⌘ 键，实在是习惯了，到那保存就是一个劲地按 Alt + S……敲了一遍代码的默认模板，5分钟敲过，和我预想中的差不多快。</p>
<p>Day1</p>
<p>上午去了学生活动中心做题，一口气切了8道题——但是都是「普及-」的题目，这可能是这三天我的活动安排的败笔。我应该做「普及/提高-」的题目的啊……</p>
<p>中午写了篇题解扔到博客上了，希望能rp++</p>
<p>下午去的时候手机居然没电了，好自闭啊。还没到2:30就带着一瓶今麦郎的凉白开进了场，居然不到时间就发了密码。<br>第一道题我居然说中了……考试前一天我还在说一道求字符串长度的题，于是用getline5分钟切了。<br>第二题依然是水题，先想到的是$O(n^2)$的做法，发现只能拿80分，于是就开始想正解。很快想到了一个$O(n)$的做法就开始敲，结果最大的样例过不了，然后简单分析了一下发现需要开long long int。不过，我在开了long long int之后只把表示∞的值提高了一点，在Day2的自测中才发现……所以我写$O(n)$的做法跟没写一样，开long long跟没开一样！看到自测的成绩后我心态是真的崩死了。<br>第三题第一眼是DP，但是推不出式子来，于是就开始想贪心做法。写了一个暴力，然后最大的样例死活调不过，浪费了近1个小时。<br>第四题一看就知道不大可做，然后尝试写暴力也没写出来，最后随便判了几个情况算完。</p>
<p>Day2<br>上午在学生活动中心把题目写了一遍，发现第二题∞的值设的过小，预测了一下省一线</p>
]]></content>
      <tags>
        <tag>NOIP</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>Manacher 算法学习笔记</title>
    <url>/2018-11-01/Manacher/</url>
    <content><![CDATA[<blockquote>
<p>$O(n)$回文串</p>
</blockquote>
<a id="more"></a>
<h1 id="Manacher-是什么"><a href="#Manacher-是什么" class="headerlink" title="Manacher 是什么"></a>Manacher 是什么</h1><p>Manacher 是一种可以在$O(n)$的时间复杂度内求出一个字符串的最长回文子串的算法。</p>
<p>Manacher，中文一般念做「马拉车」。</p>
<h1 id="Manacher-Algorithm-的思想"><a href="#Manacher-Algorithm-的思想" class="headerlink" title="Manacher Algorithm 的思想"></a>Manacher Algorithm 的思想</h1><p>首先我们来看一道题<a href="https://www.luogu.org/problemnew/show/P3805" target="_blank" rel="noopener">洛谷P3805【模板】manacher算法</a>。</p>
<p>考虑一下暴力做法，就是枚举字串的边界并进行验证，时间复杂度$O(n^3)$</p>
<p>考虑一下优化，我们可以枚举所有“回文子串”的对称轴（尽管它现在不一定是回文子串）并向两边进行扩展，用一个数组<code>external[i]</code>记录第<code>i</code>个字符可向外扩展的数量，显然数组中最大值的二倍就是答案，时间复杂度均摊$O(n^2)$。</p>
<p>但这还不够快……毕竟$\text{|s|} \leq 11000000$</p>
<p>于是我们考虑在优化的思想基础上进行再次优化。</p>
<hr>
<p>在此之前，我们首先要解决一个棘手的问题——字符串的长度。<br>一个字符串子串的对称轴是在字母中间还是在字母上，是由子串长度为偶数还是奇数决定的。于是，为了统一对于奇数长度字符串和偶数长度字符串的做法，我们需要对字符串进行修改。（代码见「代码实现」<code>Pre()</code>部分）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">就比如说</span><br><span class="line"> - - - - - -</span><br><span class="line">|%|%|%|w|y|h|</span><br><span class="line">我们要用一些无关紧要的字符填一下</span><br><span class="line"> - - - - - - - - - - -</span><br><span class="line">|%|!|%|!|%|!|w|!|y|!|h|</span><br><span class="line">这样更好处理</span><br></pre></td></tr></table></figure>
<p>修改完了之后，就是真正的<code>Manacher()</code>过程了<br>首先，我们要用一个变量<code>maxRight</code>记录「当前的 最靠右的 回文子串的 右端点」，和一个变量<code>mid</code>记录「当前的 最靠右的 回文子串的 对称轴所在的 字符的 下标」，注意这里的<code>mid</code>是可以不赋初值的</p>
<p>我们循环枚举<strong>经过处理的字符串</strong>的每一个字符。对于每一个字符的下标<code>i</code>，如果<code>i &lt; maxRight</code>，那么我们就可以获取<code>external[i]</code>的部分信息（<code>external[i]</code>的意义和上文相同），否则就只能将<code>external[i]</code>设为1</p>
<p>接着就是和暴力一样的扩展了，我这里选择用<code>for</code>语句实现（</p>
<p>最后更新一下<code>maxRight</code>和<code>mid</code>即可</p>
<p>最终答案就是<code>external[]</code>的最大值——而不是2倍，因为<strong>这是我们扩展过的字符串，最终答案还要$\times \frac{1}{2}$</strong>。</p>
<h1 id="Manacher-Algorithm-的代码实现"><a href="#Manacher-Algorithm-的代码实现" class="headerlink" title="Manacher Algorithm 的代码实现"></a>Manacher Algorithm 的代码实现</h1><p>同样也是「manacher模版」的代码实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Words -- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">31000000</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 没错，就是要开这么大</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, external[MAXN];</span><br><span class="line">    <span class="keyword">char</span> s[MAXN], str[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pre</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        str[<span class="number">0</span>] = str[<span class="number">1</span>] = <span class="string">'~'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            str[i * <span class="number">2</span> + <span class="number">2</span>] = s[i];</span><br><span class="line">            str[i * <span class="number">2</span> + <span class="number">3</span>] = <span class="string">'~'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">        str[n] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxRight = <span class="number">0</span>, mid = <span class="number">0</span>; <span class="comment">// mid 初值无所谓</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; maxRight) &#123;</span><br><span class="line">                external[i] = <span class="built_in">std</span>::min(external[(mid &lt;&lt; <span class="number">1</span>) - i], external[mid] + mid - i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                external[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; str[i + external[i]] == str[i - external[i]]; ++external[i]);</span><br><span class="line">            <span class="keyword">if</span> (external[i] + i &gt; maxRight) &#123;</span><br><span class="line">                maxRight = external[i] + i;</span><br><span class="line">                mid = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(s);</span><br><span class="line">        Pre();</span><br><span class="line">        Manacher();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) ans = <span class="built_in">std</span>::max(ans, external[i]);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    Work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>学习笔记</tag>
        <tag>回文</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1280《尼克的任务》</title>
    <url>/2018-11-01/Luogu-P1280/</url>
    <content><![CDATA[<blockquote>
<p>线性DP</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P1280" target="_blank" rel="noopener">题目🔗</a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。</p>
<p>尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。</p>
<p>写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入数据第一行含两个用空格隔开的整数$N$和$K(1≤N≤10000，1≤K≤10000)$，$N$表示尼克的工作时间，单位为分钟，$K$表示任务总数。</p>
<p>接下来共有$K$行，每一行有两个用空格隔开的整数$P$和$T$，表示该任务从第$P$分钟开始，持续时间为$T$分钟，其中$1≤P≤N$，$1≤P+T-1≤N$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 6</span><br><span class="line">1 2</span><br><span class="line">1 6</span><br><span class="line">4 11</span><br><span class="line">8 5</span><br><span class="line">8 1</span><br><span class="line">11 5</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>DP</p>
<p>我们设<code>f[i]</code>表示在前<code>i</code>分钟内的最大空闲时间<br>但是发现第<code>i</code>分钟的空闲时间是由后面的任务决定的<br>所以我们考虑倒着扫一遍</p>
<hr>
<p>我们设<code>f[i]</code>表示在第<code>i$$\rightarrow$$n</code>分钟内的最大空闲时间<br>转移方程：</p>
<ul>
<li>当第<code>i</code>分钟没有任务时，<code>f[i] = f[i + 1] + 1</code></li>
<li>当第<code>i</code>分钟有任务时，<code>f[i] = std::max(f[i], f[i + seq[j]].time)</code>，其中<code>seq[j].time</code>表示第<code>j</code>个任务的耗时</li>
</ul>
<p>如何判断当前有没有任务？<br>我们开一个数组<code>sum[i]</code>表示第<code>i</code>分钟的任务个数<br>更新就很好更新了——<br><code>++sum[seq[j].startTime]</code>，其中<code>seq[j].startTime</code>表示第<code>j</code>个任务的开始时间</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Words -- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="comment">/*/</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 设f[i]表示i-n的空闲时间</span></span><br><span class="line"><span class="comment">     * f[i] = f[i+1] + 1（无任务）</span></span><br><span class="line"><span class="comment">     * f[i] = max(f[i], f[i + seq[x]])（有任务）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">    /*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXK = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = MAXK;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QwQ</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> start, time;</span><br><span class="line">    &#125; qwq[MAXK];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">int</span> sum[MAXN];</span><br><span class="line">    <span class="keyword">int</span> f[MAXN];</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">stlCmp</span><span class="params">(QwQ x, QwQ y)</span> </span>&#123; <span class="keyword">return</span> x.start &gt; y.start; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">        n = getint();</span><br><span class="line">        k = getint();</span><br><span class="line">        For (i, <span class="number">1</span>, k) &#123;</span><br><span class="line">            qwq[i].start = getint();</span><br><span class="line">            qwq[i].time = getint();</span><br><span class="line">            ++sum[qwq[i].start];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(qwq + <span class="number">1</span>, qwq + <span class="number">1</span> + k, stlCmp);</span><br><span class="line">        <span class="comment">// 既然是倒序，所以输入也要排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[i] == <span class="number">0</span>) f[i] = f[i + <span class="number">1</span>] + <span class="number">1</span>; <span class="comment">// 当前时刻没有任务</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= sum[i]; ++j) &#123;</span><br><span class="line">                    f[i] = <span class="built_in">std</span>::max(f[i], f[i + qwq[num].time]); </span><br><span class="line">                    <span class="comment">// 当前时刻有至少一个任务，把它们都扫一遍</span></span><br><span class="line">                    ++num;</span><br><span class="line">                    <span class="comment">// 用一个变量 num 表示当前扫到的任务</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        FastIO::putint(f[<span class="number">1</span>], <span class="string">'\n'</span>);</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HANDWER_FILE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    Work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1577《切绳子》</title>
    <url>/2018-10-31/Luogu-P1577/</url>
    <content><![CDATA[<blockquote>
<p>突然想起《割绳子》</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P1577" target="_blank" rel="noopener">题面🔗</a></p>
<h1 id="题面描述"><a href="#题面描述" class="headerlink" title="题面描述"></a>题面描述</h1><p>有N条绳子，它们的长度分别为Li。如果从它们中切割出K条长度相同的绳子，这K条绳子每条最长能有多长？答案保留到小数点后2位。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数N和K，接下来N行，描述了每条绳子的长度Li。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>切割后每条绳子的最大长度。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 11</span><br><span class="line">8.02</span><br><span class="line">7.43</span><br><span class="line">4.57</span><br><span class="line">5.39</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.00</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先这题涉及到了<code>int</code>和<code>double</code>之间的精度转换 <br><br>所以我们可以把输入的<code>double</code>都乘100转为<code>int</code>（题目要求保留两位小数）</p>
<p>不难看出来这题可以枚举答案 但是显然会炸 <br><br>于是我们要想点优化——二分答案！</p>
<p>我们选择二分绳子的最大长度 <br><br>这题的单调性是显然的，我就不证了（</p>
<p><code>Check(int mid)</code>怎么写？ <br><br>我们扫一遍绳子长度<code>L[]</code>，令$ ans=\sum_{i=1}^{n}\lfloor\frac{L[i]}{mid}\rfloor $ <br><br>即最终绳子被分成的段数 <br><br>如果$ans \geq k$（题目中的$\text{k}$）则把左边界赋值为<code>mid + 1</code>，否则把右边界赋值为<code>mid - 1</code> <br><br>这里要注意的是如果<code>mid == 0</code>就直接退出循环</p>
<p>最后<code>cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (double) r / 100.0 &lt;&lt; endl;</code></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> MAXL = <span class="number">100000.00</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> L[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans += L[i] / x;</span><br><span class="line">    <span class="keyword">return</span> ans &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">double</span> P;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; P;</span><br><span class="line">        L[i] = (<span class="keyword">int</span>) (P * <span class="number">100.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">19260817</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check(mid)) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; (<span class="keyword">double</span>) r / <span class="number">100.0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1032《字串变换》</title>
    <url>/2018-10-30/Luogu-P1032/</url>
    <content><![CDATA[<blockquote>
<p>NO ANSWER!</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>已知有两个字串$A,B$及一组字串变换的规则（至多$6$个规则）:</p>
<p>$A_1 \rightarrow B_1$ </p>
<p>$A_2 \rightarrow B_2$<br>​<br>规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $B_1$，$A_2$可以变换为 $B_2 \dots$</p>
<p>例如：$A=$’$abcdabcd$’，$B＝$’$xyzxyz$’</p>
<p>变换规则为：</p>
<p>‘$abc$’$\rightarrow$‘$xu$’ <br><br>‘$ud$’$\rightarrow$‘$y$’ <br><br>‘$y$’$\rightarrow$‘$yz$’</p>
<p>则此时，$A$可以经过一系列的变换变为$B$，其变换的过程为：</p>
<p>‘$abcd$’$\rightarrow$‘$xud$’$\rightarrow$‘$xy$’$\rightarrow$‘$xyz$’</p>
<p>共进行了$3$次变换，使得$A$变换为$B$。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入格式如下：</p>
<p>$A$ $B$ <br><br>$A_1$ $B_1$<br>​<br>$A_2$ $B_2$​$|\rightarrow$ 变换规则</p>
<p>… … /</p>
<p>所有字符串长度的上限为$20$。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>输出至屏幕。格式如下：</p>
<p>若在$10$步（包含$10$步）以内能将$A$变换为$B$，则输出最少的变换步数；否则输出”NO ANSWER!”</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcd xyz</span><br><span class="line">abc xu</span><br><span class="line">ud y</span><br><span class="line">y yz</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是一个 BFS</p>
<p>题目刚上来就有一个坑 <br><br>输入不给行数 只知道最多六行 <br><br>于是我们用一个变量<code>l</code>来记录输入的行数 <br><br>我这里选择用<code>A[0]</code>和<code>B[0]</code>来存两个原字符串</p>
<p>首先如果<code>l == 0</code>而且<code>A[0] != B[0]</code>，那直接输出<code>NO ANSWER!</code></p>
<p>否则用一个变量<code>v</code>来记录<code>BFS()</code>的返回值</p>
<p>如何搜索？ <br><br><del><a href="www.baidu.com">www.baidu.com</a> </del> <br><br>我们建两个队列<code>q</code>和<code>step</code>，分别存需要修改的字符串和这个字符串所对应的步数 <br><br>循环的时候就不能只判<code>!q.empty()</code>，还要判<code>q.front() != B[0] /* 字符串还需要修改 */</code>和<code>step.front() &lt;= 10 /* 限制只能修改10次 */</code> <br><br>我们还需要用一个<code>map&lt;string, bool&gt;</code>来判重</p>
<p>剩下的一些解释我直接扔到代码注释里面了</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">6</span> + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">bool</span>&gt; KangShifu;</span><br><span class="line"><span class="built_in">string</span> A[MAXN], B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BoynextdoorFaqSearch</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; q;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; step;</span><br><span class="line">    q.push(A[<span class="number">0</span>]);</span><br><span class="line">    step.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty() &amp;&amp; q.front() != B[<span class="number">0</span>] &amp;&amp; step.front() &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (KangShifu[q.front()]) &#123;</span><br><span class="line">            q.pop();</span><br><span class="line">            step.pop();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">        &#125;</span><br><span class="line">        KangShifu[q.front()] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++i) &#123;</span><br><span class="line">            <span class="built_in">string</span> s = q.front(); <span class="comment">// 用一个string记录下当前需要修改的字符串</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            	<span class="comment">// 可能不止修改一次</span></span><br><span class="line">                <span class="keyword">int</span> loc = s.find(A[i]);</span><br><span class="line">                <span class="keyword">if</span> (loc == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 并没有找到</span></span><br><span class="line">                <span class="built_in">string</span> ss = q.front();</span><br><span class="line">                <span class="comment">// 再复制一份需要修改的字符串</span></span><br><span class="line">                ss.replace(loc, A[i].size(), B[i]);</span><br><span class="line">                <span class="comment">// 修改</span></span><br><span class="line">                q.push(ss);</span><br><span class="line">                <span class="comment">// 把它扔进队列</span></span><br><span class="line">                step.push(step.front() + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 步骤数 + 1</span></span><br><span class="line">                s[loc] = <span class="string">'~'</span>;</span><br><span class="line">                <span class="comment">// 把这个能搜到的地方用一个无关紧要的放起来</span></span><br><span class="line">                <span class="comment">// 防止下次还能被搜到</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">        step.pop();</span><br><span class="line">        <span class="comment">// 处理完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q.empty() || step.front() &gt; <span class="number">10</span>) ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 如果队列空了或超过10步了，输出NO ANSWER!</span></span><br><span class="line">    <span class="keyword">else</span> ans = step.front();</span><br><span class="line">    <span class="comment">// 否则输出真正的答案</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; A[l] &gt;&gt; B[l]) ++l;</span><br><span class="line">    --l;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] != B[<span class="number">0</span>]) <span class="built_in">puts</span>(<span class="string">"NO ANSWER!"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> v = BoynextdoorFaqSearch(l);</span><br><span class="line">        <span class="comment">// Boy Next Door</span></span><br><span class="line">        <span class="keyword">if</span> (v == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">"NO ANSWER!"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>BFS</tag>
        <tag>搜索</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3952《时间复杂度》</title>
    <url>/2018-10-29/Luogu-P3952/</url>
    <content><![CDATA[<blockquote>
<p>继《玩具谜题》后的又一力作</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P3952" target="_blank" rel="noopener">题目地址</a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。</p>
<p>A++语言的循环结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F i x y</span><br><span class="line">    循环体</span><br><span class="line">E</span><br></pre></td></tr></table></figure>
<p>其中 $\text{F i x y}$ 表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i+1$，一旦 $i$ 大于 $y$ 终止循环。</p>
<p>$x​$ 和 $y​$ 可以是正整数（$x​$ 和 $y​$ 的大小关系不定）或变量 $n​$。$n​$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。</p>
<p>“$\text{E}$”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。</p>
<p>注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“$O$”表示通常意义下“$Θ$”的概念。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h2><p>输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 $\text{F i x y}$和$\text{E}$即可计算时间复杂度。注意：循环结构 允许嵌套。</p>
<p>接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符 串表示这个程序的复杂度，<code>O(1)</code>表示常数复杂度，<code>O(n^w)</code>表示复杂度为$n^w$，其中$w$是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有<code>O(1)</code>和<code>O(n^w)</code> 两种类型。</p>
<p>接下来 $L$ 行代表程序中循环结构中的$\text{F i x y}$或者 $\text{E<br>}$。 程序行若以$\text{F}$开头，表示进入一个循环，之后有空格分离的三个字符（串）$\text{i x y}$， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。</p>
<p>程序行若以$E$开头，则表示循环体结束。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出<code>Yes</code>或<code>No</code>或者<code>ERR</code>，若程序实际复杂度与输入给出的复杂度一致则输出<code>Yes</code>，不一致则输出<code>No</code>，若程序有语法错误（其中语法错误只有: ① $\text{F}$ 和 $\text{E}$ 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出<code>ERR</code> 。</p>
<p>注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 <code>ERR</code>。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">2 O(1)</span><br><span class="line">F i 1 1</span><br><span class="line">E</span><br><span class="line">2 O(n^1)</span><br><span class="line">F x 1 n</span><br><span class="line">E</span><br><span class="line">1 O(1)</span><br><span class="line">F x 1 n</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 5 n</span><br><span class="line">F y 10 n</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 9 n</span><br><span class="line">E</span><br><span class="line">F y 2 n</span><br><span class="line">E</span><br><span class="line">4 O(n^1)</span><br><span class="line">F x 9 n</span><br><span class="line">F y n 4</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(1)</span><br><span class="line">F y n 4</span><br><span class="line">F x 9 n</span><br><span class="line">E</span><br><span class="line">E</span><br><span class="line">4 O(n^2)</span><br><span class="line">F x 1 n</span><br><span class="line">F x 1 10</span><br><span class="line">E</span><br><span class="line">E</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">ERR</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">ERR</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先我们肯定一眼就能看出这题是个没有任何优化的<big><big><big>大模拟</big>&lt;/big&gt;&lt;/big&gt;</big></big></p>
<p>那么如何模拟？ </p>
<p>首先我们为了方便，把循环体离线下来，用字符串存着 </p>
<p>根据题意，我们写一个函数<code>GetNumber()</code>把字符串里的数字存下来 具体和快读差不多 </p>
<p>我们先把小明给出的时间复杂度的$n$的指数记为$\text{w}$，这里注意$O(1)$的情况要用$0$代替</p>
<p>接着便是求真正的时间复杂度了</p>
<p>首先是判断ERR 这个比较简单 我们用一个栈来储存所有的循环体<strong>的变量名</strong></p>
<ul>
<li>当$\text{E}$已经读完但是栈不空</li>
<li>当$\text{E}$未读完但是栈空</li>
<li>当储存的变量名与现在的变量名冲突</li>
</ul>
<p>这个过程穿插在代码各处 <br></p>
<p>当读到$\text{F}$的时候往栈里 Push 循环体变量名，注意要一块把记录变量名的数组<code>used</code>进行判断并更新 <br><br>之后，我们用<code>GetNumber</code>获取一下$x$和$y$两个数，分情况讨论一下</p>
<ul>
<li>当$y$是$n$的时候，如果这次循环可以执行，++答案</li>
<li>当$y&lt;x$的时候，循环不执行，更新一下「最早不能循环的循环体」</li>
<li>剩下一种情况就是常数，可以不写</li>
</ul>
<p>当读到$\text{E}$的时候，先检查栈里还有没有东西，再 Pop 出来，注意要检查一下这个变量是不是「最早不能循环的循环体」的变量</p>
<p>最后扫完数据，判一下栈是不是还有东西没 Pop 出来，然后验一下答案，输出</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> Code[MAX];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetNumber</span><span class="params">(<span class="keyword">int</span> &amp;X, <span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(s[X]) &amp;&amp; X &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[X] == <span class="string">'n'</span>) &#123;</span><br><span class="line">            ++X;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">19260817</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[X])) &#123;</span><br><span class="line">        ret = ret * <span class="number">10</span> + s[X] - <span class="string">'0'</span>;</span><br><span class="line">        ++X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getO</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[<span class="number">2</span>] == <span class="string">'n'</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> _ = <span class="number">3</span>; <span class="comment">// 必须要传实参进去</span></span><br><span class="line">        <span class="keyword">return</span> GetNumber(_, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetO</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> earliestVariant = <span class="number">-1</span>; <span class="comment">// 「最早不能循环的循环体」</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">27</span>] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">bool</span> ran[<span class="number">27</span>] = &#123; <span class="literal">false</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Code[i][<span class="number">0</span>] == <span class="string">'F'</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> varName = Code[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (used[varName - <span class="string">'a'</span>]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            stk.push(varName);</span><br><span class="line">            used[varName - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// Get X</span></span><br><span class="line">            <span class="keyword">int</span> X = <span class="number">4</span>;</span><br><span class="line">            x = GetNumber(X, Code[i]);</span><br><span class="line">            <span class="comment">// Get Y</span></span><br><span class="line">            y = GetNumber(X, Code[i]);</span><br><span class="line">            <span class="keyword">if</span> (y - x &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="comment">// y = n</span></span><br><span class="line">                <span class="keyword">if</span> (earliestVariant == <span class="number">-1</span>) &#123;</span><br><span class="line">                    ++now;</span><br><span class="line">                    ret = <span class="built_in">std</span>::max(ret, now);</span><br><span class="line">                    ran[varName - <span class="string">'a'</span>] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; y) &#123;</span><br><span class="line">                <span class="keyword">if</span> (earliestVariant == <span class="number">-1</span>) earliestVariant = varName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (stk.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">char</span> nowVarName = stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            used[nowVarName - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (earliestVariant == nowVarName) earliestVariant = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ran[nowVarName - <span class="string">'a'</span>]) &#123;</span><br><span class="line">                ran[nowVarName - <span class="string">'a'</span>] = <span class="literal">false</span>;</span><br><span class="line">                --now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!stk.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> w, nw, l;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d "</span>, &amp;l);</span><br><span class="line">        <span class="built_in">string</span> o;</span><br><span class="line">        getline(<span class="built_in">cin</span>, o);</span><br><span class="line">        nw = getO(o);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++i) &#123;</span><br><span class="line">            getline(<span class="built_in">cin</span>, Code[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        w = GetO(l);</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">"ERR"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (w == nw) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1525《关押罪犯》</title>
    <url>/2018-10-20/Luogu-P1525/</url>
    <content><![CDATA[<blockquote>
<p>敌人的敌人就是朋友！</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P1525" target="_blank" rel="noopener">题目地址</a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>S城现有两座监狱，一共关押着 N 名罪犯，编号分别为 1−N 。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 c 的冲突事件。</p>
<p>每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。</p>
<p>在详细考察了 N 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。</p>
<p>那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>每行中两个数之间用一个空格隔开。第一行为两个正整数N,M，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的M行每行为三个正整数$a_j,b_j,c_j$，表示$a_j$号和$b_j$号罪犯之间存在仇恨，其怨气值为$c_j$。数据保证$1&lt;aj≤bj≤N,0 &lt; cj≤ 1,000,000,000$，且每对罪犯组合只出现一次。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>共 1 行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 0。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 6</span><br><span class="line">1 4 2534</span><br><span class="line">2 3 3512</span><br><span class="line">1 2 28351</span><br><span class="line">1 3 6618</span><br><span class="line">2 4 1805</span><br><span class="line">3 4 12884</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3512</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>显然这是一个并查集</p>
<p>首先我们把输入记录下来，按照权值从大到小排个序 <br><br>然后对于每一条关系，如果它们的祖先相同，就说明发生了冲突，此时直接输出 + return 0就好 <br><br>否则就进行合并</p>
<p>如何合并？ <br><br>根据“敌人的敌人就是朋友”的原则，我们维护一个<code>Enemy[i]</code>表示<code>i</code>的的敌人 <br><br>然后对于每一个人，更新它的敌人（如果它的敌人目前没被更新过）<br><br>否则就合并另一个人和他的敌人</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">20000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Relative</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, weight;</span><br><span class="line">&#125; rel[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, U[MAXM * <span class="number">2</span>], E[MAXN * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) U[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == U[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = Find(x), y = Find(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    U[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stlCmp</span><span class="params">(Relative x, Relative y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.weight &gt; y.weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; w;</span><br><span class="line">        rel[i].x = x;</span><br><span class="line">        rel[i].y = y;</span><br><span class="line">        rel[i].weight = w;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(rel + <span class="number">1</span>, rel + <span class="number">1</span> + m, stlCmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = rel[i].x, y = rel[i].y;</span><br><span class="line">        <span class="keyword">int</span> fx = Find(x), fy = Find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>, rel[i].weight);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (E[x] == <span class="number">0</span>) E[x] = y;</span><br><span class="line">        <span class="keyword">else</span> Union(E[x], y);</span><br><span class="line">        <span class="keyword">if</span> (E[y] == <span class="number">0</span>) E[y] = x;</span><br><span class="line">        <span class="keyword">else</span> Union(E[y], x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>SP3377《A Bug's Life》</title>
    <url>/2018-10-20/SP3377/</url>
    <content><![CDATA[<blockquote>
<p>谁闲的没事研究同性恋。。。</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/SP3377" target="_blank" rel="noopener">题目地址</a></p>
<p>本文同步发布于：<a href="https://www.luogu.org/blog/handwer-blog/solution-sp3377" target="_blank" rel="noopener">Handwer’s 洛谷博客</a></p>
<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>就是一个奇怪的ke学家，他专门研究虫子是否存在同性恋。。。</p>
<p>他为每一只虫子都标上了序号。</p>
<p>通过这个奇怪的ke学家的研究，找出了在这些虫子中的所有关系的虫子，题目询问在这么多有关系的虫子中是否存在“同性恋”。</p>
<h1 id="输入格式-amp-样例"><a href="#输入格式-amp-样例" class="headerlink" title="输入格式 &amp; 样例"></a>输入格式 &amp; 样例</h1><p>第一行， 输入一个数，表示有t组数据<br>对于每组数据，第一行输入n,m，表示有n只虫子，有m个关系<br>接下来行每行两个数x,y，表示x,y有关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br><span class="line">4 2</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<h1 id="输出格式-amp-样例"><a href="#输出格式-amp-样例" class="headerlink" title="输出格式 &amp; 样例"></a>输出格式 &amp; 样例</h1><p>对于每一组数据： <br><br>先输出：”Scenario #i” ，表示第i组数据 <br><br>然后如果有同性恋的输出”Suspicious bugs found!” <br><br>否则输出”No suspicious bugs found!” <br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Scenario #1:</span><br><span class="line">Suspicious bugs found!</span><br><span class="line">Scenario #2:</span><br><span class="line">No suspicious bugs found!</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>显然这是一个并查集，但并不是一个裸的并查集</p>
<p>我们要多维护一个数组<code>rel[]</code>，其中<code>rel[i]</code>表示<code>i</code>和它的祖先的关系（relative）。我们定义<code>rel[i]</code>表示两种性别，当根节点相同且<code>rel[]</code>相同时，它们就是同性恋</p>
<p><code>rel[]</code>的更新方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(in Find(x))</span><br><span class="line">rel[x] = (rel[x] + rel[U[x]]) % 2;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(in Union(x, y))</span><br><span class="line">int fx = Find(x), fy = Find(y);</span><br><span class="line">...</span><br><span class="line">rel[fx] = (rel[x] + rel[y] + 1) % 2;</span><br></pre></td></tr></table></figure>
<p><code>rel[]</code>的判断方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(in Union(x, y))</span><br><span class="line">if (fx == fy) &#123;</span><br><span class="line">	if (rel[x] == rel[y]) suspiciousFound = true;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>剩下的照常写就行</p>
<p>注意路径压缩要分开写，先创建一个变量存它的祖先节点再更新 </p>
<p><del>按秩合并没写过不知道</del></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><del>你们最喜欢的</del>代码实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> U[MAXM], rel[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x != U[x]) &#123;</span><br><span class="line">    	<span class="comment">// 把路径压缩撑开写</span></span><br><span class="line">        <span class="keyword">int</span> fux = Find(U[x]);</span><br><span class="line">        rel[x] = (rel[x] + rel[U[x]]) % <span class="number">2</span>; <span class="comment">// 更新rel数组</span></span><br><span class="line">        <span class="comment">// 1 1 -&gt; 0</span></span><br><span class="line">        <span class="comment">// 1 0 / 0 1 -&gt; 1</span></span><br><span class="line">        <span class="comment">// 0 0 -&gt; 0</span></span><br><span class="line">        <span class="comment">// 其实是一个异或的过程</span></span><br><span class="line">        U[x] = fux； <span class="comment">// qwq</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> U[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fx = Find(x), fy = Find(y);</span><br><span class="line">    <span class="keyword">if</span> (fx == fy) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rel[x] == rel[y]) flag = <span class="literal">true</span>; <span class="comment">// 判断是否同性</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    U[fx] = fy;</span><br><span class="line">    rel[fx] = (rel[x] + rel[y] + <span class="number">1</span>) % <span class="number">2</span>; <span class="comment">// 更新rel数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">_t</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(U, <span class="number">0</span>, <span class="keyword">sizeof</span>(U));</span><br><span class="line">        <span class="built_in">memset</span>(rel, <span class="number">0</span>, <span class="keyword">sizeof</span>(rel));</span><br><span class="line">        n = <span class="number">0</span>, m = <span class="number">0</span>, flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) U[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> x, y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">            Union(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Scenario #%d:\n"</span>, ++<span class="keyword">_t</span>);</span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">printf</span>(<span class="string">"Suspicious bugs found!\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No suspicious bugs found!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>; <span class="comment">// qwq</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2866《[USACO06NOV]糟糕的一天Bad Hair Day》</title>
    <url>/2018-10-06/Luogu-P2866/</url>
    <content><![CDATA[<blockquote>
<p>有点难想的单调栈模板题</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problem/show?pid=2866" target="_blank" rel="noopener">题目地址</a></p>
<p>暂不提供题面，请自行到洛谷查看题面。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：一个数N表示奶牛的数量。</p>
<p>第2到N+1行：第i+1行包含一个整数表示第i头奶牛的高。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行：一个整数，即c1到cN的和</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">10</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">12</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这就是一个单调栈的模板</p>
<p>循环读入，每次push读入的数进一个单调栈并维护这个栈的单调性，最后答案累加栈的大小-1即可（显然题意说明奶牛是看不见自己的发型的，要把自己减去）</p>
<hr>
<p>以上操作的推导过程：</p>
<ul>
<li>我们对于当前读进去的奶牛的高度，计算栈中还有多少比它矮的，把它们pop出来（维护单调性）</li>
<li>这个过程其实就是在计算当前的奶牛能被多少奶牛看见</li>
<li>接下来累计答案</li>
<li>最后将当前奶牛的高度push进去</li>
</ul>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Words -- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">80000</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">        <span class="keyword">int</span> tail;</span><br><span class="line">        </span><br><span class="line">        Stack() &#123;</span><br><span class="line">            <span class="built_in">memset</span>(seq, <span class="number">0</span>, <span class="keyword">sizeof</span>(seq));</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            tail--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> seq[tail];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tail == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!isEmpty() &amp;&amp; Top() &lt;= x) Pop();</span><br><span class="line">            seq[++tail] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">Size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> __tail_location() &#123;</span><br><span class="line">            <span class="keyword">return</span> tail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; stk;</span><br><span class="line">	<span class="comment">// 手写栈无所畏惧</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = getint();</span><br><span class="line">        stk.Push(x);</span><br><span class="line">        ans += stk.Size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>USACO</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1981《表达式求值》</title>
    <url>/2018-10-06/Luogu-P1981/</url>
    <content><![CDATA[<blockquote>
<p>新技能：手写计算器</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行，为需要你计算的表达式，表达式中只包含数字、加法运算符“$+$”和乘法运算符“ $\times$ ”，且没有括号，所有参与运算的数字均为 $0$ 到 $2^{31}$的整数。</p>
<p>输入数据保证这一行只有 $0−9$、$+$、 $\times$ 这 $12$ 种字符。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示这个表达式的值。</p>
<p>注意：当答案长度多于 4 位时，请只输出最后 4 位，前导 0 不输出。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><p>Case #1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1+1*3+4</span><br></pre></td></tr></table></figure></p>
<p>Case #2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1+1234567890*1</span><br></pre></td></tr></table></figure></p>
<p>Case #3:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1+1000000003*1</span><br></pre></td></tr></table></figure></p>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><p>Case #1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure></p>
<p>Case #2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7891</span><br></pre></td></tr></table></figure></p>
<p>Case #3:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>对于 30\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100；</p>
<p>对于 80\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤1000；</p>
<p>对于100\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100000。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们开两个单调栈，一个栈<code>num</code>来存储数字，一个栈<code>operators</code>来存储符号</p>
<p>其中<code>operators</code>的操作逻辑是这样的：</p>
<ul>
<li>首先把<code>~</code>push进去，作为一个占位符</li>
<li>我们对运算符标一个优先级，规定<code>~ &lt; + &lt; *</code>且相同运算符优先级低（满足从左到右的运算顺序），写一个判断函数</li>
<li>当push进去的运算符优先级比栈顶的低时，解决所有优先级低的运算符（维护单调性质）再push进去</li>
<li>当push进去的运算符优先级比栈顶的高时，不用管，直接push进去（满足单调性质）</li>
</ul>
<p>处理完输入之后，我们再对数字栈里剩下的数字进行处理</p>
<p>最后输出即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>这里面所有的注释都是我在DEBUG的时候手推的样例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Words -- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; operators;</span><br><span class="line">    <span class="comment">// 1: + -</span></span><br><span class="line">    <span class="comment">// 2: * /</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Priority</span><span class="params">(<span class="keyword">char</span> op1, <span class="keyword">char</span> op2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// false -&gt; op1 is lower</span></span><br><span class="line">        <span class="comment">// true -&gt; op1 is higher</span></span><br><span class="line">        <span class="keyword">if</span> (op1 == op2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (op1 == <span class="string">'~'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (op1 == <span class="string">'+'</span> &amp;&amp; op2 == <span class="string">'*'</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (op1 == <span class="string">'*'</span> &amp;&amp; op2 == <span class="string">'+'</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    <span class="comment">// 1+1*3+4</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> op = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; ans; <span class="comment">// 1</span></span><br><span class="line">    num.push(ans % MOD); <span class="comment">// &lt; 1</span></span><br><span class="line">    operators.push(<span class="string">'~'</span>); <span class="comment">// &lt; ~</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; now) &#123; <span class="comment">// +1 // *3 // +4</span></span><br><span class="line">        <span class="keyword">char</span> op1 = operators.top(); <span class="comment">// ~ // + // *</span></span><br><span class="line">        <span class="keyword">while</span> (Priority(op1, op)) &#123; <span class="comment">// false // false // true // false</span></span><br><span class="line">            <span class="keyword">int</span> opNum = num.top(); <span class="comment">// // // 3</span></span><br><span class="line">            num.pop(); <span class="comment">// // //  &lt; 1 1</span></span><br><span class="line">            <span class="keyword">int</span> opNum2 = num.top(); <span class="comment">// // // 1</span></span><br><span class="line">            num.pop(); <span class="comment">// // // &lt; 1 </span></span><br><span class="line">            <span class="keyword">if</span> (op1 == <span class="string">'+'</span>) num.push((opNum + opNum2) % MOD); <span class="comment">// // // false</span></span><br><span class="line">            <span class="keyword">if</span> (op1 == <span class="string">'*'</span>) num.push(opNum * opNum2 % MOD); <span class="comment">// // // &lt; 1 3</span></span><br><span class="line">            operators.pop(); <span class="comment">// &lt; +</span></span><br><span class="line">            op1 = operators.top(); <span class="comment">// +</span></span><br><span class="line">        &#125;</span><br><span class="line">        operators.push(op); <span class="comment">// &lt; + // &lt; + * // &lt; + +</span></span><br><span class="line">        num.push(now); <span class="comment">// &lt; 1 1 // &lt; 1 1 3 // &lt; 1 3 4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num.size() &gt; <span class="number">1</span>) &#123; <span class="comment">// true // true // false</span></span><br><span class="line">    	<span class="keyword">int</span> op = num.top(); <span class="comment">// 4 // 7</span></span><br><span class="line">    	num.pop(); <span class="comment">// &lt; 1 3 // &lt; 1</span></span><br><span class="line">    	<span class="keyword">int</span> op2 = num.top(); <span class="comment">// 3 // 1</span></span><br><span class="line">    	num.pop(); <span class="comment">// &lt; 1 // &lt;</span></span><br><span class="line">    	<span class="keyword">char</span> ope = operators.top();</span><br><span class="line">    	operators.pop();</span><br><span class="line">        <span class="keyword">if</span> (ope == <span class="string">'+'</span>) num.push((op + op2) % MOD); <span class="comment">// &lt; 1 7 // &lt; 8</span></span><br><span class="line">        <span class="keyword">if</span> (ope == <span class="string">'*'</span>) num.push(op * op2 % MOD);</span><br><span class="line">    &#125;</span><br><span class="line">    FastIO::putint(num.top() % MOD, <span class="string">'\n'</span>); <span class="comment">// 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>栈</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1750《出栈序列》</title>
    <url>/2018-10-06/Luogu-P1750/</url>
    <content><![CDATA[<blockquote>
<p>这题和栈有多少关系</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个由n个元素构成的序列，你需要将其中的元素按顺序压入一个大小为c的栈并弹出。元素按它们的出栈顺序进行排列，会得到一个新的序列。我们知道，这样的序列会有很多种，请输出所有新序列中第一个元素最小的序列（若第一个元素最小的序列有多个，则令第二个尽可能小；若仍有多个，则令第三个最小，以此类推）。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个数n,c</p>
<p>第二行n个数，为序列中n个元素的值</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出n个数，为满足要求的序列。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">5 2 3 8 7 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3 5 4 7 8</span><br></pre></td></tr></table></figure>
<h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>对于40%的数据，n&lt;=12</p>
<p>对于100%的数据，c&lt;=n&lt;=10000，元素大小均在2*10^9以内。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Words -- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">            <span class="keyword">int</span> __builtin_sequence[MAXN];</span><br><span class="line">            <span class="keyword">int</span> tail;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">            Stack() &#123;</span><br><span class="line">                <span class="built_in">memset</span>(__builtin_sequence, <span class="number">0</span>, <span class="keyword">sizeof</span>(__builtin_sequence));</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">                __builtin_sequence[++tail] = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                --tail;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> __builtin_sequence[tail];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> tail == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> tail;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; stk; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, c;</span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    n = getint();</span><br><span class="line">    c = getint();</span><br><span class="line">    <span class="keyword">int</span> used = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> unusedNum = <span class="number">1</span>;</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        seq[i] = getint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stk.size() + used &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> inQueue = stk.size();</span><br><span class="line">        <span class="keyword">int</span> origUnusedNum = unusedNum;</span><br><span class="line">        <span class="keyword">int</span> minN = <span class="number">2147482333</span>;</span><br><span class="line">        <span class="keyword">int</span> len = c - inQueue;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = origUnusedNum; i &lt;= n &amp;&amp; i &lt; origUnusedNum + len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[i] &lt; minN) &#123;</span><br><span class="line">                unusedNum = i;</span><br><span class="line">                minN = seq[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stk.empty() || minN &lt; stk.top()) &#123;</span><br><span class="line">            For (i, origUnusedNum, unusedNum) &#123;</span><br><span class="line">                stk.push(seq[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            ++unusedNum;</span><br><span class="line">        &#125; <span class="keyword">else</span> unusedNum = origUnusedNum;</span><br><span class="line">        putint(stk.top(), <span class="string">' '</span>);</span><br><span class="line">        ++used;</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">        putint(stk.top(), <span class="string">' '</span>);</span><br><span class="line">        stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 Autumn 清北学堂普及刷题班 Day5 题解</title>
    <url>/2018-10-05/2018AutumnQBXTDay5/</url>
    <content><![CDATA[<blockquote>
<p>暴力分！暴力分！</p>
</blockquote>
<a id="more"></a>
<h1 id="Problem-A-climb"><a href="#Problem-A-climb" class="headerlink" title="Problem A. climb"></a>Problem A. climb</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Bob 在一旁看 Alice 爬台阶玩， Alice 突发奇想让 Bob 闭上眼记录他爬了多少台阶，规则是这样的： Alice每次会想好爬多少级台阶，每爬一级都会数数，爬完之后走回到最底层，注意走回去的那些台阶是不算级数的。 Bob 闭上眼通过 Alice 的报数来统计 Alice 总共爬了几次，每次爬了多少级。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数 N(1 ≤ 100000)，表示 Alice 的报数次数。 <br><br>第二行包含 N 个正整数 Ai(1 ≤ Ai ≤ 1000)，表示 Alice 的报数序列。 <br></p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行包含一个整数，表示 Alice 爬的次数 T。第二行包含 T 个整数，第 i 个整数表示 Alice 每 i 次爬的台阶数。 <br></p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 3 1 2 3 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure>
<h2 id="子任务"><a href="#子任务" class="headerlink" title="子任务"></a>子任务</h2><p>对于 40% 的数据， N ≤ 20。 <br><br>对于 70% 的数据， N ≤ 1000。 <br><br>对于 100% 的数据， N ≤ 100000。 <br></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p><del>A不掉的退役吧</del></p>
<p>显然这题就是让你求有多少个1和每两个1之间的距离 <br><br>当然这题题面有点歧义 求每个1之前的数也可以（数据水</p>
<p>就没了</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[i] == <span class="number">1</span>) ++T, cnt.push_back(seq[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt.push_back(seq[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"climb.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"climb.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    </span><br><span class="line">    n = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, n) seq[i] = getint();</span><br><span class="line">    Work();</span><br><span class="line">    putint(T, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">int</span> siz = cnt.size();</span><br><span class="line">    Forw (i, <span class="number">1</span>, siz - <span class="number">1</span>) putint(cnt[i], <span class="string">' '</span>);</span><br><span class="line">    putint(cnt[siz - <span class="number">1</span>], <span class="string">'\n'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Problem-B-remove"><a href="#Problem-B-remove" class="headerlink" title="Problem B. remove"></a>Problem B. remove</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个字符串 s，字符串中只会包含⼩写字母 a − z。现在需要通过重复下面这个算法<br>符串中删去 k 个字符：<br>• 如果当前字符串中还存在字符 a，就删去字符串中最前面的一个 a 字符，结束算法<br>• 如果当前字符串中还存在字符 b，就删去字符串中最前面的一个 b 字符，结束算法<br>• …<br>• 如果当前字符串中还存在字符 z，就删去字符串中最前面的一个 z 字符，结束算法<br>求删完 k 个字符后的字符串。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数 n; k(1 ≤ k ≤ n ≤ 100000)， n 表示字符串长度， k 表示删去的字符个数。 <br><br>第二行包含一个字符串 s。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，包含删去k个字符的字符串。</p>
<h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h2><p>Case #1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 3</span><br><span class="line">cccaabababaccbc</span><br></pre></td></tr></table></figure></p>
<p>Case #2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 9</span><br><span class="line">cccaabababaccbc</span><br></pre></td></tr></table></figure></p>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h2><p>Case #1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cccbbabaccbc</span><br></pre></td></tr></table></figure></p>
<p>Case #2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cccccc</span><br></pre></td></tr></table></figure></p>
<h2 id="子任务-1"><a href="#子任务-1" class="headerlink" title="子任务"></a>子任务</h2><p>对于 40% 的数据， 1 ≤ k ≤ n ≤ 100。 <br><br>对于 70% 的数据， 1 ≤ k ≤ n ≤ 1000。 <br><br>对于 100% 的数据， 1 ≤ k ≤ n ≤ 100000。 <br></p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>这道题我在考试结束之后20min敲出了正解。。。。。。</p>
<p>我们开一个桶，把所有的字母记录下来 <br><br>接着把桶扫一遍：</p>
<ul>
<li>如果当前的k大于当前的字母数<code>alphabet[i]</code>，就让<code>k -= alphabet[i]</code>，然后把<code>alphabet[i]</code>置为0</li>
<li>否则让<code>alphabet[i] -= k</code>，然后把<code>k</code>置为0，最后<code>break</code>掉即可</li>
</ul>
<p>此时，<code>alphabet</code>的意义已经从字母数量变成了<strong>经过删除后的</strong>还可输出字母数量</p>
<p>之后，我们开一个bool数组<code>chk[i]</code>表示<code>str[i]</code>是否还能被输出，并<strong>倒序</strong>（注意是倒序，因为题目要求从前面开始删，显然我们要保留后面几位）枚举 $i\ (0 &lt; i &lt; n)$</p>
<ul>
<li>当<code>alphabet[str[i] - &#39;a&#39;] &gt; 0</code>时，将<code>chk[i]</code>设为<code>true</code>并<code>--alphabet[str[i] - &#39;a&#39;]</code></li>
</ul>
<p>最后，从头扫一遍<code>chk</code>，如果<code>chk[i] == true</code>就输出<code>str[i]</code></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">bool</span> chk[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">Work</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此为暴力做法</span></span><br><span class="line">        For (i, <span class="number">1</span>, k) &#123;</span><br><span class="line">            Forw (j, <span class="number">0</span>, <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">int</span> findnow = str.find(j + <span class="string">'a'</span>);</span><br><span class="line">                </span><br><span class="line"><span class="comment">//                printf("%c\n", j + 'a');</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (findnow != <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">                    str[findnow] = <span class="string">'-'</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nowWork</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此为正解</span></span><br><span class="line">        <span class="keyword">int</span> alphabet[<span class="number">26</span> + <span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">bool</span> printal[<span class="number">26</span>] = &#123; <span class="literal">true</span> &#125;;</span><br><span class="line">        Forw (i, <span class="number">0</span>, n) alphabet[str[i] - <span class="string">'a'</span>]++;</span><br><span class="line">        Forw (i, <span class="number">0</span>, <span class="number">26</span>) &#123;</span><br><span class="line">            <span class="comment">//cerr &lt;&lt; (char)(i + 'a')&lt;&lt; '=';</span></span><br><span class="line">            <span class="comment">//cerr &lt;&lt; alphabet[i] &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (alphabet[i] &lt; k) &#123;</span><br><span class="line">                k -= alphabet[i];</span><br><span class="line">                alphabet[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alphabet[i] -= k;</span><br><span class="line">                k = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Bak (i, n<span class="number">-1</span>, <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (alphabet[str[i] - <span class="string">'a'</span>] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            chk[i] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            --alphabet[str[i] - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Forw (i, <span class="number">0</span>, n) <span class="keyword">if</span> (chk[i]) <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此为暴力做法的输出</span></span><br><span class="line">        Forw (i, <span class="number">0</span>, n) <span class="keyword">if</span> (str[i] != <span class="string">'-'</span>) <span class="built_in">putchar</span>(str[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"remove.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"remove.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">//    int t = clock();</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="comment">//Print(Work(s));</span></span><br><span class="line">    nowWork(s);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    cerr &lt;&lt; clock() - t &lt;&lt; endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Problem-C-cut"><a href="#Problem-C-cut" class="headerlink" title="Problem C. cut"></a>Problem C. cut</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个字符串 s，其中每个字符都是 0 9 的数字。现在需要把字符串 s 分割开，这样每个<br>部分就可以看做一个数，求这些数中最多有多少个数是 3 的倍数。 <br><br>如对于字符串 3121，可以分割为 3 | 12 | 1，这样会有两个数是 3 的倍数，如果分割为 31 | 2 | 1，这样就没有数是 3 的倍数了。0 是 3 的倍数，如果 1200045 被拆分为 120 | 0045，则认为分割出来的两个数是 120 和 45，即忽略前导零。</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行包含一个字符串s，$|s|\le100000$</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行包含一个整数，表示最多有多少个数是3的倍数。</p>
<h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h2><p>Case #1:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3121</span><br></pre></td></tr></table></figure></p>
<p>Case #2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">201920181</span><br></pre></td></tr></table></figure></p>
<h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h2><p>Case #1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>Case #2:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p>
<h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p>第一个样例中可以拆分为 3 | 12 | 1。 <br><br>第二个样例中可以拆分为 201 | 9 | 2 | 0 | 18 | 1。 <br></p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>首先我们对读进来的序列整体mod 3</p>
<p>接着对这个序列扫一遍</p>
<ul>
<li><p>如果当前读到的数是0，根据贪心策略，直接在后面划上一道</p>
</li>
<li><p>否则如果当前读的数的下标大于0，就看前面的数<br>如果这个数与上个数的和能被3整除，而且下个数没有被选过，就在后面划上一道</p>
</li>
<li><p>否则如果当前读的数的下标大于1，继续看前面的数<br>如果这个数与前面两个数的和能被3整除，而且两个数都没有选过，就在后面划上一道</p>
</li>
<li><p>否则什么都不干</p>
</li>
</ul>
<p>最后输出即可</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> seq[MAXN]; </span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        For (i, <span class="number">1</span>, len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++ret;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (seq[i] + seq[i - <span class="number">1</span>]) % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; !vis[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                ++ret;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; (seq[i] + seq[i - <span class="number">1</span>] + seq[i - <span class="number">2</span>]) % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; !vis[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">2</span>]) &#123;</span><br><span class="line">                ++ret;</span><br><span class="line">                vis[i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    len = s.length();</span><br><span class="line">    For (i, <span class="number">1</span>, len) seq[i] = (s[i<span class="number">-1</span>] - <span class="string">'0'</span>) % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = Work();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Problem-D-sum"><a href="#Problem-D-sum" class="headerlink" title="Problem D. sum"></a>Problem D. sum</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>某些数有奇怪的性质：它十进制下的各位数的平方和的 T 倍等于它本身。求在 [A, B] 范围内的数有多少满足这个性质</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 T, A, B(1 ≤ T; A; B ≤ 10^18; A ≤ B)。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示满足条件的数量。</p>
<h2 id="输入样例-3"><a href="#输入样例-3" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">51 5000 10000</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-3"><a href="#输出样例-3" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h2 id="子任务-2"><a href="#子任务-2" class="headerlink" title="子任务"></a>子任务</h2><p>对于 40% 的数据， 1 ≤ T; A; B ≤ 100000; A ≤ B。<br>对于 100% 的数据， 1 ≤ T; A; B ≤ 10^18; A ≤ B。</p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>此为标程</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">calc</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        ans += (x % <span class="number">10</span>) * (x % <span class="number">10</span>);</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> k, a, b, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;k, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1600</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= k * i &amp;&amp; i &lt;= b / k)</span><br><span class="line">            <span class="keyword">if</span> (calc(k * i) == i) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, k * i);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>我的代码默认模板</title>
    <url>/2018-10-04/MyTemplate/</url>
    <content><![CDATA[<blockquote>
<p><code>运行效率++;</code> &nbsp; <code>可读性--;</code></p>
</blockquote>
<a id="more"></a>
<p>下面是我在写程序时常用的快读/写模板（虽然它不仅仅只是快读/写）<br><br>不仅提高了运行效率，还让编写时的体验更加舒适。 <br><br>假如布局安排合理的话，可读性不但不会减少，反而会进一步上升。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Words -- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>删掉了大量无用的东西</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_IN(__fname) freopen(__fname, <span class="meta-string">"r"</span>, stdin)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_OUT(__fname) freopen(__fname, <span class="meta-string">"w"</span>, stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> basketball(a,t,s,i) for (int a = t; a &gt;= s; a -= i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> countdown(s) while (s --&gt; 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPROVE_IO() std::ios::sync_with_stdio(false)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function">lli <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1886《滑动窗口》</title>
    <url>/2018-10-04/Luogu-P1886/</url>
    <content><![CDATA[<blockquote>
<p>单调队列的应用</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>现在有一堆数字共N个数字（N&lt;=10^6），以及一个大小为k的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。</p>
<p>例如：</p>
<p>The array is [1 3 -1 -3 5 3 6 7], and k = 3.</p>
<p><img src="https://cdn.luogu.org/upload/pic/688.png" alt="img1"></p>
<p><center><small>图片来自洛谷</small></center></p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一共有两行，第一行为n,k。</p>
<p>第二行为n个数($n&lt;2^{31}-1$).</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共两行，第一行为每次窗口滑动的最小值</p>
<p>第二行为每次窗口滑动的最大值</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>
<h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>50%的数据，n&lt;=10^5</p>
<p>100%的数据，n&lt;=10^6</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>最经典的单调队列题目</p>
<p>暴力妥妥的T，不用多说（不过居然有70pts）</p>
<p>我们先研究最大值怎么求 <br><br>每次往单调队列里面扔一个数，显然不管队列里发生了什么改变，单调性并不变。<br><br>我们开一个<code>id</code>数组，记录当前的数被push进去的时间 <br><br>接着扫描<code>id</code>数组，将所有过期的数全都pop出去 <br><br>最后当循环了至少k次时，输出答案。</p>
<p>最小值同理，把单调队列改一下即可。</p>
<p>（《单调队列学习笔记》将不久后更新）</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> q[MAXN];</span><br><span class="line">        <span class="keyword">int</span> head, tail;</span><br><span class="line">        Queue() &#123;</span><br><span class="line">            <span class="built_in">memset</span>(q, <span class="number">0</span>, <span class="keyword">sizeof</span>(q));</span><br><span class="line">            head = <span class="number">1</span>;</span><br><span class="line">            tail = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 维护单调递增的队列</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt;= q[tail] &amp;&amp; head &lt;= tail) --tail;</span><br><span class="line">            q[++tail] = s;	</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 维护单调递减的序列</span></span><br><span class="line">            <span class="keyword">while</span> (s &lt;= q[tail] &amp;&amp; head &lt;= tail) --tail;</span><br><span class="line">            q[++tail] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ++head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> q[head];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tail - head + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> tail - head + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Queue();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> __tail_location() &#123;</span><br><span class="line">            <span class="keyword">return</span> tail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> __head_location() &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; q1, q2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">int</span> seq[MAXN];</span><br><span class="line">    <span class="keyword">int</span> id[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            q1.push(seq[i]);</span><br><span class="line">            id[q1.__tail_location()] = i; </span><br><span class="line">            <span class="keyword">while</span> (id[q1.__head_location()] &lt;= i - k) q1.pop(); <span class="comment">// 清理过期的数</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) FastIO::putint(q1.front(), <span class="string">' '</span>); <span class="comment">// 输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            q2.push_back(seq[i]);</span><br><span class="line">            id[q2.__tail_location()] = i;</span><br><span class="line">            <span class="keyword">while</span> (id[q2.__head_location()] &lt;= i - k) q2.pop();</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) FastIO::putint(q2.front(), <span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    n = getint();</span><br><span class="line">    k = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        seq[i] = getint();</span><br><span class="line">    &#125;</span><br><span class="line">    GetMin();</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    GetMax();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>单调数据结构</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 Autumn 清北学堂普及刷题班 Day4 题解</title>
    <url>/2018-10-04/2018AutumnQBXTDay4/</url>
    <content><![CDATA[<blockquote>
<p>没人AC的题目和没人得分的题目</p>
</blockquote>
<a id="more"></a>
<h1 id="T1-牛奶"><a href="#T1-牛奶" class="headerlink" title="T1. 牛奶"></a>T1. 牛奶</h1><p><del>没AC的退役吧</del></p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>为了增加营养，你决定每天喝牛奶，牛奶的营养含量十分固定，下表示牛奶上写的营养成分表。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>项目</th>
<th>每100mL</th>
</tr>
</thead>
<tbody>
<tr>
<td>能量</td>
<td>284kJ</td>
</tr>
<tr>
<td>蛋白质</td>
<td>3.2g</td>
</tr>
<tr>
<td>脂肪</td>
<td>4.0g</td>
</tr>
<tr>
<td>碳水化合物</td>
<td>4.8g</td>
</tr>
<tr>
<td>钠</td>
<td>62mg</td>
</tr>
<tr>
<td>钙</td>
<td>100mg</td>
</tr>
</tbody>
</table>
</div>
<p>这天你喝了N mL的牛奶，那么你摄入的营养成分分别为多少呢？</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个整数N</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>6个用空格隔开的数字，分别表示6项营养成分的数值，单位和表上单位相同，四舍五入保留一位小数。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">284.0 3.2 4.0 4.8 62.0 100.0</span><br></pre></td></tr></table></figure>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于30%的数据，N是100的倍数。</p>
<p>对于50%的数据，N&lt;=1000。</p>
<p>对于100%的数据，1&lt;=N&lt;=10000。</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>没什么好说的，<strong>浮点数运算</strong>而已</p>
<p>这题唯一<del>也是最毒瘤的</del>的坑点就是<big>浮点数运算</big></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><del>毒瘤代码</del><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> energy100 = (<span class="keyword">double</span>) <span class="number">284</span>; <span class="comment">// kJ</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> protein100 = (<span class="keyword">double</span>) <span class="number">3.2</span>; <span class="comment">// g</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> fats100 = (<span class="keyword">double</span>) <span class="number">4.0</span>; <span class="comment">// g</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> carbohydrate100 = (<span class="keyword">double</span>) <span class="number">4.8</span>; <span class="comment">// g</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> sodium100 = (<span class="keyword">double</span>) <span class="number">62</span>; <span class="comment">// mg</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> calcium100 = (<span class="keyword">double</span>) <span class="number">100</span>; <span class="comment">// mg</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"milk.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"milk.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">	<span class="keyword">double</span> n = <span class="number">1.0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;n);</span><br><span class="line">	n *= <span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">double</span> anse = (<span class="keyword">double</span>) n * (<span class="keyword">double</span>) energy100 * <span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">double</span> ansp = (<span class="keyword">double</span>) n * (<span class="keyword">double</span>) protein100 * <span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">double</span> ansf = (<span class="keyword">double</span>) n * (<span class="keyword">double</span>) fats100 * <span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">double</span> ansc = (<span class="keyword">double</span>) n * (<span class="keyword">double</span>) carbohydrate100 * <span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">double</span> anss = (<span class="keyword">double</span>) n * (<span class="keyword">double</span>) sodium100 * <span class="number">1.0</span>;</span><br><span class="line">	<span class="keyword">double</span> ansl = (<span class="keyword">double</span>) n * (<span class="keyword">double</span>) calcium100 * <span class="number">1.0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%0.1lf %0.1lf %0.1lf %0.1lf %0.1lf %0.1lf\n"</span>, </span><br><span class="line">	    anse / <span class="number">100.0</span>, </span><br><span class="line">		ansp / <span class="number">100.0</span>, </span><br><span class="line">		ansf / <span class="number">100.0</span>, </span><br><span class="line">		ansc / <span class="number">100.0</span>, </span><br><span class="line">		anss / <span class="number">100.0</span>, </span><br><span class="line">		ansl / <span class="number">100.0</span></span><br><span class="line">	);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="T2-上课"><a href="#T2-上课" class="headerlink" title="T2. 上课"></a>T2. 上课</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>这天，学校正上着课，学校有n个教室，每个教室坐着$a_i$个人正在上课。 <br><br>突然来了m个人也要上课，每个人都可以选择n个教室中的任意一个教室上课，由于学校需要提供教室的座位，学校想知道这m个人来之后，最多人的那个教室人数的最小值和最大值分别为多少。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数n和m，用空格隔开。 <br><br>第二行n个数字用空格隔开，表示$a_i$。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>两个用空格隔开的数字，分别表示最小值和最大值</p>
<h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 6</span><br><span class="line">1 1 1 1</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 7</span><br></pre></td></tr></table></figure>
<h2 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于30%的数据，n=1。 <br><br>对于50%的数据，m&lt;=10000。 <br><br>对于100%的数据，1&lt;=n,ai&lt;=100,1&lt;=m&lt;=10^9。 <br></p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p><del>我们随便想一想就能想出贪心策略</del></p>
<p>首先最大值是人最多的班级的人数+m 这没什么好说的</p>
<p>最小值也很好求 <br><br>既然是最小值，那么就要保证m的平均分配 <br><br>那么我们排个序，从最小的数字依次$O(n)$扫 <br><br>对于每个数字$a_i$，计算它和最大值的差，记为$d$ <br><br>当$d\ge m$时，直接输出$d$（因为将$m$全部安排到这个班里去也不能让这个班的人数比最大值大，所以答案即是最大值）<br><br>否则让$m$减去$d$，将$a_i$赋值为最大值（把这个班的人数变成最大值） <br></p>
<p>扫完一遍之后，如果$m$变成0了，就直接输出最大值（m个人被正好安排完了）<br><br>否则就再把剩下的人一个一个地分别安排到每个班中（可能有一个班分配多人的情况），最后取个max值即可</p>
<p>这里有个小技巧，就是我们把m整除n的结果记为place，然后把整个序列都加上place，表示每个班<strong>都</strong>还要分配place个人 <br><br>再把m模n的结果记为 lm，循环把这最后lm个人分别分配到每个班中，最后取max即可</p>
<p><del>讲起来还是挺麻烦的</del></p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">	<span class="keyword">int</span> seq[MAXN];</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">stlCmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x &gt; y; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">PrintAnswer</span><span class="params">(<span class="keyword">int</span> maxAns, <span class="keyword">int</span> minAns)</span> </span>&#123;</span><br><span class="line">		FastIO::putint(minAns, <span class="string">' '</span>);</span><br><span class="line">		FastIO::putint(maxAns, <span class="string">'\n'</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Wrong Algorithm</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"class.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"class.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">	n = getint(), m = getint();</span><br><span class="line">	<span class="keyword">int</span> maxSiz = <span class="number">-233333</span>;</span><br><span class="line">	For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		seq[i] = getint();</span><br><span class="line">		maxSiz = <span class="built_in">std</span>::max(seq[i], maxSiz);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	sort(seq + <span class="number">1</span>, seq + <span class="number">1</span> + n);</span><br><span class="line">	<span class="keyword">int</span> maxAns = m + seq[n];</span><br><span class="line">	</span><br><span class="line">	For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		<span class="keyword">int</span> differ = maxSiz - seq[i];</span><br><span class="line">		<span class="keyword">if</span> (differ &gt;= m) &#123;</span><br><span class="line">			PrintAnswer(maxAns, maxSiz);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		seq[i] = maxSiz;</span><br><span class="line">		m -= differ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">		PrintAnswer(maxAns, maxSiz);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*/</span></span><br><span class="line"><span class="comment">	sort(seq + 1, seq + 1 + n, stlCmp);</span></span><br><span class="line"><span class="comment">	long long int maxAns = m + seq[n];</span></span><br><span class="line"><span class="comment">	long long int minAns = 0;</span></span><br><span class="line"><span class="comment">	/*/</span></span><br><span class="line">	<span class="comment">/*/</span></span><br><span class="line"><span class="comment">	int j = n;</span></span><br><span class="line"><span class="comment">	For (i, 1, m) &#123;</span></span><br><span class="line"><span class="comment">		++seq[j--];</span></span><br><span class="line"><span class="comment">		if (j == 0) j = n;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	/*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> place = m / n;</span><br><span class="line">	For (i, <span class="number">1</span>, n) seq[i] += place;</span><br><span class="line">	<span class="keyword">int</span> mod = m % n;</span><br><span class="line">	<span class="keyword">int</span> i = n;</span><br><span class="line">	<span class="keyword">while</span> (mod --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">		++seq[i--];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> minAns = *(max_element(seq + <span class="number">1</span>, seq + <span class="number">1</span> + n));</span><br><span class="line">	PrintAnswer(maxAns, minAns);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-维生素"><a href="#T3-维生素" class="headerlink" title="T3. 维生素"></a>T3. 维生素</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>商店里卖着n种果汁，每种果汁都有它的价格ci，每种果汁有一些维生素，维生素有三种类型，维生素A，维生素B，维生素C，每种果汁可以含有其中一种或多种维生素。 <br><br>你需要3种维生素来保持身体健康，那么你最少需要购买多少价格的果汁才能保证购买的这些果汁包含3种维生素呢？</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数n。 <br><br>接下来n行，每行包含一个整数ci和一个字符串si，si表示其中蕴含的维生素种类，只包含字母ABC且每个字母最多出现一次。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出最小能满足条件的价格，如果不能满足，输出-1。</p>
<h2 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5 C</span><br><span class="line">6 B</span><br><span class="line">16 BAC</span><br><span class="line">4 A</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>
<h2 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于30%的数据，1&lt;=n&lt;=20。 <br><br>对于另外20%的数据，所有果汁只包含单种维生素。 <br><br>对于100%的数据，1&lt;=n&lt;=1000, 1&lt;=ci&lt;=100000。</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>DP </p>
<p>我们设$f_{i,j}$表示前i种果汁状态为j时的价格，其中</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>$j$的值</th>
<th>代表意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>含有维生素A</td>
</tr>
<tr>
<td>2</td>
<td>含有维生素B</td>
</tr>
<tr>
<td>3</td>
<td>含有维生素C</td>
</tr>
<tr>
<td>4</td>
<td>含有维生素AB</td>
</tr>
<tr>
<td>5</td>
<td>含有维生素BC</td>
</tr>
<tr>
<td>6</td>
<td>含有维生素AC</td>
</tr>
<tr>
<td>7</td>
<td>含有维生素ABC</td>
</tr>
</tbody>
</table>
</div>
<p>转移方程：<br></p>
<p><center>
`a[i|w] = min(a[i|w], a[i] + c[i])` <br>
</center></p>
<p><center>
`w = w | (1 左移 (str[i] - 'A'))`，其中`1 ≤ i ≤ str.length()`
</center></p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">char</span> ch = getchar();</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">			ch = getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">			s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">			ch = getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s * x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			x = -x;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">		__basic_putint(x);</span><br><span class="line">		<span class="built_in">putchar</span>(external);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">	freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> t[<span class="number">8</span> + <span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8</span>; ++i) t[i] = <span class="number">60</span>;</span><br><span class="line">	t[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> len = s.length();</span><br><span class="line">		<span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len; ++j) v |= (<span class="number">1</span> &lt;&lt; s[j<span class="number">-1</span>] - <span class="string">'A'</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) t[j | v] = <span class="built_in">std</span>::min(t[j | v], t[j] + x);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">if</span> (t[<span class="number">7</span>] &gt; <span class="number">1e8</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; t[<span class="number">7</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-队列"><a href="#T4-队列" class="headerlink" title="T4. 队列"></a>T4. 队列</h1><p><del>挖坑待填</del></p>
]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>浮点数运算</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3110 《[USACO14DEC]驮运Piggy Back》</title>
    <url>/2018-10-04/Luogu-P3110/</url>
    <content><![CDATA[<blockquote>
<p>披着蓝题的皮跑3遍SPFA的绿题</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P3110" target="_blank" rel="noopener">题目链接</a></p>
<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>由于翻译缺失，暂不提供翻译，这里仅提供英文题面。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Bessie and her sister Elsie graze in different fields during the day, and in the evening they both want to walk back to the barn to rest. Being clever bovines, they come up with a plan to minimize the total amount of energy they both spend while walking.</p>
<p>Bessie spends B units of energy when walking from a field to an adjacent field, and Elsie spends E units of energy when she walks to an adjacent field. However, if Bessie and Elsie are together in the same field, Bessie can carry Elsie on her shoulders and both can move to an adjacent field while spending only P units of energy (where P might be considerably less than B+E, the amount Bessie and Elsie would have spent individually walking to the adjacent field). If P is very small, the most energy-efficient solution may involve Bessie and Elsie traveling to a common meeting field, then traveling together piggyback for the rest of the journey to the barn. Of course, if P is large, it may still make the most sense for Bessie and Elsie to travel</p>
<p>separately. On a side note, Bessie and Elsie are both unhappy with the term “piggyback”, as they don’t see why the pigs on the farm should deserve all the credit for this remarkable form of</p>
<p>transportation.</p>
<p>Given B, E, and P, as well as the layout of the farm, please compute the minimum amount of energy required for Bessie and Elsie to reach the barn.</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><p>INPUT: (file piggyback.in)</p>
<p>The first line of input contains the positive integers B, E, P, N, and M. All of these are at most 40,000. B, E, and P are described above. N is the number of fields in the farm (numbered 1..N, where N &gt;= 3), and M is the number of connections between fields. Bessie and Elsie start in fields 1 and 2, respectively. The barn resides in field N.</p>
<p>The next M lines in the input each describe a connection between a pair of different fields, specified by the integer indices of the two fields. Connections are bi-directional. It is always possible to travel from field 1 to field N, and field 2 to field N, along a series of such connections.</p>
<p>OUTPUT: (file piggyback.out)</p>
<p>A single integer specifying the minimum amount of energy Bessie and</p>
<p>Elsie collectively need to spend to reach the barn. In the example</p>
<p>shown here, Bessie travels from 1 to 4 and Elsie travels from 2 to 3</p>
<p>to 4. Then, they travel together from 4 to 7 to 8.</p>
<h1 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 4 5 8 8 </span><br><span class="line">1 4 </span><br><span class="line">2 3 </span><br><span class="line">3 4 </span><br><span class="line">4 7 </span><br><span class="line">2 5 </span><br><span class="line">5 6 </span><br><span class="line">6 8 </span><br><span class="line">7 8</span><br></pre></td></tr></table></figure>
<h1 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p><del>为什么这是蓝题&nbsp;</del><del>这应该是绿题啊</del></p>
<p>首先肯定是跑最短路</p>
<p>两只牛有这样两种选择：</p>
<ul>
<li>各自走回家</li>
<li>走到任意一点之后 Bessie 背着 Elsie 回家</li>
</ul>
<p>那么我们就跑3遍SPFA即可</p>
<ol>
<li>以 Bessie 为起点（即1点）</li>
<li>以 Elsie 为起点（即2点）</li>
<li>以家为起点（即n点）</li>
</ol>
<p>这里有个小技巧，不需要写3遍不同的SPFA，只需要把3个dis数组当做参数传进去即可</p>
<p>最后暴力枚举图中的所有点$i$</p>
<p>如果设$(u,v)$为$u\rightarrow v$的最短路长度的话，</p>
<p>答案就是最小的$ (1,i)+(2,i)+(n,i)$</p>
<p>注意判断点不连通（距离为INF）的情况</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">4000000</span> + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">4000000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> b, e, p, n, m;</span><br><span class="line">    <span class="keyword">int</span> head[MAXN], disB[MAXN], disE[MAXN], disN[MAXN];</span><br><span class="line">    <span class="keyword">bool</span> inQueue[MAXN];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> prev, next, weight;</span><br><span class="line">    &#125; edge[MAXM];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">        edge[++cnt].prev = prev;</span><br><span class="line">        edge[cnt].next = head[next];</span><br><span class="line">        head[next] = cnt;</span><br><span class="line">        edge[cnt].weight = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> dis[], <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//memset(dis, 0, sizeof(dis));</span></span><br><span class="line">        For (i, <span class="number">0</span>, n) dis[i] = INF;</span><br><span class="line">        dis[s] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        q.push(s);</span><br><span class="line">        inQueue[s] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            inQueue[prev] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> e = head[prev]; e; e = edge[e].next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[edge[e].prev] &gt; dis[prev] + edge[e].weight) &#123;</span><br><span class="line">                    dis[edge[e].prev] = dis[prev] + edge[e].weight;</span><br><span class="line">                    <span class="keyword">if</span> (!inQueue[edge[e].prev]) &#123;</span><br><span class="line">                        q.push(edge[e].prev);</span><br><span class="line">                        inQueue[edge[e].prev] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    b = getint();</span><br><span class="line">    e = getint();</span><br><span class="line">    p = getint();</span><br><span class="line">    n = getint();</span><br><span class="line">    m = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev, next;</span><br><span class="line">        prev = getint();</span><br><span class="line">        next = getint();</span><br><span class="line">        addEdge(prev, next);</span><br><span class="line">        addEdge(next, prev);</span><br><span class="line">    &#125;</span><br><span class="line">    SPFA(disB, <span class="number">1</span>);</span><br><span class="line">    SPFA(disE, <span class="number">2</span>);</span><br><span class="line">    SPFA(disN, n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">2147482333</span>;</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (disN[<span class="number">1</span>] == INF </span><br><span class="line">            || disN[<span class="number">2</span>] == INF </span><br><span class="line">            || disB[i] == INF </span><br><span class="line">            || disE[i] == INF </span><br><span class="line">            || disN[i] == INF</span><br><span class="line">        ) <span class="keyword">continue</span>;</span><br><span class="line">        ans = <span class="built_in">std</span>::min(ans, b * disB[i] + e * disE[i] + p * disN[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>USACO</tag>
        <tag>最短路</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 Autumn 清北学堂普及刷题班 Day3 题解</title>
    <url>/2018-10-03/2018AutumnQBXTDay3/</url>
    <content><![CDATA[<blockquote>
<p>不同寻常的题面</p>
</blockquote>
<a id="more"></a>
<h1 id="T1-H因子"><a href="#T1-H因子" class="headerlink" title="T1. H因子"></a>T1. H因子</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>h因子是一种评价学术成就的新方法。一名科研人员的h因子是指他至少有h篇论文分别被引用了不少于h次。Alice已经发表了很多论文了，现给出一个序列a0，a1，a2，…，an，其中 $a_i$ 表示有 $a_i$ 篇文章分别被引用了i次。</p>
<p>请你求出Alice的h因子。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个正整数T（1≤T≤10），表示有多少组数据。</p>
<p>每组数据的第一行包含一个正整数n（1≤n≤200,000） 。</p>
<p>每组数据的第二行包含n个正整数a0，a1，a2，……，an（1≤ai≤1000,000,000），表示序列中的每个数。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出一行，包含一个整数，表示该组数据的h因子 。</p>
<h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>首先要把题看懂！！！</p>
<p>首先要把题看懂！！！</p>
<p>首先要把题看懂！！！</p>
<p>（我就因为题意理解错误而完美爆零）</p>
<p>我们从n开始，从大到小枚举h因子</p>
<p>一个有效的h因子为i当且仅当有大于等于i篇文章被引用了大于等于i次</p>
<p>所以我们可以用一个sum来存当前有多少篇文章被引用了大于等于当前i次</p>
<p>第一个满足sum &gt;= i的i即为最大的h因子</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> seq[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">char</span> ch = getchar();</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">			ch = getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">			s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">			ch = getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s * x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			x = -x;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">		__basic_putint(x);</span><br><span class="line">		<span class="built_in">putchar</span>(external);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">	freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">	<span class="keyword">int</span> t = getint();</span><br><span class="line">	<span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> n = getint();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			seq[i] = getint();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">			sum += seq[i];</span><br><span class="line">			<span class="keyword">if</span> (sum &gt;= i) &#123;</span><br><span class="line">				putint(i, <span class="string">'\n'</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-超回文字符串"><a href="#T2-超回文字符串" class="headerlink" title="T2. 超回文字符串"></a>T2. 超回文字符串</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>给出一个只由小写字母的字符串，要求在最少的操作数下将它转成一个超回文字符串。每次操作仅可以改变字符串中的一个字符。</p>
<p>一个字符串被称为超回文字符串，当且仅当它的<strong>所有奇数长度的子串</strong>都是回文串（回文串是指一个字符串从前往后与从后往前读是一样的）。</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个正整数T（1≤T≤100），表示有多少组数据。</p>
<p>对于每组数据，只有单独一行，包含一个仅由小写字母组成的字符串。保证字符串的长度不超过100。</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出一行，包含一个整数，表示最少的操作数。</p>
<h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">ncncn</span><br><span class="line">aaaaba</span><br><span class="line">aaaabb</span><br></pre></td></tr></table></figure>
<h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p><del>简单分析之后，</del>我们发现满足题目要求的字符串存在当且仅当这个字符串的奇数位、偶数位分别相同</p>
<p>那么直接暴力就好</p>
<p>我们枚举每一个奇数位上的字母，计算有多少个奇数位上的字母与它不同（即要修改多少次）</p>
<p>取个min即为答案</p>
<p>偶数位同理</p>
<p>将两个min相加即为答案</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">char</span> ch = getchar();</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">			ch = getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">			s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">			ch = getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s * x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			x = -x;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">		__basic_putint(x);</span><br><span class="line">		<span class="built_in">putchar</span>(external);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">	freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">		<span class="keyword">int</span> len = s.length();</span><br><span class="line">		<span class="keyword">int</span> min1 = len, min2 = len;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j += <span class="number">2</span>) &#123; </span><br><span class="line">				<span class="keyword">if</span> (s[i] != s[j]) ++now; </span><br><span class="line">			&#125; </span><br><span class="line">			min1 = <span class="built_in">std</span>::min(min1, now);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (len == <span class="number">1</span>) min2 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; j += <span class="number">2</span>) &#123; </span><br><span class="line">				<span class="keyword">if</span> (s[i] != s[j]) ++now; </span><br><span class="line">			&#125; </span><br><span class="line">			min2 = <span class="built_in">std</span>::min(min2, now);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; min1 + min2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-移动桌子"><a href="#T3-移动桌子" class="headerlink" title="T3. 移动桌子"></a>T3. 移动桌子</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>题面略（表格太多）</p>
<h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个正整数T（1≤T≤10），表示有多少组数据。</p>
<p>每组数据的第一行包含一个正整数n（1≤n≤200,000），表示要移动n张桌子 。</p>
<p>每组数据的接下来n行，每行包含2个正整数a和b，表示该张桌子原本在房间a，需要移动到房间b。</p>
<h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出一行，包含一个整数，表示移动完n张桌子所需要的最少时间 。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">10</span> <span class="number">20</span></span><br><span class="line"><span class="number">30</span> <span class="number">40</span></span><br><span class="line"><span class="number">50</span> <span class="number">60</span></span><br><span class="line"><span class="number">70</span> <span class="number">80</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">200</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">10</span> <span class="number">100</span></span><br><span class="line"><span class="number">20</span> <span class="number">80</span></span><br><span class="line"><span class="number">30</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">20</span><br><span class="line">30</span><br></pre></td></tr></table></figure>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>我们对于每一个桌子的区间头和区间尾都加一再除以二（将房间化为走廊）</p>
<p>接着开一个长度为250的桶，把走廊长度累计到这个桶里面（暴力区间加1）</p>
<p>最后取最大值，乘以10（一次移动桌子10十分钟）就是最终答案</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> way[<span class="number">250</span> + <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">char</span> ch = getchar();</span><br><span class="line">		<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">			ch = getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">			s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">			ch = getchar();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> s * x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			x = -x;</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">		<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">		__basic_putint(x);</span><br><span class="line">		<span class="built_in">putchar</span>(external);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">	freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">	<span class="keyword">int</span> t = getint();</span><br><span class="line">	<span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(way, <span class="number">0</span>, <span class="keyword">sizeof</span>(way));</span><br><span class="line">		<span class="keyword">int</span> n = getint();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">			<span class="keyword">int</span> s = getint();</span><br><span class="line">			<span class="keyword">int</span> t = getint();</span><br><span class="line">			s = (s + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			t = (t + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = s; j &lt;= t; ++j) ++way[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">250</span>; ++i) ans = <span class="built_in">std</span>::max(ans, way[i]);</span><br><span class="line">		putint(ans * <span class="number">10</span>, <span class="string">'\n'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-口算"><a href="#T4-口算" class="headerlink" title="T4. 口算"></a>T4. 口算</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><p>Alice口算能力非常强。Bob为了考考Alice，给了她一个长度为n的正整数序列a1，a2，……，an，同时抛出了m个问题。<br>​<br>每个问题给出三个正整数。<br>​<br>Alice需要快速判断出$a<em>l\times a</em>{l+1}\times \dots \times a_{r-1} \times a_r $ 是不是d的倍数。<br>​<br>Alice凭借她强大的口算能力快速给出了答案。然而Bob很菜，他并不知道正确答案是什么。请写一个程序帮助Bob计算这些问题的答案。</p>
<h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个正整数T（1≤T≤10），表示有多少组数据。<br>​<br>每组数据的第一行包含两个正整数n，m（1≤n,m≤100,000），分别表示序列长度以及问题个数。<br>​<br>第二行包含n个正整数a1，a2，……，an（1≤ai≤100,000），表示序列中的每个数。<br>​<br>接下来的m行，每行包含3个正整数l,r,d（1≤l≤r≤n，1≤d≤100,000），表示每个问题。</p>
<h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个问题，输出一行，若是倍数，输出Yes，否则输出No。</p>
<h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">5 5</span><br><span class="line">6 4 7 2 5</span><br><span class="line">1 2 24</span><br><span class="line">1 3 18</span><br><span class="line">2 5 17</span><br><span class="line">3 5 35</span><br><span class="line">1 3 21</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>
<h2 id="数据规模"><a href="#数据规模" class="headerlink" title="数据规模"></a>数据规模</h2><p>【数据规模】</p>
<p>对于30%数据，1≤T≤5，1≤n,m≤50，且保证对于每一个问题，$a<em>l\times a</em>{l+1}\times \dots \times a_{r-1} \times a_r $不超过long long的数据范围。</p>
<p>对于60%数据，1≤T≤10，1≤n,m≤1000，1≤ai≤1000</p>
<p>对于100%数据，1≤T≤10，1≤n,m≤100,000，1≤ai≤100,000</p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><h3 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h3><p>30pts 的模拟</p>
<h3 id="（伪）正解"><a href="#（伪）正解" class="headerlink" title="（伪）正解"></a>（伪）正解</h3><p>进行质因数分解，暴力判断</p>
<h3 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h3><p>在（伪）正解的基础上进行优化</p>
<p>预处理：将所有的数进行质因数分解，按照顺序把所有质数的出现的下标push_back进每个质数专门的vector里</p>
<p>将读入的d进行质因数分解，同上push_back进一个专门的vector里</p>
<p>然后在给定的区间里进行寻找质因数（使用lower_bound和upper_bound）</p>
<p>如果该有的质因数都有，显然可以整除</p>
<p>否则不可以整除</p>
<h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><p>不提供。</p>
]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>玄学题面</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3956「NOIP2017普及组」《棋盘》</title>
    <url>/2018-10-02/NOIP2017-PJ-Chess-Luogu-P3958/</url>
    <content><![CDATA[<blockquote>
<p>三种搜索剪枝</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P3956" target="_blank" rel="noopener">题目链接</a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有一个$m \times m$的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。</p>
<p>任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 1个金币。</p>
<p>另外， 你可以花费 2 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。</p>
<p>现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数$m, n$，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。</p>
<p>接下来的$n$行，每行三个正整数$x, y, c$， 分别表示坐标为$(x,y)$的格子有颜色$c$。</p>
<p>其中$c=1$ 代表黄色，$c=0$ 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为$(1, 1)$，右下角的坐标为$( m, m)$。</p>
<p>棋盘上其余的格子都是无色。保证棋盘的左上角，也就是 $(1,1)$ 一定是有颜色的。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示花费的金币的最小值，如果无法到达，输出-1。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><p>Case #1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 1 0</span><br><span class="line">1 2 0</span><br><span class="line">2 2 1</span><br><span class="line">3 3 1</span><br><span class="line">3 4 0</span><br><span class="line">4 4 1</span><br><span class="line">5 5 0</span><br></pre></td></tr></table></figure>
<p>Case #2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 1 0</span><br><span class="line">1 2 0</span><br><span class="line">2 2 1</span><br><span class="line">3 3 1</span><br><span class="line">5 5 0</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><p>Case #1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<p>Case #2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>
<h1 id="样例解释-amp-其他说明"><a href="#样例解释-amp-其他说明" class="headerlink" title="样例解释 &amp; 其他说明"></a>样例解释 &amp; 其他说明</h1><p>对于 $30\%$的数据, $1 ≤ m ≤ 5, 1 ≤ n ≤ 10$</p>
<p>对于 $60\%$数据, $1 ≤ m ≤ 20, 1 ≤ n ≤ 200$</p>
<p>对于 $100\%$的数据, $1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>我们并不需要维护某一个点是否走过</p>
<p>我们需要判断边界、白格子、最优性剪枝和走到终点四种情况</p>
<p>用$mp$数组存图，规定0表示白色，1表示红色，2表示黄色</p>
<p>用$f_{i,j}$表示$1,1$到$i,j$的最少花费</p>
<p>本题主要的难点在于加入了膜法机制</p>
<p>那么DFS需要传递四个参数：</p>
<ul>
<li><code>int</code>x坐标和y坐标</li>
<li><code>int</code>当前使用的金币数量</li>
<li><code>bool</code>当前是否使用了膜法</li>
</ul>
<p>在四向DFS中，需要进行以下几点判断：</p>
<ul>
<li>当前格是否有颜色<br>若无颜色且并未使用膜法，则使用膜法，使用金币数量+2，继续DFS；<br>若无颜色且使用过膜法，没救了</li>
<li>当前格颜色和下一格颜色是否相同<br>若颜色相同，直接进行下一步DFS；<br>若颜色不同，使用金币数量+1，继续DFS</li>
</ul>
<p>要注意的是，$f$数组的赋值要在判断是否走到终点之前，最优性剪枝之后，不然可能出现赋值不上的情况</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> f[MAXM][MAXM];</span><br><span class="line">    <span class="keyword">int</span> mp[MAXM][MAXM];</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> WHITE 0</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> RED 1</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> YELLOW 2</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>,  <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m, n, ans = <span class="number">2147482333</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DaFaShi</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> nowSum, <span class="keyword">bool</span> usedMogic)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 苟利国家生死以</span></span><br><span class="line">        <span class="comment">// 岂因祸福避趋之</span></span><br><span class="line">        <span class="comment">// 你们啊，不要总是想弄个大新闻 </span></span><br><span class="line">        <span class="comment">// 说什么使用膜法</span></span><br><span class="line">        <span class="comment">// 再把我批判一番 </span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">1</span> || y &lt; <span class="number">1</span> || x &gt; m || y &gt; m) <span class="keyword">return</span>; <span class="comment">// 边界 </span></span><br><span class="line">        <span class="keyword">if</span> (mp[x][y] == WHITE) <span class="keyword">return</span>; <span class="comment">// 走到白格子 </span></span><br><span class="line">        <span class="keyword">if</span> (nowSum &gt;= f[x][y]) <span class="keyword">return</span>; <span class="comment">// 最优性剪枝 </span></span><br><span class="line">        f[x][y] = nowSum;</span><br><span class="line">        <span class="keyword">if</span> (x == m &amp;&amp; y == m) &#123;</span><br><span class="line">            ans = <span class="built_in">std</span>::min(nowSum, ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// 搜索完成 </span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        For (i, <span class="number">1</span>, <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> nx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ny = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (mp[nx][ny] != WHITE) &#123;</span><br><span class="line">                <span class="comment">// 有颜色 </span></span><br><span class="line">                <span class="keyword">if</span> (mp[nx][ny] == mp[x][y]) DaFaShi(nx, ny, nowSum, <span class="literal">false</span>);</span><br><span class="line">                <span class="comment">// 颜色相同，继续往后搜 </span></span><br><span class="line">                <span class="keyword">else</span> DaFaShi(nx, ny, nowSum + <span class="number">1</span>, <span class="literal">false</span>); <span class="comment">// 颜色不同，花费金币 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mp[nx][ny] == WHITE &amp;&amp; !usedMogic)&#123;</span><br><span class="line">                <span class="comment">// 没颜色且没用膜法 </span></span><br><span class="line">                mp[nx][ny] = mp[x][y]; <span class="comment">// 念诗，使用膜法 </span></span><br><span class="line">                DaFaShi(nx, ny, nowSum + <span class="number">2</span>, <span class="literal">true</span>); <span class="comment">// 使用膜法花费2金币 </span></span><br><span class="line">                mp[nx][ny] = WHITE; <span class="comment">// 回溯 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x7f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    m = getint();</span><br><span class="line">    n = getint();</span><br><span class="line">    For (i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, c;</span><br><span class="line">        x = getint();</span><br><span class="line">        y = getint();</span><br><span class="line">        c = getint();</span><br><span class="line">        mp[x][y] = c + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DaFaShi(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (ans == <span class="number">2147482333</span>) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2040《打开所有的灯》</title>
    <url>/2018-10-02/Luogu-P2040/</url>
    <content><![CDATA[<blockquote>
<p>益(ruo)智(zhi)的小游戏</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problem/show?pid=2040" target="_blank" rel="noopener">题目链接</a></p>
<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。</p>
<p>例如 0 1 1</p>
<p>1 0 0</p>
<p>1 0 1</p>
<p>点一下最中间的灯【2,2】就变成了</p>
<p>0 0 1</p>
<p>0 1 1</p>
<p>1 1 1</p>
<p>再点一下左上角的灯【1,1】就变成了</p>
<p>1 1 1</p>
<p>1 1 1</p>
<p>1 1 1</p>
<p>达成目标。最少需要2步。</p>
<p>输出2即可。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>九个数字，3*3的格式输入，每两个数字中间只有一个空格，表示灯初始的开关状态。（0表示关，1表示开）</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>1个整数，表示最少打开所有灯所需要的步数。 </p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0  1  1</span><br><span class="line">1  0  0</span><br><span class="line">1  0  1</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>易证得我们对于一个灯的开关，只需要按1或0次</p>
<p>所以只需要考虑这个开关按与不按即可</p>
<p>所以我们可以直接进行搜索，总运算次数不会超过$9^9$</p>
<p>用$used$数组记录$used<em>i$这个开关是否已经按过，用$f$数组记录$f</em>{i,j}$的亮灭情况</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>（以后就这个码风了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">bool</span> used[<span class="number">3</span> + <span class="number">2</span>][<span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> f[<span class="number">3</span> + <span class="number">2</span>][<span class="number">3</span> + <span class="number">2</span>], ans = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>,  <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>,  <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            f[x + dx[i]][y + dy[i]] = !f[x + dx[i]][y + dy[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!f[i][j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> steps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (steps &gt;= ans) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (Check()) ans = <span class="built_in">std</span>::min(ans, steps);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!used[i][j]) &#123;</span><br><span class="line">                    used[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    modify(i, j);</span><br><span class="line">                    dfs(steps+<span class="number">1</span>);</span><br><span class="line">                    modify(i, j);</span><br><span class="line">                    used[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">3</span>; ++j) &#123;</span><br><span class="line">            f[i][j] = FastIO::getint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    FastIO::putint(ans, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 Autumn 清北学堂普及刷题班 Day2 题解</title>
    <url>/2018-10-02/2018AutumnQBXTDay2/</url>
    <content><![CDATA[<p>由于缺少题面，故本篇无内容。</p>
<p>这里仅提供T1. coin的代码实现。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">	<span class="comment">// 中国有句古话叫做闷声ACCEPT</span></span><br><span class="line">	<span class="comment">// 我就什么都不写，才是坠吼的 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"coin.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"coin.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, X = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">    	<span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    		<span class="keyword">case</span> <span class="string">'x'</span> :</span><br><span class="line">    			++x;</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">    		<span class="keyword">case</span> <span class="string">'X'</span> :</span><br><span class="line">    			++X;</span><br><span class="line">    			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x == X) &#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; X) &#123;</span><br><span class="line">		<span class="keyword">while</span> (x != X) &#123;</span><br><span class="line">			++x, --X, ++cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (X &lt; x) &#123;</span><br><span class="line">		<span class="keyword">while</span> (x != X) &#123;</span><br><span class="line">			++X, --x, ++cnt;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FastIO::putint(cnt, <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>清北学堂</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 Autumn 清北学堂普及刷题班 日记</title>
    <url>/2018-10-01/2018AutumnQBXTDiary/</url>
    <content><![CDATA[<blockquote>
<p>Handwer STD 好菜啊</p>
</blockquote>
<a id="more"></a>
<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><p>考试150pts</p>
<p>本来能拿200pts的 结果T1写炸了只拿了50pts</p>
<p>靠着这样的成绩居然<del>玄学地</del>拿到了第三名</p>
<p>第一名 200pts</p>
<p>第二名190pts</p>
<p>还拿到了一个有线鼠标 首战告捷（人生中第一次比赛拿奖 在提高被虐惯了）</p>
<h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><p>考试140pts</p>
<p>T1数据有锅 题面保证数据没有奇数，结果只有3组数据是偶数，导致我只拿了30pts</p>
<p>好在最后重测了 拿到了100pts</p>
<p>T2和T3根本没看</p>
<p>T4打了个暴力，枚举边跑Dijkstra，期望得分60pts，结果把m写成n……只拿了40pts</p>
<p>最后还是水到了一个rk5 不过今天并没有鼠标</p>
<h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><p>考试爆炸 只拿了80pts</p>
<p>被zxk吊打</p>
<p>T1阅读题，根本没理清题意，0pt</p>
<p>T2规律题</p>
<p>T3贪心，但由于没有认真阅读题目，导致只拿了60pts</p>
<p>T4有技巧的数学题，打了个30pts的暴力结果只拿了20pts</p>
<p>最终居然还水进了前10</p>
<p>我好菜啊……</p>
<h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><p>今天的题目 <br></p>
<p><big><big><big>好！简！单！啊！</big>&lt;/big&gt;&lt;/big&gt; <br><br>今天的是真的普及组题目了 <br><br>T1和T2都是水题，T3暴力分也是足够的，凭220pts拿了个rank3</big></big></p>
<p>讲T2的时候被老师拉上去讲题，感觉整个人都在抖，毫无准备的就上去了，说话也是语无伦次，真是差点要吓死了</p>
<p>不过重点不在这个 <br><br>今天下午三点的时候RainAir问我成绩和排名，我如实地告诉了他<br><br>后面的事应该不需要想了，我被他膜了一下午</p>
<p>但！是！<br><br>接近八点的时候，Logey先是问了一下「致远星战况如何？」然后就开始膜我……说时迟，那时快，iShq也开始膜我了<br><br>接着，就是三个人一块膜我，我被膜了一晚上！<br><br>这群人fAKe起来真是没有底线啊……<br><br>他们甚至把群名改成了「王太阳fAKe群」！</p>
<p>我写博客快要写死了，今天T2要不对着代码讲出来真是太麻烦了，果然我水平还是低啊<br><br>一口气更了三篇博客，感觉自己身体素质越来越差了，熬夜都熬不了了</p>
<p>对了，现在时间是2018年10月5日凌晨0点04分</p>
<h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><p>今天题目暴力分给的真是够多的了</p>
<p>T1 AC，T2应该是90pts，T4应该是70pts，总分250pts，拿到了一个rank6</p>
<p>T2本来能A掉的，但是我正解在考完试20min之后才调出来 难受</p>
<p>又一次忙活到了23点 好累啊qaq</p>
<h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><p>今天的题目不知为何我只拿了110pts qaq</p>
<p>T1 100pts，T2 0，T3 0, T4只搜到了10pts</p>
<p>看着别人上去拿键盘 拿鼠标 心里有点羡慕（虽然我已经有一个鼠标了</p>
<p>这个句号虽然不够圆满，但是至少是完整的。</p>
]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>2018 Autumn 清北学堂普及刷题班 Day1 题解</title>
    <url>/2018-10-01/2018AutumnQBXTDay1/</url>
    <content><![CDATA[<blockquote>
<p>不知不觉弄了个鼠标回来（雾</p>
</blockquote>
<a id="more"></a>
<h1 id="T1-扑克牌"><a href="#T1-扑克牌" class="headerlink" title="T1. 扑克牌"></a>T1. 扑克牌</h1><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>【题目描述】</p>
<p>这天， 小 Q 来到了小杜家， 找小杜玩起了扑克牌的游戏。 <br><br>扑克牌有 54 张牌， 分别是数字 A,2,3,4,5,6,7,8,9,10,J,Q,K，每种数字有 4 个花色， 分别为红桃， 黑桃， 方块， 梅花， 还有两张大王和小王。 <br><br>这天小 Q 和小杜玩起来比大小的游戏， 两人各拿出一张扑克牌比大小， 很显然 3<4<5<6<7<8<9<10<j<q<k<a<2<小王<大王， 为了防止数字相同无法比较， 他们给花色也定了一个大小梅花<方块<黑桃<红桃， 规定先比较数字， 数字相同再比较花色， 由于他们只有一副扑克牌， 拿出的两张牌不可能相同， 所以一定能比出大小。 <br></4<5<6<7<8<9<10<j<q<k<a<2<小王<大王，></p>
<p>【输入描述】</p>
<p>第一行一个数字 T， 表示小 Q 和小杜玩的次数。 <br><br>接下来 T 行， 每行两个用空格隔开的数字。 <br><br>其中 1-13 分别表示梅花 A,2,3,4,5,6,7,8,9,10,J,Q,K。 <br><br>其中 14-26 分别表示方块 A,2,3,4,5,6,7,8,9,10,J,Q,K。 <br><br>其中 27-39 分别表示黑桃 A,2,3,4,5,6,7,8,9,10,J,Q,K。 <br><br>其中 40-52 分别表示红桃 A,2,3,4,5,6,7,8,9,10,J,Q,K。 <br><br>53 表示小王， 54 表示大王。 <br><br>第一个数表示小 Q 的牌， 第二个数表示小杜的牌。 <br></p>
<p>【输出描述】</p>
<p>输出共 T 行， 每行一个字母 Q 或者 D， Q 表示小 Q 赢， D 表示小杜赢。</p>
<h2 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h2><h3 id="输入格式-amp-输出格式"><a href="#输入格式-amp-输出格式" class="headerlink" title="输入格式 &amp; 输出格式"></a>输入格式 &amp; 输出格式</h3><p>见题面。</p>
<h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 13</span><br><span class="line">1 53</span><br></pre></td></tr></table></figure>
<h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Q</span><br><span class="line">D</span><br></pre></td></tr></table></figure>
<h2 id="样例解释-amp-注意事项"><a href="#样例解释-amp-注意事项" class="headerlink" title="样例解释 &amp; 注意事项"></a>样例解释 &amp; 注意事项</h2><p>【样例解释】</p>
<p>第一局小 Q 是梅花 A， 小杜是梅花 K， 所以小 Q 大 <br><br>第二局小 Q 是梅花 A， 小杜是小王， 所以小杜大。 <br></p>
<p>【数据范围】</p>
<p>对于 30%的数据， 扑克牌的范围在[1,13]。 <br><br>对于 50%的数据， 不会出现大小王。 <br><br>对于 100%的数据， 1&lt;=T&lt;=100。  <br></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p> <strong><big>照题意模拟</big></strong></p>
<p>这里有一个小技巧</p>
<p>你可以对读入的数字（<strong>必须保证数字不代表大、小王</strong>） $mod\ 13$</p>
<p>得到的新数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 10 11 12</span><br><span class="line">K A 2 3 4 5 6 7 8 9 10  J  Q</span><br></pre></td></tr></table></figure>
<p>接着特判，把K改成13，把A改成14，把2改成15，把小王改成16，把大王改成17</p>
<p>最后直接比较新数字就行了</p>
<p>当新数字相同时依题意可直接比较原数字的大小</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>（依然<del>毒瘤</del>风格）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">queryNum</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= <span class="number">52</span>) &#123; </span><br><span class="line">			x %= <span class="number">13</span>;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">0</span>) x = <span class="number">13</span>;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">1</span>) x = <span class="number">14</span>;</span><br><span class="line">			<span class="keyword">if</span> (x == <span class="number">2</span>) x = <span class="number">15</span>;</span><br><span class="line">			<span class="keyword">return</span> x;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">return</span> x - <span class="number">52</span> + <span class="number">15</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> qa = queryNum(q);</span><br><span class="line">		<span class="keyword">int</span> da = queryNum(d);</span><br><span class="line">		<span class="keyword">if</span> (qa == da) <span class="keyword">return</span> q &lt; d ? <span class="string">'D'</span> : <span class="string">'Q'</span>;</span><br><span class="line">		<span class="keyword">return</span> qa &lt; da ? <span class="string">'D'</span> : <span class="string">'Q'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"poker.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"poker.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">using</span> FastIO::getint;</span><br><span class="line">    <span class="keyword">using</span> FastIO::putint;</span><br><span class="line">    <span class="keyword">int</span> t = getint();</span><br><span class="line">    <span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">int</span> q = getint();</span><br><span class="line">    	<span class="keyword">int</span> d = getint();</span><br><span class="line">    	<span class="built_in">cout</span> &lt;&lt; Solution::Judge(q, d) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T2-密码"><a href="#T2-密码" class="headerlink" title="T2. 密码"></a>T2. 密码</h1><h2 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h2><p>【题目描述】</p>
<p>小杜开始学习 C++， 小杜想进行一些练习， 于是小杜准备上某题库网站进行做题练习， 小杜发现这样的网站都需要进入注册之后， 才可以登录进行练习， 于是小杜准备注册一个账号。 <br><br>在填写了一大堆信息之后， 网站要求小杜输入密码， 这让小杜犯了难， 网站对密码的有一定的要求， 密码只能包含大写字母， 小写字母， 并且必须包含至少一个大写字母， 至少一个小写字母， 那么对于小杜的密码， 是否符合该网站的要求呢？如果不符合网站的要求， 那么如何修改让密码变得符合要求呢，一次修改只能将密码的某一位修改成一个大写字母或小写字母， 如果有多个密码符合条件， 需要修改次数最少的， 对于修改次数相同的，输出字典序最小的（按 ASCII 码） <br></p>
<p>【输入描述】</p>
<p>第一行一个数字 T 表示数据组数。 <br><br>接下来 T 行， 每行一个字符串表示小杜的密码。 <br></p>
<p>【输出描述】</p>
<p>共 T 行。 <br><br>若小杜的密码符合条件， 将密码直接输出即可， 否则输出修改后的密码 。 <br></p>
<h2 id="Input-Output-格式-amp-样例-1"><a href="#Input-Output-格式-amp-样例-1" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h2><h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><p>见题面。</p>
<h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">abaCABA</span><br><span class="line">qwerty</span><br></pre></td></tr></table></figure>
<h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abaCABA</span><br><span class="line">Awerty</span><br></pre></td></tr></table></figure>
<h2 id="样例解释-amp-注意事项-1"><a href="#样例解释-amp-注意事项-1" class="headerlink" title="样例解释 &amp; 注意事项"></a>样例解释 &amp; 注意事项</h2><p>【数据范围】</p>
<p>对于 30%的数据， 只包含小写字母。<br>对于另外 20%的数据， 只包含大写字母。<br>对于 100%的数据， 1&lt;=T&lt;=100， 字符串长度不超过 100 并且大于等于 3，保证输入数据只包含大、小写字母。</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p> <strong><big>依然照题意模拟</big></strong></p>
<p>我们<del>贪心地</del>认为字母A越靠前，字母a越靠后，整个字符串字典序就越小</p>
<p>那么本题分两种情况讨论：</p>
<ul>
<li>只含有大写字母</li>
<li>只含有小写字母</li>
<li><del>含有特殊字符</del>并没有</li>
</ul>
<p>对于只含有大写字母的情况，把字符串末尾修改成a即可。</p>
<p>对于只含有小写字母的情况，把字符串开头修改成A即可。</p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p>（还是这种<del>玄学</del>码风</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">Check</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> lenstr, <span class="keyword">bool</span> &amp;hasUpper, <span class="keyword">bool</span> &amp;hasLower)</span> </span>&#123;</span><br><span class="line">		hasUpper = <span class="literal">false</span>;</span><br><span class="line">		hasLower = <span class="literal">false</span>;</span><br><span class="line">		Forw (i, <span class="number">0</span>, lenstr) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">isupper</span>(str[i])) hasUpper = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">islower</span>(str[i])) hasLower = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hasUpper &amp;&amp; hasLower) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">Modify</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> lenstr, <span class="keyword">bool</span> hasUpper, <span class="keyword">bool</span> hasLower)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">string</span> ret = str;</span><br><span class="line">		<span class="keyword">if</span> (hasUpper == <span class="literal">false</span> &amp;&amp; hasLower == <span class="literal">false</span>) &#123;</span><br><span class="line">			Forw (i, <span class="number">0</span>, lenstr - <span class="number">1</span>) ret[i] = <span class="string">'A'</span>;</span><br><span class="line">			ret[lenstr - <span class="number">1</span>] = <span class="string">'a'</span>;</span><br><span class="line">			ret[lenstr] = <span class="string">'\0'</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hasUpper == <span class="literal">false</span> &amp;&amp; hasLower) &#123;</span><br><span class="line">			ret[<span class="number">0</span>] = <span class="string">'A'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hasUpper &amp;&amp; hasLower == <span class="literal">false</span>) &#123;</span><br><span class="line">			ret[lenstr - <span class="number">1</span>] = <span class="string">'a'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (hasUpper &amp;&amp; hasLower) &#123;</span><br><span class="line">			Forw (i, <span class="number">0</span>, lenstr) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="built_in">isupper</span>(ret[i]) &amp;&amp; !<span class="built_in">islower</span>(ret[i])) &#123;</span><br><span class="line">					ret[i] = <span class="string">'A'</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"pass.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"pass.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    	<span class="keyword">int</span> lens = s.length();</span><br><span class="line">    	<span class="keyword">bool</span> hasUpper = <span class="literal">false</span>, hasLower = <span class="literal">false</span>;</span><br><span class="line">    	<span class="keyword">if</span> (Solution::Check(s, lens, hasUpper, hasLower)) <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    	<span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; Solution::Modify(s, lens, hasUpper, hasLower) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T3-下棋"><a href="#T3-下棋" class="headerlink" title="T3. 下棋"></a>T3. 下棋</h1><h2 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h2><p>【题目描述】</p>
<p>小 Q 拿出了一张 2 行 N 列的棋盘， 棋盘的每个位置可以放一颗黑棋或者一颗白棋。 <br>若两个棋子颜色相同且位置相邻我们就认为这两个棋子连成了一片， 当然两个棋子都和另一个棋子连成一片， 我们也认为这两个棋子连成一片。 <br>这天小杜突发奇想， 小杜想知道这个棋盘上有多少种放棋子的方法使得棋盘上的棋子片数为 K。 <br>这个数目可能非常大， 请输出方法对 998244353 取模的结果。 </p>
<p>【输入描述】</p>
<p>两个数 N 和 K， 用空格隔开。</p>
<p>【输出描述】</p>
<p>一个数字表示方案数。</p>
<h2 id="Input-amp-Output-格式-amp-样例"><a href="#Input-amp-Output-格式-amp-样例" class="headerlink" title="Input &amp; Output 格式 &amp; 样例"></a>Input &amp; Output 格式 &amp; 样例</h2><h3 id="输入输出格式-1"><a href="#输入输出格式-1" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><p>见题面。</p>
<h3 id="输入样例-2"><a href="#输入样例-2" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-2"><a href="#输出样例-2" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
<h2 id="样例解释-amp-注意事项-2"><a href="#样例解释-amp-注意事项-2" class="headerlink" title="样例解释 &amp; 注意事项"></a>样例解释 &amp; 注意事项</h2><p>【数据范围】</p>
<p>对于 30%的数据， 1&lt;=N&lt;=10,1&lt;=K&lt;=2N。 <br>对于 50%的数据， 1&lt;=N&lt;=100,1&lt;=K&lt;=2N。 <br>对于 100%的数据， 1&lt;=N&lt;=1000,1&lt;=K&lt;=2N。  </p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p><del>考场上死活没看出这是DP</del></p>
<p>我们设<code>dp[i][j]=k</code>表示前$2\times i$个格子，有$j$片，最后一个$2\times i$的格子的状态为$k\ (0 \le k \le 3)$ </p>
<p>那么只需要枚举下一个$2\times i$的状态$p\ (0 \le p \le 3)$，进行转移即可</p>
<p>转移有$4\times4=16$种方案，可以先判断加$0$片和加$1$片的情况，剩下的就是加$2$片的情况，代码会简洁不少</p>
<p>不要忘了最后$ans$要$mod\ 998244353$</p>
<h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><p>（玄学码风无误了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> HA = <span class="number">998244353</span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (x == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span> (y == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (y == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> f[MAXN][<span class="number">4</span>];</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x[MAXN][<span class="number">4</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">Work</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		f[<span class="number">1</span>][<span class="number">0</span>] = f[<span class="number">1</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">		f[<span class="number">2</span>][<span class="number">1</span>] = f[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">		Forw (i, <span class="number">0</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line">			For (j, <span class="number">1</span>, MAXN - <span class="number">10</span>) &#123;</span><br><span class="line">				Forw (xx, <span class="number">0</span>, <span class="number">4</span>) &#123;</span><br><span class="line">					Forw (y, <span class="number">0</span>, <span class="number">4</span>) &#123;</span><br><span class="line">						x[j + Query(xx, y)][y] += f[j][xx];</span><br><span class="line">						x[j + Query(xx, y)][y] %= HA;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">std</span>::swap(f, x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (f[k][<span class="number">0</span>] + f[k][<span class="number">1</span>] + f[k][<span class="number">2</span>] + f[k][<span class="number">3</span>]) % HA;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"chess.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"chess.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = FastIO::getint();</span><br><span class="line">    <span class="keyword">int</span> k = FastIO::getint();</span><br><span class="line">    FastIO::putint(Solution::Work(n, k), <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="T4-堆积木"><a href="#T4-堆积木" class="headerlink" title="T4. 堆积木"></a>T4. 堆积木</h1><p><del>太蒻不写</del></p>
]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 349B 《Color the Fence》</title>
    <url>/2018-09-30/CF349B/</url>
    <content><![CDATA[<blockquote>
<p>瞎贪心</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><center> <i> 翻译来自洛谷 </i> </center>

<p>Igor深深爱上了Tanya. 现在, Igor想表达他的爱意, 他便在Tanya家对面的墙上写下一串数字. Igor认为, 数字写得越大, Tanya越喜欢他. 不幸的是, 他只有 $v$ 升油漆, 每个数字都会花掉一定的油漆 $a_i$ . Igor不喜欢 $0$  所以数中不会出现 $0$. 问Igor能得到的最大的数是多少.</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数$v$，意义如题</p>
<p>第二行有九个数字$a_1,\ a_2,\ a_3,\ \dots \ ,\ a_9$，表示第$i$个数字需要$a_i$升油漆</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示最大的Igor可以得到的数。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><p>Case #1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5 4 3 2 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<p>Case #2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">9 11 1 12 5 8 9 10 6</span><br></pre></td></tr></table></figure>
<p>Case #3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1 1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><p>Case #1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">55555</span><br></pre></td></tr></table></figure>
<p>Case #2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">33</span><br></pre></td></tr></table></figure>
<p>Case #3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>明显的贪心</p>
<p>先对这个序列排序（优先队列方便<del>快捷</del>），再从小到大依次计算可以画出的数字和画出数字的次数</p>
<p>接着从9到1进行枚举，看一看有没有什么可以替换一下的，替换成花费相对最小的数字</p>
<p>最后输出答案数组</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>玄学代码风格（雾</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterator -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Constants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants Start  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[<span class="number">10</span>]; </span><br><span class="line"><span class="comment">// q[i].first = variant</span></span><br><span class="line"><span class="comment">// q[i].second = id</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Variants End  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DEBUG</span><span class="params">(<span class="keyword">char</span> comment[], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; comment &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HANDWER_FILE</span></span><br><span class="line">    freopen(<span class="string">"testdata.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"testdata.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    v = FastIO::getint();</span><br><span class="line">    For (i, <span class="number">1</span>, <span class="number">9</span>) &#123;</span><br><span class="line">        q[i] = FastIO::getint();</span><br><span class="line">        pq.push(<span class="built_in">std</span>::make_pair(q[i], -i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 贪心选择当前最优</span></span><br><span class="line">    <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">        pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pr = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        ans[-pr.second] = v / pr.first;</span><br><span class="line">        v %= pr.first;</span><br><span class="line">    &#125;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">2147482333</span>;</span><br><span class="line">    <span class="comment">// 进行替换</span></span><br><span class="line">    Bak (i, <span class="number">9</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        Bak (j, i - <span class="number">1</span>, <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[j] &amp;&amp; q[j] &lt; q[tmp]) tmp = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tmp) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">while</span> (ans[tmp] &amp;&amp; v &amp;&amp; v &gt;= q[i] - q[tmp]) </span><br><span class="line">            v -= q[i] - q[tmp], ++ans[i], --ans[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> Printed = <span class="literal">false</span>;</span><br><span class="line">    Bak (i, <span class="number">9</span>, <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ans[i]) &#123;</span><br><span class="line">            FastIO::__basic_putint(i);</span><br><span class="line">            --ans[i];</span><br><span class="line">            Printed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 程序并没有正确答案，输出-1</span></span><br><span class="line">    <span class="keyword">if</span> (!Printed) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 333A 《Secrets》</title>
    <url>/2018-09-30/CF333A/</url>
    <content><![CDATA[<blockquote>
<p>枚举</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/CF333A" target="_blank" rel="noopener">题目链接</a></p>
<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>Gerald 在卖一些国家机密，所有机密的花费相同——总价值为 $n$ 的钢镚。所有的钢镚的价值都是 $3^k\ (k ≥ 1)$。</p>
<p>某天来了一个交易者，他不会付出正好的价值，也就是说，Gerald 必须找钱给他。</p>
<p>求一个方案使得交易者付出的钢镚的价值 $≥n$ ，且付出最少额外价值的同时保证花费的钢镚数量最多。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><p>一行一个整数 $n$ ，意义如题。</p>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><p>一行一个整数，即最多花费的钢镚数量。</p>
<h2 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例"></a>输入样例</h2><p>Case #1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>Case #2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例"></a>输出样例</h2><p>Case #1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>Case #2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>显然，使用的金币面值越小，使用的金币数量就越大</p>
<p>那么答案就是第一个 $i$使得$\frac{n}{i}=1\ (i ≥ 1)$</p>
<p>又因为交易者不会付出正好为 $n$ 价值的钢镚，所以答案就要 $+1$</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> returnValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = -x;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (returnValue) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n, now = <span class="number">1l</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        now *= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (n % now) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; n / now + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 295B 《Greg and Graph》</title>
    <url>/2018-09-30/CF295B/</url>
    <content><![CDATA[<blockquote>
<p><del>开倒车</del> 倒序 Floyd</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/CF295B" target="_blank" rel="noopener">题目链接</a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><center> <i>翻译来自洛谷</i> </center>

<p>Greg有一个有边权的有向图，包含 $n$ 个点。这个图的每两个点之间都有两个方向的边。Greg喜欢用他的图玩游戏，现在他发明了一种新游戏：</p>
<ul>
<li>游戏包含 $n$ 步。</li>
<li>第 $i$ 步Greg从图中删掉编号为 $x_i$ 的点。当删除一个点时，这个点的出边和入边都会被删除。</li>
<li>在执行每一步之前，Greg想知道所有点对间最短路长度的和。最短路可以经过任何没删掉的点。换句话说，如果我们假设 $d(i, v, u)$ 是在删掉 $x<em>i$ 前 $v$ 和 $u$ 间的最短路长度，那么Greg想知道下面这个求和的值：$$\sum</em>{v, u, v \neq u} d(i, v, u)$$</li>
</ul>
<p>帮帮Greg，输出每一步之前要求的值。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数 $n \ (1 \leq n \leq 500)$ ，代表图中的点数。</p>
<p>下面 $n$ 行每行包含 $n$ 个整数，代表边权：第 $i$ 行的第 $j$ 个数 $a<em>{ij} \ (1 \leq a</em>{ij} \leq 10^5, a_{ii} = 0)$ 代表从 $i$ 到 $j$ 的边权。</p>
<p>最后一行包含 $n$ 个整数： $x_1, x_2, \dots, x_n \ (1 \leq x_i \leq n)$ ，分别为Greg每一步删掉的点的编号。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $n$ 个整数，第 $i$ 个数等于游戏的第 $i$ 步之前统计的求和值。</p>
<p>请不要在C++中使用<code>%lld</code>标志来输出64位整数<code>long long</code>，推荐使用<code>cin, cout</code>流或者用<code>%I64d</code>标志。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><p>Case #1: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>Case #2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">0 5</span><br><span class="line">4 0</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<p>Case #3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 3 1 1</span><br><span class="line">6 0 400 1</span><br><span class="line">2 4 0 1</span><br><span class="line">1 1 1 0</span><br><span class="line">4 1 2 3</span><br></pre></td></tr></table></figure>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>Case #1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<p>Case #2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9 0</span><br></pre></td></tr></table></figure>
<p>Case #3:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17 23 404 0</span><br></pre></td></tr></table></figure>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>$n \le 500$</p>
<p>很明显跑 Floyd 了</p>
<p>但是 Floyd 不支持删除操作</p>
<p>怎么办？</p>
<p><del>开倒车</del> 倒序添加！</p>
<p>我们记录下删除点的信息，再倒着添加回去，在这个过程中套一个 Floyd 进去</p>
<p>要注意的是累计答案的时候判断点是否存在</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> seq[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> inGraph[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> returnValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = -x;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (returnValue) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    f[s][t] = f[t][s] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            f[i][j] = getint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        seq[i] = getint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = n; l &gt; <span class="number">0</span>; --l) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = seq[l];</span><br><span class="line">        inGraph[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">std</span>::min(f[i][j], f[i][k] + f[k][j]);</span><br><span class="line">                <span class="keyword">if</span> (inGraph[i] &amp;&amp; inGraph[j]) ans[l] += f[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>图论算法</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1908《逆序对》</title>
    <url>/2018-09-15/Luogu-P1908/</url>
    <content><![CDATA[<blockquote>
<p>Based on 归并排序</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P1908" target="_blank" rel="noopener">题目地址</a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。</p>
<h1 id="Input-Output-格式"><a href="#Input-Output-格式" class="headerlink" title="Input / Output 格式"></a>Input / Output 格式</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，一个数n，表示序列中有n个数。</p>
<p>第二行n个数，表示给定的序列。序列中每个数字不超过$10^9$</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>给定序列中逆序对的数目。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">5 4 2 6 3 1</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>
<h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>对于25%的数据，$n \leq 2500n$ </p>
<p>对于50%的数据，$n \leq 4 \times 10^4$</p>
<p>对于所有数据，$n \leq 5 \times 10^5$</p>
<p>请使用较快的输入输出</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="暴力做法"><a href="#暴力做法" class="headerlink" title="暴力做法"></a>暴力做法</h2><p>$O(n)$枚举所有的点，$O(n)$比较数的大小，求出逆序对的个数</p>
<p>均摊$O(n^2)$</p>
<h2 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h2><p>分治</p>
<p>想想归并排序的过程</p>
<hr>
<p>比如我们要对下面的区间进行归并排序</p>
<script type="math/tex; mode=display">a_i\ \ mid=4\ \ a_j</script><script type="math/tex; mode=display">2\ 4\ 7\ 8\ \ \ \ \ 1\ 5\ 6\ 24</script><p>我们拿1去比较，此时可以构成的逆序对个数为4，把他放到$r_k$里，那么此时$i$是指向$a_1$的</p>
<p>接着继续比较，直到$a_i &lt; a_j$，就将$a_i$放到$r_k$里</p>
<p>以此类推，最终的逆序对个数就是中间求出的个数的和$=mid-i+1$的和</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5</span> * <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, a[MAXN], tmp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(l, mid);</span><br><span class="line">    mergeSort(mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, k = l;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j]) tmp[k] = a[i++], ++k;</span><br><span class="line">        <span class="keyword">else</span> tmp[k] = a[j++], ++k, ans += (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span>) mid - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k++] = a[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) a[i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    mergeSort(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>分治</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先搜索</title>
    <url>/2018-09-15/DepthFirstSearch/</url>
    <content><![CDATA[<blockquote>
<p>常见算法 / 骗分技巧</p>
</blockquote>
<a id="more"></a>
<h2 id="洛谷P1605-迷宫"><a href="#洛谷P1605-迷宫" class="headerlink" title="洛谷P1605 迷宫"></a>洛谷P1605 迷宫</h2><p><a href="https://www.luogu.org/problemnew/show/P1605" target="_blank" rel="noopener">题目地址</a></p>
<p>DFS 入门题</p>
<p>用一个数组<code>mp</code>存图，<code>vis</code>记录是否经过了这个点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mp[i][j] = 0 表示有障碍</span><br><span class="line">mp[i][j] = 1 表示没有障碍</span><br></pre></td></tr></table></figure>
<p>用一个函数<code>dfs(x, y)</code>来搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当坐标为终点时，直接return，方案数++</span><br><span class="line"></span><br><span class="line">如果这个点没被访问过，而且这个点没有障碍，就把这个点设为访问过，然后dfs这个点</span><br></pre></td></tr></table></figure>
<p>要注意的是起始点是访问过的</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">6</span> + <span class="number">2</span>][<span class="number">6</span> + <span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> mp[<span class="number">6</span> + <span class="number">2</span>][<span class="number">6</span> + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, endx, endy, stx, sty, n, m, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == endx &amp;&amp; y == endy) &#123;</span><br><span class="line">        ++tot;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> nowx = x + dx[i];</span><br><span class="line">        <span class="keyword">int</span> nowy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span> (!vis[nowx][nowy] &amp;&amp; mp[nowx][nowy]) &#123;</span><br><span class="line">            vis[nowx][nowy] = <span class="literal">true</span>;</span><br><span class="line">            dfs(nowx, nowy);</span><br><span class="line">            vis[nowx][nowy] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            mp[i][j] = (<span class="keyword">int</span>) <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; stx &gt;&gt; sty;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; endx &gt;&gt; endy;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        mp[l][r] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[stx][sty] = <span class="literal">true</span>;</span><br><span class="line">    dfs(stx, sty);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tot &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="洛谷P1162-填涂颜色"><a href="#洛谷P1162-填涂颜色" class="headerlink" title="洛谷P1162 填涂颜色"></a>洛谷P1162 填涂颜色</h2><p><a href="https://www.luogu.org/problemnew/show/P1162" target="_blank" rel="noopener">题目地址</a></p>
<p>本来这是一道 BFS 的题</p>
<p>但是有一种<del>玄学的</del>做法可以用 DFS</p>
<p>首先开两个<code>mp</code>存图，输入1时在第一个<code>mp</code>里存1，在第二个<code>mp</code>里存-1</p>
<p>具体就是搜索边界（每一行的第一个和第n个，每一列的第一个和第n个），在搜索的同时更新第一个<code>mp</code>为1</p>
<p>搜索完了就进行判断输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当第二个mp[i][j]为-1时输出1</span><br><span class="line">否则当第一个mp[i][j]为1时就输出2（被更新过了）</span><br><span class="line">否则输出0</span><br></pre></td></tr></table></figure>
<p><strong>代码实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mp[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> orz[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; n || x &lt; <span class="number">1</span> || y &gt; n || y &lt; <span class="number">1</span> || mp[x][y] != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    mp[x][y] = <span class="literal">true</span>;</span><br><span class="line">    dfs(x+<span class="number">1</span>, y);</span><br><span class="line">    dfs(x<span class="number">-1</span>, y);</span><br><span class="line">    dfs(x, y+<span class="number">1</span>);</span><br><span class="line">    dfs(x, y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; mp[i][j];</span><br><span class="line">            <span class="keyword">if</span> (mp[i][j] == <span class="number">1</span>) orz[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[i][<span class="number">1</span>] != <span class="number">1</span>) dfs(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (mp[i][n] != <span class="number">1</span>) dfs(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mp[<span class="number">1</span>][i] != <span class="number">1</span>) dfs(<span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">if</span> (mp[n][i] != <span class="number">1</span>) dfs(n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (orz[i][j] == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mp[i][j] == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>「五校联考」Round#1 Day1&amp;Day2 T1</title>
    <url>/2018-08-26/2018FSExamRound1T1/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="Please enter the password to read the blog." />
    <label for="pass">Please enter the password to read the blog.</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>只有经历过的人才知道的世界</tag>
        <tag>自测</tag>
        <tag>五校联考</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P3884《[JLOI2009]二叉树问题》</title>
    <url>/2018-08-08/Luogu-P3884/</url>
    <content><![CDATA[<blockquote>
<p>不用倍增的 almost裸的LCA</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>如下图所示的一棵二叉树的深度、宽度及结点间距离分别为：</p>
<p>深度：4 宽度：4（同一层最多结点个数）</p>
<p>结点间距离： ⑧→⑥为8 (3×2+2=8)</p>
<p>⑥→⑦为3 （1×2+1=3）</p>
<p>注：结点间距离的定义：由结点向根方向（上行方向）时的边数×2，</p>
<p>与由根向叶结点方向（下行方向）时的边数之和。</p>
<p><img src="https://cdn.luogu.org/upload/pic/6843.png" alt="图片来自洛谷"></p>
<p><small><small><center>图片来自洛谷</center></small>&lt;/small&gt;</small></p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件第一行为一个整数n(1≤n≤100)，表示二叉树结点个数。接下来的n-1行，表示从结点x到结点y（约定根结点为1），最后一行两个整数u、v，表示求从结点u到结点v的距离。</p>
<h2 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h2><p>三个数，每个数占一行，依次表示给定二叉树的深度、宽度及结点u到结点v间距离。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10                                </span><br><span class="line">1 2                            </span><br><span class="line">1 3                            </span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">3 6</span><br><span class="line">3 7</span><br><span class="line">5 8</span><br><span class="line">5 9</span><br><span class="line">6 10</span><br><span class="line">8 6</span><br></pre></td></tr></table></figure>
<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>树的深度可以取$max${$depth[i]$}</p>
<p>树的宽度可以在取深度的时候拿一个桶记录下来，再循环取一遍$max$</p>
<p>两点之间的距离可以先求$LCA$，再用一个公式算出来</p>
<script type="math/tex; mode=display">distance = (depth[u] - depth[lca]) \times 2 + depth[v] - depth[lca]</script><p>其中$lca = LCA(u, v)$</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">&#125; edge[MAXN * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], father[MAXN][<span class="number">22</span>], lg[MAXN], depth[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt, n, m, s;</span><br><span class="line"><span class="keyword">int</span> KangShifu[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> returnValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = -x;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (returnValue) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    edge[++cnt].prev = prev;</span><br><span class="line">    edge[cnt].next = head[next];</span><br><span class="line">    head[next] = cnt; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsInit</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    depth[root] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    father[root][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= depth[root]; ++i) &#123;</span><br><span class="line">        father[root][i] = father[father[root][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[root]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[e].prev != fa) dfsInit(edge[e].prev, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">while</span> (depth[x] &gt; depth[y]) </span><br><span class="line">        x = father[x][lg[depth[x] - depth[y]] - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg[depth[x]]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint(), next = getint();</span><br><span class="line">        addEdge(prev, next);</span><br><span class="line">        addEdge(next, prev);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">int</span> u = getint();</span><br><span class="line">    <span class="keyword">int</span> v = getint();</span><br><span class="line">    dfsInit(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    	lg[i] = lg[i<span class="number">-1</span>] + (<span class="number">1</span> &lt;&lt; lg[i<span class="number">-1</span>] == i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lca = LCA(u, v);</span><br><span class="line">    <span class="keyword">int</span> Depth = <span class="number">-23333</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        Depth = <span class="built_in">std</span>::max(Depth, depth[i]);</span><br><span class="line">        ++KangShifu[depth[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">-23333</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Depth + <span class="number">2</span>; ++i) width = <span class="built_in">std</span>::max(width, KangShifu[i]);</span><br><span class="line">    putint(Depth, <span class="literal">true</span>);</span><br><span class="line">    putint(width, <span class="literal">true</span>);</span><br><span class="line">    putint((depth[u] - depth[lca]) * <span class="number">2</span> + (depth[v] - depth[lca]), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>各省省选</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最近公共祖先 LCA 算法学习笔记</title>
    <url>/2018-08-07/LeastCommonAncestors/</url>
    <content><![CDATA[<blockquote>
<p>两个结点找共同的爸爸</p>
</blockquote>
<a id="more"></a>
<h1 id="LCA-的概念"><a href="#LCA-的概念" class="headerlink" title="LCA 的概念"></a>LCA 的概念</h1><blockquote>
<p>在<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA" target="_blank" rel="noopener">图论</a>和<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>中，<strong>最近公共祖先</strong>（英语：lowest common ancestor）是指在一个<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E5%9B%BE%E8%AE%BA" target="_blank" rel="noopener">树</a>)或者<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE" target="_blank" rel="noopener">有向无环图</a>中同时拥有v和w作为后代的最深的节点。</p>
<p align="right">——Wikipedia</p>

</blockquote>
<p><del>看不懂没关系</del></p>
<p>简单的来说，就是两个节点v和w的最近的祖先节点</p>
<p>如下图</p>
<p><img src="https://user-images.githubusercontent.com/33089328/43761882-f2ed7180-9a58-11e8-946c-acabf14c1b25.png" alt="image"></p>
<p>6和7的LCA是2，3和7的LCA是1</p>
<h1 id="LCA-的求法"><a href="#LCA-的求法" class="headerlink" title="LCA 的求法"></a>LCA 的求法</h1><h2 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h2><p>让他们一步一步往上爬，直到相遇</p>
<blockquote>
<p><del>节点背着那重重的编号呀 一步一步地往上爬 ——《蜗牛与黄鹂鸟》</del></p>
</blockquote>
<p>显然，这样的算法会<strong>T到飞起</strong></p>
<p>所以我们要使用<code>倍增</code>优化</p>
<h2 id="倍增求解"><a href="#倍增求解" class="headerlink" title="倍增求解"></a>倍增求解</h2><blockquote>
<p>所谓倍增，就是按2的倍数来增大，也就是跳 1、2、4 、8 、16、32 …</p>
</blockquote>
<p>但是在这里，我们要考虑<del><code>开倒车</code></del>从大到小跳</p>
<p>因为<code>如果我们从小到大跳，就会出现要「回溯」的情况，因为我们不一定能精准地跳，而从大到小跳可以避开这种情况</code></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/wxl-Ezio/1173002/o_QQ%E5%9B%BE%E7%89%8720180320205056.png" alt="图片来自cnblogs"></p>
<center><small><small><small>图源cnblogs</small></small></small></center>

<p>对于上面这一棵更复杂的树，我们考虑17和18的LCA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">17 -&gt;(跳4) 3</span><br><span class="line">18 -&gt;(跳4) 5 -&gt;(跳1) -&gt; 3</span><br></pre></td></tr></table></figure>
<p>是不是快多了，跳的次数大大减小</p>
<p>时间复杂度$O(nlogn)$</p>
<h1 id="LCA-的代码-amp-实现流程"><a href="#LCA-的代码-amp-实现流程" class="headerlink" title="LCA 的代码 &amp; 实现流程"></a>LCA 的代码 &amp; 实现流程</h1><h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>首先我们要记录各个点的深度$depth[\ ]$和它们$2^i$级的祖先$father[\ ][\ ]$</p>
<p>用$depth[i]$表示$i$点的深度，$father[i][j]$表示$i$点的$2^i$级的祖先</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsInit</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    depth[root] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    father[root][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= depth[root]; ++i) &#123;</span><br><span class="line">        father[root][i] = father[father[root][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[root]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[e].prev != fa) dfsInit(edge[e].prev, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我们就可以找LCA辣</p>
<p>对了，我们可以让它跑得更快</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提前预处理出log2i + 1的值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    lg[i] = lg[i<span class="number">-1</span>] + (<span class="number">1</span> &lt;&lt; lg[i<span class="number">-1</span>] == i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在求 LCA 之前，我们先让两个节点蹦到同一层</p>
<hr>
<p>但是跳的时候不能直接跳到 LCA 上，要跳到 LCA - 1 上，再输出 当前的父节点 就行了</p>
<p>因为直接蹦到 LCA 上可能会出现「误判」，比如上图中$4$和$8$，若不判断，则在跳的时候会输出1，但是答案是3</p>
<p>所以我们就可以让它们跳到$2$和$5$，然后输出父节点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们设x的深度大于y的深度</span></span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">while</span> (depth[x] &gt; depth[y]) </span><br><span class="line">        x = father[x][lg[depth[x] - depth[y]] - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x; <span class="comment">// x 是 y 的祖先</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg[depth[x]]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i];</span><br><span class="line">        <span class="comment">// 不相等就往上跳</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">500000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">&#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN], father[MAXN][<span class="number">22</span>], lg[MAXN], depth[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt, n, m, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> returnValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = -x;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (returnValue) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next)</span> </span>&#123;</span><br><span class="line">    edge[++cnt].prev = prev;</span><br><span class="line">    edge[cnt].next = head[next];</span><br><span class="line">    head[next] = cnt; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfsInit</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    depth[root] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    father[root][<span class="number">0</span>] = fa;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= depth[root]; ++i) &#123;</span><br><span class="line">        father[root][i] = father[father[root][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[root]; e; e = edge[e].next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (edge[e].prev != fa) dfsInit(edge[e].prev, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们设x的深度大于y的深度</span></span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">while</span> (depth[x] &gt; depth[y]) </span><br><span class="line">        x = father[x][lg[depth[x] - depth[y]] - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x; <span class="comment">// x 是 y 的祖先</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg[depth[x]]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i];</span><br><span class="line">        <span class="comment">// 不相等就往上跳</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    n = getint(), m = getint(), s = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint(), next = getint();</span><br><span class="line">        addEdge(prev, next);</span><br><span class="line">        addEdge(next, prev);</span><br><span class="line">    &#125; </span><br><span class="line">    dfsInit(s, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    	lg[i] = lg[i<span class="number">-1</span>] + (<span class="number">1</span> &lt;&lt; lg[i<span class="number">-1</span>] == i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = getint(), y = getint();</span><br><span class="line">        putint(LCA(x, y), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>学习笔记</tag>
        <tag>LCA</tag>
        <tag>图论算法</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1531《I Hate It》</title>
    <url>/2018-08-05/Luogu-P1531/</url>
    <content><![CDATA[<blockquote>
<p>暴力能过的线段树板子题</p>
</blockquote>
<a id="more"></a>
<h1 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h1><p>很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。</p>
<p>学生ID编号分别从1编到N。</p>
<p>第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。</p>
<p>接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。</p>
<p>当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。</p>
<p>当C为’U’的时候，表示这是一条更新操作，如果当前A学生的成绩低于B，则把ID为A的学生的成绩更改为B，否则不改动。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每一次询问操作，在一行里面输出最高成绩</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 6</span><br><span class="line">1 2 3 4 5</span><br><span class="line">Q 1 5</span><br><span class="line">U 3 6</span><br><span class="line">Q 3 4</span><br><span class="line">Q 4 5</span><br><span class="line">U 2 9</span><br><span class="line">Q 1 5</span><br></pre></td></tr></table></figure>
<p> 输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>单点修改，区间查询 ……</p>
<p><del>线段树</del> 树状数组！</p>
<p>对了，注意处理输入，含读入<code>char</code>的题目最好不要用快读 ……</p>
<p><del>别问我怎么知道的</del></p>
<h2 id="线段树解法"><a href="#线段树解法" class="headerlink" title="线段树解法"></a>线段树解法</h2><p>可以说是很裸的一道题了</p>
<p>只需要单点修改，<code>lazyTag</code>什么的不需要的</p>
<p>就简单把<code>区间和查询</code>改成<code>区间最值查询</code>就行了</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="线段树解法-1"><a href="#线段树解法-1" class="headerlink" title="线段树解法"></a>线段树解法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], segt[MAXN * <span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    segt[root] = <span class="built_in">std</span>::max(segt[leftChild(root)], segt[rightChild(root)]);</span><br><span class="line">    <span class="comment">// 更新最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        segt[root] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    buildTree(l, mid, leftChild(root));</span><br><span class="line">    buildTree(mid + <span class="number">1</span>, r, rightChild(root));</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr, <span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-2147483640</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> segt[root];</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid) res = <span class="built_in">std</span>::max(res, query(l, mid, ql, qr, leftChild(root)));</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; qr) res = <span class="built_in">std</span>::max(res, query(mid + <span class="number">1</span>, r, ql, qr, rightChild(root)));</span><br><span class="line">    <span class="comment">// 查询最大值</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> dest, <span class="keyword">int</span> root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        segt[root] = <span class="built_in">std</span>::max(segt[root], k);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (dest &lt;= mid) Modify(l, mid, dest, leftChild(root), k);</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; dest) Modify(mid + <span class="number">1</span>, r, dest, rightChild(root), k);</span><br><span class="line">    pushUp(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> returnValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = -x;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (returnValue) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    buildTree(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="comment">// 推荐使用std::cin！</span></span><br><span class="line">        <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'Q'</span>: &#123;</span><br><span class="line">                putint(query(<span class="number">1</span>, n, a, b, <span class="number">1</span>), <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'U'</span>: &#123;</span><br><span class="line">                Modify(<span class="number">1</span>, n, a, <span class="number">1</span>, b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="暴力代码"><a href="#暴力代码" class="headerlink" title="暴力代码"></a>暴力代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> segt[MAXN]; </span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">		s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> returnValue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		x = -x;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">	<span class="keyword">if</span> (returnValue) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">-2147483640</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) res = <span class="built_in">std</span>::max(res, segt[i]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Modify</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	segt[r] = <span class="built_in">std</span>::max(segt[r], k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; segt[i];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cout</span> &lt;&lt; segt[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="keyword">char</span> op;</span><br><span class="line">		<span class="keyword">int</span> a, b;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="keyword">switch</span>(op) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'Q'</span>: &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; query(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'U'</span>: &#123;</span><br><span class="line">				Modify(a, b);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>数据结构</tag>
        <tag>暴力</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1563「NOIP2016」《玩具谜题》</title>
    <url>/2018-08-05/Luogu-P1563/</url>
    <content><![CDATA[<blockquote>
<p>暴力模拟</p>
</blockquote>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>小南有一套可爱的玩具小人, 它们各有不同的职业。</p>
<p>有一天, 这些玩具小人把小南的眼镜藏了起来。 小南发现玩具小人们围成了一个圈,它们有的面朝圈内,有的面朝圈外。如下图:</p>
<p><img src="https://cdn.luogu.org/upload/pic/3438.png" alt="img"></p>
<center><small><small>图片摘自洛谷</small></small></center>

<p>这时 singer 告诉小南一个谜題: “眼镜藏在我左数第3个玩具小人的右数第 1 个玩具小人的左数第 2 个玩具小人那里。 ”</p>
<p>小南发现, 这个谜题中玩具小人的朝向非常关键, 因为朝内和朝外的玩具小人的左右方向是相反的: 面朝圈内的玩具小人, 它的左边是顺时针方向, 右边是逆时针方向; 而面向圈外的玩具小人, 它的左边是逆时针方向, 右边是顺时针方向。</p>
<p>小南一边艰难地辨认着玩具小人, 一边数着:</p>
<p>singer 朝内, 左数第 3 个是 archer 。</p>
<p>archer 朝外,右数第 1 个是 thinker 。</p>
<p>thinker 朝外, 左数第 2 个是 writer。</p>
<p>所以眼镜藏在 writer这里!</p>
<p>虽然成功找回了眼镜, 但小南并没有放心。 如果下次有更多的玩具小人藏他的眼镜, 或是谜題的长度更长, 他可能就无法找到眼镜了 。 所以小南希望你写程序帮他解决类似的谜題。 这样的谜題具体可以描述为:</p>
<p>有 n 个玩具小人围成一圈, 已知它们的职业和朝向。现在第 1 个玩具小人告诉小南一个包含 m 条指令的谜題, 其中第 z 条指令形如“左数/右数第 s ,个玩具小人”。 你需要输出依次数完这些指令后,到达的玩具小人的职业。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input / Output 格式 &amp; 样例"></a>Input / Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行包含两个正整数 n,m ，表示玩具小人的个数和指令的条数。</p>
<p>接下来 n 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 0 表示朝向圈内， 1 表示朝向圈外。 保证不会出现其他的数。字符串长度不超过 10 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。</p>
<p>接下来 m 行，其中第 i 行包含两个整数 $ a_i,s_i$  ，表示第 i 条指令。若 $a_i=0$，表示向左数 $s_i$ 个人；若 $a_i=1$，表示向右数 $s_i$ 个人。 保证 $a_i$ 不会出现其他的数， $1 \le s_i &lt; n$ 。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个字符串，表示从第一个读入的小人开始，依次数完 m 条指令后到达的小人的职业。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7 3</span><br><span class="line">0 singer</span><br><span class="line">0 reader</span><br><span class="line">0 mengbier </span><br><span class="line">1 thinker</span><br><span class="line">1 archer</span><br><span class="line">0 writer</span><br><span class="line">1 mogician </span><br><span class="line">0 3</span><br><span class="line">1 1</span><br><span class="line">0 2</span><br></pre></td></tr></table></figure>
<p>输出样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">writer</span><br></pre></td></tr></table></figure>
<p>输入样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 10</span><br><span class="line">1 C</span><br><span class="line">0 r</span><br><span class="line">0 P</span><br><span class="line">1 d</span><br><span class="line">1 e</span><br><span class="line">1 m</span><br><span class="line">1 t</span><br><span class="line">1 y</span><br><span class="line">1 u</span><br><span class="line">0 V</span><br><span class="line">1 7</span><br><span class="line">1 1</span><br><span class="line">1 4</span><br><span class="line">0 5</span><br><span class="line">0 3</span><br><span class="line">0 1</span><br><span class="line">1 6</span><br><span class="line">1 2</span><br><span class="line">0 8</span><br><span class="line">0 4</span><br></pre></td></tr></table></figure>
<p>输出样例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y</span><br></pre></td></tr></table></figure>
<h1 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h1><p>$1 \le n,m \le 100000$</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一看就是<big><big><big>大</big>&lt;/big&gt;&lt;/big&gt; 模拟</big></big></p>
<p>用一个结构体来存每个玩具的名字和朝向</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Toy</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">bool</span> faceTo; <span class="comment">// 朝向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Toy t[MAXN];</span><br></pre></td></tr></table></figure>
<p>约定true表示朝向圈外，false表示朝向圈内</p>
<p>在读入操作时，用一个变量now记录当前转到了哪个玩具</p>
<p>最后输出<code>t[now].name</code>即可</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Toy</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">bool</span> faceTo;</span><br><span class="line">    <span class="comment">// true 表示朝向圈外 </span></span><br><span class="line">    <span class="comment">// false 表示朝向圈内 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Toy t[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> returnValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = -x;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (returnValue) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    n = getint(), m = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> to;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; to;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line">        t[i].faceTo = (to == <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>);</span><br><span class="line">        t[i].name = name; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tA = getint();</span><br><span class="line">        <span class="keyword">bool</span> right = tA == <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// true 表示在右边</span></span><br><span class="line">        <span class="comment">// false 表示在左边</span></span><br><span class="line">        <span class="keyword">int</span> s = getint();</span><br><span class="line">        <span class="keyword">if</span> (right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[now].faceTo == <span class="literal">true</span>) now -= s;</span><br><span class="line">            <span class="keyword">else</span> now += s;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[now].faceTo == <span class="literal">true</span>) now += s;</span><br><span class="line">            <span class="keyword">else</span> now -= s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now &gt; n) now -= n;</span><br><span class="line">        <span class="keyword">if</span> (now &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> moved = <span class="number">1</span> - now;</span><br><span class="line">            now = n + <span class="number">1</span> - moved;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t[now].name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后：</p>
<p><img src="https://s1.ax2x.com/2018/08/05/55Yun6.png" alt="55Yun6.png"></p>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>乘法逆元求法</title>
    <url>/2018-08-05/mul-inverse-modulo/</url>
    <content><![CDATA[<blockquote>
<p>数论中的重要内容</p>
</blockquote>
<a id="more"></a>
<p>注意：本文只讨论模数为质数的情况，因为当模数为合数时，不一定所有数都有逆元</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在$\bmod\ p$的意义下，我们把$x$的乘法逆元写作$x^{-1}$。乘法逆元有这样一条性质：</p>
<script type="math/tex; mode=display">x \times x^{-1} \equiv 1\ (\bmod\ p)</script><p>乘法逆元有什么用呢？<br></p>
<p>模意义下的<strong>除法运算</strong>！</p>
<p>除法运算对于模运算来说并不是「封闭」的，所以我们可以把除法<strong>转化</strong>成乘法</p>
<h2 id="费马小定理求法"><a href="#费马小定理求法" class="headerlink" title="费马小定理求法"></a>费马小定理求法</h2><p>前置知识：「快速幂」</p>
<blockquote>
<p> $a^{p-1} \equiv 1 (\bmod\ p)%$</p>
</blockquote>
<p>经过变形，可得</p>
<p>$a \times a^{p-2} \equiv 1(\bmod\ p)$</p>
<p>由定义可得，$a$的乘法逆元就是$a^{p-2}$</p>
<p>这就要用到「快速幂」</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">slowPower</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = <span class="number">1l</span>l * ans * a % p;</span><br><span class="line">        a = <span class="number">1l</span>l * a * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">invMod</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> slowPower(x, p - <span class="number">2</span>, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>输出1到n的逆元</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- Basic Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- STL Iterators -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- External Headers -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* -- Defined Functions -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> For(a,x,y) for (int a = x; a &lt;= y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Forw(a,x,y) for (int a = x; a &lt; y; ++a)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Bak(a,y,x) for (int a = y; a &gt;= x; --a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FastIO &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch = getchar();</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            s = s * <span class="number">10l</span>l + ch - <span class="string">'0'</span>;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">void</span> __basic_putint(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = -x;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) __basic_putint(x / <span class="number">10</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x, <span class="keyword">char</span> external)</span> </span>&#123;</span><br><span class="line">        __basic_putint(x);</span><br><span class="line">        <span class="built_in">putchar</span>(external);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Solution &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5000000</span> + <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> n, k, HA, a[MAXN];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> fac[MAXN], invf[MAXN];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">SlowPower</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  a^x mod m</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">while</span> (x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x &amp; <span class="number">1</span>) ret = ret * a % HA;</span><br><span class="line">            a = a * a % HA;</span><br><span class="line">            x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Solution;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FastIO;</span><br><span class="line">    n = getint(); HA = getint();</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        fac[i] = (fac[i - <span class="number">1</span>] * i) % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    invf[n] = SlowPower(fac[n], HA - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        invf[i] = (invf[i + <span class="number">1</span>] * (i + <span class="number">1</span>)) % HA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (invf[i] * fac[i - <span class="number">1</span>]) % HA);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划练习题代码</title>
    <url>/2018-08-03/DP-Exercise/</url>
    <content><![CDATA[<blockquote>
<p>DP 是啥？能吃吗？</p>
</blockquote>
<a id="more"></a>
<p>本文内容难度：从<code>普及-</code>到<code>普及+/提高</code></p>
<h1 id="数字三角形问题"><a href="#数字三角形问题" class="headerlink" title="数字三角形问题"></a>数字三角形问题</h1><p>给你一个数字三角形，计算出从三角形的顶至底的一条路径，使该路径经过的数字总和最大，</p>
<p>规定每一步只能从一个数走到下一层上和它最近的左边的数或者右边的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 设f[i][j]表示从第i行第j列走到底部的最优答案</span></span><br><span class="line"><span class="comment"> * 转移方程：f[i][j] = a[i][j] + max(f[i+1][j], f[i+1][j+1])</span></span><br><span class="line"><span class="comment"> * 注意边界</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-23333333</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            f[i][j] = a[i][j] + <span class="built_in">std</span>::max(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">    		ans = <span class="built_in">std</span>::max(ans, f[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一维线性动态规划"><a href="#一维线性动态规划" class="headerlink" title="一维线性动态规划"></a>一维线性动态规划</h1><h2 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意子序列可以不连续</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 设f[i]表示目前选第i个数时的最长上升子序列的长度</span></span><br><span class="line"><span class="comment"> * 也就是以第i个数结尾的最长上升子序列的长度</span></span><br><span class="line"><span class="comment"> * f[i] = std::max(1, f[j] + 1)</span></span><br><span class="line"><span class="comment"> * 其中1 &lt;= j &lt; i, a[j] &lt; a[i]</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n^2)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN], a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j)  &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) f[i] = <span class="built_in">std</span>::max(<span class="number">1</span>, f[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="「NOIP2004」合唱队形"><a href="#「NOIP2004」合唱队形" class="headerlink" title="「NOIP2004」合唱队形"></a>「NOIP2004」合唱队形</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">'='</span> &lt;&lt; x &lt;&lt; std::endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 正着求一遍最长上升子序列，反着求一遍最长上升子序列</span></span><br><span class="line"><span class="comment"> * （也就是接着求一遍最长下降子序列）</span></span><br><span class="line"><span class="comment"> * 用f数组存最长上升子序列长度</span></span><br><span class="line"><span class="comment"> * 用g数组存最长下降子序列长度</span></span><br><span class="line"><span class="comment"> * 答案是n - max(f[i] + g[i] - 1)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN], g[MAXN], a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) f[i] = <span class="built_in">std</span>::max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n+<span class="number">1</span>; j &gt; i; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i]) g[i] = <span class="built_in">std</span>::max(g[i], g[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-23333333</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    	ans = <span class="built_in">std</span>::max(ans, f[i] + g[i] - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n - ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段覆盖"><a href="#线段覆盖" class="headerlink" title="线段覆盖"></a>线段覆盖</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- DP 做法 -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 先对线段排序</span></span><br><span class="line"><span class="comment"> * 再设f[i]表示前i条线段中不重叠的最大数量</span></span><br><span class="line"><span class="comment"> * f[i] = max(f[i - 1], f[j] + 1)</span></span><br><span class="line"><span class="comment"> * 其中1 &lt;= j &lt; i, 第j条线段的右端点 &lt;= 第i条线段的左端点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个时间复杂度洛谷会RE（实为TLE） */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">&#125; line[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stlCmp</span><span class="params">(Line x, Line y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.right &lt; y.right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    	<span class="built_in">cin</span> &gt;&gt; line[i].left &gt;&gt; line[i].right;</span><br><span class="line">    	<span class="keyword">if</span> (line[i].left &gt; line[i].right) swap(line[i].left, line[i].right);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(line + <span class="number">1</span>, line + <span class="number">1</span> + n, stlCmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line[j].right &lt;= line[i].left) f[i] = <span class="built_in">std</span>::max(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-23333333</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ans = <span class="built_in">std</span>::max(ans, f[i]); </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* -- 贪心做法 -- */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left, right;</span><br><span class="line">&#125; line[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stlCmp</span><span class="params">(Line x, Line y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.right &lt; y.right;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">cin</span> &gt;&gt; line[i].left &gt;&gt; line[i].right;</span><br><span class="line">    sort(line + <span class="number">1</span>, line + <span class="number">1</span> + n, stlCmp);</span><br><span class="line">    <span class="keyword">int</span> maxRight = <span class="number">-23333333</span>, lines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxRight &lt;= line[i].left) ++lines, maxRight = line[i].right;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lines &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h1><h2 id="「NOIP2008」传纸条"><a href="#「NOIP2008」传纸条" class="headerlink" title="「NOIP2008」传纸条"></a>「NOIP2008」传纸条</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设dp[i][j][x][y] 表示第一张纸条传到了(i, j)，第二张纸条传到了(x, y)时</span></span><br><span class="line"><span class="comment"> * 的最大答案 </span></span><br><span class="line"><span class="comment"> * dp[i][j][k][l] = std::max(</span></span><br><span class="line"><span class="comment"> *                      std::max(</span></span><br><span class="line"><span class="comment"> *					        dp[i-1][j][k-1][l], </span></span><br><span class="line"><span class="comment"> *                          dp[i][j-1][k-1][l]</span></span><br><span class="line"><span class="comment"> *					    ), </span></span><br><span class="line"><span class="comment"> *					    std::max(</span></span><br><span class="line"><span class="comment"> *					        dp[i-1][j][k][l-1], </span></span><br><span class="line"><span class="comment"> *					        dp[i][j-1][k][l-1]</span></span><br><span class="line"><span class="comment"> *						)</span></span><br><span class="line"><span class="comment"> *					) </span></span><br><span class="line"><span class="comment"> *					+ a[i][j] </span></span><br><span class="line"><span class="comment"> *					+ a[k][l] </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 其中 j+1 &lt;= l &lt;= n</span></span><br><span class="line"><span class="comment"> * 最终答案是dp[m][n-1][m-1][n] </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">/*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAX][MAX][MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> n, m, a[MAX][MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> returnValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = -x;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (returnValue) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    m = getint(), n = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            a[i][j] = getint();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; ++k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = j + <span class="number">1</span>; l &lt;= n; ++l) &#123;</span><br><span class="line">                    dp[i][j][k][l] = <span class="built_in">std</span>::max(<span class="built_in">std</span>::max(dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][l], dp[i<span class="number">-1</span>][j][k][l<span class="number">-1</span>]), <span class="built_in">std</span>::max(dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][l], dp[i][j<span class="number">-1</span>][k][l<span class="number">-1</span>])) + a[i][j] + a[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    putint(dp[m][n<span class="number">-1</span>][m<span class="number">-1</span>][n], <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="「NOIP2008-普及」-传球游戏"><a href="#「NOIP2008-普及」-传球游戏" class="headerlink" title="「NOIP2008 普及」 传球游戏"></a>「NOIP2008 普及」 传球游戏</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">30</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设dp[i][j]表示球传到第i次，传到第j个小朋友手中时的方案数</span></span><br><span class="line"><span class="comment"> * dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] </span></span><br><span class="line"><span class="comment"> * 其中dp[0][1] = 1，ans = dp[m][1] </span></span><br><span class="line"><span class="comment">/*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> dp[MAXM][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">		s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> returnValue)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		x = -x;</span><br><span class="line">		<span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">	<span class="keyword">if</span> (returnValue) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">	n = getint(), m = getint();</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">2</span>] + dp[i<span class="number">-1</span>][n];</span><br><span class="line">		dp[i][n] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + dp[i<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; ++j) &#123;</span><br><span class="line">			dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	putint(dp[m][<span class="number">1</span>], <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="NASA-的食物计划"><a href="#NASA-的食物计划" class="headerlink" title="NASA 的食物计划"></a>NASA 的食物计划</h2><p><code>普及-</code>，很水</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXVolume = <span class="number">400</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXWeight = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxVolume, maxWeight, n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXVolume][MAXWeight];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Food</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Volume;</span><br><span class="line">    <span class="keyword">int</span> Weight;</span><br><span class="line">    <span class="keyword">int</span> Calories;</span><br><span class="line">&#125; food[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> newLine)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (newLine) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    maxVolume = getint();</span><br><span class="line">    maxWeight = getint();</span><br><span class="line">    n = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        food[i].Volume = getint();</span><br><span class="line">        food[i].Weight = getint();</span><br><span class="line">        food[i].Calories = getint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = maxVolume; j &gt;= food[i].Volume; --j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = maxWeight; k &gt;= food[i].Weight; --k) &#123;</span><br><span class="line">                f[j][k] = <span class="built_in">std</span>::max(f[j][k], f[j - food[i].Volume][k - food[i].Weight] + food[i].Calories);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[maxVolume][maxWeight]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="装箱问题"><a href="#装箱问题" class="headerlink" title="装箱问题"></a>装箱问题</h2><p>真 · 背包问题模板题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">30</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">20000</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> item[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXV];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; item[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= v; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= item[i]) f[i][j] = <span class="built_in">std</span>::max(f[i<span class="number">-1</span>][j], f[i<span class="number">-1</span>][j-item[i]] + item[i]);</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v - f[n][v] &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="榨取kkksc03"><a href="#榨取kkksc03" class="headerlink" title="榨取kkksc03"></a>榨取kkksc03</h2><p>实在想不通这题为啥是<code>普及/提高-</code>，不应该是<code>普及-</code>吗</p>
<p><del>所以这就是你评<code>普及/提高-</code>的理由？</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> __RETURN = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> __NO_RETURN = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXT = <span class="number">200</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m ,T; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dream</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line">&#125; d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXM][MAXT];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 设dp[i][j][k]表示当选择第i个愿望，</span></span><br><span class="line"><span class="comment"> * 时间不超过j，金钱不超过k时的最大数量</span></span><br><span class="line"><span class="comment"> * dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-d[i].time][k-d[i].cost] + 1)</span></span><br><span class="line"><span class="comment"> * 其中 j &gt;= d[i].time, k &gt;= d[i].cost </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> returnValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = -x;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) putint(x / <span class="number">10</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span> (returnValue) <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    n = getint(), m = getint(), T = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        d[i].time = getint();</span><br><span class="line">        d[i].cost = getint();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= T; ++k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= d[i].time &amp;&amp; k &gt;= d[i].cost) &#123;</span><br><span class="line">                    dp[i][j][k] = <span class="built_in">std</span>::max(dp[i<span class="number">-1</span>][j][k], dp[i<span class="number">-1</span>][j - d[i].time][k - d[i].cost] + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j][k] = dp[i<span class="number">-1</span>][j][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    putint(dp[n][m][T], __RETURN); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1892《[BOI2003]团伙》</title>
    <url>/2018-07-28/Luogu-P1892/</url>
    <content><![CDATA[<blockquote>
<p>本题来自「2018 SDSC」Day 3 考试题目</p>
</blockquote>
<p><a href="https://www.luogu.org/problemnew/show/P1892" target="_blank" rel="noopener">题目链接</a></p>
<a id="more"></a>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>1920年的芝加哥，出现了一群强盗。如果两个强盗遇上了，那么他们要么是朋友，要么是敌人。而且有一点是肯定的，就是：</p>
<p>我朋友的朋友是我的朋友；</p>
<p>我敌人的敌人也是我的朋友。</p>
<p>两个强盗是同一团伙的条件是当且仅当他们是朋友。现在给你一些关于强盗们的信息，问你最多有多少个强盗团伙。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h1><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件gangs.in的第一行是一个整数N(2&lt;=N&lt;=1000)，表示强盗的个数（从1编号到N）。 <br><br>第二行M(1&lt;=M&lt;=5000)，表示关于强盗的信息条数。 <br><br>以下M行，每行可能是<code>F p q</code>或是<code>E p q</code>（1&lt;=p q&lt;=N），F表示p和q是朋友，E表示p和q是敌人。<br><br>输入数据保证不会产生信息的矛盾。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件gangs.out只有一行，表示最大可能的团伙数。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">4</span><br><span class="line">E 1 4</span><br><span class="line">F 3 5</span><br><span class="line">F 4 6</span><br><span class="line">E 1 2</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>很显然这是一道并查集的题目</p>
<p>初始时我们把每一个人单独列为一个团伙</p>
<p>由题可得，这道题主要有如下合并方式：</p>
<ol>
<li>我的朋友是我的朋友</li>
<li>我的朋友的朋友是我的朋友</li>
<li>我的敌人的朋友是我的敌人</li>
<li>我的敌人的敌人是我的朋友</li>
</ol>
<p>那么我们要另开一个$Enemy[\ ]$数组，$Enemy[i]$表示 $i$ 的<strong>其中一个</strong>敌人</p>
<p>每次合并敌人的时候，先判断是否有记录过敌人：</p>
<ul>
<li>如果有，那么就把当前的敌人和记录的敌人合并在一个团伙里</li>
<li>如果没有，那么就把当前的敌人记录</li>
</ul>
<p>最后开一个数组$count[\ ]$进行统计</p>
<p><strong><big><big>这里要注意几个点：</big>&lt;/big&gt;</big></strong></p>
<ol>
<li>开始时并查集数组要<strong>开两倍</strong>，因为你要把敌人和朋友存在一个数组里</li>
<li>合并敌人时要注意合并的不是敌人本身，而是$Find($敌人$)$</li>
<li>最后统计的时候也要统计$Find($敌人$)$</li>
</ol>
<p>对了，注意输入…<br><br>建议使用iostream…<br><br>别问我为什么会写上这句话</p>
<p><a href="https://imgse.com/i/53vhll" target="_blank" rel="noopener"><img src="https://s1.ax2x.com/2018/07/28/53vhll.png" alt="53vhll.png"></a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXN * <span class="number">2</span>], Enemy[MAXN * <span class="number">2</span>], n, m;</span><br><span class="line"><span class="keyword">int</span> count[MAXN * <span class="number">2</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">putint</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = -x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        putint(x / <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = Find(x), y = Find(y);</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">    U[x] = y;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"P1892.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n * <span class="number">2</span>; ++i) U[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'F'</span>: &#123;</span><br><span class="line">                Union(x, y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> (Enemy[x] == <span class="number">0</span>) Enemy[x] = Find(y);</span><br><span class="line">                <span class="keyword">else</span> Union(y, Enemy[x]);</span><br><span class="line">                <span class="keyword">if</span> (Enemy[y] == <span class="number">0</span>) Enemy[y] = Find(x);</span><br><span class="line">                <span class="keyword">else</span> Union(x, Enemy[y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) ++count[Find(i)];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="keyword">if</span> (count[i]) ++cnt;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1821 《[USACO07FEB]银牛派对Silver Cow Party》</title>
    <url>/2018-07-20/Luogu-P1821/</url>
    <content><![CDATA[<blockquote>
<p>巧妙地把单终点最短路径问题转化为单源最短路径问题</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problem/show?pid=1821" target="_blank" rel="noopener">题目地址</a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>寒假到了，N头牛都要去参加一场在编号为X（1≤X≤N）的牛的农场举行的派对（1≤N≤1000），农场之间有M（1≤M≤100000）条有向路，每条路长Ti（1≤Ti≤100）。</p>
<p>每头牛参加完派对后都必须回家，无论是去参加派对还是回家，每头牛都会选择最短路径，求这N头牛的最短路径（一个来回）中最长的一条路径长度。</p>
<h1 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h1><p><strong>输入格式：</strong><br><br>第一行三个整数N，M, X；</p>
<p>第二行到第M+1行：每行有三个整数Ai，Bi, Ti ,表示有一条从Ai农场到Bi农场的道路，长度为Ti。</p>
<p><strong>输出格式：</strong><br><br>一个整数，表示最长的最短路得长度。</p>
<p><strong>输入样例#1：</strong><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 8 2</span><br><span class="line">1 2 4</span><br><span class="line">1 3 2</span><br><span class="line">1 4 7</span><br><span class="line">2 1 1</span><br><span class="line">2 3 5</span><br><span class="line">3 1 2</span><br><span class="line">3 4 4</span><br><span class="line">4 2 3</span><br></pre></td></tr></table></figure></p>
<p><strong>输出样例#1：</strong><br><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure></p>
<h1 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h1><p><img src="https://cdn.luogu.org/upload/pic/667.png" alt><br><br><small>图片来自洛谷</small></p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>单源最短路我们都会做，一遍<code>SPFA</code>或<code>Dijkstra</code>就行了。</p>
<p>单终点最短路呢？</p>
<p>对于这道题，奶牛们从派对分别回家就是一个单源最短路问题，而奶牛们从家到派对就是一个单终点最短路问题。</p>
<p>如何把单终点最短路转化为单源最短路问题？<br>注意：题目中建的是有向边</p>
<p>实在是想不出来的我翻了一波题解，发现他们都在输入的时候另建了一个图，<big><strong>反向存边</strong></big>，就完美地把一个单终点最短路转化为单源最短路<br><br>因为单源和单终点的区别仅仅是<big><strong>方向改变</strong></big>，很显然这么做是对的</p>
<p>最后的答案是什么？<br><br>正向建图的距离+反向建图的距离的最大值</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>我们在数组后加上「Reversed」，表示它存的是反向的图</p>
<p><a href="https://www.luogu.org/record/show?rid=8666784" target="_blank" rel="noopener">评测记录 AC</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prev;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">&#125; edge[MAXM], edgeReversed[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, x, cnt, maxWeight = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN], head[MAXN], disReversed[MAXN], headReversed[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inQueue[MAXN], inQueueReversed[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        (ch == <span class="string">'-'</span>) &amp;&amp; (x = <span class="number">-1</span>);</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdgeReversed</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    edgeReversed[cnt].prev = prev;</span><br><span class="line">    edgeReversed[cnt].weight = weight;</span><br><span class="line">    edgeReversed[cnt].next = headReversed[next];</span><br><span class="line">    headReversed[next] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> prev, <span class="keyword">int</span> next, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">    edge[++cnt].prev = prev;</span><br><span class="line">    edge[cnt].weight = weight;</span><br><span class="line">    edge[cnt].next = head[next];</span><br><span class="line">    head[next] = cnt;</span><br><span class="line">    addEdgeReversed(next, prev, weight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inQueue, <span class="number">0</span>, <span class="keyword">sizeof</span>(inQueue));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) dis[i] = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; q;</span><br><span class="line">    inQueue[s] = <span class="literal">true</span>;</span><br><span class="line">    q.push(make_pair(s, <span class="number">0</span>));</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = q.top().first;</span><br><span class="line">        <span class="keyword">int</span> weight = q.top().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        inQueue[prev] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = head[prev]; e; e = edge[e].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[edge[e].prev] &gt; edge[e].weight + weight) &#123;</span><br><span class="line">                dis[edge[e].prev] = edge[e].weight + weight;</span><br><span class="line">                q.push(make_pair(edge[e].prev, dis[edge[e].prev])); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DijkstraReversed</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(inQueueReversed, <span class="number">0</span>, <span class="keyword">sizeof</span>(inQueueReversed));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) disReversed[i] = <span class="number">2147483647</span>;</span><br><span class="line">    <span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; q;</span><br><span class="line">    inQueueReversed[s] = <span class="literal">true</span>;</span><br><span class="line">    q.push(make_pair(s, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = q.top().first;</span><br><span class="line">        <span class="keyword">int</span> weight = q.top().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        inQueueReversed[prev] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = headReversed[prev]; e; e = edgeReversed[e].next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (disReversed[edgeReversed[e].prev] &gt; edgeReversed[e].weight + weight) &#123;</span><br><span class="line">                disReversed[edgeReversed[e].prev] = edgeReversed[e].weight + weight;</span><br><span class="line">                q.push(make_pair(edgeReversed[e].prev, disReversed[edgeReversed[e].prev])); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    n = getint(), m = getint(), x = getint();</span><br><span class="line">    <span class="keyword">int</span> tm = m;</span><br><span class="line">    <span class="keyword">while</span> (tm --&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> prev = getint(), next = getint(), weight = getint();</span><br><span class="line">        addEdge(prev, next, weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tn = n;</span><br><span class="line">    Dijkstra(x, n);</span><br><span class="line">    DijkstraReversed(x, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        maxWeight = <span class="built_in">std</span>::max(maxWeight, dis[i] + disReversed[i]);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, maxWeight);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1149《火柴棒等式》</title>
    <url>/2018-07-15/Luogu-P1149/</url>
    <content><![CDATA[<blockquote>
<p>「枚举」的入门题目</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P1149" target="_blank" rel="noopener">题目地址</a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你n根火柴棍，你可以拼出多少个形如$ A+B=C$的等式？等式中的 $A 、 B 、 C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$ ）。用火柴棍拼数字 $0-9$ 的拼法如图所示：</p>
<p><img src="https://cdn.luogu.org/upload/pic/49.png" alt="img"></p>
<center><small>图片来自洛谷</small></center>

<p>注意：</p>
<ol>
<li>加号与等号各自需要两根火柴棍</li>
<li>如果 $A≠B$ ，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式( $A,B,C&gt;=0$ )</li>
<li>$n$ 根火柴棍必须全部用上</li>
</ol>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p><strong>输入格式：</strong></p>
<p>一个整数 $n$($n&lt;=24$) 。</p>
<p><strong>输出格式：</strong></p>
<p>一个整数，能拼成的不同等式的数目。</p>
<p><strong>输入样例#1：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure></p>
<p><strong>输出样例#1：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p><strong>输入样例#2：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18</span><br></pre></td></tr></table></figure></p>
<p><strong>输出样例#2：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure></p>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>【输入输出样例1解释】</p>
<p>$2$ 个等式为 $0+1=1$ 和 $1+0=1$ 。</p>
<p>【输入输出样例2解释】</p>
<p>$9$ 个等式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0+4=4</span><br><span class="line">0+11=11</span><br><span class="line">1+10=11</span><br><span class="line">2+2=4</span><br><span class="line">2+7=9</span><br><span class="line">4+0=4</span><br><span class="line">7+2=9</span><br><span class="line">10+1=11</span><br><span class="line">11+0=11</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="枚举思路"><a href="#枚举思路" class="headerlink" title="枚举思路"></a>枚举思路</h2><p>我们可以枚举$A$和$B$</p>
<big><strong>上界？</strong></big>

<p>手算啊</p>
<p>$n&lt;=24$，去掉符号用的4根火柴棒，相当于是「$n&lt;=20$」</p>
<p>再$\frac{n}{2}$（这里只考虑有$A$和$B$两个数字），可得</p>
<blockquote>
<p>对于某一个数字，可调用的火柴棒共有10个</p>
</blockquote>
<p>由于使用火柴棒数量最少的$1$要使用2根，所以我们假设两个数字都为$11111$，但是显然这样是不成立的，因为$2\times5 + 2 * 5$就已经达到$20$了，没有火柴棒再放第三个数字，那么由此可粗略得出</p>
<blockquote>
<p>对于某一个数字，它最高有5位</p>
</blockquote>
<p>于是我们可以选择枚举到$9999$，洛谷的评测机上也不会TLE</p>
<p>当然CCF的老爷机就不一定了（</p>
<p>于是我们可以选择再精确一点</p>
<p>// 未完待<strong>续</strong></p>
<p>枚举之后相加，取出所用的火柴棒数，进行判断就好了</p>
<h2 id="预处理思路"><a href="#预处理思路" class="headerlink" title="预处理思路"></a>预处理思路</h2><p>火柴棒数怎么求？</p>
<p>新建一个数组 f[10000 * 2 + 10] ，表示i这个数字需要用f[i]根火柴</p>
<p>题目已经给出了f[0~9]，如何处理出f[10~(10000*2)]？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f[i] = f[i/<span class="number">10</span>] + f[i%<span class="number">10</span>]; <span class="comment">// (i &gt;= 10)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里的i/10可以取它除了个位上其他位的数，在前面已经处理过，</span></span><br><span class="line"><span class="comment">所以可以直接使用；这里的i%10可以取它个位上的数，也处理过，</span></span><br><span class="line"><span class="comment">可以直接使用。两个火柴棒数目一相加，就能获得火柴棒的总数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>循环一遍就好了</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sticks[<span class="number">10001</span> * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">	sticks[<span class="number">0</span>] = sticks[<span class="number">6</span>] = sticks[<span class="number">9</span>] = <span class="number">6</span>;</span><br><span class="line">	sticks[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">	sticks[<span class="number">2</span>] = sticks[<span class="number">3</span>] = sticks[<span class="number">5</span>] = <span class="number">5</span>;</span><br><span class="line">	sticks[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line">	sticks[<span class="number">7</span>] = <span class="number">3</span>;</span><br><span class="line">	sticks[<span class="number">8</span>] = <span class="number">7</span>;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt;= <span class="number">20000</span>; ++i) &#123;</span><br><span class="line">		sticks[i] = sticks[i/<span class="number">10</span>] + sticks[i%<span class="number">10</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9999</span>; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9999</span>; ++j) &#123;</span><br><span class="line">			<span class="keyword">if</span> (sticks[i] + <span class="number">2</span> + sticks[j] + <span class="number">2</span> + sticks[i+j] == n) ++sum;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>暴力</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>2017 国庆清北刷题冲刺班 《角谷猜想》</title>
    <url>/2018-07-04/Kakutani/</url>
    <content><![CDATA[<blockquote>
<p>不错的字符串模拟</p>
</blockquote>
<a id="more"></a>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>某个名字末尾是654321的小A同学是个大家眼中公认的学霸（虽然他永远不承认），他对题目的直觉到了一种可怕的地步，一眼看出题目的算法对他而言只是小 Case，他甚至能在看到一个证明的瞬间敏锐地判断出这个证明的真伪。</p>
<p>现在小A同学机缘巧合地看到了角古猜想（即对于$x$当它为奇数则$x=3x+1$,$x$为偶数，则$x=\frac{x}{2}$，一直重复这个步骤，则最终$x$会变为$1$），在看完这个猜想的一瞬间，他的直觉就来了——他认为角古猜想一定是错的！然后——他立刻就能找出反例！</p>
<p>他立刻在纸上写满了$n$($1&lt;=n&lt;=1000$)个小于$10^L$($0&lt;=L&lt;=10^4$)的正整数，打算放到他的grand super computer 上去跑，可是他突然觉得有些正整数不是很吉利，可能会干扰到他的最终结果，所以他打算把一些正整数加工一下。</p>
<p>小A觉得4、7、13都是不吉利的数字，所以要把所有正整数里的4、7、13都去掉，如果去掉后得到的新数字里依旧有4、7、13，那么就要继续删掉，直到最后的数组不存在4、7、13，它才是一个吉利的数字。例如$1411733=&gt;111733=&gt;11133=&gt;113=&gt;1$<br>特别规定，如果最后所有数字都被删掉了，就输出$0$<br>小A觉得这个枯燥的工作不适合他这样的天才，于是就把这个工作交给了你。</p>
<p>当然，只要你能顺利解决，小A承诺会在那篇将会震惊世界的论文的特别感谢栏上署上你的大名。</p>
<h2 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h2><p><strong>Input</strong></p>
<p>一共$n+1$行。</p>
<p>第一行一个正整数$n$($1&lt;=n&lt;=100$)，表示数字个数。</p>
<p>接下来每行一个正整数$x$。</p>
<p><strong>Output</strong></p>
<p>一共$n$行。</p>
<p>每行一个正整数，表示输入每个$x$对应的答案。</p>
<p><strong>Sample Input 1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">13713</span><br><span class="line">141713</span><br><span class="line">1333333372589</span><br><span class="line">1411733</span><br><span class="line">2147483647</span><br></pre></td></tr></table></figure>
<p><strong>Sample Output1</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">11</span><br><span class="line">3333332589</span><br><span class="line">1</span><br><span class="line">21836</span><br></pre></td></tr></table></figure>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于$10%$的数据，$0&lt;=x&lt;=2147483647$<br>对于另外的$10%$数据，给定的数字没有数码$3$<br>对于另外的$10%$数据，$n=1$<br>对于全部的数据，$n$($1&lt;=n&lt;=1000$)，$1&lt;=x&lt;=10^L$($0&lt;=L&lt;=10^4$)</p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>「$1&lt;=x&lt;=10^L$($0&lt;=L&lt;=10^4$)」</p>
<p>显而易见的高精</p>
<p>进而联想到字符串模拟</p>
<p>这道题有两个点需要注意：</p>
<ul>
<li>顺序不能乱</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先执行删除4和7的操作，再执行删除13的操作</span><br></pre></td></tr></table></figure>
<ul>
<li>在删除13时要检查是否残留</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">样例里有一个数据1411733</span><br><span class="line">先删除4和7，得到11133</span><br><span class="line">再删除13，得到113</span><br><span class="line"></span><br><span class="line">假如只删除一次13，那么就会有残留的13出现</span><br><span class="line">所以要在删除之后进行检查，</span><br><span class="line">否则就需要递归，将13再次删除</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://aor.sd.cn/status/c758e25f7995b52f5662fa42a25f384e" target="_blank" rel="noopener">评测记录 AC</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">eraseAll4s</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> len = x.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span> (x[i] == <span class="string">'4'</span>) x[i] = <span class="string">'-'</span>; <span class="comment">// 删除的'4'用'-'表示</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span> (<span class="built_in">isdigit</span>(x[i])) ret += x[i]; <span class="comment">// 采集存留的数字，组成一个新的字符串</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">eraseAll7s</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码思想一样，不再赘述</span></span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> len = x.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span> (x[i] == <span class="string">'7'</span>) x[i] = <span class="string">'-'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span> (<span class="built_in">isdigit</span>(x[i])) ret += x[i];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">eraseAll13s</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> len = x.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x[i] == <span class="string">'1'</span> &amp;&amp; x[i+<span class="number">1</span>] == <span class="string">'3'</span>) x[i] = x[i+<span class="number">1</span>] = <span class="string">'-'</span>;</span><br><span class="line">        <span class="comment">// 注意这里要同时检测两个字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> b = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) <span class="keyword">if</span> (<span class="built_in">isdigit</span>(x[i])) ret += x[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 重新进行检查</span></span><br><span class="line">        <span class="keyword">if</span> (ret[i] == <span class="string">'1'</span> &amp;&amp; ret[i+<span class="number">1</span>] == <span class="string">'3'</span>) &#123;</span><br><span class="line">            b = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b) &#123;</span><br><span class="line">        ret = eraseAll13s(ret); <span class="comment">// 递归删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Modify</span><span class="params">(<span class="built_in">string</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret = <span class="string">""</span>;</span><br><span class="line">    ret = eraseAll4s(x);</span><br><span class="line">    ret = eraseAll7s(ret);</span><br><span class="line">    ret = eraseAll13s(ret);</span><br><span class="line">    <span class="comment">// 进行删除</span></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="string">""</span>) ret = <span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n --&gt; <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">           这里是一个比较神奇的 while()，</span></span><br><span class="line"><span class="comment">           效果相当于 for (int i = 0; i &lt; n; ++i)，</span></span><br><span class="line"><span class="comment">           但是会对n进行修改，下标也是从n-1到0</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; Modify(v) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P2330 《[SCOI2005]繁忙的都市》</title>
    <url>/2018-07-04/Luogu-P2330/</url>
    <content><![CDATA[<blockquote>
<p>接近裸的最小生成树</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P2330" target="_blank" rel="noopener">题目地址</a></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市C的道路是这样分布的：城市中有n个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：</p>
<p>1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2．在满足要求1的情况下，改造的道路尽量少。 3．在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。</p>
<p>任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。</p>
<h2 id="Input-Output-格式-amp-样例"><a href="#Input-Output-格式-amp-样例" class="headerlink" title="Input/Output 格式 &amp; 样例"></a>Input/Output 格式 &amp; 样例</h2><p><strong>输入格式</strong>：</p>
<p>第一行有两个整数n,m表示城市有n个交叉路口，m条道路。</p>
<p>接下来m行是对每条道路的描述，u, v, c表示交叉路口u和v之间有道路相连，分值为c。(1≤n≤300，1≤c≤10000，1≤m≤50000)</p>
<p><strong>输出格式</strong>：</p>
<p>两个整数s, max，表示你选出了几条道路，分值最大的那条道路的分值是多少。</p>
<p>输入样例#1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2 3</span><br><span class="line">1 4 5</span><br><span class="line">2 4 7</span><br><span class="line">2 3 6</span><br><span class="line">3 4 8</span><br></pre></td></tr></table></figure></p>
<p>输出样例#1：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6</span><br></pre></td></tr></table></figure></p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>前面已经提到过，</p>
<p>$1 \le n \le 300, 1 \le c \le 10000, 1 \le m \le 50000$</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>「1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。」</p>
<p>显然这是一道<strong>最小生成树</strong>的题目</p>
<p>但是题目中并没有要求输出最小的总权值，而是要输出最长边边权</p>
<p>所以它和裸的最小生成树还是有一些区别的</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://www.luogu.org/record/show?rid=8135156" target="_blank" rel="noopener">评测记录 AC</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">50000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> cntTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> prev, next, w;</span><br><span class="line">&#125; edge[MAXM * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sortCmp</span><span class="params">(Edge x, Edge y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> treeAns = <span class="number">0</span>;</span><br><span class="line">    sort(edge + <span class="number">1</span>, edge + <span class="number">1</span> + m, sortCmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAXN; ++i) U[i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> eprev = Find(edge[i].prev);</span><br><span class="line">        <span class="keyword">int</span> enext = Find(edge[i].next);</span><br><span class="line">        <span class="keyword">if</span> (eprev == enext) <span class="keyword">continue</span>;</span><br><span class="line">        treeAns += edge[i].w;</span><br><span class="line">        U[eprev] = enext;</span><br><span class="line">        ret = max(ret, edge[i].w); <span class="comment">// 更新权值</span></span><br><span class="line">        ++cntTree;</span><br><span class="line">        <span class="keyword">if</span> (cntTree == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    n = getint(), m = getint();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = getint(), next = getint(), w = getint();</span><br><span class="line">        edge[i].prev = v;</span><br><span class="line">        edge[i].next = next;</span><br><span class="line">        edge[i].w = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = Kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, n - <span class="number">1</span>, ans);</span><br><span class="line">    <span class="comment">// 显而易见，生成的树肯定有 n - 1 条边，所以直接输出 n - 1 就好</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>生成树</tag>
        <tag>各省省选</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路径算法</title>
    <url>/2018-07-03/ShortestPath/</url>
    <content><![CDATA[<blockquote>
<p>较简单的图论算法</p>
</blockquote>
<a id="more"></a>
<p>最短路算法有很多种，比较著名的有</p>
<ul>
<li>Bellman-Ford</li>
<li>SPFA（队列优化版 Bellman-Ford）</li>
<li>Dijkstra</li>
<li>Floyd（基于DP思想）</li>
</ul>
<p>其中 Floyd 只适用于多源最短路径，SPFA 和 Bellman-Ford 代码易于理解但是效率低，Dijkstra 效率高但是不适用于图中有负边权的情况</p>
<p><del>至于其他算法……我见过某个dalao用线段树写最短路</del></p>
<p>本文只介绍单源最短路径中的 SPFA 和 Dijkstra （ Bellman-Ford 由于速度慢于 SPFA 所以忽略）。</p>
<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA 可以处理图含有负边权的情况，同时又因为它效率较低，所以它更适合处理稀疏图</p>
<p>这里给出数组版代码</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXINT = <span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">6200</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, next, w;</span><br><span class="line">&#125;edge[MAXM * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[MAXN];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inQueue[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[++cnt].v = v;</span><br><span class="line">  edge[cnt].w = w;</span><br><span class="line">  edge[cnt].next = head[u];</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = MAXINT;</span><br><span class="line">  dis[s] = <span class="number">0</span>;</span><br><span class="line">  inQueue[s] = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  q.push(s);</span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">    inQueue[v] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[v]; e; e = edge[e].next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dis[edge[e].v] &gt; edge[e].w + dis[v]) &#123;</span><br><span class="line">        dis[edge[e].v] = edge[e].w + dis[v];</span><br><span class="line">        <span class="keyword">if</span> (!inQueue[edge[e].v]) &#123;</span><br><span class="line">            q.push(edge[e].v);</span><br><span class="line">            inQueue[edge[e].v] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n, m, s, t;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    n for the nodes' count</span></span><br><span class="line"><span class="comment">    m for the edges' count</span></span><br><span class="line"><span class="comment">    s for the start node</span></span><br><span class="line"><span class="comment">    t for the end node</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d %d %d\n"</span>, &amp;n, &amp;m, &amp;s, &amp;t);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d\n"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">    addEdge(u, v, w);</span><br><span class="line">    addEdge(v, u, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, SPFA(s, t, n));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><p>Dijkstra 不能解决图中有负边权的情况，算法效率较高，适合在不含负边权的稠密/稀疏图中使用</p>
<p>这里还是给出数组写法</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp std::make_pair</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000000</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Pair;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> ch = getchar();</span><br><span class="line">  <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = -x;</span><br><span class="line">    ch = getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">    s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">    ch = getchar();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> v, next, w;</span><br><span class="line">&#125;edge[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, head[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> inQueue[MAXN];</span><br><span class="line"></span><br><span class="line">ll dis[MAXN]; <span class="comment">// dis[i] --&gt; the distance from i to n</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  edge[++num].v = v;</span><br><span class="line">  edge[num].w = w;</span><br><span class="line">  edge[num].next = head[u];</span><br><span class="line">  head[u] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// s for start, t for end, n for the count of the nodes</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) dis[i] = INF;</span><br><span class="line">  <span class="built_in">std</span>::priority_queue&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;, <span class="built_in">std</span>::greater&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; &gt; q;</span><br><span class="line">  inQueue[s] = <span class="literal">true</span>;</span><br><span class="line">  dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  q.push(mp(s,<span class="number">0</span>)); </span><br><span class="line">  <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">    <span class="keyword">int</span> v = q.top().first;</span><br><span class="line">    <span class="keyword">int</span> value = q.top().second;</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = head[v]; e; e = edge[e].next) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dis[edge[e].v] &gt; value + edge[e].w) &#123;</span><br><span class="line">        dis[edge[e].v] = (value + edge[e].w) ; </span><br><span class="line">        q.push(mp(edge[e].v, dis[edge[e].v]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dis[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  n = getint(), m = getint();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, z;</span><br><span class="line">    x = getint(), y = getint(), z = getint();</span><br><span class="line">    addEdge(x, y, z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dijkstra(<span class="number">1</span>, n, n)); </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1955 《[NOI2015]程序自动分析》</title>
    <url>/2018-05-12/Luogu-P1955/</url>
    <content><![CDATA[<blockquote>
<p>第一道NOI的题目</p>
</blockquote>
<a id="more"></a>
<h1 id="洛谷-P1955-题解"><a href="#洛谷-P1955-题解" class="headerlink" title="洛谷 P1955 题解"></a>洛谷 P1955 题解</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。</p>
<p>考虑一个约束满足问题的简化版本：假设x1,x2,x3…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。</p>
<p>现在给出一些约束满足问题，请分别对它们进行判定。</p>
<h2 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h2><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>从文件prog.in中读入数据。</p>
<p>输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。</p>
<p>对于每个问题，包含若干行：</p>
<p>第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj；</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>输出到文件 prog.out 中。</p>
<p>输出文件包括t行。</p>
<p>输出文件的第 k行输出一个字符串“ YES” 或者“ NO”（不包含引号，字母全部大写），“ YES” 表示输入中的第k个问题判定为可以被满足，“ NO” 表示不可被满足。</p>
<h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入 #1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 2 1</span><br><span class="line">1 2 0</span><br><span class="line">2</span><br><span class="line">1 2 1</span><br><span class="line">2 1 1</span><br></pre></td></tr></table></figure></p>
<p>输出 #1<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure></p>
<p>输入 #2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 1 1</span><br><span class="line">4</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">3 4 1</span><br><span class="line">1 4 0</span><br></pre></td></tr></table></figure></p>
<p>输出 #2<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure></p>
<p>数据范围（图片来自洛谷）<br><img src="https://cdn.luogu.org/upload/pic/1503.png" alt="data"></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>把题目中的「x1=x2」看做x1和x2在同一个集合里，「x1≠x2」看做x1和x2不在同一个集合里……</p>
<p>好了，显而易见这是道并查集的题目</p>
<p>读懂了题目，下手就很简单了</p>
<p>这里要注意：<br>「x1≠x2」是无法进行的操作（因为你不能强制他们不在同一个集合里！若非要实现，就又要维护一个数组），把它看成查询操作。</p>
<p>而且「x1=x2」类似的操作要先做，「x1≠x2」类似的操作要最后做（因为后者对集合没有影响，它是一个查询操作）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果你遇到了类似这样的数据：</span><br><span class="line">...</span><br><span class="line">1 2 0</span><br><span class="line">1 2 1</span><br><span class="line">...</span><br><span class="line">那么根据我们的思路， 「1 2 0」是一个查询操作，对集合没有影响，那么就相当于少了一个操作！</span><br><span class="line">必须要先进行「x1=x2」类似的合并操作，再做「x1≠x2」类似的查询操作</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://www.luogu.org/record/show?rid=7256140" target="_blank" rel="noopener">90分代码 评测记录（未离散化）</a><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXN], n, t;</span><br><span class="line"><span class="keyword">int</span> e[MAXN], e0[MAXN], x[MAXN], y[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快读 */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = -x;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">		s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">		ch = getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	x = Find(x), y = Find(y);</span><br><span class="line">	<span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">	U[x] = y;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = getInt();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; ++i) &#123;</span><br><span class="line">		U[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line">	<span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line">	<span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="keyword">sizeof</span>(y));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		x[i] = getInt(), y[i] = getInt(), e[i] = getInt();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 第一次做 「x1=y1」的合并操作</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> fe = e[i], fx = x[i], fy = y[i];</span><br><span class="line">		<span class="keyword">if</span> (fe == <span class="number">1</span>) Union(fx, fy);</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">//  第二次做 「x1≠y1」的查询操作</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> fe = e[i], fx = x[i], fy = y[i];</span><br><span class="line">		<span class="keyword">if</span> (fe == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Find(fx) == Find(fy)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	t = getInt();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (Main()) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><right>——引自百度百科</right><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。</span><br><span class="line">通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：</span><br><span class="line">原数据：1,999,100000,15；处理后：1,3,4,2；</span><br><span class="line">原数据：&#123;100,200&#125;，&#123;20,50000&#125;，&#123;1,400&#125;；</span><br><span class="line">处理后：&#123;3,4&#125;，&#123;2,6&#125;，&#123;1,5&#125;；</span><br></pre></td></tr></table></figure></p>
<p>对一堆数据进行离散化，</p>
<ol>
<li>先排序 [ 推荐 std::sort() ]（针对有序序列进行离散化）</li>
<li>删除重复元素（节省空间）</li>
<li>对数据进行索引（最终目的）</li>
</ol>
<p>而其中我们要用到STL提供的pair来储存变量。pair提供一个包含两个数据成员的结构体模板，可以快速访问其中的元素，就像一个压缩包一样（  </p>
<h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><p><a href="https://www.luogu.org/record/show?rid=7260594" target="_blank" rel="noopener">AC代码 评测记录</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pair pair<span class="meta-string">&lt;ll,ll&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">600000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXN], n, t;</span><br><span class="line"><span class="keyword">int</span> e[MAXN], x[MAXN], y[MAXN];</span><br><span class="line"></span><br><span class="line">Pair p[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>, x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) x = -x;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">        s = s * <span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (U[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    x = Find(x), y = Find(y);</span><br><span class="line">    U[x] = y;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">stlCmp</span><span class="params">(Pair x, Pair y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x.first &gt; y.first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Disc</span><span class="params">(Pair a[], <span class="keyword">int</span> A[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n*<span class="number">2</span> + <span class="number">1</span>, stlCmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n*<span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || a[i].first != a[i<span class="number">-1</span>].first) tot++;</span><br><span class="line">        A[a[i].second] = tot;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = getInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500010</span>; ++i) &#123;</span><br><span class="line">        U[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="keyword">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line">    <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="keyword">sizeof</span>(y));</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="keyword">sizeof</span>(p));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> ax = getInt(), ay = getInt(), ae = getInt();</span><br><span class="line">        e[i] = ae;</span><br><span class="line">        p[i] = make_pair(ax, i);</span><br><span class="line">        p[i + n] = make_pair(ay, i+n);</span><br><span class="line">    &#125;</span><br><span class="line">    Disc(p, x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) y[i] = x[n + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fe = e[i], fx = x[i], fy = y[i];</span><br><span class="line">        <span class="keyword">if</span> (fe == <span class="number">1</span>) Union(fx, fy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> fe = e[i], fx = x[i], fy = y[i];</span><br><span class="line">        <span class="keyword">if</span> (fe == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Find(fx) == Find(fy)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    t = getInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Main()) <span class="built_in">puts</span>(<span class="string">"YES"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"NO"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集模板</title>
    <url>/2018-04-14/union-set/</url>
    <content><![CDATA[<blockquote>
<p>并查集模板</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problemnew/show/P3367" target="_blank" rel="noopener">题目链接</a></p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>如题，现在有一个并查集，你需要完成合并和查询操作。</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p><strong>输入格式</strong>：</p>
<p>第一行包含两个整数N、M，表示共有N个元素和M个操作。</p>
<p>接下来M行，每行包含三个整数Zi、Xi、Yi</p>
<p>当Zi=1时，将Xi与Yi所在的集合合并</p>
<p>当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N</p>
<p><strong>输出格式</strong>：</p>
<p>如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入输出样例1"><a href="#输入输出样例1" class="headerlink" title="输入输出样例1"></a>输入输出样例1</h2><p>input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 7</span><br><span class="line">2 1 2</span><br><span class="line">1 1 2</span><br><span class="line">2 1 2</span><br><span class="line">1 3 4</span><br><span class="line">2 1 4</span><br><span class="line">1 2 3</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">N</span><br><span class="line">Y</span><br><span class="line">N</span><br><span class="line">Y</span><br></pre></td></tr></table></figure>
<h1 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h1><p>时空限制：1000ms,128M</p>
<p>数据规模：</p>
<p>对于30%的数据，N&lt;=10，M&lt;=20；</p>
<p>对于70%的数据，N&lt;=100，M&lt;=1000；</p>
<p>对于100%的数据，N&lt;=10000，M&lt;=200000。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> U[MAXN], m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (U[x] &lt; <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> U[x] = Find(U[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	x = Find(x), y = Find(y);</span><br><span class="line">	<span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">	U[x] += U[y];</span><br><span class="line">	U[y] = x; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; MAXN;i++) U[i] = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;z);</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line">		<span class="keyword">switch</span>(z) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">				Union(x, y);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;x, &amp;y);</span><br><span class="line">				<span class="keyword">if</span> (Find(x) == Find(y)) <span class="built_in">puts</span>(<span class="string">"Y"</span>);</span><br><span class="line">				<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"N"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1536 《村村通》</title>
    <url>/2018-04-14/Luogu-P1536/</url>
    <content><![CDATA[<blockquote>
<p>并查集的好题目</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problem/show?pid=1536" target="_blank" rel="noopener">题目地址</a> </p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府“村村通工程”的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p><strong>输入格式：</strong><br>每个输入文件包含若干组测试测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目N（N&lt;1000）和道路数目M；随后的M行对应M条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从1到N编号。</p>
<p>注意：两个城市间可以有多条道路相通。例如：</p>
<p>3 3 1 2 1 2 2 1 这组数据也是合法的。当N为0时，输入结束。</p>
<p><strong>输出格式：</strong><br>对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">4 3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">999 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">998</span><br></pre></td></tr></table></figure>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这是道并查集的题目，可以说接近是裸的并查集，但是你没法把这题理解为并查集这就很烦了啊喂</p>
<p>我们可以把它的公路理解成一条一条绳子，用来连接各个城市，可以把几个城市绑在一块（雾 </p>
<p>那么这样就更像并查集了</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG_CERR(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">'='</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> u[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u[x] &lt; <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">return</span> u[x] = Find(u[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	x = Find(x), y = Find(y);</span><br><span class="line">	<span class="keyword">if</span> (x == y) <span class="keyword">return</span>;</span><br><span class="line">	u[x] += u[y];</span><br><span class="line">	u[y] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m) == <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; MAXN;i++) u[i] = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> a, b;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">			a = Find(a), b = Find(b);</span><br><span class="line">			<span class="keyword">if</span> (a != b) Union(a, b); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (u[i] &lt; <span class="number">0</span>) ans++; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.org/record/show?rid=6799967" target="_blank" rel="noopener">提交记录</a></p>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树学习笔记</title>
    <url>/2018-04-01/Segment-Tree/</url>
    <content><![CDATA[<blockquote>
<p>快速查找和修改区间</p>
</blockquote>
<p>注：本文包含<a href="https://www.luogu.org/problemnew/show/P3372" target="_blank" rel="noopener">洛谷 P3372 【模板】线段树 1</a> 题解</p>
<a id="more"></a>
<h1 id="线段树模板"><a href="#线段树模板" class="headerlink" title="线段树模板"></a>线段树模板</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>什么是线段树？</li>
</ul>
<p>线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。</p>
<ul>
<li>线段树的主要用途及好处？</li>
</ul>
<p>线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。</p>
<ul>
<li>线段树的应用？</li>
</ul>
<p>最简单的应用就是记录线段是否被覆盖，随时查询当前被覆盖线段的总长度。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h3><p>我们选择一个$O(1)$的取儿子函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">leftChild</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左子树 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rightChild</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 右子树</span></span><br></pre></td></tr></table></figure>
<p>线段树的维护：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	t[p] = t[leftChild(p)] + t[rightChild(p)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向上维护区间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUpMin</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	t[p] = <span class="built_in">std</span>::min(t[leftChild(p)], t[rightChild(p)]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 向t[p]下放Min标签</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushUpMax</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	t[p] = <span class="built_in">std</span>::max(t[leftChild(p)], t[rightChild(p)]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 向t[p]下放Max标签</span></span><br></pre></td></tr></table></figure>
<p>递归建树：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> lli;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(lli p, lli l, lli r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		ans[p] = a[l];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果左右区间相同，则必是叶子节点</span></span><br><span class="line">	lli mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	buildTree(leftChild(p), l, mid);</span><br><span class="line">	buildTree(rightChild(p), mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="comment">// 递归</span></span><br><span class="line">	pushUp(p); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 递归 + 二分建树</span></span><br></pre></td></tr></table></figure>
<h3 id="区间修改函数"><a href="#区间修改函数" class="headerlink" title="区间修改函数"></a>区间修改函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Record</span><span class="params">(lli p, lli l, lli r, lli k)</span> </span>&#123;</span><br><span class="line">	tag[p] = tag[p] + k;</span><br><span class="line">	ans[p] = ans[p] + k * (r - l + <span class="number">1</span>);</span><br><span class="line">	<span class="comment">// 因为是区间统一改变，所以ans要加元素个数 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 记录当前节点所代表的区间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(lli p, lli l, lli r)</span> </span>&#123;</span><br><span class="line">	lli mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	Record(leftChild(p), l, mid, tag[p]);</span><br><span class="line">	Record(rightChild(p), mid + <span class="number">1</span>, r, tag[p]);</span><br><span class="line">	tag[p] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 每次更新两个儿子节点，不断向下传递 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(lli nl, lli nr, lli l, lli r, lli p, lli k)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 将要修改从 nl 到 nr 的区间</span></span><br><span class="line">	<span class="comment">// l,r 为当前节点所储存的区间 </span></span><br><span class="line">	<span class="comment">// p 为当前节点的编号</span></span><br><span class="line">	<span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr) &#123;</span><br><span class="line">		ans[p] += k * (r - l + <span class="number">1</span>);</span><br><span class="line">		tag[p] += k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	pushDown(p, l, r);	</span><br><span class="line">	lli mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (nl &lt;= mid) update(nl, nr, l, mid, leftChild(p), k)</span><br><span class="line">	<span class="keyword">if</span> (nr &gt; mid) update(nl, nr,mid + <span class="number">1</span>, r, rightChild(p), k);</span><br><span class="line">	pushUp(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新区间</span></span><br></pre></td></tr></table></figure>
<h3 id="查询区间函数"><a href="#查询区间函数" class="headerlink" title="查询区间函数"></a>查询区间函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> lli <span class="title">query</span><span class="params">(lli qx, lli qy, lli l, lli r, lli p)</span> </span>&#123;</span><br><span class="line">	lli res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= l &amp;&amp; r &lt;= qy) <span class="keyword">return</span> ans[p];</span><br><span class="line">	lli mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	pushDown(p, l, r);</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= mid) res += query(qx, qy, l, mid, leftChild(p));</span><br><span class="line">	<span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= qy) res += query(qx, qy, mid + <span class="number">1</span>, r, rightChild(p));</span><br><span class="line">	<span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询区间</span></span><br></pre></td></tr></table></figure>
<p>依然采用二分的形式…</p>
<h1 id="洛谷-P3372-题解"><a href="#洛谷-P3372-题解" class="headerlink" title="洛谷 P3372 题解"></a>洛谷 P3372 题解</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知一个数列，你需要进行下面两种操作：</p>
<p>1.将某区间每一个数加上x</p>
<p>2.求出某区间每一个数的和</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。</p>
<p>第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。</p>
<p>接下来M行每行包含3或4个整数，表示一个操作，具体如下：</p>
<p>操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k</p>
<p>操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包含若干行整数，即为所有操作2的结果。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 5 4 2 3</span><br><span class="line">2 2 4</span><br><span class="line">1 2 3 2</span><br><span class="line">2 3 4</span><br><span class="line">1 1 5 1</span><br><span class="line">2 1 4</span><br></pre></td></tr></table></figure>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br><span class="line">8</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>就是把上面的函数都复制下来就行了= =</p>
<p>没什么多解释的</p>
<p>注释见上面代码</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace std;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000000</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ull n, m, a[MAXN], ans[MAXN &lt;&lt; <span class="number">2</span>], tag[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">ls</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &lt;&lt; <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">rs</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (ll i = <span class="number">1</span>;i &lt;= n;i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(ll p)</span> </span>&#123;</span><br><span class="line">	ans[p] = ans[ls(p)] + ans[rs(p)];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(ll p, ll l, ll r)</span> </span>&#123;</span><br><span class="line">	tag[p] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">		ans[p] = a[l];</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	build(ls(p), l, mid);</span><br><span class="line">	build(rs(p), mid + <span class="number">1</span>, r);</span><br><span class="line">	pushUp(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rec</span><span class="params">(ll p, ll l, ll r, ll k)</span> </span>&#123;</span><br><span class="line">	tag[p] = tag[p] + k;</span><br><span class="line">	ans[p] = ans[p] + k * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(ll p,ll l, ll r)</span> </span>&#123;</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	rec(ls(p), l, mid, tag[p]);</span><br><span class="line">	rec(rs(p), mid + <span class="number">1</span>, r, tag[p]);</span><br><span class="line">	tag[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(ll nl, ll nr, ll l, ll r, ll p, ll k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (nl &lt;= l &amp;&amp; r &lt;= nr) &#123;</span><br><span class="line">		ans[p] += k * (r - l + <span class="number">1</span>);</span><br><span class="line">		tag[p] += k;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	pushDown(p, l, r);</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (nl &lt;= mid) update(nl, nr, l, mid, ls(p), k);</span><br><span class="line">	<span class="keyword">if</span> (nr &gt; mid) update(nl, nr, mid + <span class="number">1</span>, r, rs(p), k);</span><br><span class="line">	pushUp(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(ll qx, ll qy, ll l, ll r, ll p)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= l &amp;&amp; r &lt;= qy) <span class="keyword">return</span> ans[p];</span><br><span class="line">	ll mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	pushDown(p, l, r);</span><br><span class="line">	<span class="keyword">if</span> (qx &lt;= mid) res += query(qx, qy, l, mid, ls(p));</span><br><span class="line">	<span class="keyword">if</span> (qy &gt; mid) res += query(qx, qy, mid + <span class="number">1</span>, r, rs(p));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">	ll a1, b, c, d, e, f;</span><br><span class="line">	scan();</span><br><span class="line">	build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a1);</span><br><span class="line">		<span class="keyword">switch</span>(a1) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>, &amp;b, &amp;c, &amp;d);</span><br><span class="line">				update(b, c, <span class="number">1</span>, n, <span class="number">1</span>, d);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>, &amp;e, &amp;f);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(e, f, <span class="number">1</span>, n, <span class="number">1</span>));	</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意一下，stdio 和 iostream 混用会出现很多奇怪的bug！</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>计算π</title>
    <url>/2018-03-31/calculating-pi/</url>
    <content><![CDATA[<blockquote>
<p>计算$π$可不是件容易事</p>
</blockquote>
<a id="more"></a>
<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>偶然在WA谷上看到一道题</p>
<p><img src="https://s1.ax2x.com/2018/04/01/tlUNK.png" alt="tlUNK.png"></p>
<p>不得不说很玄学</p>
<p>抱着好奇的心态我点开了题解</p>
<p>发现了一个打表的。。。。</p>
<p>于是心血来潮去搜了一下如何计算π</p>
<p>于是就有了这篇文章</p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>Handwer STD 要你计算一下圆周率，要求最少为4000位（从小数部分第一位开始算起）</p>
<h1 id="输入描述-amp-样例"><a href="#输入描述-amp-样例" class="headerlink" title="输入描述&amp;样例"></a>输入描述&amp;样例</h1><p>无输入</p>
<h1 id="输出描述-amp-样例"><a href="#输出描述-amp-样例" class="headerlink" title="输出描述&amp;样例"></a>输出描述&amp;样例</h1><p>输出$π$，要求保留<strong>至少</strong>4000位小数。</p>
<p>样例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3141592653589793......</span><br></pre></td></tr></table></figure>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>时限为5000ms</p>
<h1 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们需要找到一个合适、可靠且快速的圆周率计算公式</p>
<p>我选择了基于级数的快速收敛公式</p>
<p>这是一个很快、精度也很高的算法</p>
<p>公式为：</p>
<p><img src="https://s1.ax2x.com/2018/04/01/tlkra.png" alt="tlkra.png"></p>
<p>（懒得写LaTeX码了</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n = <span class="number">16366</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[<span class="number">16366</span> + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">double</span> cost;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span>  i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (n - i) d[++i] = <span class="number">2000</span>;</span><br><span class="line">	<span class="keyword">for</span> (;n;n -= <span class="number">14</span>) &#123;</span><br><span class="line">		<span class="keyword">long</span> <span class="keyword">long</span> p;</span><br><span class="line">		<span class="keyword">for</span> (p = <span class="number">0</span>,i = n;i;i--) &#123;</span><br><span class="line">			p = p * i + d[i] * <span class="number">10000</span>;</span><br><span class="line">			d[i] = p % (<span class="number">2</span> * i - <span class="number">1</span>);</span><br><span class="line">			p /= <span class="number">2</span> * i - <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%.4d"</span>,d[<span class="number">0</span>] + p / <span class="number">10000</span>);</span><br><span class="line">		d[<span class="number">0</span>] = p % <span class="number">10000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 快速读入 模板</title>
    <url>/2018-03-23/CPP-Fast-RW/</url>
    <content><![CDATA[<blockquote>
<p>比某记者还快！</p>
</blockquote>
<a id="more"></a>
<h2 id="C-快速读入、输出"><a href="#C-快速读入、输出" class="headerlink" title="C++ 快速读入、输出"></a>C++ 快速读入、输出</h2><h3 id="在-C-上实现快速读入模板，这里是一个读取int-的示例。"><a href="#在-C-上实现快速读入模板，这里是一个读取int-的示例。" class="headerlink" title="在 C++ 上实现快速读入模板，这里是一个读取int 的示例。"></a>在 C++ 上实现快速读入模板，这里是一个读取int 的示例。</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Quick_Read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>,w = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (ch &lt;= <span class="string">'0'</span> || ch &gt; <span class="string">'9'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">'-'</span>) w = <span class="number">-1</span>;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) s = s * <span class="number">10</span> + ch - <span class="string">'0'</span> , ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> s * w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 本代码来自 wyh's Blog</span></span><br><span class="line"><span class="comment">// 地址: blog.aor.sd.cn</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="在-C-上实现快速输出模板，这里是一个输出int-的示例。"><a href="#在-C-上实现快速输出模板，这里是一个输出int-的示例。" class="headerlink" title="在 C++ 上实现快速输出模板，这里是一个输出int 的示例。"></a>在 C++ 上实现快速输出模板，这里是一个输出int 的示例。</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Quick_Write</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">    re = -re;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断负数</span></span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">9</span>) Quick_Write(x/<span class="number">10</span>);</span><br><span class="line">  <span class="comment">// 判断是否大于10</span></span><br><span class="line">  <span class="built_in">putchar</span>(x%<span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="懒人解决办法"><a href="#懒人解决办法" class="headerlink" title="懒人解决办法"></a>懒人解决办法</h2><p>听说你不想写超过三行代码？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getint</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x); <span class="keyword">return</span> x; &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">getll</span><span class="params">()</span> </span>&#123; <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> x; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;x); <span class="keyword">return</span> x; &#125; <span class="comment">// lld 按需换成 I64d</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵乘法</title>
    <url>/2018-03-10/matrix-mul/</url>
    <content><![CDATA[<blockquote>
<p>“简单”的矩阵乘法</p>
</blockquote>
<a id="more"></a>
<p>矩阵乘法，就是将两个矩阵相乘</p>
<p><img src="https://s1.ax2x.com/2018/03/10/EThWN.png" alt="EThWN.png"></p>
<p>现要求写一个程序，可以实现矩阵相乘。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行三个正整数 $n$、$p$、$m$，表示矩阵的长宽。<br>之后的$n$ 行，每行 $p$ 个整数，表示矩阵 $A$。<br>之后的 $p$ 行，每行 $m$ 个整数，表示矩阵 $B$。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 $n$ 行，每行 $m$ 个整数，表示矩阵 $A×B$ ，每个数模 $10 ^ 9 + 7$ 输出。</p>
<h2 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 5</span><br><span class="line">-2 -8 -9 8</span><br><span class="line">-10 0 6 -8</span><br><span class="line">-10 -6 6 9</span><br><span class="line">4 -7 5 -5 9</span><br><span class="line">10 -2 -10 5 5</span><br><span class="line">-3 -7 -3 8 -2</span><br><span class="line">-6 7 7 3 -2</span><br></pre></td></tr></table></figure>
<p><strong>良心数据</strong></p>
<h2 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">999999898 149 153 999999929 999999951</span><br><span class="line">999999997 999999979 999999883 74 999999921                                                 </span><br><span class="line">999999835 103 55 95 999999857</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF  = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD  = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span>&#123;</span></span><br><span class="line">	LL arr[maxn][maxn];</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp;b)<span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="comment">// 重载运算符</span></span><br><span class="line">      	Matrix res;</span><br><span class="line">		<span class="built_in">memset</span>(res.arr,<span class="number">0</span>,<span class="keyword">sizeof</span>(res.arr));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; b.m;j++)</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; m;k++)&#123;</span><br><span class="line">					(res.arr[i][j] += arr[i][k] * b.arr[k][j] % MOD) %= MOD;</span><br><span class="line">				&#125;</span><br><span class="line">		res.n = n;res.m = b.m;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a,b,ans;</span><br><span class="line"><span class="comment">// 用结构体来储存矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> n,p,m;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;p,&amp;m);</span><br><span class="line">	</span><br><span class="line">	a.n = n;a.m = p;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; p;j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a.arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 输入矩阵</span></span><br><span class="line">	b.n = p;b.m = m;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; p;i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;b.arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	ans = a * b;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m - <span class="number">1</span>;j++)&#123;</span><br><span class="line">		    (ans.arr[i][j] += MOD) %= MOD;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%lld "</span>,ans.arr[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		(ans.arr[i][m - <span class="number">1</span>] += MOD) %= MOD;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans.arr[i][m - <span class="number">1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 输出矩阵</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center><small>图片 by [simimg.com](https://simimg.com/) </small></center>

]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 10 体验记</title>
    <url>/2018-03-05/windows10/</url>
    <content><![CDATA[<blockquote>
<p>Windows 10 从入门到放弃到重拾再到（伪）精通</p>
</blockquote>
<a id="more"></a>
<p>终于把Windows 10 的更新配置好了，再也不用5分钟开机了（</p>
<p>先把方法记一下吧<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. DiskGenius 激活Windows分区（默认激活deepin 根目录分区）</span><br><span class="line">2. 重启之后引导就炸了</span><br><span class="line">3. （进入Windows）使用 EasyBCD 重建Windows引导（可以不添加deepin）</span><br><span class="line">4. 重启之后引导还是爆炸的</span><br><span class="line">5. （进入deepin）执行 sudo grub-install /dev/sda &amp;&amp; sudo update-grub</span><br><span class="line">6. 重启之后还是deepin的grub引导，但是活动分区是Windows的</span><br><span class="line">7. 下载Fall Creators更新</span><br><span class="line">8. 安装更新</span><br><span class="line">9. 正常使用</span><br></pre></td></tr></table></figure></p>
<p>全程惊悚…</p>
<h2 id="2018-3-5"><a href="#2018-3-5" class="headerlink" title="2018.3.5"></a>2018.3.5</h2><p>Windows 10 可以正常使用的第一天，同时今天也开学了QAQ</p>
<p>开学什么的，体验最差了，况且今天还有什么收心考试</p>
<p>好在今天作业少，终于有时间写代码了（ · v · ）</p>
<p>用 Dev-C++ 写了 <strong>P1179 P1420 P1567</strong> 这两道大水题</p>
<p>总体感觉还是不错的</p>
<p>Dev-C++ 界面还行，还能看</p>
<p><img src="https://s1.ax2x.com/2018/03/13/L0Uea.jpg" alt="L0Uea.jpg"></p>
<p>后台开着一个火萤桌面，一个Chrome和一个Markdown编辑器</p>
<p>不得不说 Dev-C++ 真的是轻量级，占的内存从不超过100MB，Atom开完100MB就没了 对于这种老爷机真的很有用</p>
<blockquote>
<p>我好像可以Wine一个Dev-C++出来…但是不能编译</p>
</blockquote>
<p>这次体验感觉还不错，或许我可以主力一段时间…</p>
<h2 id="2018-3-13"><a href="#2018-3-13" class="headerlink" title="2018.3.13"></a>2018.3.13</h2><p>已经是深夜了，洗漱完又上洛谷打了个卡，写了一道<strong>入门难度</strong>的大水题</p>
<p>周六因为晚上需要写《矩阵乘法》，所以就没更这篇文章</p>
<p>（话说这个矩阵乘法耗了我一下午…我可能真的太弱了</p>
<p>周六我全天都在使用 Windows 10，除了更 Blog 需要重启到Linux </p>
<p>这几天体验下来，感觉还不错，态度慢慢好转</p>
<p>Windows 10 的触摸板手势真的爽！Deepin 15 的触摸板手势太不灵敏了，经常误触或无效操作<br>全靠友商衬托.png</p>
<p>（主要是 Windows 10 的电源调配真的比 Linux 好…耗电比 Linux 少</p>
<p>我现在已经是 Windows 10 主力了，Linux 用来更 Blog</p>
<p>等鼓捣好 Windows Subsystem for Linux （WSL） 之后应该就可以在 Windows 10 上更博客了<br>微软强势拉用户.jpg</p>
<h2 id="2018-3-14"><a href="#2018-3-14" class="headerlink" title="2018.3.14"></a>2018.3.14</h2><p>今天作业少 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈</p>
<p>我在学校就完成了几乎全部的作业，到家就只剩下5个小题</p>
<p>做完作业后便欢欢喜喜地来搞 Windows Subsystem for Linux（WSL）</p>
<p>经过不懈的努力（其实就是重启一次）终于弄好了WSL</p>
<p>现在正在装 g++ </p>
<p>网慢死了QAQ</p>
<p><img src="https://s1.ax2x.com/2018/03/14/LUlOu.jpg" alt="g++.jpg"></p>
<center><small>PS：由于我没有截任务栏，所以比例有点奇怪</small></center>

<p>又用 Dev-C++ 写了一道记忆化搜索的大水题，感觉 Dev-C++ 比 Atom 好用多了，毕竟 Core i3 3110m 带不起 Atom</p>
<p>本来打算今天的 Blog 用 WSL 交，想想还是算了吧，出现意外没时间处理</p>
<h2 id="2019-7-12"><a href="#2019-7-12" class="headerlink" title="2019.7.12"></a>2019.7.12</h2><p>想了一想 决定把这篇文章用来更新 Boot Camp 的使用体验</p>
<h2 id="2019-10-26"><a href="#2019-10-26" class="headerlink" title="2019.10.26"></a>2019.10.26</h2><p>宣布本文章暂停更新</p>
]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找&二分答案</title>
    <url>/2018-02-06/BSAnswer/</url>
    <content><![CDATA[<blockquote>
<p>  $O(\log_2n)$的优秀算法</p>
</blockquote>
<a id="more"></a>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="百度百科原话"><a href="#百度百科原话" class="headerlink" title="百度百科原话"></a>百度百科原话</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</span><br></pre></td></tr></table></figure>
<p>二分查找的时间复杂度是$O(log_{2}n)$</p>
<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>查找的序列必须采用顺序存储结构</li>
</ul>
<ul>
<li>查找的序列必须是有序排列的</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>将需要查找的序列进行排序（一般为升序排列）</p>
</li>
<li><p>将序列中间位置记录的元素与关键字比较</p>
</li>
<li><p>如果相等，则<code>返回查找成功</code><br>如果不相等，则<code>将序列分成左右两个子序列，若元素小于关键字，就到左子序列中查找；否则就到右子序列中查找</code></p>
</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> t,<span class="keyword">int</span> x[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[mid] == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[mid] &lt; t) l = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x[mid] &gt; t) r = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> dest;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; dest;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,BinarySearch(<span class="number">0</span>,n - <span class="number">1</span>,dest,p)?<span class="string">"YES"</span>:<span class="string">"NO"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h2><p>看完了二分查找，你会发现二分好像只能用来在有序数列里找数。</p>
<p>对，一些情况二分只能拿来找数，但是从它身上衍生出来的二分答案却是一个很有用的东西！</p>
<p>二分答案，就是通过二分查找的方式枚举出一个答案来，然后再验证你的查找结果是否正确，从而获取答案</p>
<h3 id="要求-amp-特点"><a href="#要求-amp-特点" class="headerlink" title="要求&amp;特点"></a>要求&amp;特点</h3><ol>
<li>答案具有<strong>单调性</strong></li>
<li>题面里包含与“最小的最大，最大的最小”相关的字眼</li>
</ol>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol>
<li><p>先将给定的序列排序</p>
</li>
<li><p>参照二分查找，枚举一个答案mid</p>
</li>
<li><p>验证这个答案是否可行</p>
</li>
<li><p>如果可行，<code>更新边界，找寻更佳答案</code><br>如果不可行，<code>更新边界，继续寻找答案</code></p>
</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>一般模板</p>
<p>其中的check函数需要针对每一个题目进行验证</p>
<p>当然你会写暴力枚举的check也可以借鉴过来#(滑稽)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="comment">/* code here*/</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,m;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">2</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">  <span class="comment">// -----------------------------------</span></span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>,r = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (check(ans))&#123;</span><br><span class="line">      l = mid + <span class="number">1</span>;</span><br><span class="line">      ans = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// -----------------------------------</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="推荐题目"><a href="#推荐题目" class="headerlink" title="推荐题目"></a>推荐题目</h2><ol>
<li><a href="https://www.luogu.org/problemnew/show/P2678" target="_blank" rel="noopener">「洛谷P2678 跳房子」</a> 出处：NOIP2015 提高组</li>
<li><a href="https://www.luogu.org/problemnew/show/P1824" target="_blank" rel="noopener">「洛谷P1824 进击的奶牛」</a> 出处：USACO </li>
</ol>
]]></content>
      <tags>
        <tag>二分查找</tag>
        <tag>二分答案</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷P1102 《A-B数对》</title>
    <url>/2018-02-01/Luogu-P1102/</url>
    <content><![CDATA[<blockquote>
<p>普及- 的“水”题</p>
</blockquote>
<a id="more"></a>
<p><a href="https://www.luogu.org/problem/show?pid=1102" target="_blank" rel="noopener">题目地址</a> </p>
<p>提前说明：本题难度为<strong>普及-</strong> </p>
<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给出一串数以及一个数字C，要求计算出所有A-B=C的数对的个数。（不同位置的数字一样的数对算不同的数对）</p>
<h1 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h1><p><strong>输入格式</strong>：</p>
<p>第一行包括2个非负整数N和C，中间用空格隔开。</p>
<p>第二行有N个整数，中间用空格隔开，作为要求处理的那串数。</p>
<p><strong>输出格式</strong>：</p>
<p>输出一行，表示该串数中包含的所有满足A-B=C的数对的个数。</p>
<h1 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h1><h2 id="输入输出样例1"><a href="#输入输出样例1" class="headerlink" title="输入输出样例1"></a>输入输出样例1</h2><p>input:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 1</span><br><span class="line">1 1 2 3</span><br></pre></td></tr></table></figure>
<p>output:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h1><p>对于73%的数据，N &lt;= 2000；</p>
<p>对于100%的数据，N &lt;= 200000。</p>
<p>所有输入数据都在longint范围内。</p>
<p><strong>原题目</strong>2017/4/29新添数据两组</p>
<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>粗略一看，这道题是不是特别水？</p>
<p>只需要用$O(n^2)$的暴力解法不就可以了吗？</p>
<p>​        枚举A和B，再判断A-B是否为C</p>
<p>但是！</p>
<p>你们Naive，没看见那个<em>N&lt;=200000</em> 吗</p>
<p>这样肯定会TLE的啊喂</p>
<p><a href="https://www.luogu.org/record/show?rid=5540782" target="_blank" rel="noopener">测试记录 76分</a></p>
<h2 id="正确解法"><a href="#正确解法" class="headerlink" title="正确解法"></a>正确解法</h2><p>作为C++选手，我们一定要发扬光大Alexander留给我们的STL</p>
<p>于是我们就可以用std::map映射来做这道题目（注意这是<strong>普及-</strong>的题目）</p>
<p>将A-B=C转换为A-C=B，然后找这N个数中有几个B就行了</p>
<p><a href="https://www.luogu.org/recordnew/show/5555723" target="_blank" rel="noopener">测试记录 AC</a></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="暴力解法-1"><a href="#暴力解法-1" class="headerlink" title="暴力解法"></a>暴力解法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> *arr,n,c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; c;</span><br><span class="line">  arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">      <span class="keyword">if</span> ((arr[i] - arr[j] == c)) ans++;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  read();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; work() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正确解法-1"><a href="#正确解法-1" class="headerlink" title="正确解法"></a>正确解法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">200001</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">LetMeAccept</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,c;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;c);</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,a + i);</span><br><span class="line">    p[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    ans += p[a[i] + c];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123;</span><br><span class="line">    LetMeAccept();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>图论之建立基础的图</title>
    <url>/2017-12-31/CreateGraph/</url>
    <content><![CDATA[<blockquote>
<p>指针建图</p>
</blockquote>
<a id="more"></a>
<p>学（背）会建立一个基础的图，是写好图论算法的基础。</p>
<p>具体就是写一个循环，通过构造函数来创建一个一个的边和结点<br>附代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 2e31-1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">'='</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2500 + 5</span></span><br><span class="line"><span class="comment">//设定图的最大结点值为2500</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">  Edge *firstEdge;</span><br><span class="line">  <span class="keyword">int</span> dist;</span><br><span class="line">  <span class="keyword">bool</span> inQueue;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">  Node *s,*t;</span><br><span class="line">  <span class="keyword">int</span> w; <span class="comment">//权值</span></span><br><span class="line">  Edge *next; <span class="comment">//下一条边</span></span><br><span class="line"></span><br><span class="line">  Edge(Node *s,Node *t,<span class="keyword">int</span> w) : s(s),t(t),w(w),next(s-&gt;firstEdge);</span><br><span class="line">  <span class="comment">//构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s,<span class="keyword">const</span> <span class="keyword">int</span> &amp;t,<span class="keyword">const</span> <span class="keyword">int</span> &amp;w)</span></span>&#123;</span><br><span class="line">  node[s].firstEdge = <span class="keyword">new</span> Edge(&amp;node[s],&amp;node[t],w);</span><br><span class="line">  node[t].firstEdge = <span class="keyword">new</span> Edge(&amp;node[t],&amp;node[s],w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*      code here</span></span><br><span class="line"><span class="comment"> *  请在这里写各种的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n,m,s,t;</span><br><span class="line">   ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">   <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">     <span class="keyword">int</span> u,v,w;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; u,v,w;</span><br><span class="line">     add(u,v,w);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/* code here*/</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>SPFA</title>
    <url>/2017-12-30/SPFA/</url>
    <content><![CDATA[<blockquote>
<p>简单的SPFA最短路模板，适用于图的边权有负数的情况。</p>
</blockquote>
<a id="more"></a>
<h1 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h1><p>我们用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。运用动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行操作，直至队列空为止。</p>
<h1 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h1><p>给一个指针实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2500 + 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG(x) cerr &lt;&lt; #x &lt;&lt; <span class="meta-string">'='</span> &lt;&lt; x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">2e31</span><span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">	Edge *firstEdge;</span><br><span class="line">	<span class="keyword">int</span> dist;</span><br><span class="line">	<span class="keyword">bool</span> inQueue;</span><br><span class="line">&#125; node[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">	Node *s,*t;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	Edge *next;</span><br><span class="line"></span><br><span class="line">	Edge(Node *s,Node *t,<span class="keyword">int</span> w) : s(s),t(t),w(w),next(s-&gt;firstEdge)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s,<span class="keyword">const</span> <span class="keyword">int</span> &amp;t,<span class="keyword">const</span> <span class="keyword">int</span> &amp;w)</span></span>&#123;</span><br><span class="line">  node[s].firstEdge = <span class="keyword">new</span> Edge(&amp;node[s],&amp;node[t],w);</span><br><span class="line">  node[t].firstEdge = <span class="keyword">new</span> Edge(&amp;node[t],&amp;node[s],w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">spfa</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;s,<span class="keyword">const</span> <span class="keyword">int</span> &amp;t,<span class="keyword">const</span> <span class="keyword">int</span> &amp;n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">    node[i].dist = Inf;</span><br><span class="line">    node[i].inQueue = <span class="literal">false</span>; <span class="comment">//将所有节点的在队列的情况设为false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">queue</span>&lt;Node *&gt; q;</span><br><span class="line">  q.push(&amp;node[s]);</span><br><span class="line">  node[s].dist = <span class="number">0</span>;</span><br><span class="line">  node[s].inQueue = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">    Node *u = q.front();</span><br><span class="line">    q.pop();</span><br><span class="line">		u-&gt;inQueue = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Edge *e = u-&gt;firstEdge;e;e = e-&gt;next)&#123;</span><br><span class="line">			Node *v = e-&gt;t;</span><br><span class="line">			<span class="keyword">if</span> (v-&gt;dist &gt; u-&gt;dist + e-&gt;w)&#123;</span><br><span class="line">				v-&gt;dist = u-&gt;dist + e-&gt;w;</span><br><span class="line">				<span class="keyword">if</span> (!v-&gt;inQueue)&#123;</span><br><span class="line">					q.push(v);</span><br><span class="line">					v-&gt;inQueue = <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> node[t].dist;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n,m,s,t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;n,&amp;m,&amp;s,&amp;t);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= m;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v,w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		add(u,v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,spfa(s,t,n));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017-10-25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
