<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[公告栏]]></title>
    <url>%2F2020-02-07%2FBulletinBoard%2F</url>
    <content type="text"><![CDATA[这里可能会挂些什么东西。 There may be something here. 《关于新开的&nbsp;cnblogs&nbsp;博客的一些说明》 《如何把 Android P 的小药丸改成&nbsp;Q&nbsp;的小横条》]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何把 Android P 的小药丸改成 Q 的小横条]]></title>
    <url>%2F2020-02-05%2FFake-Android-Q-Navigation-Handle%2F</url>
    <content type="text"><![CDATA[Android Q 是真的香，可惜我只有 Android P 前言看了酷安上一条动态，上面说 Android P 可以获得 Q 的动画和手势，我当即就备份好数据刷了 OmniROM Pie，结果发现修改的教程失效了……根据评论区的留言和一位老哥 @飞碟lcj 分享的两条动态自己摸索出了一条路子 准备材料 原生 / 类原生 Android P Magisk QuickSwitch 模块 MT 管理器 教程刷机麒麟 95x 双基带手机直接刷的话用不了双卡，可以参考这篇教程 开启手势及动画Lawnchair 测试版拥有 Android Q 的动画和手势，下载安装后用 Magisk 模块 QuickSwitch 设为默认桌面和最近应用提供者（Recent Provider），重启即可 接下来长按桌面空白处，打开「主屏幕设置」，找到「最近任务」，把「向上滑动以切换应用」、「Full gesture mode」、「向左滑动以返回」都打开并重启 接下来打开应用、返回桌面的动画就会变成 Android Q 的非线性动画，小药丸此时和 Android Q 的小横条的功能是一样的，只有外观不一样 更改外观需要修改系统文件 小药丸的外观是由 SystemUI.apk 控制的，导航栏的大小是由 framework-res.apk 控制的，需要修改这两个文件 修改 SystemUI打开 MT 管理器，定位到 /system/priv-app/SystemUI/，将里面的 SystemUI.apk 文件做好备份，出事了直接进 recovery 恢复（data 没有解锁的需要刷完整包） 点击 SystemUI.apk 再点击「查看」，此时这个 apk 以 zip 的形式展开了。点击右上角三个点 $\vdots$ 选择「搜索」，在搜索框中输入 ic_sysbar_home_quick，理论上只有一个搜索结果 ic_sysbar_home_quick_step.xml，点开它，此时进入了该文件所在的目录。点击该文件，选择「反编译」，等待它加载好。 修改 android:height 和 android:width 后面的值为 140dp修改 android:viewportWidth 和 android:viewportHeight 后面的值为 140.0 修改 android:pathData 后面的字符串为： 1M138,72H2c-0.89,0-2-1.11-2-2l0,0c0-0.89,1.11-2,2-2H138c1.11,0,2,0.89,2,2l0,0c0,0.89,-1.11,2,-2,2z 只替换引号里面的内容，请直接复制，一个字母都不能错，否则有可能开机后无限 fc android:fillColor 不用动 最终这个文件应该差不多长这样： 上面的数据请不要随意更改，请直接使用上面提供的数据 保存文件，退出编辑器，提示更新文件选是，重启，此时小药丸就变成小横条了，但是导航栏还是那么大一个 修改 framework-res.apk更改导航栏高度有两个选择： 直接上重力工具箱（Android P 版本） 修改 framework-res.apk 这里介绍如何修改 framework-res.apk 打开 MT 管理器，定位到 /system/framework/，将里面的 framework-res.apk 文件做好备份，出事了也可以直接用 recovery 恢复 点击 framework-res.apk 再点击「查看」，此时这个 apk 以 zip 的形式展开了。点击 resources.arsc 文件，再点击「Arsc编辑器」。 点击「Android」，之后点击「dimen」，进入之后再次点击「dimen」（理论上应该是第一个选项），点击右上角三个点 $\vdots$ 选择过滤，在搜索框中输入「navigation」，点击确定 此时应该就剩下 123456navigation_bar_heightnavigation_bar_height_car_modenavigation_bar_height_landscapenavigation_bar_height_landscape_car_modenavigation_bar_widthnavigation_bar_width_car_mode 这几项 修改下面这几项（点击选项，在输入框中修改） 1234navigation_bar_heightnavigation_bar_height_landscapenavigation_bar_widthnavigation_bar_width_car_mode 为 25dp（这个是我觉得一个比较适合的值，数字大了导航栏就会更高，数字小了导航栏就会更低，可以按照习惯自由调整）剩下的两项改不改都可以 调整完了保存文件，退出编辑器，提示更新文件选是，接着重启，重启之后导航栏的高度就降下来了 此时你就获得了一个 Android Q 的小横条 效果图 优化侧滑返回手势可以使用流体手势实现，但是返回键的小钩子还有，如何去除？ 修改 /system/priv-app/SystemUI/SystemUI.apk 中的 ic_sysbar_back_quick_step.xml（寻找方式同上） 将 android:fillColor 后的值改为 ?00000000（也就是不透明度为0%的黑色），剩下的什么都不要动 保存退出重启即可 效果图]]></content>
      <tags>
        <tag>刷机</tag>
        <tag>魔改</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1608《路径统计》]]></title>
    <url>%2F2020-01-20%2FLuogu-P1608%2F</url>
    <content type="text"><![CDATA[《最短路计数》加上一点小细节 解析具体实现思想就不说了。说一点要注意的细节： 判重！！！ 本题有重边，而且重边似乎不算不同路径？ 所以要对本题的加边稍加修改 1234567891011int minEdge[MAXN][MAXN];// ...for (int i = 1; i &lt;= e; ++i) &#123; int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); if (minEdge[u][v] == 0 || minEdge[u][v] &gt;= w) &#123; minEdge[u][v] = w; head[u].push_back(Edge(v, w)); &#125;&#125; 剩下就没了 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//// LuoguP1608.cpp// Debugging//// Created by HandwerSTD on 2019/9/7.（9月7号的代码次年1月才写完。。。）// Copyright © 2019 HandwerSTD. All rights reserved.////#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;const int MAXN = 2000 + 10;struct Edge &#123; int v, w; Edge(int _v = 0, int _w = 0) : v(_v), w(_w) &#123;&#125; &#125;;struct Node &#123; int now, wt; Node(int _n = 0, int _w = 0) : now(_n), wt(_w) &#123;&#125; bool operator &lt; (const Node &amp;that) const &#123; return wt &gt; that.wt; &#125;&#125;;int n, e;std::vector&lt;Edge&gt; head[MAXN];int dis[MAXN], ans[MAXN];int minEdge[MAXN][MAXN];bool vis[MAXN];std::priority_queue&lt;Node&gt; q;void SPFA() &#123; memset(dis, 0x3f, sizeof dis); q.push(Node(1, 0)); dis[1] = 0; ans[1] = 1; while (!q.empty()) &#123; Node nwn = q.top(); q.pop(); int u = nwn.now; if (vis[u]) continue; vis[u] = true; for (int i = 0, siz = (int) head[u].size(); i &lt; siz; ++i) &#123; int v = head[u][i].v, w = head[u][i].w; if (dis[v] &gt; dis[u] + w) &#123; dis[v] = dis[u] + w; ans[v] = ans[u]; q.push(Node(v, dis[v])); &#125; else if (dis[v] == dis[u] + w) &#123; ans[v] += ans[u]; &#125; &#125; &#125;&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;e); for (int i = 1; i &lt;= e; ++i) &#123; int u, v, w; scanf("%d %d %d", &amp;u, &amp;v, &amp;w); if (minEdge[u][v] == 0 || minEdge[u][v] &gt;= w) &#123; minEdge[u][v] = w; head[u].push_back(Edge(v, w)); &#125; &#125; SPFA(); if (dis[n] == 0x3f3f3f3f) printf("No answer\n"); else printf("%d %d\n", dis[n], ans[n]); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2001《Shortest Prefixes》]]></title>
    <url>%2F2020-01-18%2FPOJ2001%2F</url>
    <content type="text"><![CDATA[这题在纸上手玩一遍找找规律就出来了 传送门：http://poj.org/problem… 解析首先看到这是个字符串题 再然后一想，这个要处理前缀相等问题 好，就是你了，Trie 先把给定的字符串插进 Trie 里 在纸上画出样例的 Trie 树，手玩一下，找找规律 应该可以发现这样一句废话：一个字符串的「最短无歧义缩写」是该字符串到「它的『最长有歧义缩写』的最后一位」的下一位所构成的前缀 举个例子： 123456字符串“wyhaksx”和“wyhaknoi”w y h a k s xw y h a k n o i此时 wyhak 这个缩写是有歧义的，因为它两句话都能表示，而且它还是最长有歧义缩写；但是再加一个字母，wyhaks 就没有歧义了，是最短无歧义缩写，因为它只能表示 wyhaksx 不能表示 wyhaknoi，而你找不到比它更短的了 同时对照着 Trie 树看看（再添加一个“wyhac”加强例子的一般性）： 12345678910w → y → h↘ a → c ↓ k ↙ ↘ s n ↓ ↓ x o ↓ i 你发现了什么？最长有歧义缩写的结尾正好在深度最大的分支处！最短无歧义缩写的结尾正好是深度最大的分支的子节点！ 两个字符串，一个字符串是另一个字符串的子串（“wyh”和“wyhak”）这种情况先不考虑。 那么现在问题转化成了如何找深度最高的分支的位置。 这个比较简单，在插入字符串的时候，对于每一个节点，记一下这个点有几条向下连的边，连边数超过 2 的话就是分支；再记一下这个节点的父亲是谁；插完之后记一下这个字符串对应结尾在 Trie 中的位置（也就是动态开点后的节点编号）。 查找的时候，从刚刚记的结尾位置开始向上查找，直到找到第一个分支，返回它的子节点编号即可 代码： 123456789101112int findNode(int down) &#123; // 沿着叶子节点往上走，找到第一个分叉节点，返回它的儿子 // 分叉节点即为向下连的边超过两条的点 int now = location[down]; // 获取这个字符串对应的结尾节点 while (true) &#123; if (now == 1) break; // 居然滚回根节点了 int father = node[now].from; // 父亲节点 if (node[father].edges &gt;= 2) break; // 找到了 orz now = father; // 往上跳 &#125; return now;&#125; 接下来只需要顺着下去溜一遍，把字符串复制一下输出就好了，需要注意的是到了刚刚找到的节点要 break 掉 代码： 1234567891011std::string find(int down) &#123; int endNode = findNode(down); // 调用上面的函数获取最终节点 std::string res = ""; std::string &amp;ds = originalStrings[down]; int now = 1; for (int i = 0, len = (int) ds.length(); i &lt; len; ++i) &#123; int next = node[now].next[toNum(ds[i])]; // 获取当前节点的子节点 res += ds[i]; now = next; // 复制字符串，更新位置 if (next == endNode) break; // 如果下一个节点是终点，那就停掉 &#125; return res; // 返回这个输出的结果就好了&#125; One more thing. 「两个字符串，一个字符串是另一个字符串的子串的情况」？答案：简单粗暴地在字符串尾加一个特殊字符，强行搞出一个分支来 12345例如“wyh”和“wyhak”可以修改成“wyh#”和“wyhak#”w → y → h → # ↘ a → k → # 这样不就有分支了吗 那是不是还要修改一下 std::string find(int) 函数？不用！ 注意到这种情况下，调用 findNode(int) 函数获得的实际上是 # 所在的节点编号，而 find(int) 函数在找的时候，循环 至多 会循环到 原字符串的长度，复制字符串 至多 会复制 完整的原字符串，所以压根不需要特判。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;const int MAXSTRS = 1000 + 10;std::string originalStrings[MAXSTRS];int location[MAXSTRS];class Trie &#123;private: static const int MAXNODES = 30000 + 10; struct Node &#123; bool str; int from, siz, edges; int next[30]; Node() &#123; str = 0; from = siz = edges = 0; memset(next, 0, sizeof next); &#125; &#125;; Node node[MAXNODES]; int cnt; int toNum(const char &amp;s) &#123; if (s == '#') return 27; return s - 'a' + 1; &#125;public: Trie() &#123; cnt = 1; &#125; void insert(std::string s, int down) &#123; int now = 1, strLen = (int) s.length(); for (int i = 0; i &lt; strLen; ++i) &#123; int &amp;next = node[now].next[toNum(s[i])]; if (next == 0) &#123; next = ++cnt; node[next].from = now; ++node[now].edges; &#125; now = next; &#125; node[now].str = true; location[down] = now; &#125; int findNode(int down) &#123; // 沿着叶子节点往上走，找到第一个分叉节点，返回它的儿子 // 分叉节点即为向下连的边超过两条的点 int now = location[down]; while (true) &#123; if (now == 1) break; // md 居然滚回根节点了 int father = node[now].from; // 父亲节点 // printf("\tNow on node [%d], its father is [%d], \n\tits father's out-edges amount is %d;\n", now, father, node[father].edges); if (node[father].edges &gt;= 2) break; // 找到了 orz now = father; // 往上跳 &#125; return now; &#125; std::string find(int down) &#123; // 获得答案 // printf("[DEBUG] Now processing [%d] -&gt; %s:\n", down, originalStrings[down].c_str()); int endNode = findNode(down); // printf("\tendNode = %d\n", endNode); // printf("\tCopying string...\n"); std::string res = ""; std::string &amp;ds = originalStrings[down]; int now = 1; for (int i = 0, len = (int) ds.length(); i &lt; len; ++i) &#123; int next = node[now].next[toNum(ds[i])]; // printf("\tnow = %d, next = %d, now char = %c\n", now, next, ds[i]); res += ds[i]; now = next; if (next == endNode) break; &#125; return res; &#125;&#125; trie;int main() &#123; int n = 0; while (std::cin &gt;&gt; originalStrings[++n]); --n; for (int i = 1; i &lt;= n; ++i) trie.insert(originalStrings[i] + "#", i); // trie.initSize(); for (int i = 1; i &lt;= n; ++i) &#123; printf("%s %s\n", originalStrings[i].c_str(), trie.find(i).c_str()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2761《软件补丁问题》]]></title>
    <url>%2F2020-01-17%2FLuogu-P2761%2F</url>
    <content type="text"><![CDATA[或 CTSC99《补丁 VS 错误》 说的那么麻烦，其实就一最短路。。 题目传送门：https://www.luogu.com.cn/problem/P2761 解析第一个，这题是状压，反正错误不超过 20 个； 第二个，这题要在一个一个状态之间转移，因为补丁包修复错误的同时还带来了错误； 第三个，这题有起始状态（全是错误）和最终状态（没有错误），状态转移还有额外代价。 所以！这题用动态规划最短路肯定没错！ 把 20 个错误的拥有情况压成 20 位的 int，0 表示无此错误，1 表示有此错误 把这些状态抽象成点，在一个一个状态之间转移的补丁包抽象成有向边，补丁包的安装时间抽象成边权，跑最短路就完了 问题是，边的数量未免有点太多了吧，可以构造出一个全 0 的补丁包，这样所有的点都要连边啊 qaq 那就索性不连边了……反正就 100 个补丁包，每次 for 一遍检查哪些补丁包能用的也没大问题 检查补丁包能不能用这个我不用再讲了吧……基本二进制操作 有一个小 trick：在修复软件包的时候不能直接把错误状态和修复状态异或（因为有些错误可能并不存在，这时候异或就不对了），例子是 1011 ^ 0111 = 1100 != 1000。这时候可以先让它强制获得这个错误，然后再修复掉这些错误，也就是先 1011 | 0111 再 1111 ^ 0111 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;queue&gt;const int MAXM = 100 + 10;const int MAX_NODE = (1 &lt;&lt; 22);int n, m;struct Patch &#123; int usage; int required, requiredNot; int fixedBugs, newBugs; Patch(int _us = 0, int _r = 0, int _rn = 0, int _f = 0, int _n = 0) : usage(_us), required(_r), requiredNot(_rn), fixedBugs(_f), newBugs(_n) &#123;&#125; void read() &#123; std::string requireStr, effectStr; std::cin &gt;&gt; usage &gt;&gt; requireStr &gt;&gt; effectStr; for (int i = 0; i &lt; n; ++i) &#123; if (requireStr[i] == '+') required += (1 &lt;&lt; (i)); else if (requireStr[i] == '-') requiredNot += (1 &lt;&lt; (i)); if (effectStr[i] == '-') fixedBugs += (1 &lt;&lt; (i)); else if (effectStr[i] == '+') newBugs += (1 &lt;&lt; (i)); &#125; &#125;&#125; patches[MAXM];struct Node &#123; int id, wt; Node(int _i = 0, int _w = 0) : id(_i), wt(_w) &#123;&#125; bool operator &lt; (const Node &amp;that) const &#123; return wt &gt; that.wt; &#125;&#125;;int dist[MAX_NODE];bool vis[MAX_NODE];int getInstallResult(int id, Patch p) &#123; if ((id | p.required) != id) return -1; if ((id &amp; p.requiredNot) != 0) return -1; int res = (((id | p.fixedBugs) ^ p.fixedBugs) | p.newBugs); return res;&#125;void shortestPath() &#123; std::priority_queue&lt;Node&gt; q; int init = ((1 &lt;&lt; n) - 1); while (!q.empty()) q.pop(); q.push(Node(init, 0)); memset(dist, 0x3f, sizeof dist); dist[init] = 0; while (!q.empty()) &#123; Node nownode = q.top(); q.pop(); int u = nownode.id; if (vis[u]) continue; vis[u] = true; for (int i = 1; i &lt;= m; ++i) &#123; int res = getInstallResult(u, patches[i]); if (res == -1) continue; if (dist[res] &gt; dist[u] + patches[i].usage) &#123; dist[res] = dist[u] + patches[i].usage; q.push(Node(res, dist[res])); &#125; &#125; &#125;&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; patches[i].read(); &#125; shortestPath(); if (dist[0] != 0x3f3f3f3f) printf("%d\n", dist[0]); else puts("0"); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2449《[SDOI2005]矩形》]]></title>
    <url>%2F2019-11-05%2FLuogu-P2449%2F</url>
    <content type="text"><![CDATA[真就正解是暴力呗 题目描述现在我们在一个平面上画了n个矩形。每一个矩形的两边都与坐标轴相平行，且矩形定点的坐标均为整数。现我们定义满足如下性质的图形为一个块： 1.每一个矩形都是一个块； 2.如果两个块有一段公共的部分，那么这两个块就会形成一个新的块，否则这两个块就是不同的。 示例： 图1中的矩形形成了两个不同的块。图2中的矩形形成了一个块。 任务： 请写一个程序： 1.从文本文件PRO.IN中读入各个矩形的顶点坐标； 2.找出这些矩形中不同的块的数目； 3.把结果输出到文本文件PRO.OUT中。 输入格式文本文件PRO.IN的第一行包括一个整数n，1 &lt;= n &lt;= 7000，为矩形的数目。以下的n行为矩形顶点的坐标。每一个矩形都是用四个整数来描述的：左下角的x坐标、左下角的y坐标、右上角的x坐标和右上角的y坐标。所有的坐标都是不大于10000的非负整数。 输出格式在文本文件PRO.OUT中输出唯一的一个整数——这些矩形所形成的不同的块的数目。 解析考试题 当时看到这题发现自己只会 $O(n^2\log n)$，最后拿了 54pts考试结束看了一眼洛谷题解，发现这玩意真就是个暴力。。。自己写丑了才少拿了分 具体就是 $O(n^2)$ 枚举所有的矩形，判断是否是一个联通块，是就用并查集把编号连起来，时间复杂度 $O(n^2\log n)$ 代码实现这里不给出代码，原因是洛谷数据过水导致我的 AC 代码可以被 Hack 掉。。找个时间再放上来吧]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>并查集</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3200《[HNOI2009]有趣的数列》]]></title>
    <url>%2F2019-11-04%2FLuogu-P3200%2F</url>
    <content type="text"><![CDATA[卡特兰数 + 质因数分解 题目描述我们称一个长度为2n的数列是有趣的，当且仅当该数列满足以下三个条件： (1)它是从1到2n共2n个整数的一个排列{ai}； (2)所有的奇数项满足a1&lt;a3&lt;…&lt;a2n-1，所有的偶数项满足a2&lt;a4&lt;…&lt;a2n； (3)任意相邻的两项a2i-1与a2i(1&lt;=i&lt;=n)满足奇数项小于偶数项，即：a2i-1&lt;a2i。 现在的任务是：对于给定的n，请求出有多少个不同的长度为2n的有趣的数列。因为最后的答案可能很大，所以只要求输出答案 mod P的值。 输入格式输入文件只包含用空格隔开的两个整数n和P。输入数据保证，50%的数据满足n&lt;=1000，100%的数据满足n&lt;=1000000且P&lt;=1000000000。 输出格式仅含一个整数，表示不同的长度为2n的有趣的数列个数mod P的值。 解析首先给出结论：卡特兰数。 注意到偶数位的数字必须大于前面偶数位、偶数位必须大于奇数位两个性质，可以得出这个结论： 对于任意偶数位的数字，都满足该数字大于前面的所有数字 考虑把偶数位、奇数位拆出来看，即拆成一个两行 n 列的矩阵，第一行表示奇数位，第二行表示偶数位。上面的式子可以写成： 对于任意在第二行的数字，都满足它大于它左边、左上边（不含正上方）的所有数字 把第一排的数字都记为 0，第二排的数字都记为 1，放回到原序列，再联系前面的结论，可以得出： 在（更新为 0 或 1 的）原序列中，对于任意一位 0，都满足前面的所有 0 的个数不小于前面所有 1 的个数；对于任意一位 1，都满足前面的所有 0 的个数大于前面所有 1 的个数 如果把 0 看作栈的入栈操作，1 看作栈的出栈操作，那么上面的式子可以写成： 在一个栈操作序列中，对于任意一个入栈操作，都满足前面的入栈操作数不小于前面的出栈操作数；对于任意一个出栈操作，都满足前面的入栈操作数大于前面的出栈操作数 也就是求 长度为 n 的合法栈操作序列个数 / 出栈序列个数 这个怎么求我不用再多说了吧 接下来是另一个问题：取模 题目的 $p$ 是读入的，样例就明明白白的说了不一定是质数，甚至还可能很小 怎么办？ 分解质因数。 注意到 \begin{aligned} \text{ans} &= {C_{2n}^n \over n + 1} \\ &= { { { (2n)! } \over { n! \times n! } } \over { n + 1 } } \\ &= { { (2n)! } \over { (n!)^2(n + 1) } } \\ &= { { 1\times 2\times\dots \times (n - 1)\times n\times (n + 1)\times\dots\times (2n - 1)\times 2n } \over { [1\times 2\times\dots \times (n - 1)\times n] \times [1\times 2\times\dots \times (n - 1)\times n] \times (n + 1) } } \end{aligned}分数上下消一消 \begin{aligned} \text{ans} &= { {(n + 2) \times (n + 3) \times \dots \times (2n - 1) \times 2n} \over {1\times 2\times\dots \times (n - 1)\times n} } \end{aligned}然后记 $f_i(i \in \text{Primes})$ 表示在答案中，编号为 $i$ 的质数被乘了几次，也就是把 $ans$ 进行唯一分解放到一个数组里 怎么求 $f$ ？ 直接上代码： 1234567891011121314151617181920// 在线性筛中，如果 i 这个数是被第 k 个质数筛掉的，那么 sieveBy[i] = k// prs[i] 表示第 i 个质数for (int i = n + 2; i &lt;= 2 * n; ++i) &#123; // 加上分子 n + 2 到 2n 的乘积的分解 int x = i; while (x &gt; 1) &#123; // 分解质因数 ++f[sieveBy[x]]; x = x / prs[sieveBy[x]]; &#125;&#125;for (int i = 2; i &lt;= n; ++i) &#123; // 消去分母中 1 到 n 的乘积的分解 int x = i; while (x &gt; 1) &#123; --f[sieveBy[x]]; x = x / prs[sieveBy[x]]; &#125;&#125; 最后 for 一遍所有的质数，快速幂乘一下就好了 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;bool notprime[2000000 + 10];int prs[2000000 + 10], cnt;int sieveBy[2000000 + 10];int n, p;int calcs[2000000 + 10];int fastPow(int a, int b, int p) &#123; int ret = 1; while (b) &#123; if (b &amp; 1) ret = 1ll * ret * 1ll * a % p; a = 1ll * a * 1ll * a % p; b &gt;&gt;= 1; &#125; return ret;&#125;void sieve() &#123; notprime[0] = notprime[1] = true; for (int i = 2; i &lt;= 2 * n; ++i) &#123; if (!notprime[i]) &#123; prs[++cnt] = i; sieveBy[i] = cnt; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; i * prs[j] &lt;= 2 * n; ++j) &#123; notprime[i * prs[j]] = true; sieveBy[i * prs[j]] = j; &#125; &#125;&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;p); sieve(); // ans = ((2n)! / (n! * n!) * (n + 1)) // = ((1 * 2 * ... * (n - 1) * n * (n + 1) * (n + 2) * (n + 3) * ... * 2n) / // (1 * 2 * ... * (n - 1) * n) * (1 * 2 * ... * (n - 1) * n) * (n + 1)) // = ((n + 1) * (n + 2) * (n + 3) * ... * 2n) / // ((1 * 2 * ... * (n - 1) * n) * (n + 1)) // = ((n + 2) * (n + 3) * ... * 2n) / ((1 * 2 * ... * (n - 1) * n) for (int i = n + 2; i &lt;= 2 * n; ++i) &#123; int x = i; while (x &gt; 1) &#123; // printf("Now exting: %d\n", x); ++calcs[sieveBy[x]]; x = x / prs[sieveBy[x]]; &#125; &#125; // printf("Calc 1.\n"); for (int i = 2; i &lt;= n; ++i) &#123; int x = i; while (x &gt; 1) &#123; --calcs[sieveBy[x]]; x = x / prs[sieveBy[x]]; &#125; &#125; int ans = 1; for (int i = 1; i &lt;= cnt; ++i) &#123; ans = 1ll * ans * 1ll * fastPow(prs[i], calcs[i], p) % p; &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>筛法</tag>
        <tag>质数</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3331《[BeiJing2013]压力》]]></title>
    <url>%2F2019-11-03%2FBZOJ3331%2F</url>
    <content type="text"><![CDATA[题意给你一张 n 个点 m 条边的无向图，再给你 q 个点对，让你计算对于每一个点，有多少个点对间的路径必定经过这个点。N≤100000,M,Q≤200000。 解析首先可以发现这样一个东西： 在原图对应的圆方树上，一个点对之间的所有圆点都会被经过 那就好做了 首先建出圆方树，然后问题转化为了一个树上链修改，单点查询的题目 直接树上差分一下就行了 我还是讲一下这个差分吧 具体就是对于点对(u,v)，diff[u]++, diff[v]++, diff[LCA(u,v)]--, diff[father[LCA(u,v)]]-- 最后一遍 dfs 还原一下树上前缀和即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//// Created by HandwerSTD on 2019/11/2.// Copyright (c) 2019 HandwerSTD. All rights reserved.// Title: [BeiJing2013]压力//// sto Qingyu orz// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，// 使其天天爆零// 我不由自主地膜拜真神sqy。//#include &lt;cstdio&gt;#include &lt;vector&gt;const int MAXN = 200000 + 10;const int NEWN = MAXN &lt;&lt; 1;const int MAXQ = 200000 + 10;struct Node &#123; int next; bool typ; Node(int _next = 0, bool _typ = false) &#123; next = _next; typ = _typ; &#125;&#125;;struct qu &#123; int u, v; qu(int _u = 0, int _v = 0) &#123; u = _u; v = _v; &#125; &#125; qs[MAXQ];int n, tn, m, q;std::vector&lt;int&gt; head[MAXN];std::vector&lt;int&gt; tree[NEWN];namespace Tarjan &#123; static int dfn[MAXN], low[MAXN], timestamp; static int stk[MAXN], top; void work(int, int); void tarjan() &#123; tn = n; for (int i = 1; i &lt;= tn; ++i) if (!dfn[i]) work(i, 0); &#125; void work(int u, int fa) &#123; dfn[u] = low[u] = ++timestamp; stk[++top] = u; for (int i = 0, siz = (int) head[u].size(); i &lt; siz; ++i) &#123; int v = head[u][i]; if (!dfn[v]) &#123; work(v, u); low[u] = std::min(low[u], low[v]); if (low[v] &gt;= dfn[u]) &#123; int x = -1; ++tn; // 直接在这里建圆方树，++tn 是给圆方树的方点分配编号 do &#123; x = stk[top--]; tree[tn].push_back(x); tree[x].push_back(tn);// printf("Edge connected: &lt;%d, %d&gt;\n", tn, x); &#125; while (x != v); tree[u].push_back(tn); tree[tn].push_back(u);// printf("Edge connected: &lt;%d, %d&gt;\n", tn, u); &#125; &#125; else if (v != fa) low[u] = std::min(low[u], dfn[v]); &#125; &#125;&#125;namespace LCA &#123; static int father[NEWN][30], depth[NEWN]; static int lg[NEWN]; void dfs(int, int); void init() &#123; for (int i = 1; i &lt;= tn; ++i) &#123; lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i); &#125; dfs(1, 0); &#125; void dfs(int u, int fa) &#123; father[u][0] = fa; depth[u] = depth[fa] + 1; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[u]; ++i) &#123; father[u][i] = father[father[u][i - 1]][i - 1]; &#125; for (int i = 0, siz = (int) tree[u].size(); i &lt; siz; ++i) &#123; int v = tree[u][i]; if (v != fa) dfs(v, u); &#125; &#125; int get(int u, int v) &#123; if (depth[u] &lt; depth[v]) std::swap(u, v); while (depth[u] &gt; depth[v]) &#123; u = father[u][lg[depth[u] - depth[v]] - 1]; &#125; if (u == v) return u; for (int i = lg[depth[u]]; i &gt;= 0; --i) &#123; if (father[u][i] != father[v][i]) &#123; u = father[u][i]; v = father[v][i]; &#125; &#125; return father[u][0]; &#125;&#125;namespace Difference &#123; static int diff[NEWN]; void modify(int u, int v) &#123; int l = LCA::get(u, v);// printf("u = %d, v = %d, LCA&lt;%d, %d&gt; = %d, LCA's father = %d\n", u, v, u, v, l, LCA::father[l][0]); ++diff[u]; ++diff[v]; --diff[l]; --diff[LCA::father[l][0]]; &#125; void dfs(int u) &#123;// printf("[dfs(u)] u = %d\n", u); using LCA::father; for (int i = 0, siz = (int) tree[u].size(); i &lt; siz; ++i) &#123; int v = tree[u][i]; if (v == father[u][0]) continue; dfs(v); diff[u] += diff[v]; &#125; &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= m; ++i) &#123; int u, v; scanf("%d %d", &amp;u, &amp;v); head[u].push_back(v); head[v].push_back(u); &#125; for (int i = 1; i &lt;= q; ++i) &#123; int u, v; scanf("%d %d", &amp;u, &amp;v); qs[i] = qu(u, v); &#125; Tarjan::tarjan(); LCA::init(); for (int i = 1; i &lt;= q; ++i) &#123; int u = qs[i].u, v = qs[i].v;// printf("Query #%d: u = %d, v = %d\n", i, u, v); Difference::modify(u, v); &#125; Difference::dfs(1); for (int i = 1; i &lt;= n; ++i) &#123; printf("%d\n", Difference::diff[i]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>差分</tag>
        <tag>Tarjan</tag>
        <tag>圆方树</tag>
        <tag>LCA</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可持久化线段树学习笔记]]></title>
    <url>%2F2019-11-03%2FPersistent-Segment-Tree%2F</url>
    <content type="text"><![CDATA[可持久化数据结构初探 操作请设计一个支持如下操作的数据结构： 扩大这个数据结构的范围（如从 $[1,n]$ 扩大到 $[1,n + k]$，保证最终的大小不会超过 $10^5$） 在最新版本基础上修改某个位置上的值 查询最新版本某个位置上的值 回滚到某一个版本 在某一个版本基础上修改某个位置的值 查询某一个版本某个位置上的值 为了方便，初始时数据结构范围为 $[1,1]$；输入数据均为正整数；每次修改时，都要新建一个版本（基于哪一个版本取决于操作的编号）；每次查询时，新建一个与最新版本相同的版本 解析前置条件： 数组下标从 1 开始 一开始就直接开到最大数据结构大小 朴素算法 1将版本视为一个时间轴，建立一个二维数组，第一维表示版本，第二维存对应版本的数据，每一次操作时把基于的版本复制一遍，然后修改、查询。 时空复杂度 $\mathcal{O}(nm)$，其中 $n$ 为数据结构最大大小，$m$ 为数据结构最大版本数 朴素算法 2依然将版本视为一个时间轴，建立意义与朴素算法 1 相同的二维数组，不同的是，这次不再复制整个数组，取而代之的是在没有用到的下标 0 处记录这个版本是基于哪个版本的，修改只需修改对应的元素即可。查询时，先看这个元素是不是 0（意味着未被修改），是则跳到下标 0 记录的版本，重复这个过程，直到元素非 0，输出即可 空间复杂度 $\mathcal{O}(nm)$；修改时间复杂度 $\mathcal{O}(1)$，查询时间复杂度最坏为 $\mathcal{O}(m)$；$n,m$ 意义同朴素算法 1。 可持久化线段树为什么要说算法 2 呢？我个人认为，算法 2 只修改有用的点的特性正符合可持久化线段树的特点。 顺着算法 2 想下去。发现算法 2 有大量无用的空间，怎么办？ 搬出树形结构，再加动态开点。 树的结构及修改操作一棵线段树长这样： 然后发现修改第二个元素需要经历这些节点： 依据算法 2，开一些新的点作为这个版本的点蓝点为原来的点，橙点为这个版本经过的点 可以发现它不再是一棵树。但是如果不看那些“被修改”的蓝点，它仍然是一棵二叉树……怎么办？ 不妨把它视为多棵线段树，每一棵树都是一个版本，最顶上的依然是树根，只不过这些线段树共享了一些相同的节点。 具体实现的话，就把线段树的根节点们存在一个数组root[]中，这样，root[i]就表示第 i 棵（第 i 个版本的）线段树的根节点编号。 看一眼代码吧： 1234567891011121314151617181920212223242526272829// 建树，把原始数列建到树的 0 版本上int roots[]; // 根节点数组struct Node &#123; int ls, rs, val; // ls 表示左儿子编号，rs 表示右儿子编号，val 表示节点信息&#125; tree[];int cnt; // 节点编号计数器void buildTree(int &amp;root, int l, int r) &#123; // root 要引用的原因是操作过程中 // 要对存放根节点、左儿子（左子树的根节点）、右儿子（右子树的根节点）编号的变量进行更新 // 直接引用变量的话可以省一步赋值，写起来也方便 root = ++cnt; // 给新的节点——当前子树的根节点分配编号 if (l == r) return ((void) (tree[root].val = seq[l])); // 经典的线段树赋值 int mid = (l + r) &gt;&gt; 1; buildTree(tree[root].ls, l, mid); buildTree(tree[root].rs, mid + 1, r); // 左右子树建树 &#125;int main() &#123; // ... buildTree(roots[0], 1, n); // 把 0 版本的根节点编号传进去 // ...&#125; 123456789101112131415161718// 修改操作，root 表示当前子树根节点编号，引用也是因为更新方便// base 表示当前修改的是基于哪个版本的，存的是那个版本「对应深度」子树的根节点编号void modify(int &amp;root, int base, int l, int r, int pos, int k) &#123; root = ++cnt; tree[root] = tree[base]; // 分配根节点编号，把节点信息原份复制下来，后面再修改 if (l == r) &#123; tree[root].val = k; return; &#125; // 经典的单点赋值 int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) modify(tree[root].ls, tree[base].ls, l, mid, pos, k); else modify(tree[root].rs, tree[base].rs, mid + 1, r, pos, k); // 对左右子树修改，顺便可以直接更新这个节点的左右儿子信息int main() &#123; // ... modify(roots[新的版本], roots[基于哪个版本], 1, n, 修改的位置, 值); // ...&#125; 查询操作明白了 root[] 数组的意义，查询就很简单了 比如说查询版本 1（初始版本为 0），就是顺着版本 1 的根节点往下找对应位置，查到底部返回。图中灰色的节点是查版本 1 永远碰不到的节点——因为它们在版本 1 中被修改了，而剩下的点依然形成了一棵线段树，顺着这棵树查下去就完事了 123456789101112131415// 查询操作，root 不加引用是因为查询操作没必要对线段树进行修改// 经典的单点查询，不讲了int query(int root, int l, int r, int pos) &#123; if (l == r) return tree[root].val; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) return query(tree[root].ls, l, mid, pos); else return query(tree[root].rs, mid + 1, r, pos); &#125;int main() &#123; // ... query(roots[查询的版本], 1, n, 查询的位置); // ...&#125; 杂项扩大数据结构范围这个其实不用管。。。毕竟一开始就已经把范围开好了 回滚到某个版本对线段树的具体内容没有一点操作，直接把新版本的根节点编号设为回滚到的版本 12345int main() &#123; // ... roots[新的版本] = roots[回滚到的版本]; // ...&#125; 关于数据范围由于线段树的空间开销本身就很大，再加上可持久化的节点，一般开到原数据范围的 32 倍（即MAXN &lt;&lt; 5） 代码实现题目：洛谷P3919《【模板】可持久化数组》支持的操作：操作 2、3、5、6 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//// Created by HandwerSTD on 2019/11/2.// Copyright (c) 2019 HandwerSTD. All rights reserved.// Title: 可持久化数组// Used data structure: 可持久化线段树//#include &lt;cstdio&gt;const int MAXN = 1e6 + 10;struct Node &#123; int ls, rs, val; Node(int _ls = 0, int _rs = 0, int _val = 0) &#123; ls = _ls; rs = _rs; val = _val; &#125;&#125; tree[MAXN &lt;&lt; 5]; int cnt;int n, m, seq[MAXN], roots[MAXN], versions;void buildTree(int &amp;root, int l, int r) &#123; root = ++cnt; if (l == r) return ((void) (tree[root].val = seq[l])); int mid = (l + r) &gt;&gt; 1; buildTree(tree[root].ls, l, mid); buildTree(tree[root].rs, mid + 1, r);&#125;void modify(int &amp;root, int base, int l, int r, int pos, int k) &#123; root = ++cnt; tree[root] = tree[base]; if (l == r) &#123; tree[root].val = k; return; &#125; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) modify(tree[root].ls, tree[base].ls, l, mid, pos, k); else modify(tree[root].rs, tree[base].rs, mid + 1, r, pos, k);&#125;int query(int root, int l, int r, int pos) &#123; if (l == r) return tree[root].val; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) return query(tree[root].ls, l, mid, pos); else return query(tree[root].rs, mid + 1, r, pos);&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf("%d", seq + i); buildTree(roots[0], 1, n); for (int i = 1; i &lt;= m; ++i) &#123; int ver, cmd, loc; scanf("%d %d %d", &amp;ver, &amp;cmd, &amp;loc); if (cmd == 1) &#123; int x; scanf("%d", &amp;x); modify(roots[++versions], roots[ver], 1, n, loc, x); &#125; else &#123; printf("%d\n", query(roots[ver], 1, n, loc)); roots[++versions] = roots[ver]; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>可持久化线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1383「IOI 2012」《高级打字机》]]></title>
    <url>%2F2019-11-02%2FLuogu-P1383%2F</url>
    <content type="text"><![CDATA[IOI 也出板子题？ 题目描述早苗入手了最新的高级打字机。最新款自然有着与以往不同的功能，那就是它具备撤销功能，厉害吧。 请为这种高级打字机设计一个程序，支持如下3种操作： 1.T x：在文章末尾打下一个小写字母x。(type操作) 2.U x：撤销最后的x次修改操作。（Undo操作） （注意Query操作并不算修改操作） 3.Q x：询问当前文章中第x个字母并输出。（Query操作） 文章一开始可以视为空串。 输入格式第1行：一个整数n，表示操作数量。 以下n行，每行一个命令。保证输入的命令合法。 输出格式每行输出一个字母，表示Query操作的答案。 输入输出样例输入 #1123456787T aT bT cQ 2U 2T cQ 2 输出 #112bc 说明/提示【数据范围】 对于40%的数据 n&lt;=200; 对于100%的数据 n&lt;=100000；保证Undo操作不会撤销Undo操作。 &lt;高级挑战&gt; 对于200%的数据 n&lt;=100000；Undo操作可以撤销Undo操作。 必须使用在线算法完成该题。 解析普通数据就是个模拟。。。没啥好讲的 代码之后会给 IOI 挑战原题为 IOI2012 Scrivener PDF 链接 这不就是个可持久化数组板子吗。。。 就这还 IOI 题？ 算了还是好好说一下三种操作吧 插入操作提前开好一个大小为 n 的可持久化数组，每次插入的时候建一个新的版本，把上个版本的长度 + 1 处字符修改了就好 撤销操作直接新开一个版本，把版本信息（根节点和长度）修改成撤销到的那个版本就行了 查询操作这个就是模板操作了，不再赘述 什么？听说你不会可持久化数据结构？不久之后我会专门开一篇讲的 代码实现普通数据1234567891011121314151617181920212223242526#include &lt;cstdio&gt;const int MAXN = 100000 + 10;int n, ptr;char ss[MAXN];int main() &#123; scanf("%d", &amp;n); while (n --&gt; 0) &#123; char op[3], a[3]; int x; scanf("%s", op); if (op[0] == 'T') &#123; scanf("%s", a); ss[++ptr] = a[0]; &#125; else if (op[0] == 'U') &#123; scanf("%d", &amp;x); ptr -= x; &#125; else &#123; scanf("%d", &amp;x); printf("%c\n", ss[x]); &#125; &#125; return 0;&#125; IOI 挑战12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;const int MAXN = 100000 + 10;struct Node &#123; int ls, rs; char val; Node(int _ls = 0, int _rs = 0, char _val = 0) &#123; ls = _ls; rs = _rs; val = _val; &#125;&#125; tree[MAXN &lt;&lt; 5]; int cnt;int n, roots[MAXN &lt;&lt; 5], lens[MAXN &lt;&lt; 5], version;void modify(int &amp;root, int base, int l, int r, int pos, char val) &#123; root = ++cnt; tree[root] = tree[base]; if (l == r) return (void) (tree[root].val = val); int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) modify(tree[root].ls, tree[base].ls, l, mid, pos, val); else modify(tree[root].rs, tree[base].rs, mid + 1, r, pos, val);&#125;char query(int root, int l, int r, int pos) &#123; if (l == r) return tree[root].val; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) return query(tree[root].ls, l, mid, pos); else return query(tree[root].rs, mid + 1, r, pos);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; char cmd[3]; scanf("%s", cmd); if (cmd[0] == 'T') &#123; ++version; lens[version] = lens[version - 1] + 1; char sss[3]; scanf("%s", sss); modify(roots[version], roots[version - 1], 1, n, lens[version], sss[0]); &#125; else if (cmd[0] == 'U') &#123; int ver; scanf("%d", &amp;ver); ++version; roots[version] = roots[version - ver - 1]; lens[version] = lens[version - ver - 1]; &#125; else &#123; int pos; scanf("%d", &amp;pos); printf("%c\n", query(roots[version], 1, n, pos)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>可持久化数据结构</tag>
        <tag>线段树</tag>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2090《数字对》]]></title>
    <url>%2F2019-11-01%2FLuogu-P2090%2F</url>
    <content type="text"><![CDATA[更相减损术 题目描述对于一个数字对(a, b)，我们可以通过一次操作将其变为新数字对(a+b, b)或(a, a+b)。 给定一正整数n，问最少需要多少次操作可将数字对(1, 1)变为一个数字对，该数字对至少有一个数字为n。 输入格式第一行一个正整数 n 输出格式一个整数表示答案。 输入输出样例输入 #1 15 输出 #1 13 说明/提示样例解释： (1,1) → (1,2) → (3,2) → (5,2) 对于30%的数据， 1 &lt;= n &lt;= 1000 对于60%的数据， 1 &lt;= n &lt;= 20000 对于100%的数据，1 &lt;= n &lt;= 10^6 解析先手玩一下样例，发现式子是这样的： $(a,b) \leftarrow (a’ + b, b)$ 反过来写 $(a’,b) \rightarrow (a - b, b)$ 这个不是。。。更相减损术？ 所以题目就转化成了：找到一个数字对 $(n,a)$ 使得 gcd(n, a) 进行更相减损的次数最小。 考虑枚举 $a$，上界怎么确定？ 手玩的时候顺便发现从 $(1,1)$ 分出的两条分支是对称的，那么超出 $n$ 的枚举是没有必要的，所以 $1\leq a \leq n$ 每一次 gcd 传下去的参数都是 b,a mod b，更相减损了 $\lfloor {a \over b} \rfloor$ 次， 每次步数要加上这个数；最后如果 $b = 1$，那么步数要另加上 $a - 1$ （从 $(1,1)$ 转移到 $(a,1)$ 需要 $a - 1$ 步）；最后如果 $b = 0$ 那就无解，直接 return inf 别让答案更新就好 代码实现123456789101112131415161718192021222324252627282930//// Created by HandwerSTD on 2019/11/1.// Copyright (c) 2019 HandwerSTD. All rights reserved.// Title: 数字对//// sto Qingyu orz// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，// 使其天天爆零// 我不由自主地膜拜真神sqy。//#include &lt;cstdio&gt;#include &lt;algorithm&gt;int n, ans = 0x7f7f7f7f;int gcd(int a, int b) &#123; if (b == 1) return a - 1; if (b == 0) return 0x7f7f7f7f; return a / b + gcd(b, a % b);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; ans = std::min(ans, gcd(n, i)); &#125; printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2062《分队问题》]]></title>
    <url>%2F2019-11-01%2FLuogu-P2062%2F</url>
    <content type="text"><![CDATA[题目描述给定n个选手，将他们分成若干只队伍。其中第i个选手要求自己所属的队伍的人数大等于a[i]人。 在满足所有选手的要求的前提下，最大化队伍的总数。 注：每个选手属于且仅属于一支队伍。 输入格式第一行一个整数n，表示人数。 以下n行，每行一个整数表示a[i]。 输出格式输出队伍总数的最大值。数据保证有解。 输入输出样例输入 #1123456521223 输出 #112 说明/提示对于20%的数据，n &lt;= 10 对于40%的数据，n &lt;= 1000 对于60%的数据，n &lt;= 10000 对于100%的数据，1 &lt;= n &lt;= 10^6 解析第一反应是个贪心 就是从大往小排序，然后从前往后扫，每碰到一个人就把它后面的人都拉进队 每个元素只会访问一次，时间复杂度$\mathcal{O}(n)$ 但是这个是错的 考虑这组数据： 1n = 4, a[] = &#123; 2, 3, 3, 3 &#125; 贪心跑出来是 2，答案应该是 3原因在于贪心无法判断当前的人是另开一队更优还是加入已有队伍更优，赛后我看了一眼洛谷题解，有人判了这个之后贪心过了但我没看懂 考虑 dp 首先把 a[] 从小到大排个序 然后设 f[i] 表示当前安排了前 i 个人所能获得的最大队伍数转移方程： f_i=\left\{\begin{array}{ll}{f_{i - 1}} & {\left(i < a_i)\right.} \\ {f_{i - a_{i}} + 1} & {\left(i \geq a_i\right)}\end{array}\right.就是，对于一个人，可以把他塞进旧队伍里，也可以接着前面的 $a_i$ 个人开一个新队伍 时间复杂度 $\mathcal{O}(n)$ 代码实现123456789101112131415161718192021222324252627282930//// Created by HandwerSTD on 2019/11/1.// Copyright (c) 2019 HandwerSTD. All rights reserved.// Title: 分队问题//// sto Qingyu orz// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，// 使其天天爆零// 我不由自主地膜拜真神sqy。//#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;const int MAXN = 1e6 + 10;int n, arr[MAXN], f[MAXN];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf("%d", arr + i); std::sort(arr + 1, arr + 1 + n); for (int i = 1; i &lt;= n; ++i) &#123; if (i &lt; arr[i]) f[i] = f[i - 1]; else f[i] = std::max(f[i - 1], f[i - arr[i]] + 1); &#125; printf("%d\n", f[n]); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 1244D《Paint the Tree》]]></title>
    <url>%2F2019-10-28%2FCF1244D%2F</url>
    <content type="text"><![CDATA[因为细节问题没过 pretest 导致我掉分的题目 题意翻译有一棵树，有3种颜色，第i个节点染成第j种颜色的代价是$c_{j,i}$，现在要你求出一种染色方案，使得总代价最小，且对于任意三个相邻的节点，颜色不能相同。输出最小代价与其中一种方案。无解输出$-1$。 $3\le n\le 10^5$ 输入输出样例输入 #112345633 2 34 3 23 1 31 22 3 输出 #11261 3 2 输入 #21234567853 4 2 1 24 2 1 5 45 3 2 1 11 23 24 35 3 输出 #21-1 输入 #31234567853 4 2 1 24 2 1 5 45 3 2 1 11 23 24 35 4 输出 #31291 3 2 1 3 解析拿到样例之后就随便手玩一下，然后再随便举几个例子发现这样一个奇怪的事情： 好像任意的$k(k \geq 2)$叉树都没法染色。。。 这里直接用二叉树的情况解释一下 12345graph LR;A --&gt; BA --&gt; CB --&gt; DB --&gt; E 发现在无论怎么染色，对 A、B、D、E 进行染色总会冲突 所以分析了半天可以发现这样一个有趣的性质： 一棵树能被正确进行染色当且仅当这棵树为一条链。 判完 -1 再来想一想怎么搞一条链的情况 不会了啊。。。完了今晚要掉分了 想一下暴力是怎么做的：$3^n$枚举所有的点怎么填颜色，然后扫一遍判断。继续手玩一条链的情况，发现一个事情： 两个点确定了，整条链的染色方案就唯一确定了。 做法就出来了。 首先判断树是否为一条链（判断每个点的度），不为链则 Failed；然后两重循环大力枚举前两个点的颜色，之后扫一遍确定其他点的颜色，顺便算出花费，更新答案输出最终答案 实现的时候要注意细节很多。。。我比赛的时候因为时间不太够写的很急，结果没过 pretest。。。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//// Created by HandwerSTD on 2019/10/27.// Copyright (c) 2019 HandwerSTD. All rights reserved.// Title: Paint the Tree//// sto Qingyu orz// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，// 使其天天爆零// 我不由自主地膜拜真神sqy。//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using std::cin;using std::cout;using std::endl;const int MAXN = 100000 + 10;int n, linkTop;long long int ans = 10000000000000000;long long int cost[MAXN][4];int degree[MAXN];std::vector&lt;int&gt; head[MAXN];int next[MAXN];long long int col[MAXN], fcol[MAXN];void DFS(int now, int pre) &#123; for (auto v : head[now]) &#123; if (v == pre) continue; next[now] = v; DFS(v, now); &#125;&#125;void Search(int now, int pre, int ppre) &#123; for (; now; now = next[now]) &#123; if (col[ppre] == 1) &#123; if (col[pre] == 2) col[now] = 3; else col[now] = 2; &#125; else if (col[ppre] == 2) &#123; if (col[pre] == 1) col[now] = 3; else col[now] = 1; &#125; else &#123; if (col[pre] == 1) col[now] = 2; else col[now] = 1; &#125; ppre = pre; pre = now; &#125; long long int fcost = 0; for (int i = 1; i &lt;= n; ++i) &#123; fcost += cost[i][col[i]]; &#125; if (ans &gt;= fcost) &#123; ans = fcost; for (int i = 1; i &lt;= n; ++i) &#123; fcol[i] = col[i]; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int c = 1; c &lt;= 3; ++c) &#123; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; cost[i][c]; &#125; &#125; for (int i = 1; i &lt;= n - 1; ++i) &#123; int u = 0, v = 0; scanf("%d %d", &amp;u, &amp;v); head[u].push_back(v); ++degree[u]; head[v].push_back(u); ++degree[v]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (degree[i] &gt; 2) return (0 &amp; puts("-1")); if (degree[i] == 1 &amp;&amp; !linkTop) linkTop = i; &#125; DFS(linkTop, 0); for (int i = 1; i &lt;= 3; ++i) &#123; col[linkTop] = i; int linkNext = next[linkTop]; for (int j = 1; j &lt;= 3; ++j) &#123; col[linkNext] = j; if (i == j) continue; Search(next[linkNext], linkNext, linkTop); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; fcol[i] &lt;&lt; (i == n ? '\n' : ' '); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P5142《区间方差》]]></title>
    <url>%2F2019-10-26%2FLuogu-P5142%2F</url>
    <content type="text"><![CDATA[简单的数据结构题目以及无处不在的取模 题目背景出题人并没有能力写有趣的题面…… 题目描述对于一个长度为n的序列$a_1,a_2,a_3\cdots a_n$​，我们定义它的平均数a为: $a=\frac{1}{n}\sum_{i=1}^{n}a_i$ 并定义它的方差d为: $d=\frac{1}{n}\sum_{i=1}^{n}(a_i-a)^2$ 现在给定一个长度为n的序列$b_1,b_2\cdots b_n$​。你需要支持两种操作。每种操作的格式为c x y。 若c=1，为修改操作，代表将$b_x$​赋值为y。 若c=2，为查询操作，代表查询$b_x$​到$b_y$的方差。 为了避免浮点数误差，请以分数取模形式输出结果（对1000000007（$10^9+7$）取模）。如果不知道什么是分数取模，请看下文。 作者注：原文这里是对乘法逆元对介绍，在此省略 输入格式第一行两个数n,m，代表序列b的长度为n，有m个操作。 第二行n个整数$b_i$​，表示序列b的初始值。 下面有m行整数，每行格式为c a b，含义如上文所示。保证所有操作合法。 输出格式对于每个操作2，输出一行。 输入输出样例输入 #1123456789104 80 0 0 01 1 11 2 21 3 31 4 42 1 12 1 22 1 32 1 4 输出 #112340250000002666666672250000003 说明/提示四次修改后，序列b为：1,2,3,4。 区间[1,1]的方差为0. 区间[1,2]的方差为1/4。4的逆元为250000002。 区间[1,3]的方差为2/3。3的逆元为333333336，2*333333336%M=666666672。 对于50%的数据，n≤1000，m≤1000. 对于100%的数据，n≤100000，m≤100000，1≤b_i≤1000000000，1≤x≤n。对于操作1，1≤y≤1000000000。对于操作2，x≤y≤n。 保证逆元一定存在。注意M=1000000007（10^9+7）。 解析没啥可解析的……推推式子就完了 查询 $[l,r]$ 的方差：首先令 $N = r - l + 1$，有 a = {1 \over N} \sum_{i = l}^{r} a_i而且 d = {1 \over N} \sum_{i = l}^{r} (a_i - a)^2对下面的式子作一番变形： \begin{align*} d &= {1 \over N} \sum_{i = l}^{r} (a_i - a)^2 \\&= {1 \over N} \sum_{i = l}^{r} (a_i^2 + a^2 - 2 a \cdot a_i) \\&= {1 \over N} \big( \sum_{i = l}^{r} a_i^2 + \sum_{i = l}^{r} a^2 - \sum_{i = l}^{r} 2 a \cdot a_i \big) \\&= {1\over N} \big(\sum_{i = l}^{r} a_i^2 + N \times a^2 - 2a \sum_{i = l}^{r} a_i\big) \\&={1\over N}\sum_{i = l}^{r} a_i^2 + {1\over N} \times N \times a^2 - {1\over N} \times2a \sum_{i = l}^{r} a_i \\&={1\over N}\sum_{i = l}^{r} a_i^2 + a^2 - {1\over N} \times2a \sum_{i = l}^{r} a_i \end{align*}这个式子复杂的令人自闭。。这时设 F = \sum_{i = l}^{r} a_i, G = \sum_{i = l}^{r} a_i^2这样到后面式子会好看许多，把 $a$ 代入继续变形 \begin{align*} d &= {1\over N}\sum_{i = l}^{r} a_i^2 + a^2 - {1\over N} \times2a \sum_{i = l}^{r} a_i \\&= {1\over N}\cdot G + {\big({1 \over N} \sum_{i = l}^{r} a_i\big)}^2 - 2 \times {1 \over N} \times {1 \over N} \sum_{i = l}^{r} a_i \times \sum_{i = l}^{r} a_i \\&= {1\over N} \cdot G + {1\over N^2} \cdot F^2-2\times {1\over N^2}\cdot F^2 \\&= {1\over N} \cdot G -{1\over N^2}\cdot F^2 \end{align*}这个就是最后的方差式子。。。终于推出来了 注意到之前设的 $F$ 和 $G$ 是 F = \sum_{i = l}^{r} a_i, G = \sum_{i = l}^{r} a_i^2发现这个东西似乎可以用数据结构维护 然后就是一道树状数组模板题了 维护两个树状数组，一个记录区间和，一个记录区间平方和 这个很好做吧，下面放代码 12345678910111213141516171819202122232425262728// 前缀和lli qu(int p) &#123; lli r = 0; while (p &gt;= 1) &#123; (r += bit[p]) %= HA; lb(p, -1ll); &#125; return r; &#125; // 前缀平方和lli qux(int p) &#123; lli r = 0; while (p &gt;= 1) &#123; (r += bitt[p]) %= HA; lb(p, -1ll); &#125; return r; &#125; // 修改，注意操作是单点覆盖而不是单点加void mo(int p, lli x) &#123; lli d = x - (qu(p) - qu(p - 1)), dx = x * x - (qux(p) - qux(p - 1)); while (p &lt;= n) &#123; bit[p] = (bit[p] + d) % HA; bitt[p] = (bitt[p] + dx) % HA; lb(p, 1ll); &#125; &#125; 然后这道省选/NOI-的题目就做完了真就评分虚高嗷 注意几个坑点 题目的操作是单点覆盖，但是树状数组只能区间加，要先查询一下当前点的值然后加上差值，这个见代码吧 取模！取模！取模 修改和查询都要取模！还要注意负数取模的问题！ 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//// Created by HandwerSTD on 2019/10/23.// Copyright (c) 2019 HandwerSTD. All rights reserved.// Title: 区间方差//// sto Qingyu orz// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，// 使其天天爆零// 我不由自主地膜拜真神sqy。//#include &lt;cstdio&gt;#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define lb(x,y) ((x = x + y * (x &amp; (-x))))typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;const int MAXN = 100000 + 10;const lli HA = 1000000007;int n, m;lli bit[MAXN], bitt[MAXN];lli qu(int p) &#123; lli r = 0; while (p &gt;= 1) &#123; (r += bit[p]) %= HA; lb(p, -1ll); &#125; return r; &#125;lli qux(int p) &#123; lli r = 0; while (p &gt;= 1) &#123; (r += bitt[p]) %= HA; lb(p, -1ll); &#125; return r; &#125;void mo(int p, lli x) &#123; lli d = x - (qu(p) - qu(p - 1)), dx = x * x - (qux(p) - qux(p - 1)); while (p &lt;= n) &#123; bit[p] = (bit[p] + d) % HA; bitt[p] = (bitt[p] + dx) % HA; lb(p, 1ll); &#125;&#125;lli pw(lli a, lli b) &#123; lli r = 1; while (b) &#123; if (b &amp; 1) r = r * a % HA; a = a * a % HA; b &gt;&gt;= 1; &#125; return r; &#125;lli inv(lli a) &#123; return pw(a, HA - 2); &#125;int main() &#123; n = getint(); m = getint(); rap (i, 1, n, 1) mo(i, getint()); rap (i, 1, m, 1) &#123; int c = getint(); int x = getint(); int y = getint(); if (c == 1) mo(x, y); else &#123; lli N = (y - x + 1); lli iN = inv(N); lli fx = (qu(y) - qu(x - 1) + HA) % HA, gx = (qux(y) - qux(x - 1) + HA) % HA; lli tx = (iN * gx % HA - iN * iN % HA * fx % HA * fx % HA); while (tx &lt;= 0) tx += HA; tx %= HA; printf("%lld\n", tx % HA); &#125; &#125; return 0;&#125; 代码也不长啊，不就50行吗 相似题目强化版：洛谷P1471《方差》]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 453A《Little Pony and Expected Maximum》]]></title>
    <url>%2F2019-10-25%2FCF453A%2F</url>
    <content type="text"><![CDATA[简单期望题目 题意翻译 翻译来自洛谷 暮暮刚刚在和她的朋友——AJ（苹果杰克）、FS（小蝶）、RD（云宝黛西）玩Ludo游戏。但是她马品没攒够总是输。回到城堡过后，她对游戏用的骰子产生了兴趣。 题目描述 这个骰子有M面：骰子的第一面有一个点，第二面有两个点，以此类推，第m面含有M点。暮暮确信的是，当掷骰子时，每一面都有1/m的可能性出现，并且每次投掷的概率都是都是独立的。请你帮助她计算掷N次骰子后每次得到的点数中最大值的期望。 输入输出格式 输入格式： 一行两个整数 m 和 n (1 ≤ m, n ≤ 10^5). 输出格式： 输出一行一个实数，与答案误差不大于10^-4 输入输出样例输入 #116 1 输出 #113.500000000000 输入 #216 3 输出 #214.958333333333 输入 #312 2 输出 #311.750000000000 说明/提示Consider the third test example. If you’ve made two tosses: You can get 1 in the first toss, and 2 in the second. Maximum equals to 2. You can get 1 in the first toss, and 1 in the second. Maximum equals to 1. You can get 2 in the first toss, and 1 in the second. Maximum equals to 2. You can get 2 in the first toss, and 2 in the second. Maximum equals to 2. The probability of each outcome is 0.25, that is expectation equals to:$(2+1+2+2) \cdot 0.25=\frac{7}{4}$You can read about expectation using the following link: http://en.wikipedia.org/wiki/Expected_value 解析代码里什么都有 期望的公式是 $E(x) = \sum P(x = i) \times i$ 顺便把注释里的两个式子渲染一下： ans = {\sum_{i = 1}^{m} i \times [i^n - (i - 1)^n] \over m^n} ans = \sum_{i = 1}^{m} i \times \big[\big({i \over m}\big)^n - \big({i - 1 \over m}\big)^n\big]代码实现1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;typedef double db;db fp(db a, int b) &#123; db r = 1; while (b) &#123; if (b &amp; 1) r = r * a; a = a * a; b &gt;&gt;= 1; &#125; return r; &#125;int n, m;double ans;/** * * 掷 n 次骰子，最大点数不超过 k 的方案数为 k^n * 掷 n 次骰子，最大点数不超过 k - 1 的方案数为 (k - 1)^n * 减一下就可以知道最大点数为 k 的方案数 * 然后套一下期望的公式就可以知道 * ans = &#123;\sum_&#123;i = 1&#125;^&#123;m&#125; i \times [i^n - (i - 1)^n] \over m^n&#125; * 整理一下得到 * ans = \sum_&#123;i = 1&#125;^&#123;m&#125; i \times \big[\big(&#123;i \over m&#125;\big)^n - \big(&#123;i - 1 \over m&#125;\big)^n\big] * */int main() &#123; scanf("%d %d", &amp;m, &amp;n); double last = 0; for (int i = 1; i &lt;= m; ++i) &#123; db d = fp(((double) i * 1.0) / ((double) m * 1.0), n); ans = ans + ((double) i * 1.0) * (d - last); last = d; &#125; printf("%0.12lf\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>Codeforces</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1074《靶型数独》]]></title>
    <url>%2F2019-10-20%2FLuoguP1074%2F</url>
    <content type="text"><![CDATA[基于常识的搜索顺序优化 题目描述小城和小华都是热爱数学的好学生，最近，他们不约而同地迷上了数独游戏，好胜的他们想用数独来一比高低。但普通的数独对他们来说都过于简单了，于是他们向 Z 博士请教，Z 博士拿出了他最近发明的“靶形数独”，作为这两个孩子比试的题目。 靶形数独的方格同普通数独一样，在 99 格宽×99 格高的大九宫格中有99 个 33 格宽×33 格高的小九宫格（用粗黑色线隔开的）。在这个大九宫格中，有一些数字是已知的，根据这些数字，利用逻辑推理，在其他的空格上填入 11 到 99的数字。每个数字在每个小九宫格内不能重复出现，每个数字在每行、每列也不能重复出现。但靶形数独有一点和普通数独不同，即每一个方格都有一个分值，而且如同一个靶子一样，离中心越近则分值越高。（如图） 上图具体的分值分布是：最里面一格（黄色区域）为 1010 分，黄色区域外面的一圈（红色区域）每个格子为99分，再外面一圈（蓝色区域）每个格子为88 分，蓝色区域外面一圈（棕色区域）每个格子为77分，最外面一圈（白色区域）每个格子为66分，如上图所示。比赛的要求是：每个人必须完成一个给定的数独（每个给定数独可能有不同的填法），而且要争取更高的总分数。而这个总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和 总分数即每个方格上的分值和完成这个数独时填在相应格上的数字的乘积的总和。如图，在以下的这个已经填完数字的靶形数独游戏中，总分数为 2829。游戏规定，将以总分数的高低决出胜负。 由于求胜心切，小城找到了善于编程的你，让你帮他求出，对于给定的靶形数独，能够得到的最高分数。 输入格式一共 99 行。每行99个整数（每个数都在 0-90−9 的范围内），表示一个尚未填满的数独方格，未填的空格用“00”表示。每两个数字之间用一个空格隔开。 输出格式输出共 11 行。输出可以得到的靶形数独的最高分数。如果这个数独无解，则输出整数-1−1。 输入输出样例输入 #1复制 1234567897 0 0 9 0 0 0 0 1 1 0 0 0 0 5 9 0 0 0 0 0 2 0 0 0 8 0 0 0 5 0 2 0 0 0 3 0 0 0 0 0 0 6 4 8 4 1 3 0 0 0 0 0 0 0 0 7 0 0 2 0 9 0 2 0 1 0 6 0 8 0 4 0 8 0 5 0 4 0 1 2 输出 #1复制12829 输入 #2复制1234567890 0 0 7 0 2 4 5 3 9 0 0 0 0 8 0 0 0 7 4 0 0 0 5 0 1 0 1 9 5 0 8 0 0 0 0 0 7 0 0 0 0 0 2 5 0 3 0 5 7 9 1 0 8 0 0 0 6 0 1 0 0 0 0 6 0 9 0 0 0 0 1 0 0 0 0 0 0 0 0 6 输出 #2复制 12852 解析拿到题目：这啥啊。。。不是很会啊。。。暴搜估计搜不过去啊。。。 无奈之下看了一眼题解，忽然就想起来了自己以前填数独的技巧。 填数独有一个技巧，就是提前填工作量最小的地方，也就是优先填数最满的地方 确定这个搜索顺序之后这个题就差不多做完了 分别开三个数组记录这一行某一个数字是否被填过，这一列某一个数字是否被填过，这一个宫是否被填过 每次搜索记录当前搜到了哪个点，枚举当前格子是填 1-9 中哪个数字，搜一搜就好了 搜索顺序如何求出？再开俩数组分别记录每一行填了多少数字，每一列填了多少数字，转移时先枚举填的数字最多的行，然后在这一行中确定没填过的格子对应的填的数字最多的列，下一次搜索的时候就搜行列相交处的格子 建议配合代码理解 代码实现我写完代码之后才发觉 line 和 row 都是「行」的意思。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;const int MAXN = 9 + 2;const int weight[11][11] = &#123; &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;, &#123;0, 6, 6, 6, 6, 6, 6, 6, 6, 6&#125;, &#123;0, 6, 7, 7, 7, 7, 7, 7, 7, 6&#125;, &#123;0, 6, 7, 8, 8, 8, 8, 8, 7, 6&#125;, &#123;0, 6, 7, 8, 9, 9, 9, 8, 7, 6&#125;, &#123;0, 6, 7, 8, 9,10, 9, 8, 7, 6&#125;, &#123;0, 6, 7, 8, 9, 9, 9, 8, 7, 6&#125;, &#123;0, 6, 7, 8, 8, 8, 8, 8, 7, 6&#125;, &#123;0, 6, 7, 7, 7, 7, 7, 7, 7, 6&#125;, &#123;0, 6, 6, 6, 6, 6, 6, 6, 6, 6&#125;,&#125;;const int area[11][11] = &#123; &#123;0, 0, 0, 0, 0, 0, 0, 0, 0, 0&#125;, &#123;0, 1, 1, 1, 6, 6, 6, 9, 9, 9&#125;, &#123;0, 1, 1, 1, 6, 6, 6, 9, 9, 9&#125;, &#123;0, 1, 1, 1, 6, 6, 6, 9, 9, 9&#125;, &#123;0, 8, 8, 8, 7, 7, 7, 3, 3, 3&#125;, &#123;0, 8, 8, 8, 7, 7, 7, 3, 3, 3&#125;, &#123;0, 8, 8, 8, 7, 7, 7, 3, 3, 3&#125;, &#123;0, 4, 4, 4, 5, 5, 5, 2, 2, 2&#125;, &#123;0, 4, 4, 4, 5, 5, 5, 2, 2, 2&#125;, &#123;0, 4, 4, 4, 5, 5, 5, 2, 2, 2&#125;,&#125;;struct Order &#123; int id, siz; Order(int _id = 0, int _siz = 0) : id(_id), siz(_siz) &#123;&#125; bool operator &lt; (const Order &amp;that) const &#123; return siz &gt; that.siz; &#125;&#125; order[MAXN];int n = 9, sd[MAXN][MAXN], linesiz[MAXN], rowsiz[MAXN];bool lineUsed[MAXN][10], rowUsed[MAXN][10], areaUsed[MAXN][10];int ans = 0, vis = 0;void print() &#123; puts(""); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; printf("%d%c", sd[i][j], j == n ? '\n' : ' '); &#125; &#125; puts("");&#125;void placeNum(int x, int y, int num) &#123; sd[x][y] = num; ++linesiz[x]; ++rowsiz[y]; lineUsed[x][num] = rowUsed[y][num] = true; areaUsed[area[x][y]][num] = true;&#125;void displaceNum(int x, int y, int num) &#123; sd[x][y] = 0; --linesiz[x]; --rowsiz[y]; lineUsed[x][num] = rowUsed[y][num] = false; areaUsed[area[x][y]][num] = false;&#125;void DFS(int line = 0, int row = 0, int totalPlaced = 0) &#123; if (totalPlaced == 81) &#123; vis = 1; int fans = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; fans += sd[i][j] * weight[i][j]; &#125; &#125;// print();// cout &lt;&lt; fans &lt;&lt; endl; ans = std::max(ans, fans); return; &#125; for (int num = 1; num &lt;= 9; ++num) &#123; if (lineUsed[line][num] || rowUsed[row][num] || areaUsed[area[line][row]][num]) continue; placeNum(line, row, num); int nextLine = 0, maxSize = -1; for (int i = 1; i &lt;= n; ++i) &#123; if (maxSize &lt; linesiz[i] &amp;&amp; linesiz[i] != 9) &#123; maxSize = linesiz[i]; nextLine = i; &#125; &#125; int nextRow = 0; maxSize = -1; for (int i = 1; i &lt;= n; ++i) &#123; if (maxSize &lt; rowsiz[i] &amp;&amp; !sd[nextLine][i]) &#123; maxSize = rowsiz[i]; nextRow = i; &#125; &#125;// printf("\nModified &lt;%d,%d&gt;: %d\n", line, row, sd[line][row]);// print(); DFS(nextLine, nextRow, totalPlaced + 1); displaceNum(line, row, num); &#125;&#125;int main() &#123; int maxSiz1 = -1, lc = 0, maxSiz2 = -1, rc = 0, cnt = 0; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; sd[i][j] = getint(); if (sd[i][j] == 0) continue; cnt += (sd[i][j] &gt; 0); linesiz[i] += (sd[i][j] &gt; 0); rowsiz[j] += (sd[i][j] &gt; 0); lineUsed[i][sd[i][j]] = rowUsed[j][sd[i][j]] = true; areaUsed[area[i][j]][sd[i][j]] = true; &#125; if (maxSiz1 &lt; linesiz[i] &amp;&amp; linesiz[i] != 9) &#123; lc = i; maxSiz1 = linesiz[i]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (maxSiz2 &lt; rowsiz[i] &amp;&amp; !sd[lc][i]) &#123; rc = i; maxSiz2 = rowsiz[i]; &#125; &#125; DFS(lc, rc, cnt); if (!vis) puts("-1"); else printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4514《上帝造题的七分钟》]]></title>
    <url>%2F2019-10-20%2FLuoguP4514%2F</url>
    <content type="text"><![CDATA[二维树状数组 题目描述“第一分钟，X说，要有矩阵，于是便有了一个里面写满了0的n×m矩阵。第二分钟，L说，要能修改，于是便有了将左上角为(a,b)，右下角为(c,d)的一个矩形区域内的全部数字加上一个值的操作。第三分钟，k说，要能查询，于是便有了求给定矩形区域内的全部数字和的操作。第四分钟，彩虹喵说，要基于二叉树的数据结构，于是便有了数据范围。第五分钟，和雪说，要有耐心，于是便有了时间限制。第六分钟，吃钢琴男说，要省点事，于是便有了保证运算过程中及最终结果均不超过32位有符号整数类型的表示范围的限制。第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。”——《上帝造裸题的七分钟》所以这个神圣的任务就交给你了。 输入格式输入数据的第一行为X n m，代表矩阵大小为n×m。从输入数据的第二行开始到文件尾的每一行会出现以下两种操作： L a b c d delta —— 代表将(a,b),(c,d)为顶点的矩形区域内的所有数字加上delta。 k a b c d —— 代表求(a,b),(c,d)为顶点的矩形区域内所有数字的和。 请注意，kk为小写。 输出格式针对每个k操作，在单独的一行输出答案。 输入输出样例输入 #1 1234X 4 4L 1 1 3 3 2L 2 2 4 4 1k 2 2 3 3 输出 #1 112 解析不多说了。。。 就是一个支持矩阵的子矩阵加减、子矩阵和查询的树状数组模板题 讲解见这里吧 代码实现代码也不放了。。上面的链接给的代码就是这题的 AC 代码]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4145《上帝造题的七分钟2 / 花神游历各国》]]></title>
    <url>%2F2019-10-20%2FLuoguP4145%2F</url>
    <content type="text"><![CDATA[你会支持区间开平方的数据结构吗？ 题目背景XLk觉得《上帝造题的七分钟》不太过瘾，于是有了第二部。 题目描述“第一分钟，X说，要有数列，于是便给定了一个正整数数列。 第二分钟，L说，要能修改，于是便有了对一段数中每个数都开平方(下取整)的操作。 第三分钟，k说，要能查询，于是便有了求一段数的和的操作。 第四分钟，彩虹喵说，要是noip难度，于是便有了数据范围。 第五分钟，诗人说，要有韵律，于是便有了时间限制和内存限制。 第六分钟，和雪说，要省点事，于是便有了保证运算过程中及最终结果均不超过64位有符号整数类型的表示范围的限制。 第七分钟，这道题终于造完了，然而，造题的神牛们再也不想写这道题的程序了。” ——《上帝造题的七分钟·第二部》 所以这个神圣的任务就交给你了。 输入格式第一行一个整数n，代表数列中数的个数。 第二行n个正整数，表示初始状态下数列中的数。 第三行一个整数m，表示有m次操作。 接下来m行每行三个整数k,l,r， k=0表示给[l,r]中的每个数开平方(下取整) k=1表示询问[l,r]中各个数的和。 数据中有可能l&gt;r，所以遇到这种情况请交换l和r。 输出格式对于询问操作，每行输出一个回答。 输入输出样例输入 #1复制12345678101 2 3 4 5 6 7 8 9 1050 1 101 1 101 1 50 5 81 4 8 输出 #11231976 解析我不会支持区间开方的数据结构。怎么办呢？ 一个很容易发现的事实是题目给的所有数最多被开方6次（原题数据范围1e12）。为什么呢？ 懂了吧 所以开方操作直接暴力修改就好。每次修改之前查询一下这个块的最大值是不是1，是的话就不去开方这个区间了，这样跑的飞快 查询操作就是正常的不带 lazy tag 的查询函数 还有一个坑点就是 l 和 r 的大小关系，这个注意一下就好了 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//// Created by HandwerSTD.// Copyright (c) 2019 HandwerSTD. All rights reserved.// Title: 上帝造题的七分钟2 / 花神游历各国//// sto Qingyu orz// 感谢真神sqy无私的教诲。膜时队者处处阿克，只因大师sqy在他背后。不膜大师者违背了真神的旨意，真神必将降下天谴，// 使其天天爆零// 我不由自主地膜拜真神sqy。//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define down(a,t,s,i) for (int a = t; a &gt;= s; a -= i)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;const int MAXN = 1e5 + 10;int n, m;lli osq[MAXN];namespace SegmentTree &#123;#define lson (root &lt;&lt; 1)#define rson (root &lt;&lt; 1 | 1) lli sum[MAXN &lt;&lt; 2], max[MAXN &lt;&lt; 2]; void update(int root) &#123; sum[root] = sum[lson] + sum[rson]; max[root] = std::max(max[lson], max[rson]); &#125; void buildTree(int root = 1, int l = 1, int r = n) &#123; if (l == r) return (void) (sum[root] = max[root] = osq[l]); int mid = (l + r) &gt;&gt; 1; buildTree(lson, l, mid); buildTree(rson, mid + 1, r); update(root); &#125; void modify(int ll, int rr, int root = 1, int l = 1, int r = n) &#123; if (l == r) &#123; sum[root] = max[root] = sqrt(sum[root]); return; &#125; int mid = (l + r) &gt;&gt; 1; if (ll &lt;= mid &amp;&amp; max[lson] &gt; 1) modify(ll, rr, lson, l, mid); if (mid + 1 &lt;= rr &amp;&amp; max[rson] &gt; 1) modify(ll, rr, rson, mid + 1, r); update(root); &#125; lli querySum(int ll, int rr, int root = 1, int l = 1, int r = n) &#123; if (ll &lt;= l &amp;&amp; r &lt;= rr) return sum[root]; lli rt = 0; int mid = (l + r) &gt;&gt; 1; if (ll &lt;= mid) rt += querySum(ll, rr, lson, l, mid); if (mid + 1 &lt;= rr) rt += querySum(ll, rr, rson, mid + 1, r); return rt; &#125;&#125;int main() &#123; n = getint(); rap (i, 1, n, 1) osq[i] = getll(); SegmentTree::buildTree(); m = getint(); rap (i, 1, m, 1) &#123; int cmd = getint(); int l = getint(); int r = getint(); if (l &gt; r) std::swap(l, r); if (!cmd) SegmentTree::modify(l, r); else printf("%lld\n", SegmentTree::querySum(l, r)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>暴力</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「初赛」康托展开学习笔记]]></title>
    <url>%2F2019-10-17%2FCantor-Expansion%2F</url>
    <content type="text"><![CDATA[简介康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。 ——Wikipedia 公式直接给式子吧 对于一个长度为 $n$ 的排列，它在全排列中的排名为 x=1+a_{n}(n-1) !+a_{n-1}(n-2) !+\cdots+a_{1} \cdot 0 !其中$a_i$为给定排列前 $i - 1$个数中 小于 $a_i$ 的 没有出现的 数的数量 例子：12345t = &#123;1, 6, 4, 5, 3, 2&#125;那么a = &#123;0, 4&lt;2,3,4,5&gt;, 2&lt;2,3&gt;, 2&lt;2,3&gt;, 1&lt;2&gt;, 0&#125;其中&lt;&gt;里具体说明了是哪几个数此时 x = 114 另外，$x-1$就是有多少个排列比给定排列要小。这个很显然。 逆康托展开前面说了是可逆的，那么说一说怎么逆回去。 1234567891011121314151617181920如n=5,x=96时：首先用96-1得到95，说明x之前有95个排列.(将此数本身减去1)用95去除4! 得到3余23，说明有3个数比第1位小，所以第一位是4.用23去除3! 得到3余5，说明有3个数比第2位小，所以是4，但是4已出现过，因此是5.用5去除2!得到2余1，类似地，这一位是3.用1去除1!得到1余0，这一位是2.最后一位只能是1.所以这个排列是&#123;4, 5, 3, 2, 1&#125;.再给一个例子：n = 6, x = 123123 / (5!) = 1...33 / (4!) = 0...3...（结果都是0...3）3 / (2!) = 1...11 / (1!) = 1...00 / (0!) = 0...0所以最终排列为&#123;2, 1, 3, 5, 6, 4&#125; 用途写这玩意有什么用？打开NOIP2018提高组初赛第21题看程序写输出，他要求的就是给定排列往后数t个得到的排列 使用这个方法就可以将给定排列转化为排名，加t之后再转化回排列，进而得到结果]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>学习笔记</tag>
        <tag>数学</tag>
        <tag>初赛</tag>
        <tag>排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组学习笔记]]></title>
    <url>%2F2019-10-17%2FBinaryIndexedTree%2F</url>
    <content type="text"><![CDATA[高效又好写的数据结构 简介树状数组或二叉索引树（英语：Binary Indexed Tree），又以其发明者命名为Fenwick树，最早由Peter M. Fenwick于1994年以A New Data Structure for Cumulative Frequency Tables为题发表在SOFTWARE PRACTICE AND EXPERIENCE。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以${\displaystyle O(\log n)}$的时间得到任意前缀和${\displaystyle \sum _{i=1}^{j}A[i],1\le j\le N}$!，并同时支持在${\displaystyle O(\log n)}$时间内支持动态单点值的修改。空间复杂度${\displaystyle O(n)}$。 ——Wikipedia 简单的说，树状数组就是一个便于在 $O(\log n)$ 时间内维护一个数列 / 矩阵的前缀和，可以支持单点修改、查询，区间修改、查询的数据结构。 依据支持操作的不同（包含关系），我这里把它分为六类： 支持序列单点加减、区间和查询的树状数组 支持序列区间加减、单点查询的树状数组 支持序列区间加减、区间和查询的树状数组 支持矩阵单点加减、子矩阵和查询的树状数组 支持矩阵的子矩阵加减、单点查询的树状数组 支持矩阵的子矩阵加减、子矩阵和查询的树状数组 这些会一个一个的讲。 序列操作单点加减、区间和查询这个是最基础的树状数组，应该没有人不会吧…… 原理就是通过维护前缀和，修改的时候像暴力维护前缀和一样一个一个往后加，不过每次增长的值不是1而是lowbit，其中“一个数取lowbit能跳到哪”这个关系连边后就形成了一个二叉搜索树。 按照Peter M. Fenwick的说法，正如所有的整数都可以表示成2的幂和，我们也可以把一串序列表示成一系列子序列的和。采用这个想法，我们可将一个前缀和划分成多个子序列的和，而划分的方法与数的2的幂和具有极其相似的方式。一方面，子序列的个数是其二进制表示中1的个数，另一方面，子序列代表的f[i]的个数也是2的幂。 ——Wikipedia 比如说这一棵就是八个元素的树状数组，对照下面的表可以发现上面的连边规律（点下面的是编号，请自动忽略根节点 9 以及那条边）。 123456789101&apos;s lowbit = 1, 1 + lowbit = 22&apos;s lowbit = 2, 2 + lowbit = 43&apos;s lowbit = 1, 3 + lowbit = 44&apos;s lowbit = 4, 4 + lowbit = 85&apos;s lowbit = 1, 5 + lowbit = 66&apos;s lowbit = 2, 6 + lowbit = 87&apos;s lowbit = 1, 7 + lowbit = 88&apos;s lowbit = 8, 8 + lowbit = 169&apos;s lowbit = 1, 9 + lowbit = 1010&apos;s lowbit = 2, 10 + lowbit = 12 那么代码就很容易写出来了： 123456789101112131415161718192021int n, tree[MAX_SIZE];// n 为元素个数，tree[] 为树状数组维护的前缀和int lowbit(int x) &#123; return (x) &amp; (-x); &#125;void Modify(int pos, int x) &#123; // 将 pos 位置的数加上 x for (; pos &lt;= n; pos += lowbit(pos)) tree[pos] += x;&#125;int Query(int pos) &#123; // 查询 [1,pos] 之间的数的和 int ret = 0; for (; pos &gt;= 1; pos -= lowbit(pos)) ret += tree[pos]; return ret;&#125;int rangeQuery(int l, int r) &#123; // 查询 [l,r] 之间的数的和 return Query(r) - Query(l - 1);&#125; 区间加减、单点查询不知道你们有没有听说过一个东西叫做「差分」 定义差分数组 d[i] = a[i] - a[i - 1]，其中 a[] 表示原数列那么对 d[i] 求一个前缀和就可以得出 a[i]的值了举个例子：123数组下标从 0 开始，元素存储从 1 开始，a[0] = d[0] = 0a[] = &#123;0, 1, 3, 4, 2&#125;d[] = &#123;/, 1, 2, 2, -2&#125; 发现了什么？ \sum_{i = 1}^{n} d_i = a_i如何修改$\text{[L,R]}+x$？先给结论：在$\text{L}$处$+x$，在$\text{R+1}$处$-x$直观理解：1234567下标从 1 开始。原数列：0 0 0 0 0 0按照上面的方法 [2,4]+x0 x 0 0 -x 0看看前缀和之后会发生什么……0 x x x 0 0！！！！！ 而维护前缀和这种事情，树状数组最在行了 可以写出代码： 1234567891011121314151617181920212223242526272829303132int n, a[MAXN], bit[MAXN]; // n 为元素个数，a 为原数组，bit 为差分数组void Modify(int pos, int x) &#123; for (; pos &lt;= n; pos += lowbit(pos)) bit[pos] += x; &#125;void rangeModify(int l, int r, int x) &#123; Modify(l, x); Modify(r + 1, -x);&#125; int Query(int pos) &#123; int ret = 0; for (; pos &gt;= 1; pos -= lowbit(pos)) ret += bit[pos]; return ret; &#125;int main() &#123; ... for (i = 1 to n increase 1) &#123; read a[i] rangeModify(i, i, a[i]); &#125; ... read x, read y, read k rangeModify(x, y, k); // 将 [x,y] 区间内的数加上 k ... read k printf("%d\n", Query(k)); // 查询 k 位置的元素&#125; 区间加减、区间和查询线段树天下第一但是线段树难写、难调，常数还大，占空间还多。。。 如果你只需要区间加减、区间和查询，树状数组无疑是你最好的选择 区间加减维护一下差分数组就行了 考虑区间和本质是 \sum_{a = 1}^{p}\sum_{i = 1}^{a}d_i计算一下每个 $d_i$ 被算的次数，顺便把式子变换一下 \sum_{a = 1}^{p}d_a \times (p - a + 1)123456789举个例子比如说 p = 5 时，可以发现 ans = d[1] + d[1] + d[2] +d[1] + d[2] + d[3] + d[1] + d[2] + d[3] + d[4] + d[1] + d[2] + d[3] + d[4] + d[5]找一找规律就可以搞出上面的式子了 拆一下 $\sum$，可以变换成 (p + 1)\sum_{a = 1}^{p}d_a - \sum_{a = 1}^{p}d_a \times a这样的话，只需要分别维护两个差分数组，一个记 $d_a$，一个记 $d_a \times a$ 就行 修改$\text{[L,R] + }x$的时候，像上面区间加减、单点查询一样，把 $\text{[L]} + x,\text{[R+1]} - x$（对两个数组进行的修改可以合并到 Modify() 函数中，具体见代码）查询的时候像上面单点加减、区间和查询一样，是前缀和作差 代码： 1234567891011121314151617181920212223242526// 代码没有经过提交，仅进行了一些小样例测试！typedef long long int lli;int n, m; lli ss[MAXN]; lli biti[MAXN], bitpi[MAXN];// ss 表示原数组，biti 表示维护 d[a] 的数组， bitpi 表示维护 d[a] * a 的数组void Modify(int pos, lli x) &#123; int dx = pos; for (; pos &lt;= n; pos += lowbit(pos)) &#123; // 为了方便，可以把 rangeModify() 里的乘法挪到 Modify() 里面 biti[pos] += x; bitpi[pos] += x * 1ll * dx; &#125; &#125; void rangeModify(int l, int r, lli x) &#123; // 这是把括号里的乘法挪到 Modify() 里面的写法 Modify(l, x); Modify(r + 1, -x); &#125; lli Query(int pos) &#123; lli ret = 0, dx = pos; while (pos &gt;= 1) &#123; ret += (dx + 1) * 1ll * biti[pos] - bitpi[pos]; pos -= lowbit(pos); &#125; return ret; &#125; lli rangeQuery(int l, int r) &#123; return Query(r) - Query(l - 1); &#125; 矩阵操作一维的操作都讲完了，那能不能把它推广到二维上面呢？答案是肯定的。提前说一句，以下操作从访问$n$个元素变成了$nm$个元素，时间复杂度变为$O(\log(nm))$ 单点加减、子矩阵和查询前面说过，树状数组是利用前缀和的思想进行实现的，既然二维也有前缀和，何不照葫芦画瓢把而为树状数组搞出来呢？ 先来复习一下。 \sum_{i = l}^{r} a_i = \sum_{i = 1}^{r} a_i - \sum_{i = 1}^{l - 1} a_i为了方便，定义 f(x,y)=\sum_{i = 1}^{x} \sum_{j = 1}^{y} a_{i,j} \sum_{i = x_1}^{x_2}\sum_{j = y_1}^{y_2}a_{i,j}=f(x_2,y_2)-f(x_1 - 1,y_2)-f(x_2,y_1-1)+f(x_1-1,y_1-1)直观来看， 定义$\text{Sum}(a,b,c,d)$为以$(a,b)$为左下角，$(c,d)$为右上角（对于矩阵是反着的）的矩阵元素之和，那么很显然能看出 $\text{Sum}(5,4,7,5)=\text{Sum}(1,1,7,5)-\text{Sum}(1,1,7,3)-\text{Sum}(1,1,4,5)+\text{Sum}(1,1,4,3)$，也就是四边形$\text{ABCD}-\text{ABGI}-\text{AHFD}+\text{AHEI}$元素的值 二维树状数组和一位的除了多了一维之外没多大区别，手法从一维前缀和换到了二维前缀和 看代码就知道了 1234567891011121314151617181920212223242526272829303132// 代码没有经过提交，仅进行了一些小样例测试！int n, m, q, bit[MAXN][MAXN]; // 是不是和一维的手法差不多（逃void Modify(int x, int y, int w) &#123; for (; x &lt;= n; x += lowbit(x)) &#123; for (int fy = y; fy &lt;= m; fy += lowbit(fy)) &#123; // 说一个坑：这里不要对 y 进行直接修改 // 因为下一次循环 x 的时候需要用 y // 我当初在这里栽坑调了快 10min。。。 bit[x][fy] += w; &#125; &#125; &#125; int Query(int x, int y) &#123; int ans = 0; for (; x &gt;= 1; x -= lowbit(x)) &#123; for (int fy = y; fy &gt;= 1; fy -= lowbit((fy))) &#123; ans += bit[x][fy]; &#125; &#125; return ans; &#125; int matrixQuery(int x1, int y1, int x2, int y2) &#123; // x1 &lt;= x2, y1 &lt;= y2 int a = Query(x2, y2); int b = Query(x1 - 1, y2); int c = Query(x2, y1 - 1); int d = Query(x1 - 1, y1 - 1); return a - b - c + d; &#125; 子矩阵加减、单点查询还记得区间加减、单点查询吗？接下来把它推广到二维！ 查询手法一样的，二维前缀和 如何修改$(x_1,y_1)\text{ to }(x_2,y_2)$？先说结论：$d[x_1][y_1] + x,d[x_1][y_2+1]-x,d[x_2+1][y_1]-x,d[x_2+1][y_2+1]+x$直观理解：123456789101112131415161718下标从 1 开始 1 2 3 4 51 0 0 0 0 02 0 0 0 0 03 0 0 0 0 04 0 0 0 0 0修改(1,2)-&gt;(4,3) + x 1 2 3 4 51 0 0 0 0 02 x 0 0 0 -x3 0 0 0 0 04 -x 0 0 0 x前缀和： 1 2 3 4 51 0 0 0 0 02 x x x x 03 x x x x 04 0 0 0 0 0 放代码 1234567891011121314151617181920212223242526// 代码没有经过提交，仅进行了一些小样例测试！int n, m, q, bit[MAXN][MAXN]; // n,m 为矩阵大小，bit 为差分数组 void Modify(int x, int y, int w) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; for (int j = y; j &lt;= m; j += lowbit(j)) &#123; bit[i][j] += w; &#125; &#125; &#125; void matrixModify(int x1, int y1, int x2, int y2, int w) &#123; // x1 &lt;= x2 Modify(x1, y1, w); Modify(x1, y2 + 1, -w); Modify(x2 + 1, y1, -w); Modify(x2 + 1, y2 + 1, w); &#125; int Query(int x, int y) &#123; int ret = 0; for (int i = x; i &gt;= 1; i -= lowbit(i)) &#123; for (int j = y; j &gt;= 1; j -= lowbit(j)) &#123; ret += bit[i][j]; &#125; &#125; return ret; &#125; 子矩阵加减、子矩阵和查询最后一种操作，也是最难的操作 ……其实并不难，如果你把前面都学懂了。 和区间加减、区间和查询一样，先看看查询操作的本质 \sum_{i=1}^{x} \sum_{j=1}^{y} \sum_{k=1}^{i} \sum_{h=1}^{j} d[h][k]先统计一下 $d[i][j]$ 被访问了多少次，然后稍微整理一下式子，变成 {\sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times(x+1-i) \times(y+1-j)} \\= {(x+1)(y+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j]} \\ {-(y+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times i} \\ {-(x+1) \times \sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times j} \\ {\quad+\sum_{i=1}^{x} \sum_{j=1}^{y} d[i][j] \times i \times j} 所以，实现区修区查需要维护四个差分数组！ 第一个：维护$d[i][j]$ 第二个：维护$d[i][j]\times i$ 第三个：维护$d[i][j]\times j$ 第四个：维护$d[i][j]\times i\times j$ 接下来是完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// // Created by HandwerSTD on 2019/10/17. // // 洛谷 P4514 《上帝造题的七分钟》// 常数略大。。开O2过的 #include &lt;algorithm&gt; #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;string&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; #define FILE_IN(__fname) freopen(__fname, "r", stdin) #define FILE_OUT(__fname) freopen(__fname, "w", stdout) #define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i) #define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i) #define countdown(s) while (s --&gt; 0) #define IMPROVE_IO() std::ios::sync_with_stdio(false) #define lowbit(x) ((x &amp; (-x))) using std::cin; using std::cout; using std::endl; typedef long long int lli; int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125; lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125; const int MAXN = 2048 + 10; int n, m, q; namespace BIT &#123; int d[MAXN][MAXN], di[MAXN][MAXN]; int dj[MAXN][MAXN], dij[MAXN][MAXN]; void Modify(int x, int y, int w) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) &#123; for (int j = y; j &lt;= m; j += lowbit(j)) &#123; d[i][j] += w; di[i][j] += w * x; dj[i][j] += w * y; dij[i][j] += w * x * y; &#125; &#125; &#125; void matrixModify(int x1, int y1, int x2, int y2, int w) &#123; Modify(x1, y1, w); Modify(x2 + 1, y2 + 1, w); Modify(x1, y2 + 1, -w); Modify(x2 + 1, y1, -w); &#125; int Query(int x, int y) &#123; int ret = 0; for (int i = x; i &gt;= 1; i -= lowbit(i)) &#123; for (int j = y; j &gt;= 1; j -= lowbit(j)) &#123; ret += d[i][j] * (x + 1) * (y + 1) - (y + 1) * di[i][j] - (x + 1) * dj[i][j] + dij[i][j]; &#125; &#125; return ret; &#125; int matrixQuery(int x1, int y1, int x2, int y2) &#123; int a = Query(x2, y2); int b = Query(x1 - 1, y1 - 1); int c = Query(x1 - 1, y2); int d = Query(x2, y1 - 1); return a - c - d + b; &#125; &#125; int main() &#123; std::ios::sync_with_stdio(false); std::string _s; cin &gt;&gt; _s; cin &gt;&gt; n &gt;&gt; m; // rap (i, 1, n, 1) &#123; // rap (j, 1, m, 1) &#123; // int fx = 0; // scanf("%d", &amp;fx); // BIT::matrixModify(i, j, i, j, fx); // &#125; // &#125; char ch = 0; while (cin &gt;&gt; ch) &#123; int a = 0, b = 0, c = 0, d = 0; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if (ch == 'L') &#123; int delta = 0; cin &gt;&gt; delta; BIT::matrixModify(a, b, c, d, delta); &#125; else &#123; // scanf("\n"); // printf("%d\n", BIT::matrixQuery(a, b, c, d)); cout &lt;&lt; BIT::matrixQuery(a, b, c, d) &lt;&lt; endl; &#125; // getchar(); &#125; return 0; &#125;]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU6108《小C的倍数问题》]]></title>
    <url>%2F2019-10-13%2FHDU6108%2F</url>
    <content type="text"><![CDATA[真·小学数学 Problem Description根据小学数学的知识，我们知道一个正整数x是3的倍数的条件是x每一位加起来的和是3的倍数。反之，如果一个数每一位加起来是3的倍数，则这个数肯定是3的倍数。 现在给定进制P，求有多少个B满足P进制下，一个正整数是B的倍数的充分必要条件是每一位加起来的和是B的倍数。 Input第一行一个正整数T表示数据组数(1&lt;=T&lt;=20)。 接下来T行，每行一个正整数P(2 &lt; P &lt; 1e9)，表示一组询问。 Output对于每组数据输出一行，每一行一个数表示答案。 Sample Input12110 Sample Output13 解析小 学 数 学 考虑$p$进制表示的实质是$x = a1p^n+a_2p^{(n - 1)} + a_3p^{(n - 2)} + \dots + a{n+1}$稍微变形一下 x=a_1(p^n-1)+a_2(p^{n-1}-1)+a_3(p^{n - 3} - 1) + \dots + \sum_{i = 1}^{n + 1}a_i然后注意到$p^n - 1=(p - 1)(p^{n - 1} + p^{n - 2} + \dots + 1)$把它代入进去 \begin{aligned} x&=a_1(p - 1)(p^{n - 1} + p^{n - 2} + \dots + 1) \\&+a_2(p - 1)(p^{n - 2} + p^{n - 3} + \dots + 1) \\&+a_3(p - 1)(p^{n - 3} + p^{n - 4} + \dots + 1) + \dots \\&+ \sum_{i = 1}^{n + 1}a_i \end{aligned}发现前面几项都有一个 $p - 1$那么，当且仅当$\sum_{i = 1}^{n + 1}a_i$，即 x 各位数字之和 $\equiv 0(\bmod (p - 1))$ 时，$x \equiv 0 (\bmod (p - 1))$ one more thing对于任意的自然数$a,p$，如果 $a \mod p = 0$，那么有$a \mod x = 0(x \mid p)$ 所以这题的思路已经很明显了，求的就是$p - 1$的因子个数 代码实现1234567891011121314151617181920212223//// Created by HandwerSTD on 2019/10/13.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;int T;int main() &#123; scanf("%d", &amp;T); while (T --&gt; 0) &#123; int fx = 0, ans = 0; scanf("%d", &amp;fx); --fx; for (int i = 1, fs = sqrt(fx); i &lt;= fs; ++i) &#123; if (fx % i != 0) continue; ++ans; if ((fx / i) != i) ++ans; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国剩余定理（CRT）学习笔记]]></title>
    <url>%2F2019-10-03%2FChinaRemainderTheroem%2F</url>
    <content type="text"><![CDATA[有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？ 简介孙子定理是中国古代求解一次同余式组（见同余）的方法。是数论中一个重要定理。又称中国余数定理。 ——百度百科 公式孙子定理是用来求解这样的方程组的： （我博客行间公式渲染好像有点问题……） CRT 的使用条件是 $m_i$ 两两互质，$m_i$ 两两不互质需要使用 exCRT 即扩展中国剩余定理 首先定义 $M = \prod_{i = 1}^n m_i$，并设 $M_i = \lfloor {M \over {m_i}} \rfloor$，$t_i = M_i^{-1} \bmod M$（即$t_i$满足$M_i t_i \equiv 1 (\bmod M)$）那么该同余方程的一个解为 x_0=(\sum_{i=1}^{k} a_{i} M_i t_{i})\bmod M通解为 $x = x_0 + i \times M$，最小非负整数解为 $(x_0 \bmod M + M) \bmod M$ 如果有 $a &lt; 0$ 的情况时要注意负数取模问题 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//// CRT.cpp// Debugging//// Created by HandwerSTD on 2019/10/3.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;lli k, a[10000 + 10], m[10000 + 10];namespace ChinaRemainderTheorem &#123; lli exgcd(lli a, lli b, lli &amp;x, lli &amp;y) &#123; if (b == 0) &#123; x = 1; y = 0; return a; &#125; lli g = exgcd(b, a % b, y, x); y -= a / b * x; return g; &#125; lli CRT() &#123; lli X = 0, M = 1; for (lli i = 1; i &lt;= k; ++i) M *= m[i]; for (lli i = 1; i &lt;= k; ++i) &#123; lli ti = 0, y = 0; lli mmi = M / m[i]; exgcd(mmi, m[i], ti, y); X = ((X + a[i] * mmi * ti) % M + M) % M; &#125; return X &lt; 0 ? (X + M) : X; &#125;&#125;signed main() &#123; k = getll(); /// x === ai (mod mi) rap (i, 1, k, 1) &#123; m[i] = getll(); a[i] = getll(); &#125; printf("%lld\n", ChinaRemainderTheorem::CRT()); return 0;&#125;]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1168《中位数》]]></title>
    <url>%2F2019-10-02%2FLuogu-P1168%2F</url>
    <content type="text"><![CDATA[两个优先队列 解析第一反应肯定是堆，毕竟自带排序，找中位数也方便 关键是 std::priority_queue 不能访问内部元素就很烦 但是，要访问的内部元素好像就一个中位数啊？ 考虑把中位数手动记下来，然后把中位数前边的数用一个大根堆存一下，把中位数后面的数用一个小根堆存一下，这样依然能保证元素是始终有序的 依次读入每一个数，如果这个数比「当前记着的中位数」小就放进大根堆里，否则放进小根堆里 查询的时候需要对中位数进行更新：如果左右两个堆的大小相等，说明中位数还是那个中位数；否则分两种情况讨论： 大根堆更大说明中位数一定在大根堆里，那么就把中位数塞进小根堆里，再把大根堆堆顶取出来当新的中位数，重复做直到两个堆大小相等 小根堆更大说明中位数一定在小根堆里，那么就把中位数塞进大根堆里，再把小根堆堆顶取出来当新的中位数，重复做直到两个堆大小相等 最后输出更新完的中位数即可 本方法对应代码中的 Method1 或者可以直接使用 std::vector 和 std::upper_bound 来模拟一个堆，输出的时候直接访问 vec[(i / 2 + 1) - 1] 即可 std::upper_bound(Begin Iterator, End Iterator, Value) 是一个使用二分查找，在有序序列 [Begin Iterator, End Iterator) 中查找第一个大于 Value 的位置的函数；std::vector&lt;int&gt;::insert(Position Iterator, Value) 可以在 Position Iterator 前面插入元素 Value，利用这两个函数可以实现插入元素而不破坏序列的有序性。 本方法对应代码中的 Method2 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//// LuoguP1168.cpp// Title: 中位数// Debugging//// Created by HandwerSTD on 2019/10/2.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;int n;namespace Method1 &#123; /** * 此题正解 * 用一个大根堆维护中位数之前的数，一个小根堆维护中位数之后的数 */ std::priority_queue&lt;int&gt; before; std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; after; int mid; void _main() &#123; for (int i = 1; i &lt;= n; ++i) &#123; int now = getint(); if (i == 1) &#123; mid = now; &#125; else &#123; if (now &lt; mid) before.push(now); else after.push(now); &#125; if (i &amp; 1) &#123; unsigned long befsiz = before.size(); unsigned long aftsiz = after.size(); while (befsiz != aftsiz) &#123; if (befsiz &lt; aftsiz) &#123; before.push(mid); mid = after.top(); after.pop(); &#125; else &#123; after.push(mid); mid = before.top(); before.pop(); &#125; befsiz = before.size(); aftsiz = after.size(); &#125; printf("%d\n", mid); &#125; &#125; &#125;&#125;namespace Method2 &#123; /** * 沙雕做法 * 使用 std::vector 和 std::lower_bound 手写堆 */ std::vector&lt;int&gt; vec; void _main() &#123; for (int i = 1; i &lt;= n; ++i) &#123; int now = getint(); vec.insert(std::upper_bound(vec.begin(), vec.end(), now), now); if (i &amp; 1) printf("%d\n", vec.at(i / 2 + 1 - 1)); &#125; &#125;&#125;int main() &#123; n = getint(); if (1 + 1 == 3) Method2::_main(); else Method1::_main(); return 0;&#125;]]></content>
      <tags>
        <tag>队列</tag>
        <tag>堆</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2158《[SDOI2008]仪仗队》]]></title>
    <url>%2F2019-08-18%2FLuogu-P2158-BZOJ2190%2F</url>
    <content type="text"><![CDATA[题目描述作为体育委员，C君负责这次运动会仪仗队的训练。仪仗队是由学生组成的N * N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。 现在，C君希望你告诉他队伍整齐时能看到的学生人数。 输入格式共一个数 N 输出格式共一个数，即C君应看到的学生人数。 输入输出样例输入 #1 14 输出 #1 19 说明/提示【数据规模和约定】 对于 100% 的数据，1 ≤ N ≤ 40000 解析来快乐推一推式子 首先考虑一下没有被看到的点长什么样显然没有被看到的点$(x,y)$与原点的连线上一定有一点，记为 $(\frac x t , \frac y t )$ 由于所有坐标都是整数，那么有 t \mid x, t \mid y \Leftrightarrow t \mid \gcd(x, y)所以可以知道这个事情：一个点$(x, y)$不可以被看到，等价于$\gcd(x, y) \neq 1$。所以题目要求的就是所有的数对$(x,y)$的个数，满足 $\gcd(x, y) = 1$ 分开考虑答案 首先是坐标形如 $(0, y), (x, 0)$ 的这些点，也就是在 $x$ 轴和 $y$ 轴上的点，均只能看见一个 $(0, 1),(1, 0)$，统计答案的时候就直接 $+ 2$ 就行了。 然后是在直线 $y = x$ 上的点，也只能被看见一个 $(1, 1)$，统计答案的时候再来个 $+ 1$。 剩下的点可以用两个 $\sum$ 统计。最后式子长这样（注意$\text{ans}$函数的参数值）： \begin{align} \text{ans}(n + 1) = 3 + \sum_{x = 1}^{n} \sum_{y = 1}^{x - 1}[\gcd(x, y) = 1] + \sum_{x = 1}^{n} \sum_{y = x + 1}^{n}[\gcd(x, y) = 1] \end{align}看一眼这张图： 可以发现，第一种情况对应的是点 $U, V$，第二种情况对应的是 $W$，两个 $\sum$ 分别对应点 $A \rightarrow J$ 和 $K \rightarrow T$ 的能看见的点的数量。 还是不懂？ 手动模拟一下吧，看看它会统计哪些点两个 $\sum$ 相当于语句 12345678ans = 0for x = 1 to n do for y = 1 to x - 1 do ans = ans + (gcd(x,y) == 1)for x = 1 to n do for y = x + 1 to n do ans = ans + (gcd(x,y) == 1)ans = ans + 3 显然可以看到的点是关于直线 $y = x$ 对称的，所以上面的式子又可以写成 \text{ans}(n + 1) = 3 + 2\sum_{x = 1}^{n} \sum_{y = 1}^{x - 1}[\gcd(x, y) = 1] 这个式子肯定跑不过去的。把这个式子化简一下 注意到一个很常见的积性函数 \varphi(x) = \sum_{i = 1}^{x}[\gcd(i, x) = 1]代入原式！ $\text{ans}(n + 1) = 3 + 2\sum{x = 1}^{n} \sum{y = 1}^{x - 1}[\gcd(x, y) = 1]$$= 3 + 2\sum{x = 1}^{n} (\sum{y = 1}^{x}[\gcd(x, y) = 1] - [\gcd(x, x) = 1])$$= 3 + 2\sum_{x = 1}^{n} (\varphi(x) - [\gcd(x, x) = 1])$ 好了，现在就有了一个可以 $O(n)$ 计算的式子了！ （式子要分行写是因为我博客的 Math 引擎好像炸了。。。渲染不了多行，将就看吧/kk） 最后说个事，$n = 1$ 的时候答案为 $0$，这个很显然吧，都没有学生了（ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970//// LuoguP2158.cpp// Title: [SDOI2008]仪仗队// Alternatives: BZOJ2190// Debugging//// Created by HandwerSTD on 2019/8/18.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;const int MAXN = 40000 + 10;bool notprime[MAXN];int prime[MAXN], phi[MAXN], cnt;int n;lli ans;void Sieve() &#123; notprime[0] = notprime[1] = true; phi[1] = 1; for (int i = 2; i &lt; MAXN; ++i) &#123; if (!notprime[i]) &#123; prime[++cnt] = i; phi[i] = i - 1; &#125; for (int j = 1; j &lt;= cnt &amp;&amp; (i * prime[j]) &lt; MAXN; ++j) &#123; int x = i * prime[j]; notprime[x] = true; if (i % prime[j] == 0) &#123; phi[x] = phi[i] * prime[j]; break; &#125; phi[x] = phi[i] * (prime[j] - 1); &#125; &#125;&#125;void Solve(int fn) &#123; for (int x = 1; x &lt;= fn; ++x) &#123; ans += phi[x]; if (x == 1) ans -= 1; &#125;&#125;int main() &#123; Sieve(); n = getint(); if (n == 1) return (0 &amp; printf("0\n")); Solve(n - 1); printf("%lld\n", ans * 2 + 3); return 0;&#125;]]></content>
      <tags>
        <tag>各省省选</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2196《Computer》]]></title>
    <url>%2F2019-08-15%2FHDU2196%2F</url>
    <content type="text"><![CDATA[利用树的直径的性质 Problem DescriptionA school bought the first computer some time ago(so this computer’s id is 1). During the recent years the school bought N-1 new computers. Each new computer was connected to one of settled earlier. Managers of school are anxious about slow functioning of the net and want to know the maximum distance Si for which i-th computer needs to send signal (i.e. length of cable to the most distant computer). You need to provide this information. Hint: the example input is corresponding to this graph. And from the graph, you can see that the computer 4 is farthest one from 1, so S1 = 3. Computer 4 and 5 are the farthest ones from 2, so S2 = 2. Computer 5 is the farthest one from 3, so S3 = 3. we also get S4 = 4, S5 = 4. InputInput file contains multiple test cases.In each case there is natural number N (N&lt;=10000) in the first line, followed by (N-1) lines with descriptions of computers. i-th line contains two natural numbers - number of computer, to which i-th computer is connected and length of cable used for connection. Total length of cable does not exceed 10^9. Numbers in lines of input are separated by a space. OutputFor each case output N lines. i-th line must contain number Si for i-th computer (1&lt;=i&lt;=N). Sample Input1234551 12 13 11 1 Sample Output1234532344 解析首先有一个性质：在一棵树上，距离任意点最远的点一定是这棵树直径的一个端点 然后这题不就好做了吗 先以 1 为根求一遍直径，再分别以两个端点为根求一遍这个点到其他点的距离，取个最大值，输出即可，这个可以写一个DFS调用三遍 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//// HDU2196.cpp// Title: Computer// Debugging//// Created by HandwerSTD on 2019/8/15.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;const int MAXN = 10000 + 10;struct Edge &#123; int v, w; Edge(int v = 0, int w = 0) : v(v), w(w) &#123;&#125;&#125;;std::vector&lt;Edge&gt; head[MAXN];int n, farthest;lli maxdis;lli f[MAXN];inline void addEdge(int u, int v, int w) &#123; head[u].push_back(Edge(v, w)); head[v].push_back(Edge(u, w));&#125;void DFS(int u, int fa, lli dis) &#123; if (dis &gt; maxdis) &#123; maxdis = dis; farthest = u; &#125; f[u] = std::max(f[u], dis); for (int i = 0, siz = (int) head[u].size(); i &lt; siz; ++i) &#123; int v = head[u][i].v, w = head[u][i].w; if (v == fa) continue; DFS(v, u, dis + w); &#125;&#125;void _main() &#123; for (int i = 1; i &lt;= n - 1; ++i) &#123; int v = getint(); int w = getint(); addEdge(i + 1, v, w); &#125; int p1 = 0, p2 = 0; DFS(1, 0, 0); p1 = farthest; DFS(p1, 0, 0); // 以上这两遍DFS是在求树的直径 // 第二遍DFS顺便更新了一下从某一个端点出发的答案 p2 = farthest; DFS(p2, 0, 0); // 由于在每个点的最长路径可能到达两个端点 // 所以要对两个端点分别更新一遍答案 // 这一遍DFS是在更新从另一个端点出发的答案 for (int i = 1; i &lt;= n; ++i) printf("%lld\n", f[i]); memset(f, 0, sizeof f); for (int i = 1; i &lt;= n; ++i) head[i].clear(); n = maxdis = farthest = 0; return;&#125;int main() &#123; while (scanf("%d", &amp;n) != EOF) _main(); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3714《Kuglarz》]]></title>
    <url>%2F2019-08-15%2FBZOJ3714%2F</url>
    <content type="text"><![CDATA[这是最小生成树？ Description魔术师的桌子上有n个杯子排成一行，编号为1,2,…,n，其中某些杯子底下藏有一个小球，如果你准确地猜出是哪些杯子，你就可以获得奖品。花费c_ij元，魔术师就会告诉你杯子i,i+1,…,j底下藏有球的总数的奇偶性。采取最优的询问策略，你至少需要花费多少元，才能保证猜出哪些杯子底下藏着球？ Input第一行一个整数n(1&lt;=n&lt;=2000)。第i+1行(1&lt;=i&lt;=n)有n+1-i个整数，表示每一种询问所需的花费。其中c_ij（对区间[i,j]进行询问的费用，1&lt;=i&lt;=j&lt;=n,1&lt;=c_ij&lt;=10^9）为第i+1行第j+1-i个数。 Output输出一个整数，表示最少花费。 Sample Input1234565 1 2 3 4 5 4 3 2 1 3 4 5 2 1 5 Sample Output17 解析从代码里复制过来的 知道两段杯子的奇偶性，相当于知道左边杯子左边的缝到右边杯子右边的缝到奇偶性 然后显然这个东西具有传递性，即知道缝a到缝b、缝b到缝c的奇偶性 $\Leftrightarrow$ 缝a到缝c的奇偶性 知道所有数列要保证缝两两之间的奇偶性都要知道 那么就可以把缝抽象成点，缝两两之间的奇偶性信息抽象成边，边权为询问的代价 一遍最小生成树完事 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//// BZOJ3714.cpp// Debugging//// Created by HandwerSTD on 2019/8/15.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;/** * 知道两段杯子的奇偶性，相当于知道左边杯子左边的缝到右边杯子右边的缝到奇偶性 * 然后显然这个东西具有传递性，即知道缝a到缝b、缝b到缝c的奇偶性 &lt;=&gt; 缝a到缝c的奇偶性 * 知道所有数列要保证缝两两之间的奇偶性都要知道 * 那么就可以把缝抽象成点，缝两两之间的奇偶性信息抽象成边，边权为询问的代价 * 一遍最小生成树完事 */const int MAXN = 2000 + 10;struct UnionFind &#123; int u[MAXN]; UnionFind() &#123; memset(u, 0, sizeof u); &#125; void Init(int x) &#123; for (int i = 1; i &lt;= x; ++i) u[i] = i; &#125; int Find(int x) &#123; return u[x] == x ? x : (u[x] = Find(u[x])); &#125; bool Union(int x, int y) &#123; x = Find(x); y = Find(y); if (x == y) return false; u[x] = y; return true; &#125;&#125; U;struct Edge &#123; int u, v, w; Edge(int u = 0, int v = 0, int w = 0) : u(u), v(v), w(w) &#123;&#125; bool operator &lt; (const Edge &amp;that) const &#123; return w &lt; that.w; &#125;&#125;;int n, cnt;lli ans;std::vector&lt;Edge&gt; edge;void Kruskal() &#123; int tot = 0; // std::sort(edge + 1, edge + 1 + cnt); std::sort(edge.begin(), edge.end()); for (int i = 0; i &lt; cnt; ++i) &#123; if (U.Union(edge[i].u, edge[i].v)) &#123; // printf("choosed edge[%d] = &#123; %d %d %d &#125;\n", i, edge[i].u, edge[i].v, edge[i].w); ++tot; ans += 1ll * edge[i].w; &#125; &#125;&#125;int main() &#123; n = getint(); U.Init(n + 1); for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt;= n; ++j) &#123; int x = getint(); edge.push_back(Edge(i, j, x)); &#125; &#125; cnt = (int) edge.size(); Kruskal(); printf("%lld\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于新开的 cnblogs 博客的一些说明]]></title>
    <url>%2F2019-08-14%2FArticles-Moving-To-cnblogs%2F</url>
    <content type="text"><![CDATA[因为一些原因，文章没有被各大搜索引擎收录多少，PV和UV都很低（截止2019.08.12 7:20，没有破 5K），于是就想找一个博客网站放一些自己的文章，希望更多人能看到自己的文章，同时可以给自己博客引引流，最后选中了 cnblogs 文章会陆续按照创建时间排序搬上来，以后两个博客（有时候可能会在洛谷博客也更新）同步更新 一些很沙雕的文章可能不会放上去（ 不过这么做可能会引来转载，比如说某aichengxu、某voidcn啊之类的，链个博客链接应该就没事了（]]></content>
      <tags>
        <tag>博客相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZROI 918《「良心普及组」黄队的宫殿》]]></title>
    <url>%2F2019-08-13%2FZROI918%2F</url>
    <content type="text"><![CDATA[密码为：使用 base64 加密过的本场比赛第一名的总用时（去掉冒号） Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>只有经历过的人才知道的世界</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU1483《Automatic Correction of Misspellings》]]></title>
    <url>%2F2019-08-08%2FHDU1483%2F</url>
    <content type="text"><![CDATA[Problem DescriptionSome text editors offer a feature to correct words which seem to be written incorrectly. In this problem you are asked to implement a simple Automatic Correction of Misspellings (ACM). ACM takes care of the following misspellings of words: 1.One letter is missing (e.g., letter is written leter) or too much (e.g., letter is written lettter).2.One letter is wrong (e.g., letter is written ketter)3.The order of two adjacent letters is wrong (e.g., letter is written lettre) ACM is based on a dictionary of known words. When a text contains a word which is not in the dictionary, ACM will try to replace it by a similar word of the dictionary. Two words are similar if we can transform one word into the other by doing exactly one of the misspellings listed above. An unknown word is left unchanged if there is no similar word in the dictionary. InputThe first line of the input file will give the number n of words in the dictionary (n ≤ 10000). The next n lines contain the dictionary words. The following line contains an integer q ≤ 1000, the number of query words. The next q lines contain the query words. You may assume that each word in the input consists of 1 to 25 lower case letters (‘a’ to ‘z’). OutputFor each query word, print one line with the query word followed by one of the following possibilities: is correct, if the word occurs in the dictionary. is a misspelling of , where is a word of the dictionary similar to the query word, and the query word is not in the dictionary. In the case that there are several possibilities, select the word from the dictionary which appeared earlier in the input. is unknown, if cases 1 and 2 do not apply. Sample Input12345678910111213141516171810thisisadictionarythatwewilluseforus6suasthedictonaryuswilll Sample Output123456su is a misspelling of usas is a misspelling of isthe is unknowndictonary is a misspelling of dictionaryus is correctwilll is a misspelling of will 解析还是从代码里复制过来的（ 场上写一个 Trie 写到自闭。。。赛后来补一下 道理我都懂，但是这题为什么暴力能过。。。 以下，将字典中的串称作「字典串」，将询问的串称作「匹配串」 首先扫一遍字典，有相同的直接输出 correct 然后如果没有相同的，再扫一遍字典，对于每一个字典串，做这样几件事： 如果字典串和匹配串长度相等，就说明这个匹配串可能是当前字典串的一个错误拼写逐位扫一遍两个串，记一下错误的次数，以及最后一次错误的下标如果错误次数是 1 就直接输出 misspelling，此时匹配串相对于字典串只错了一个字符如果错误次数是 2 就判断一下是否是顺序弄反了，这个用最后一次错误下标很好写，如果是就输出 misspelling否则就凉凉 如果字典串比匹配串长 1，就说明这个匹配串可能是当前字典串漏了一个字逐位扫一遍字典串，用一个变量 k 记录当前字典串这一位对应的是匹配串的哪一位如果当前的两个串对应字符相等，就让 k 正常加一，否则就不让 k 加一显然如果真的是只漏了一个字，那么最后 k 一定等于匹配串长度，输出 misspelling否则 k 一定不等于匹配串长度（具体会变成什么值我也不大清楚，反正模拟一下就好了） 如果字典串比匹配串短 1，就说明这个匹配串可能是当前字典串添了一个字仿照着情况 2 做就完事了 最后如果三种情况都没有，输出 unknown 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596//// HDU1483.cpp// Title: Automatic Correction of Misspellings// Debugging//// Created by HandwerSTD on 2019/8/8.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;const int MAXN = 10000 + 10;int n, q;std::string dict[MAXN];int dictlen[MAXN];class AutoCorrectionMachine &#123;public: bool isMisspelling(std::string d, std::string m, int len) &#123; int wrong = 0, pos = 0; for (int i = 0; i &lt; len; ++i) &#123; if (d[i] != m[i]) &#123; ++wrong; pos = i; &#125; &#125; if (wrong == 1) return true; if (wrong == 2 &amp;&amp; (d[pos] == m[pos - 1] &amp;&amp; d[pos - 1] == m[pos])) return true; return false; &#125; bool isCharacterDeletion(std::string d, std::string m, int lend, int lenm) &#123; int k = 0; for (int i = 0; i &lt; lend; ++i) &#123; if (d[i] != m[k++]) --k; &#125; return k == lenm; &#125; bool isCharacterAddition(std::string d, std::string m, int lend, int lenm) &#123; int k = 0; for (int i = 0; i &lt; lenm; ++i) &#123; if (m[i] != d[k++]) --k; &#125; return k == lend; &#125;&#125; acm;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n; rap (i, 1, n, 1) &#123; cin &gt;&gt; dict[i]; dictlen[i] = (int) dict[i].length(); &#125; cin &gt;&gt; q; while (q --&gt; 0) &#123; std::string env; cin &gt;&gt; env; int lenenv = (int) env.length(); cout &lt;&lt; env; bool cor = false; for (int i = 1; i &lt;= n; ++i) if (dict[i] == env) &#123; cor = true; break; &#125; if (cor) cout &lt;&lt; " is correct\n"; else &#123; int i = 1; for (; i &lt;= n; ++i) &#123; if (dictlen[i] == lenenv) &#123; if (acm.isMisspelling(dict[i], env, lenenv)) &#123; cout &lt;&lt; " is a misspelling of " &lt;&lt; dict[i] &lt;&lt; endl; break; &#125; &#125; else if (dictlen[i] == lenenv + 1) &#123; if (acm.isCharacterDeletion(dict[i], env, dictlen[i], lenenv)) &#123; cout &lt;&lt; " is a misspelling of " &lt;&lt; dict[i] &lt;&lt; endl; break; &#125; &#125; else if (dictlen[i] == lenenv - 1) &#123; if (acm.isCharacterAddition(dict[i], env, dictlen[i], lenenv)) &#123; cout &lt;&lt; " is a misspelling of " &lt;&lt; dict[i] &lt;&lt; endl; break; &#125; &#125; &#125; if (i == n + 1) cout &lt;&lt; " is unknown\n"; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3183《A Magic Lamp》]]></title>
    <url>%2F2019-08-08%2FHDU3183%2F</url>
    <content type="text"><![CDATA[DescriptionKiki likes traveling. One day she finds a magic lamp, unfortunately the genie in the lamp is not so kind. Kiki must answer a question, and then the genie will realize one of her dreams. The question is: give you an integer, you are allowed to delete exactly m digits. The left digits will form a new integer. You should make it minimum.You are not allowed to change the order of the digits. Now can you help Kiki to realize her dream? InputThere are several test cases.Each test case will contain an integer you are given (which may at most contains 1000 digits.) and the integer m (if the integer contains n digits, m will not bigger then n). The given integer will not contain leading zero. OutputFor each case, output the minimum result you can get in one line.If the result contains leading zero, ignore it. Sample Input12345178543 4 1000001 1100001 212345 254321 2 Sample Output123451310123321 解析显然删除从左向右遇到的第一个比下一个数大的数，也就是让最高位最小的过程。那么按这样的策略做 m 次即可获得正确答案，删除后的序列可使用双向链表（STL 里有std::list&lt;int&gt;）来维护。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//// HDU3183.cpp// Title: A Magic Lamp// Debugging//// Created by HandwerSTD on 2019/8/8.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;list&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define charat(x) ((x - 1))using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;/** * 删除从左向右遇到的第一个比下一个数大的数 * 用一个双向链表维护 */int m;std::string s;std::list&lt;int&gt; lst;int main() &#123; while (cin &gt;&gt; s &gt;&gt; m) &#123; int n = (int) s.length(); lst.clear(); for (int i = 1; i &lt;= n; ++i) &#123; lst.insert(lst.end(), s[charat(i)] - '0'); &#125; for (int i = 1; i &lt;= m; ++i) &#123; for (auto i = lst.begin(); i != lst.end(); i++) &#123; i++; if (i == lst.end()) &#123; --i; lst.erase(i); break; &#125; int next = (*i); --i; if (*i &gt; next) &#123; lst.erase(i); break; &#125; &#125; &#125; bool fz = true; for (auto i : lst) &#123; if (fz &amp;&amp; i == 0) continue; fz = false; printf("%d", i); &#125; if (fz) printf("0"); puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 402B《Trees in a Row》]]></title>
    <url>%2F2019-08-07%2FCF402B%2F</url>
    <content type="text"><![CDATA[Translate有n个正整数，可以对一个数进行修改(修改后也是正整数)，要求修改之后满足$a_i+k=a{i+1}$，求最少的修改次数以及具体的修改方案 DescriptionThe Queen of England has n trees growing in a row in her garden. At that, the i-th (1 ≤ i ≤ n) tree from the left has height ai meters. Today the Queen decided to update the scenery of her garden. She wants the trees’ heights to meet the condition: for all i (1 ≤ i &lt; n), ai + 1 - ai = k, where k is the number the Queen chose. Unfortunately, the royal gardener is not a machine and he cannot fulfill the desire of the Queen instantly! In one minute, the gardener can either decrease the height of a tree to any positive integer height or increase the height of a tree to any positive integer height. How should the royal gardener act to fulfill a whim of Her Majesty in the minimum number of minutes? InputThe first line contains two space-separated integers: n, k (1 ≤ n, k ≤ 1000). The second line contains n space-separated integers a1, a2, …, an (1 ≤ ai ≤ 1000) — the heights of the trees in the row. OutputIn the first line print a single integer p — the minimum number of minutes the gardener needs. In the next p lines print the description of his actions. If the gardener needs to increase the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, then print in the corresponding line “+ j x”. If the gardener needs to decrease the height of the j-th (1 ≤ j ≤ n) tree from the left by x (x ≥ 1) meters, print on the corresponding line “- j x”. If there are multiple ways to make a row of trees beautiful in the minimum number of actions, you are allowed to print any of them. Examplesinput4 11 2 1 5 output2 3 2 4 1 input4 11 2 3 4 output0 解析本文同步发布于洛谷博客) 先说点题外话 这道题是我今天（发题解的那一天，2019.08.07）打 ACM 的时候做的，当时看到这题口胡了一下做法，没敢写，交给队友去写了，然后一遍AC 感谢队友把我带飞 言归正传。 考虑枚举第一棵树的高度，因为这样就能直接确定后面的树的高度了 然后假设当前枚举第一棵树高度为 $l$，那么第 $i$ 棵树的高度 $h_i$ 就应该是 $l + k(i - 1)$，这个应该很好理解吧，如果不懂可以评论区留个言，我找个时间写一下 那么再套一层循环，枚举所有的树，如果当前枚举到的第 $i$ 棵树的高度不是 $l + k(i - 1)$，就意味着这棵树需要被修改，需要增高 / 降低的高度是 $\text{abs}(l - k(i - 1))$，需要增高还是降低取决于 $l - k(i - 1)$ 的符号 统计一下修改了多少次，作为一个方案，最后取一个最优方案的输出就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;const int MAXNKH = 1000 + 10; // the max of n, k, heightconst int LOC = 0;const int MODIFY = 1;int n, k, ans = 0x7f7f7f7f, ansf[MAXNKH][2], p, f[MAXNKH][2];int height[MAXNKH];int main() &#123; n = getint(); k = getint(); rap (i, 1, n, 1) height[i] = getint(); rap (h1, 1, 1000, 1) &#123; // 枚举第一棵树的高度，可以直接确定后面树的高度 p = 0; memset(f, 0, sizeof f); rap (i, 1, n, 1) &#123; if (height[i] - (i - 1) * k != h1) &#123; // 记一下要修改的树的下标和要增加 / 减少的值 f[++p][LOC] = i; f[p][MODIFY] = (h1 + (i - 1) * k) - height[i]; &#125; &#125; if (p &lt; ans) &#123; // 更优的方案，更新一下 ans = p; memcpy(ansf, f, sizeof f); &#125; &#125; printf("%d\n", ans); rap (i, 1, ans, 1) printf("%c %d %d\n", (ansf[i][MODIFY] &lt; 0 ? '-' : '+'), ansf[i][LOC], std::abs(ansf[i][MODIFY])); return 0;&#125;// Code by Handwer]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3177《[HAOI2015]树上染色》]]></title>
    <url>%2F2019-07-31%2FLuogu-P3177-BZOJ4033%2F</url>
    <content type="text"><![CDATA[我推式子推了半个小时。。。 Description有一棵点数为N的树，树边有边权。给你一个在0~N之内的正整数K，你要在这棵树中选择K个点，将其染成黑色，并 将其他的N-K个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间距离的和的收益。 问收益最大值是多少。 Input第一行两个整数N,K。 接下来N-1行每行三个正整数fr,to,dis，表示该树中存在一条长度为dis的边(fr,to)。 输入保证所有点之间是联通的。 N&lt;=2000,0&lt;=K&lt;=N Output输出一个正整数，表示收益的最大值。 Sample Input123455 2 1 2 3 1 5 1 2 3 1 2 4 2 Sample Output117 【样例解释】将点1,2染黑就能获得最大收益。 解析第一反应设 $\text{dp[i][j]}$ 表示以 i 为根的子树选 j 个黑点的最大收益但是是错的 康了一眼这个我就瞬间明白了关于式子的推导，组成部分的意义，还有循环顺序的选择，这篇文章都讲得很清楚 老规矩，题解都在代码里 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//// BZOJ4033.cpp// Title: [HAOI2015]树上染色// Alternatives: Luogu-P3177// Debugging//// Created by HandwerSTD on 2019/7/31.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;/** * * 参考资料：https://www.luogu.org/blog/ahaha254/solution-p3177 * 关于 val(x,y) 和枚举顺序的解释可以康一康这篇文章 * * 设 f[i][j] 表示以 i 为根的子树中取了 j 个黑点「对答案的贡献」 * 转移方程： * f[u][j] = max( * f[u][j], * f[u][j - k] + f[v][k] + val(u,v) * ) * 其中 v 是 u 的儿子，k 是枚举出来的 * j = min(m,size(x)) -&gt; 0, k = 0 -&gt; min(j,size(y)) * 其中 val(x,y) 表示边 (x,y) 对答案的贡献，它等于 * 「该边两边黑点数量的乘积 乘以 边长 加上 该边两边白点数量的乘积 乘以 边长」 * 也就是 val(x,y) = k * (m - k) * weight(x,y) + (size(y) - k) * ((n - m) - (size(y) - k)) * weight(x,y) * 其中 m 是总的黑点数，k 是边 (x,y) 另一边的黑点数，那么 (m - k) 就是这一边的黑点数 * size(y) 是以 y 为根的子树的大小，也就意味着 (size(y) - k) 是另一边的白点数（另一边的肯定不是黑点就是白点） * (n - m) 是总的白点数，(size(y) - k) 是另一边的白点数，也就意味着 ((n - m) - (size(y) - k)) 是边 (x,y) 这一边的白点数（白点肯定不在那边就在这边） * */const int MAXN = 2000 + 10;const int MAXK = 2000 + 10;struct Edge &#123; int v; lli w; Edge(int v = 0, lli w = 0) : v(v), w(w) &#123;&#125;&#125;;std::vector&lt;Edge&gt; head[MAXN];int n, m, size[MAXN];lli dp[MAXN][MAXK];bool vis[MAXN][MAXK];// dp 数组大概 31 MB// size 数组大概 8 KB// vis 数组大概 4 MBvoid DFS(int root = 1, int father = 0) &#123; size[root] = 1; vis[root][0] = vis[root][1] = true; for (int i = 0, siz = (int) head[root].size(); i &lt; siz; ++i) &#123; int next = head[root][i].v; if (next == father) continue; DFS(next, root); size[root] += size[next]; &#125; for (int i = 0, siz = (int) head[root].size(); i &lt; siz; ++i) &#123; int next = head[root][i].v; if (next == father) continue; lli weight = head[root][i].w; for (int j = std::min(m, size[root]); j &gt;= 0; --j) &#123; int up = std::min(j, size[next]); for (int k = 0; k &lt;= up; ++k) &#123; if (!vis[root][j - k]) continue; lli val = k * (m - k) * weight + (size[next] - k) * ((n - m) - (size[next] - k)) * weight; dp[root][j] = std::max(dp[root][j], dp[root][j - k] + dp[next][k] + val); vis[root][j] = true; &#125; &#125; &#125;&#125;int main() &#123; n = getint(); m = getint(); rap (i, 1, n - 1, 1) &#123; int prev = getint(), next = getint(), weight = getint(); head[prev].push_back(Edge(next, weight)); head[next].push_back(Edge(prev, weight)); &#125; DFS(); printf("%lld\n", dp[1][m]); return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>各省省选</tag>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TopCoder 13955《WalkOverATree》]]></title>
    <url>%2F2019-07-31%2FTopCoder13955%2F</url>
    <content type="text"><![CDATA[Problem StatementGiven is a tree on n nodes. The nodes are numbered 0 through n-1. You are given the description of the tree as a int[] parent with n-1 elements. For each valid i, there is an edge between vertices (i+1) and parent[i]. A person is currently standing in node 0. In a single step, the person can move from its current node to any adjacent node. You are given an int L. The person is allowed to make at most L steps. Return the maximum number of nodes the person can visit during the walk. Node 0 (where the walk starts) and the node where the walk ends count as visited. Each visited node is only counted once, even if it is visited multiple times. DefinitionClass: WalkOverATreeMethod: maxNodesVisitedParameters: int[], intReturns: intMethod signature: int maxNodesVisited(int[] parent, int L)(be sure your method is public) Constraints parent will contain between 0 and 49 elements, inclusive. For each i, parent[i] will be between 0 and i, inclusive. L will be between 1 and 100, inclusive. Examples请自行到 vjudge 上寻找 解析英文很好懂，只需人教初二水平（反正我准初三选手看懂了） 题目大意：给定一棵 n 个点的树，编号 0~n-1。连边方式以输入每个点的父亲给出，对于每个 i，有一条边连接点 (i+1) 和点 father[i]，而且 father[i] 是 (i+1) 的父亲。有一个人站在点 0，可以向四周走不超过 L 步，求出这个人能经过多少不同的点 这题和 dp 有什么关系吗。。。 这题的难点大概就是 class 的使用和答案统计了吧 class 的使用可以参考这里 答案统计和基本的思路见代码吧 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//// TopCoder13955.cpp// Title: WalkOverATree// Debugging//// Created by HandwerSTD on 2019/7/31.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt;= s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;class WalkOverATree &#123; /** * * 直接暴力就好了。。。 * 一遍 DFS 预处理出所有的点的深度（根节点深度为 0） * 答案的输出见下 * */ private: static const int MAXN = 50 + 10; static const int MAXL = 100 + 10; std::vector&lt;int&gt; head[MAXN]; int depthWalk[MAXL]; int maxstep = 0; void DFS(int root = 1, int father = 0, int step = 0) &#123; depthWalk[root] = step; for (int i = 0, siz = (int) head[root].size(); i &lt; siz; ++i) &#123; int next = head[root][i]; if (next == father) continue; DFS(next, root, step + 1); &#125; &#125; public: int ans = 0; int maxNodesVisited(std::vector&lt;int&gt; father, int L) &#123; memset(head, 0, sizeof head); maxstep = L; int N = (int) father.size() + 1; // 把根节点算上 for (int i = 0, siz = N - 1; i &lt; siz; ++i) &#123; int prev = (i + 1) + 1, next = father[i] + 1; // 编号整体加一 head[prev].push_back(next); head[next].push_back(prev); &#125; DFS(); ans = *std::max_element(depthWalk + 1, depthWalk + 1 + N); if (ans &gt; L) return L + 1; // 能走的最长的路径已经超过了 L，直接返回 L + 1（把根节点算上） ans = std::min(N, ans + 1 + (L - ans) / 2); // ans + 1：走过的最长路径加上根节点 // L - ans：剩下能走的路径，不能浪费 // (L - ans) / 2：需要一半的路径来折返 // 注意：剩下的 L - ans 这些路径可以在任何地方用来走，不只是用来在最深的点折返 // 还有一种情况：所有的点都走完了，还有步数 // 这时候答案就不会再继续累加了 // 这种情况下 ans 就要对 N 取个 min return ans; &#125;&#125;;// 记得最后提交的时候不要带 main 函数/* int main() &#123; std::vector&lt;int&gt; fa; fa.clear(); int x = 0; while (true) &#123; cin &gt;&gt; x; if (x == -1) break; fa.push_back(x); &#125; int l = 0; cin &gt;&gt; l; WalkOverATree wk; cout &lt;&lt; wk.maxNodesVisited(fa, l) &lt;&lt; endl; return 0; &#125; */]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>TopCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2519《[HAOI2011]problem a》]]></title>
    <url>%2F2019-07-30%2FLuogu-P2519-BZOJ2298%2F</url>
    <content type="text"><![CDATA[人类智慧题 由于一些原因，不对题面作出展示，请自行寻找 解析我个人对「人类智慧题」对定义是「运用人脑求特殊解也想不出来的问题」 第一眼看到这题的时候，我一脸问号直到老师开始讲题…… 首先把题目转化一下对于每个学生，给定了有多少成绩比他好、比他差，那就把数据转换为一个成绩区间，表示这个区间内的人（可能只有 1 个）成绩相同 然后考虑一下「假话」的判断方式 成绩比他好的 + 成绩比他差的 + 他 &gt; 总人数这个请自行理解 两个有交集的区间没有完全相同，那么两个区间必有一个是假话这个很显然吧，就是两个区间有交集的话说明它们是一个成绩，然而小于这个成绩的人或大于这个成绩的人却不相同 对于一堆完全相同的区间，它们之间是真话的个数至多是[区间长度]个，超出的部分全都是假话想一想区间长度的现实意义是什么：有[区间长度]个学生成绩相同。那么，一个成绩是有[区间长度]个人的，也就是说，至多有[区间长度]个属于这个区间对应的成绩的学生在说真话（可以看作他们的成绩属于这个区间对应的成绩），剩下的学生都在说假话。这样说应该会好理解一些吧……实在不行我举个例子：[2,4]，意味着这个区间对应的成绩有 3 个人获得了，那么如果有 4 个人说“我获得了这个成绩”，那么肯定有 1 个人在说假话。 经过筛选，区间数量减少了一些，再去个重，把相同的区间个数用权值的形式表示出来（对每种区间分配唯一 id），比如说我有三个[2,4]和一个[7,8]，我就可以对[2,4]这个区间加一个权值 3，对[7,8]这个区间加一个权值 1。 那么问题现在变成了：带权值的线段覆盖，求最大权值和 这个就是一个 dp 问题了 下面这一段也是从我代码里复制过来的（ 1234567// 设 F[i] 表示选择右端点不超过 i 的最大权值// 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话// 初始：F[i] = F[i - 1]// 转移：当 i 点为某一线段的右端点时，// F[i] = max(F[i], F[j - 1] + Weight)// 其中 j 为该线段的左端点，Weight 为该线段的权值// (j - 1) 是因为线段不能重叠 代码实现代码里有很多注释，应该会很好理解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//// LuoguP2519.cpp// Title: [HAOI2011]problem a// Alternatives: BZOJ2298// Debugging//// Created by HandwerSTD on 2019/7/29.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;const int MAXN = 100000 + 10;struct Segment &#123; int l, r, w; Segment(int l = 0, int r = 0, int w = 0) : l(l), r(r), w(w) &#123;&#125; bool operator &lt; (const Segment &amp;that) const &#123; if (r == that.r) return l &lt; that.l; return r &lt; that.r; &#125;&#125; segt[MAXN];int Ls[MAXN], Rs[MAXN], Ws[MAXN];// segt 记录读入后经过处理的线段，Ls, Rs, Ws 记录去重后的线段int n, cnt, cntnew;int dp[MAXN];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; int l = 0, r = 0; scanf("%d %d", &amp;l, &amp;r); // 将给定的数据转化为学生 i 的排名 // 用区间[l,r]的形式表示（按成绩排名）第 l 个人到第 r 个人成绩相同 // 考虑把所有完全相同的线段记为单个带权值的线段 // 那么问题就变为了一个带权线段覆盖问题 if (l + r &gt;= n) continue; // 学生数量不合法，显然是错的 ++l; r = (n - ((r + 1) - 1)); // 避免出现左端点为 0 的情况，因为读入的 l 有可能是 0 segt[++cnt] = Segment(l, r); // 记一下目前合法的线段数量 &#125; std::sort(segt + 1, segt + 1 + cnt); for (int i = 1; i &lt;= cnt; ++i) &#123; if (!(segt[i].l == segt[i - 1].l &amp;&amp; segt[i].r == segt[i - 1].r)) ++cntnew; // 两条线段如果重合，就增加该线段的权值 // 两条线段如果不重合，就新开一条线段 // 本质是一个去重并合并权值的过程 Ws[cntnew] = std::min((segt[i].r - segt[i].l + 1), Ws[cntnew] + 1); // 重合的线段表示有(线段长度)个人是相同成绩的 // 所以每组重合线段（按线段长度分组）的个数如果超过了它的长度 // 则超出去的那部分必定是假话 Ls[cntnew] = segt[i].l; Rs[cntnew] = segt[i].r; // 记一下去重后的线段 &#125; for (int i = 1, j = 1; i &lt;= n; ++i) &#123; // 设 F[i] 表示选择右端点不超过 i 的最大权值 // 现实意义就是前 i 个人（按照成绩排序）中有多少人说了真话 // 初始：F[i] = F[i - 1] // 转移：当 i 点为某一线段的右端点时， // F[i] = max(F[i], F[j - 1] + Weight) // 其中 j 为该线段的左端点，Weight 为该线段的权值 // (j - 1) 是因为线段不能重叠 dp[i] = dp[i - 1]; while (j &lt;= cntnew &amp;&amp; Rs[j] == i) &#123; dp[i] = std::max(dp[i], dp[Ls[j] - 1] + Ws[j]); ++j; &#125; &#125; // 由于 F[i] 表示说真话的数量，所以答案为学生的数量 - 说真话的数量 // 也就是 n - dp[n] printf("%d\n", n - dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>各省省选</tag>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF816E / CF815C《Karen and Supermarket》]]></title>
    <url>%2F2019-07-30%2FCF816E-CF815C%2F</url>
    <content type="text"><![CDATA[DescriptionOn the way home, Karen decided to stop by the supermarket to buy some groceries. She needs to buy a lot of goods, but since she is a student her budget is still quite limited. In fact, she can only spend up to $b$ dollars. The supermarket sells $n$ goods. The $i$-th good can be bought for $c_i$ dollars. Of course, each good can only be bought once. Lately, the supermarket has been trying to increase its business. Karen, being a loyal customer, was given $n$ coupons. If Karen purchases the $i$-th good, she can use the $i$-th coupon to decrease its price by $d_i$. Of course, a coupon cannot be used without buying the corresponding good. There is, however, a constraint with the coupons. For all $i≥ 2$, in order to use the $i$-th coupon, Karen must also use the $x_i$ -th coupon (which may mean using even more coupons to satisfy the requirement for that coupon). Karen wants to know the following. What is the maximum number of goods she can buy, without exceeding her budget $b$? Input FormatThe first line of input contains two integers nn and bb ( 1&lt;=n&lt;=50001&lt;=n&lt;=5000 , 1&lt;=b&lt;=10^{9}1&lt;=b&lt;=109 ), the number of goods in the store and the amount of money Karen has, respectively. The next nn lines describe the items. Specifically: The ii -th line among these starts with two integers, c{i}ci​ and d{i}di​ ( 1&lt;=d{i}&lt;c{i}&lt;=10^{9}1&lt;=di​&lt;ci​&lt;=109 ), the price of the ii -th good and the discount when using the coupon for the ii -th good, respectively. If i&gt;=2i&gt;=2 , this is followed by another integer, x{i}xi​ ( 1&lt;=x{i}&lt;i1&lt;=xi​&lt;i ), denoting that the x_{i}xi​ -th coupon must also be used before this coupon can be used. Output FormatOutput a single integer on a line by itself, the number of different goods Karen can buy, without exceeding her budget. Input / Output SamplesInput #1 12345676 1610 910 5 112 2 120 18 310 2 32 1 5 Output #1 14 Input #2 1234565 103 13 1 13 1 23 1 33 1 4 Output #2 15 解析从代码里复制过来的（ 一道树形 DP 显然优惠券的使用逻辑可以构成一棵树设 $\text{f[i][j][0/1]}$ 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费初始状态： $\text{f[][][] = INF}$$\text{f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read}$ 转移方程：$\text{f[root][i + j][0] = min{ f[root][i + j][0], f[root][i][0] + f[u][j][0] | u} \in subtree(root) \ }$$\text{f[root][i + j][1] = min{ f[root][i + j][1], f[root][i][1] + min{ f[u][j][0], f[u][j][1] } | u} \in subtree(root)\ }$ 其中 $i \leq \text{size[root]}, j \leq \text{size[u]}$，i 需要倒序枚举来避免重复选商品 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//// CF816E.cpp// Title: Karen and Supermarket// Alternatives: CF815C// Debugging//// Created by HandwerSTD on 2019/7/30.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt; s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;// CodeForces 中请使用 %I64d/** * * 显然优惠券的使用逻辑可以构成一棵树 * 设 f[i][j][0/1] 表示在树根为 i 的子树中购买 j 件商品，是(1)否(0)可以使用优惠券的最小花费 * 初始状态： * f[][][] = INF * f[i][1][0] = Read, f[i][1][1] = f[i][1][0] - Read * 转移方程： * f[root][i + j][0] = min&#123; f[root][i + j][0], f[root][i][0] + f[u][j][0] | u 为 root 的孩子 &#125; * f[root][i + j][1] = min&#123; f[root][i + j][1], f[root][i][1] + min&#123; f[u][j][0], f[u][j][1] &#125; | u 为 root 的孩子 &#125; * 其中 i &lt;= size[root], j &lt;= size[u]，i 需要倒序枚举 * */const int MAXN = 5000 + 10;int n, b;std::vector&lt;int&gt; head[MAXN];lli dp[MAXN][MAXN][2];int size[MAXN];// dp 数组耗空间约 383MB// size 数组耗空间约 20KBvoid DFS(int u = 1, int fa = 0) &#123; size[u] = 1; for (int v : head[u]) &#123; DFS(v, u); for (int i = size[u]; i &gt;= 0; --i) &#123; for (int j = 0; j &lt;= size[v]; ++j) &#123; dp[u][i + j][0] = std::min( dp[u][i + j][0], dp[u][i][0] + dp[v][j][0] ); dp[u][i + j][1] = std::min( dp[u][i + j][1], dp[u][i][1] + std::min( dp[v][j][0], dp[v][j][1] ) ); &#125; &#125; size[u] += size[v]; &#125;&#125;int main() &#123; n = getint(); b = getint(); memset(dp, 0x7f, sizeof dp); rap (i, 1, n, 1) &#123; dp[i][0][0] = 0; dp[i][1][0] = getll(); dp[i][1][1] = dp[i][1][0] - getll(); if (i &gt;= 2) &#123; int next = getint(); head[next].push_back(i); &#125; &#125; DFS(); int i = n; for (; i &gt;= 1; --i) &#123; if (dp[1][i][0] &lt;= b || dp[1][i][1] &lt;= b) break; &#125; printf("%d\n", i); return 0;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2218《[HAOI2007]覆盖问题》]]></title>
    <url>%2F2019-07-30%2FLuogu-P2218-BZOJ1052%2F</url>
    <content type="text"><![CDATA[题目描述某人在山上种了N棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用3个L*L的正方形塑料薄膜将小树遮起来。 我们不妨将山建立一个平面直角坐标系，设第i棵小树的坐标为（Xi,Yi），3个L*L的正方形的边要求平行 与坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求L最小值。 输入格式第一行有一个正整数N，表示有多少棵树。 接下来有N行，第i+1行有2个整数Xi,Yi，表示第i棵树的坐标，保证不会有2个树的坐标相同。 输出格式一行，输出最小的L值。 输入输出样例输入 #1 1234540 10 -11 0-1 0 输出 #1 11 说明/提示数据范围 100%的数据，-1,000,000,000&lt;=Xi,Yi&lt;=1,000,000,000 30%的数据，N&lt;=100 50%的数据，N&lt;=2000 100%的数据，N&lt;=20000 解析显然答案具有单调性，因为边长为 k 的正方形能覆盖的话，边长为 k + 1 的正方形一定能覆盖考虑二分答案 首先用一个最小的矩形覆盖所有的点 很容易想到一个做法：先把矩形的左上角、右下角用正方形覆盖，再把中间的用正方形覆盖然而这样是不行的，反例很多，这里就不写了但是换个思路，矩形的四个角一定会有贴着边放的正方形 所以换一个做法：枚举矩形的四个角，放正方形；此时还剩下一些点，再找一个最小的矩形覆盖所有点，递归进去做即可，深度只有 3 层 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//// LuoguP2218.cpp// Title: [HAOI2007]覆盖问题// Alternatives: BZOJ1052// Debugging//// Created by HandwerSTD on 2019/7/25.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;using std::min;using std::max;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;const int MAXN = 20000 + 10;const int INF = 0x3f3f3f3f;lli n, maxx = -(0x3f3f3f3f), minx = (0x3f3f3f3f), maxy = -(0x3f3f3f3f), miny = (0x3f3f3f3f);lli x[MAXN], y[MAXN];int cov[MAXN];/** * * 确定一个最小的矩形使得这个矩形可以覆盖所有点。 * 枚举这个矩形的四个角，把一个正方形放到这个角上， * 有一些点会被覆盖，此时递归进去确定剩下未被覆盖的点即可 * */inline void _Cover(int lx, int rx, int ly, int ry, int ts) &#123; for (int i = 1; i &lt;= n; ++i) if (!cov[i] &amp;&amp; lx &lt;= x[i] &amp;&amp; x[i] &lt;= rx &amp;&amp; ly &lt;= y[i] &amp;&amp; y[i] &lt;= ry) cov[i] = ts;&#125;inline void Uncover(int ts) &#123; for (int i = 1; i &lt;= n; ++i) if (cov[i] == ts) cov[i] = 0;&#125;inline int _CHECK(int mid, int depth) &#123; lli minx = INF, maxx = -INF, miny = INF, maxy = -INF; for (int i = 1; i &lt;= n; ++i) if (!cov[i]) &#123; minx = min(minx, x[i]); maxx = max(maxx, x[i]); miny = min(miny, y[i]); maxy = max(maxy, y[i]); &#125; if (max(maxx - minx, maxy - miny) &lt;= mid) return 1; if (depth == 3) return 0; _Cover(minx, minx + mid, miny, miny + mid, depth); // ld if (_CHECK(mid, depth + 1)) return 1; Uncover(depth); _Cover(minx, minx + mid, maxy - mid, maxy, depth); // lu if (_CHECK(mid, depth + 1)) return 1; Uncover(depth); _Cover(maxx - mid, maxx, miny, miny + mid, depth); // rd if (_CHECK(mid, depth + 1)) return 1; Uncover(depth); _Cover(maxx - mid, maxx, maxy - mid, maxy, depth); // ru if (_CHECK(mid, depth + 1)) return 1; Uncover(depth); return 0;&#125;bool Check(int mid) &#123; memset(cov, 0, sizeof cov); return _CHECK(mid, 1);&#125;int main() &#123; n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = getint(); y[i] = getint(); &#125; int l = 0, r = 2e9; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1; if (Check(mid)) r = mid; else l = mid + 1; &#125; printf("%d\n", l); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>模拟</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2341《[HAOI2006]受欢迎的牛》]]></title>
    <url>%2F2019-07-29%2FLuogu-P2341-BZOJ1051-LOJ10091%2F</url>
    <content type="text"><![CDATA[Tarjan 缩点板子题 题目描述每头奶牛都梦想成为牛棚里的明星。被所有奶牛喜欢的奶牛就是一头明星奶牛。所有奶 牛都是自恋狂，每头奶牛总是喜欢自己的。奶牛之间的“喜欢”是可以传递的——如果A喜 欢B，B喜欢C，那么A也喜欢C。牛栏里共有N 头奶牛，给定一些奶牛之间的爱慕关系，请你 算出有多少头奶牛可以当明星。 输入格式第一行：两个用空格分开的整数：N和M 第二行到第M + 1行：每行两个用空格分开的整数：A和B，表示A喜欢B 输出格式第一行：单独一个整数，表示明星奶牛的数量 输入输出样例输入 #1 12343 31 22 12 3 输出 #1 11 说明/提示只有 3 号奶牛可以做明星 【数据范围】 10%的数据N&lt;=20, M&lt;=50 30%的数据N&lt;=1000,M&lt;=20000 70%的数据N&lt;=5000,M&lt;=50000 100%的数据N&lt;=10000,M&lt;=50000 解析首先把题目转化一下 显然能成为明星的奶牛们一定是互相喜欢的那么可以这样想：能成为明星的奶牛们都是在一个强连通分量中的，这样意味着互相喜欢所以问题转化为了求图中强连通分量大小，这个用 Tarjan 来完成 值得注意的是，把强连通分量缩点之后，所得的图一定是一个DAG（这是一个性质）（实际写代码的时候不需要重新建图）回到题目，缩完点之后，强连通分量对应的点的出度一定为0，而且有且仅有强连通分量对应的点出度为 0，因为如果强连通分量对应的点出度大于 0，则连出去的边与其他的点连到强连通分量的边就构成了一个环，与上面的性质相矛盾 注意到强连通分量对应的点出度为 0，那么该图合法必须要保证只有一个强连通分量（想一想，为什么） 所以写代码的思路就大体形成了：Tarjan求强连通分量大小➡️缩点求出度➡️判断强连通分量个数➡️输出0或者强连通分量大小 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//// LuoguP2341.cpp// Title: [HAOI2006]受欢迎的牛// Alternatives: BZOJ1051-LOJ10091// Debugging//// Created by HandwerSTD on 2019/7/28.// Copyright © 2019 HandwerSTD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;const int MAXN = 10000 + 10;const int MAXM = 50000 + 10;std::vector&lt;int&gt; head[MAXN];int dfn[MAXN], low[MAXN];bool inStack[MAXN];int rep[MAXM], ren[MAXM];// 把输入数据存一下int sizSC[MAXN], ode[MAXN];int ftot = 0;int top, Stack[MAXN];int col, timestamp, SC[MAXN];// dfn：dfs的时间戳// low：在点u的子树能到达的节点中dfn的最小值// SC：点u属于哪一个强连通分量// inStack：是否在栈中// sizSC：该强连通分量的大小// ode：该“点”的出度void addEdge(int x, int y) &#123; head[x].push_back(y); &#125;void Tarjan(int u) &#123; low[u] = dfn[u] = ++timestamp; Stack[++top] = u; inStack[u] = true; for (int i = 0, siz = (int) head[u].size(); i &lt; siz; ++i) &#123; int v = head[u][i]; if (!dfn[v]) &#123; // 没被访问过 Tarjan(v); low[u] = std::min(low[u], low[v]); &#125; else if (inStack[v]) low[u] = std::min(low[u], low[v]); &#125; if (dfn[u] == low[u]) &#123; // 意味着u的子树中没有能到达u的祖先的边，也就是找到了一个强连通分量 SC[u] = ++col; inStack[u] = false; ++sizSC[col]; while (Stack[top] != u) &#123; SC[Stack[top]] = col; ++sizSC[col]; inStack[Stack[top--]] = false; &#125; top--; &#125;&#125;int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); addEdge(a, b); &#125; for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) Tarjan(i); // 对所有联通块进行tarjan for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0, siz = (int) head[i].size(); j &lt; siz; ++j) &#123; int v = head[i][j]; if (SC[i] != SC[v]) ++ode[SC[i]]; &#125; &#125; int ans = 0; for (int i = 1; i &lt;= col; ++i) if (!ode[i]) &#123; if (ans) &#123; printf("0"); return 0; &#125; ans = sizSC[i]; &#125; printf("%d\n", ans); return 0;&#125;// tm这题我调了2h]]></content>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2606《排列计数》]]></title>
    <url>%2F2019-07-21%2FLuogu-P2606%2F</url>
    <content type="text"><![CDATA[披着数论皮的图论 题目描述称一个1,2,…,N的排列P1,P2…,Pn是Magic的，当且仅当2&lt;=i&lt;=N时，Pi&gt;Pi/2. 计算1，2，…N的排列中有多少是Magic的，答案可能很大，只能输出模P以后的值 输入输出格式输入格式输入文件的第一行包含两个整数 n和p，含义如上所述。 输出格式输出文件中仅包含一个整数，表示计算1,2,⋯, N的排列中， Magic排列的个数模 p的值。 输入输出样例输入样例 120 23 输出样例 116 说明100%的数据中，1 ≤N ≤ 10^6, P≤ 10^9，p是一个质数。 解析考虑这么一个事情：$Pi &gt; P{i / 2}$放到一棵树上是什么？把$P_i$看作第$i$个点的权值，那么…… 第$i$个点的权值比第$i/2$个点的权值要大，也就是第$i$个点的权值要比第$i \times 2$个点的权值要小……想一想二叉树的表示方法……这好像是一个小根堆？ 问题转化为了：求1-n的所有排列中，可以构成一个小根堆的排列的个数 考虑dp设dp[u]表示以u为根结点分配1~size(u)的小根堆的方案数转移：d p(x)=\left(\begin{array}{c}{\operatorname{sz}(x)-1} \\ {\operatorname{sz}\left(u_{1}\right), s z\left(u_{2}\right), \ldots, s z\left(u_{r}\right)}\end{array}\right) \prod d p\left(u_{i}\right) 最终答案就是$dp(1)$ 代码实现我开了O2才过。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;const int MAXN = 1e6 + 10;long long int n, HA, fac[MAXN], inv[MAXN], siz[MAXN], dp[MAXN];std::vector&lt;int&gt; head[MAXN &lt;&lt; 1];/*long long int getll() &#123; long long int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * x + 1ll * ch - 1ll * '0'; ch = getchar(); &#125; return 1ll * s * x; &#125;void putll(long long int x) &#123; if (x &lt; 0) &#123; putchar('-'); x = -x; &#125; putll(x / 10); putchar(x % 10 + '0'); &#125;*/long long int fastPow(long long int a, long long int b) &#123; if (b == 0) return 1; if (b == 1) return a % HA; long long int ret = 1; while (b) &#123; if (b &amp; 1) ret = ret * a % HA; a = a * a % HA; b &gt;&gt;= 1; &#125; return ret;&#125;long long int C(long long int m, long long int n) &#123; // 洛谷上数据水不用 Lucas 定理 // n! / (m!(n - m)!) return fac[n] * inv[m] % HA * inv[n - m] % HA;&#125;inline void addEdge(int prev, int next) &#123; head[prev].push_back(next); head[next].push_back(prev);&#125;void DFS(long long int father = 0, long long int root = 1) &#123; siz[root] = 1; dp[root] = 1; for (int i = 0, ss = head[root].size(); i &lt; ss; ++i) &#123; int next = head[root][i]; if (father == next) continue; DFS(root, next); siz[root] += siz[next]; dp[root] = 1ll * dp[root] * C(siz[next], siz[root] - 1) % HA * dp[next] % HA; &#125;&#125;int main() &#123; //n = getll(); HA = getll(); scanf("%lld %lld", &amp;n, &amp;HA); fac[0] = 1; inv[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; fac[i] = fac[i - 1] * i % HA; inv[i] = fastPow(fac[i], HA - 2); int lson = (i &lt;&lt; 1), rson = (i &lt;&lt; 1 | 1); if (lson &lt;= n) addEdge(i, lson); if (rson &lt;= n) addEdge(i, rson); &#125; DFS(); //putll(dp[1] % HA); printf("%lld\n", dp[1] % HA); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>数论</tag>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单调栈专项练习]]></title>
    <url>%2F2019-07-21%2FMonotoneStack-Luogu-P1901-Luogu-P1823-Luogu-P2947%2F</url>
    <content type="text"><![CDATA[单调数据结构 练习：洛谷P2947《Look Up》题目描述Farmer John’s N (1 &lt;= N &lt;= 100,000) cows, conveniently numbered 1..N, are once again standing in a row. Cow i has height H_i (1 &lt;= H_i &lt;= 1,000,000). Each cow is looking to her left toward those with higher index numbers. We say that cow i ‘looks up’ to cow j if i &lt; j and H_i &lt; H_j. For each cow i, FJ would like to know the index of the first cow in line looked up to by cow i. Note: about 50% of the test data will have N &lt;= 1,000. 约翰的N(1≤N≤10^5)头奶牛站成一排，奶牛i的身高是Hi(l≤Hi≤1,000,000)．现在，每只奶牛都在向右看齐．对于奶牛i，如果奶牛j满足i&lt;j且Hi&lt;Hj，我们可以说奶牛i可以仰望奶牛j． 求出每只奶牛离她最近的仰望对象． Input 输入输出格式输入格式 Line 1: A single integer: N Lines 2..N+1: Line i+1 contains the single integer: H_i 第 1 行输入 N，之后每行输入一个身高 H_i。 输出格式 Lines 1..N: Line i contains a single integer representing the smallest index of a cow up to which cow i looks. If no such cow exists, print 0. 共 N 行，按顺序每行输出一只奶牛的最近仰望对象，如果没有仰望对象，输出 0。 输入输出样例输入样例 123456763 2 6 1 1 2 输出样例 1234563 3 0 6 6 0 说明FJ has six cows of heights 3, 2, 6, 1, 1, and 2. Cows 1 and 2 both look up to cow 3; cows 4 and 5 both look up to cow 6; and cows 3 and 6 do not look up to any cow. 【输入说明】6 头奶牛的身高分别为 3, 2, 6, 1, 1, 2. 【输出说明】奶牛#1,#2 仰望奶牛#3，奶牛#4,#5 仰望奶牛#6，奶牛#3 和#6 没有仰望对象。 【数据规模】 对于 20%的数据： 1≤N≤10； 对于 50%的数据： 1≤N≤1,000； 对于 100%的数据：1≤N≤100,000；1≤H_i≤1,000,000； 解析题目就是说，依次给出一堆线段，求对于每条线段，第一个在它右面，长度大于它的线段的下标是多少我们先来模拟一下： 1234561[===] 歪着看体验更佳（逃2[==]3[======]4[=]5[=]6[==] 第一次，1号进来了，没有比它高的，让它等一会第二次，2号进来了，它甚至比1号还低，对1号的答案没有什么影响，也让它等一会第三次，3号进来了，它比1、2号都高！此时1、2号的答案都是3号，而且1、2号对于以后的线段答案是没有影响的，呆在队伍里已经没有什么用了，让它们出去即可第四次、第五次，4号和5号依次进来，对3号的答案并没有什么影响第六次，6号进来了，4号和5号的答案更新为6号，而且对以后的线段答案也是没有什么影响的（如果以后还有线段的话），出去即可队伍里还有俩线段3和6，它们的答案没有被更新过，也就是没有答案 这就是一个单调栈的工作流程，通过清除栈里的元素来维护单调性，而本题中第三次循环和第六次循环则是对于单调数据结构进行具体问题具体分析的关键点 可以看出，实质上是维护了一个单调不增的栈，在维护栈的单调性过程中求出了答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define repp(a,s,t,i) for (int a = s; a &lt; t; a += i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;long long int getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;const int MAXN = 100000 + 10;int n, ans[MAXN];struct Cow &#123; int height, id; Cow() : height(0), id(0) &#123;&#125; Cow(int height, int id) : height(height), id(id) &#123;&#125;&#125;;std::stack&lt;Cow&gt; stk;int main() &#123; n = getint(); rep (i, 1, n, 1) &#123; int height = getint(); while (!stk.empty() &amp;&amp; stk.top().height &lt; height) &#123; // stk.top().height &lt; height 维护栈内元素单调不增性 // 如果 stk.top().height &gt; height 则单调性仍存在，不必维护 ans[stk.top().id] = i; // 更新答案 stk.pop(); &#125; stk.push((Cow) &#123; height, i &#125;); &#125; rep (i, 1, n, 1) &#123; printf("%d\n", ans[i]); &#125; return 0;&#125; 巩固：洛谷P1901《发射站》题目描述某地有 N 个能量发射站排成一行，每个发射站 i 都有不相同的高度 Hi，并能向两边（当 然两端的只能向一边）同时发射能量值为 Vi 的能量，并且发出的能量只被两边最近的且比 它高的发射站接收。 显然，每个发射站发来的能量有可能被 0 或 1 或 2 个其他发射站所接受，特别是为了安 全，每个发射站接收到的能量总和是我们很关心的问题。由于数据很多，现只需要你帮忙计 算出接收最多能量的发射站接收的能量是多少。 输入输出格式输入格式第 1 行：一个整数 N; 第 2 到 N+1 行：第 i+1 行有两个整数 Hi 和 Vi，表示第 i 个人发射站的高度和发射的能量值。 输出格式输出仅一行，表示接收最多能量的发射站接收到的能量值，答案不超过 longint。 输入输出样例输入样例#1 123434 2 3 5 6 10 输出样例#1 17 说明对于 40%的数据，1&lt;=N&lt;=5000；1&lt;=Hi&lt;=100000；1&lt;=Vi&lt;=10000; 对于 70%的数据，1&lt;=N&lt;=100000；1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000; 对于 100%的数据，1&lt;=N&lt;=1000000;1&lt;=Hi&lt;=2,000,000,000；1&lt;=Vi&lt;=10000。 解析同样的，先来模拟一下这个过程： 1231[====](2)2[===](5)3[======](10) 第一次，1号发射站进来，它莫得其他发射站来传输能量第二次，2号发射站进来，它可以给1号传输能量第三次，3号发射站进来：2号发射站可以给3号发射站传输能量，1号发射站亦可。由于这两个发射站对于其他发射站的答案已经没有贡献，自己的答案也确定了，让它们出去即可 本质上也是维护了一个单调递减的栈，在维护单调性的同时确定答案 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define repp(a,s,t,i) for (int a = s; a &lt; t; a += i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;long long int getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;struct Launcher &#123; int id; int height; long long int energy; // height: 该发射站的高度 // energy: 该发射站的能量强度 Launcher() &#123; id = height = energy = 0; &#125; Launcher(int id, int height, long long int energy) : id(id), height(height), energy(energy) &#123;&#125;&#125;;const int MAXN = 1000000 + 10;int n;long long int ans[MAXN]; // 答案不超过 long intstd::stack&lt;Launcher&gt; stk;int main() &#123; n = getint(); rep (i, 1, n, 1) &#123; int h = getint(); int energy = getint(); while (!stk.empty() &amp;&amp; stk.top().height &lt; h) &#123; ans[i] += stk.top().energy; // 栈顶对应的发射站能「向右」发射能量到当前的发射站 stk.pop(); // 维护栈的单调递减性 &#125; if (!stk.empty()) ans[stk.top().id] += energy; // 当前发射站能「向左」发射能量到栈顶对应的发射站 stk.push((Launcher) &#123; i, h, energy &#125;); &#125; printf("%lld\n", (long long int) *std::max_element(ans + 1, ans + 1 + n)); return 0;&#125; 提高：洛谷P1823《Patrik 音乐会的等待》题目描述N个人正在排队进入一个音乐会。人们等得很无聊，于是他们开始转来转去，想在队伍里寻找自己的熟人。队列中任意两个人A和B，如果他们是相邻或他们之间没有人比A或B高，那么他们是可以互相看得见的。 写一个程序计算出有多少对人可以互相看见。 输入输出格式输入格式输入的第一行包含一个整数N (1 ≤ N ≤ 500 000), 表示队伍中共有N个人。 接下来的N行中，每行包含一个整数，表示人的高度，以毫微米(等于10的-9次方米)为单位，每个人的调度都小于2^31毫微米。这些高度分别表示队伍中人的身高。 输出格式输出仅有一行，包含一个数S，表示队伍中共有S对人可以互相看见。 输入输出样例输入样例#1 123456787 2 4 1 2 2 5 1 输出样例#1 110 解析依然来模拟一下：， 12345671[==]2[====]3[=]4[==]5[==]6[=====]7[=] 第一次，1号进入，它谁都望不到第二次，2号进入，1、2号能互相看见，此时1号对答案已经没有贡献，出去即可第三次，3号进入，2、3号能互相看见第四次，4号进入，3、4号能互相看见，同时2、4号也可以互相看见，此时3号对答案已经没有贡献，出去即可第五次……第六次……第七次…… 已经很明显了，依然是维护一个单调不增的栈，在维护元素单调性的同时更新答案但是这里的代码实现有一定的技巧 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define repp(a,s,t,i) for (int a = s; a &lt; t; a += i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;long long int getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;struct Height &#123; // 按照顺序把相邻等高的人视为一组 int height; long long int amount; // height: 该组的高度 // amount: 该组的人数 Height() &#123; height = amount = 0; &#125; Height(int height, long long int amount) : height(height), amount(amount) &#123;&#125;&#125;;int n;long long int ans;std::stack&lt;Height&gt; stk;int main() &#123; n = getint(); rep (i, 1, n, 1) &#123; int h = getint(); Height hh = (Height) &#123; h, 1 &#125;; while (!stk.empty() &amp;&amp; stk.top().height &lt;= h) &#123; ans += stk.top().amount; // 当前人能够看见上一组整组的人 if (stk.top().height == h) hh.amount += stk.top().amount; // 如果两组人等高，就把两组人归到一组去 stk.pop(); &#125; if (!stk.empty()) ++ans; // 在放当前的人进栈之前，如果栈非空，说明栈顶这个人是能看见当前的人的 stk.push(hh); &#125; printf("%lld\n", ans); // C(100000, 2) &gt; (1 &lt;&lt; 31) // 答案超过 int return 0;&#125;]]></content>
      <tags>
        <tag>专项练习</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3884 洛谷P4139《上帝与集合的正确用法》]]></title>
    <url>%2F2019-07-18%2FBZOJ3884-Luogu-P4139%2F</url>
    <content type="text"><![CDATA[$2^{2^{2^{2^{2^{…}}}}}$ Description根据一些书上的记载，上帝的一次失败的创世经历是这样的：第一天， 上帝创造了一个世界的基本元素，称做“元”。第二天， 上帝创造了一个新的元素，称作“α”。“α”被定义为“元”构成的集合。容易发现，一共有两种不同的“α”。第三天， 上帝又创造了一个新的元素，称作“β”。“β”被定义为“α”构成的集合。容易发现，一共有四种不同的“β”。第四天， 上帝创造了新的元素“γ”，“γ”被定义为“β”的集合。显然，一共会有16种不同的“γ”。如果按照这样下去，上帝创造的第四种元素将会有65536种，第五种元素将会有2^65536种。这将会是一个天文数字。然而，上帝并没有预料到元素种类数的增长是如此的迅速。他想要让世界的元素丰富起来，因此，日复一日，年复一年，他重复地创造着新的元素……然而不久，当上帝创造出最后一种元素“θ”时，他发现这世界的元素实在是太多了，以致于世界的容量不足，无法承受。因此在这一天，上帝毁灭了世界。至今，上帝仍记得那次失败的创世经历，现在他想问问你，他最后一次创造的元素“θ”一共有多少种？上帝觉得这个数字可能过于巨大而无法表示出来，因此你只需要回答这个数对p取模后的值即可。你可以认为上帝从“α”到“θ”一共创造了10^9次元素，或10^18次，或者干脆∞次。一句话题意：求 $2^{2^{2^{2^{2^{…}}}}}\bmod p$的值 Input接下来T行，每行一个正整数p，代表你需要取模的值 OutputT行，每行一个正整数，为答案对p取模后的值 Sample Input12343236 Sample Output123014 HINT对于100%的数据，T&lt;=1000,p&lt;=10^7 解析一开始看到这个题目，我是懵逼的 这题让我们求$2^\infty\bmod p$的值，考虑把它转化一下 根据扩展欧拉定理可知 a ^ b= \begin{cases} a ^ {b \bmod \varphi(p)} \quad & \gcd(a,p)=1 \\ a ^ b \quad & \gcd(a,p) \not=1, b < \varphi(p)\\ a ^ {b \bmod \varphi(p) + \varphi (p)} \quad & \gcd(a,p) \not=1, b \ge \varphi(p)\\ \end{cases}所以把它变成第三条的形式 2^{2^{2^{2^{2^{...}}}}}\bmod p=2^{2^{2^{2^{2^{...}}}} \bmod \varphi(p) + \varphi(p)}把第一个2的指数摘出来单独康一康 2^{2^{2^{2^{...}}}} \bmod \varphi(p) + \varphi(p)设$\varphi(p) + \varphi(p) = a$，上式变为 2^{2^{2^{2^{...}}}} \bmod a好像在哪见过……那就再来一遍 2^{2^{2^{2^{2^{...}}}}}\bmod a=2^{2^{2^{2^{2^{...}}}} \bmod \varphi(a) + \varphi(a)}这是个递归式！ 那么解法就很显然了：根据扩展欧拉定理，把指数部分变形，然后递归进去继续变形指数部分的指数部分…… 找一找递归出口在模$p$的意义下，一个数的取值范围是$[0,p-1]$考虑让这个数变成定值，显然$p=1$时，这个数为$0$这个就是递归出口，当模数为1时，返回0 求$\varphi(i)$建议使用根号算法，更快一些 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define repp(a,s,t,i) for (int a = s; a &lt; t; a += i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;long long int getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;long long int p;long long int fastPower(long long int x, long long int a, long long int p) &#123; long long int ret = 1; if (a == 0) return x; while (a) &#123; if (a &amp; 1) ret = ret * x % p; x = x * x % p; a &gt;&gt;= 1; &#125; return ret;&#125;long long int phi(long long int x) &#123; long long int ret = x, a = x; for (long long int i = 2; i * i &lt;= a; ++i) &#123; if (a % i == 0) &#123; // 如果i是a的质因子 ret = ret / i * (i - 1); while (a % i == 0) a /= i; // 筛去所有的i &#125; &#125; if (a &gt; 1) ret = ret / a * (a - 1); return ret;&#125;long long int solve(long long int pp) &#123; if (pp == 1) return 0; long long int pf = phi(pp); return fastPower(2, solve(pf) + pf, pp);&#125;int main() &#123; int T = getint(); countdown (T) &#123; p = getll(); printf("%lld\n", solve(p)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>EXGCD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于近期对博客大部分文章进行整理的说明]]></title>
    <url>%2F2019-07-12%2FArticles-Reform%2F</url>
    <content type="text"><![CDATA[利用这几天时间对博客文章的排版、一句话说明、标签等内容进行修改和更新 博客主题也有大幅度变动的可能 特此说明]]></content>
      <tags>
        <tag>博客相关</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3907《圈的异或》]]></title>
    <url>%2F2019-07-12%2FLuogu-P3907%2F</url>
    <content type="text"><![CDATA[暴力 DFS 即可(???) 题目描述给出无向图G，边(A_i,B_i) 的权是C_i，判断下列性质是否成立： 对于任意圈C，其边权的异或和是0 输入格式第1 行，1 个整数T，表示数据的组数。 每组数据第1 行，2 个整数N,M，表示图G 点和边的数量。 M 行，每行3 个整数A_i,B_i,C_i 输出格式对每个数据输出一行，“Yes” 或者“No” 输入输出样例输入 #1 123456723 31 2 12 3 23 1 31 11 1 1 输出 #1 12YesNo 解析第一反应搜索 其他的都没的说，如何判断异或和？ 维护一个 $\text{prefix[x]}​$ 数组表示 dfs 序中从起点到点$\text{x}​$的边权异或和，可以理解为一个类似于前缀和的东西 它工作是这样一个过程： 比如说这么一个图，我从 6 开始搜索 当前搜到了 5，检测出来返祖边了，在这停下不知所措黑色部分是$\text{prefix[5]}$，青色部分是$\text{prefix[1]}$ 那么答案就是从 1 走到 5 的异或和（设为$X$） $\text{xor}$ $\text{weight}(1,5)$ $X$怎么求？来想一想 $\text{xor}$ 的性质吧：$a \text{ xor } a=0, a\text{ xor }0=a $ 那么…… \text{sum[5]}=X\text{ xor sum[1]}\\ \text{sum[5] xor sum[1]} \\=X \text{ xor sum[1] xor sum[1]} \\=X\text{ xor 0}$\text{prefix[5]}=X \text{ xor prefix[1]}$ 所以 $\text{prefix[5] xor prefix[1]}$ $=X \text{ xor prefix[1] xor prefix[1]}\=X \text{ xor } 0 \ = X$ ！！！那么求 $X$ 就直接把上面那俩 xor 一下就行了 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define repp(a,s,t,i) for (int a = s; a &lt; t; a += i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;long long int getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;const int MAXN = 50 + 10;int T, n, m;struct Graph&#123; struct Edge &#123; int next, weight; Edge() &#123; next = weight = 0; &#125; Edge(int next, int weight) : next(next), weight(weight) &#123;&#125; &#125;; std::vector&lt;Edge&gt; head[MAXN]; int prefix[MAXN]; bool vis[MAXN], exitNeeded; Graph() &#123; memset(prefix, 0, sizeof prefix); memset(vis, 0, sizeof vis); exitNeeded = false; &#125; inline void addEdge(int prev, int next, int weight) &#123; head[prev].push_back((Edge) &#123; next, weight &#125;); head[next].push_back((Edge) &#123; prev, weight &#125;); &#125; void DFS(int now, int last, int ans) &#123; if (exitNeeded) return; vis[now] = true; prefix[now] = ans; for (int i = 0, siz = (int) head[now].size(); i &lt; siz &amp;&amp; !exitNeeded; ++i) &#123; int next = head[now][i].next; if (!vis[next]) DFS(next, now, ans ^ head[now][i].weight); else &#123; // 前面的点被搜过了，返祖边！ if (now != last) &#123; if (head[now][i].weight ^ prefix[now] ^ prefix[next]) &#123; // 对应解析中 X 的求法 exitNeeded = true; return; &#125; &#125; &#125; &#125; &#125;&#125;;int main() &#123; T = getint(); countdown (T) &#123; Graph G; n = getint(); m = getint(); for (int i = 1; i &lt;= m; ++i) &#123; int prev = getint(); int next = getint(); int weight = getint(); G.addEdge(prev, next, weight); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (!G.vis[i]) G.DFS(i, 0, 0); if (G.exitNeeded) break; &#125; puts(G.exitNeeded ? "No" : "Yes"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2023《维护序列》]]></title>
    <url>%2F2019-07-06%2FLuogu-P2023%2F</url>
    <content type="text"><![CDATA[多操作线段树标记下方是有顺序的 题目描述老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。 有长为N的数列，不妨设为a1,a2,…,aN 。有如下三种操作形式：(1)把数列中的一段数全部乘一个值;(2)把数列中的一段数全部加一个值;(3)询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模P的值。 输入输出格式输入格式： 第一行两个整数N和P(1≤P≤1000000000）。第二行含有N个非负整数,从左到右依次为a1,a2,…,aN, (0≤ai≤1000000000,1≤i≤N)。第三行有一个整数M，表示操作总数。从第四行开始每行描述一个操作，输入的操作有以下三种形式：操作1：“1 t g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai×c(1≤t≤g≤N,0≤c≤1000000000)。操作2：“2 t g c”(不含双引号)。表示把所有满足t≤i≤g的ai改为ai+c (1≤t≤g≤N,0≤c≤1000000000)。操作3：“3 t g”(不含双引号)。询问所有满足t≤i≤g的ai的和模P的值 (1≤t≤g≤N)。同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。 输出格式： 对每个操作3，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。 输入输出样例输入样例123456787 431 2 3 4 5 6 751 2 5 53 2 42 3 7 93 1 33 4 7 输出样例1232358 解题思路多操作线段树模板题，同《线段树 2》 大致方向首先我们来康一康只有区间加的时候怎么做 维护一个标记add[i]表示节点i对应的区间[l,r]被加了多少 在下放标记时，sum[i]会被更新为sum[i] + add[i] * (r - l + 1) 我们把它看作 $x + b$ 的形式，其中sum[i]对应$x$， add[i] 对应$b$，后面的看作常数就好啦 那么区间加乘的形式就应该是 $ax+b$，也就意味着要多维护一个标记mul[i]表示节点i对应的区间[l,r]被乘了多少，sum[i]会被更新为sum[i] * mul[i] + add[i] * (r - l + 1) 区间修改先看乘法，比如i节点对应区间[l,r]被乘了一个$k$，本质上就是$k(ax+b)$，拆出来就是$kax + kb$，也就是把mul[i]和add[i]都乘上一个$k$ 加法本质上就是 $ax + b + k$，整理得 $ax + (b + k)$，那么把add[i]加上$k$就行了 标记下放同样地，把每个节点看作 $ax+b$ 的关系，在这里i节点对应的区间和[l,r]为$ax+b$，左子树lc(i)对应的区间和[l, mid]为$a’y+b’$ 遵循先乘后加的原则，对左子树乘上一个$a$得 aa'y+ab' 然后加上 $b$ aa'y+ab'+b 整理得 (aa')y + (ab' + b) 观察下这个式子，把它写成$ax+b$的形式 Ay+B\ (A=aa',B=ab' + b) 发现了什么？ 本质上就是，左子树的乘法标记 乘上 当前点的乘法标记 左子树的加法标记 先乘上 当前点的乘法标记 再加上 当前点的加法标记 mul[lc(i)] *= mul[i], add[lc(i)] = add[lc(i)] * mul[i] + add[i] 对右子树进行一遍同样的操作，清空标记即可（稍有常识的人都知道mul[i]要初始化为1） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rep(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define repp(a,s,t,i) for (int a = s; a &lt; t; a += i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 200000 + 10;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;long long int getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;int n, CH, m;long long int a[MAXN / 2];struct SegmentTree &#123; long long int sum[MAXN &lt;&lt; 2]; long long int mul[MAXN &lt;&lt; 2], add[MAXN &lt;&lt; 2]; #define lc(x) ((x &lt;&lt; 1))#define rc(x) ((x &lt;&lt; 1 | 1)) SegmentTree() &#123; memset(sum, 0, sizeof sum); memset(mul, 1, sizeof mul); memset(add, 0, sizeof add); &#125; void PushTag(int root, int l, int r) &#123; if (mul[root] == 1 &amp;&amp; add[root] == 0) return; // 该处标记不存在或已被下放 if (l != r) &#123; mul[lc(root)] = mul[lc(root)] * mul[root] % CH; mul[rc(root)] = mul[rc(root)] * mul[root] % CH; add[lc(root)] = (add[lc(root)] * mul[root] % CH + add[root]) % CH; add[rc(root)] = (add[rc(root)] * mul[root] % CH + add[root]) % CH; &#125; sum[root] = (sum[root] * mul[root] % CH + add[root] * (r - l + 1) % CH) % CH; mul[root] = 1; add[root] = 0; &#125; void buildTree(int root, int l, int r, long long int *seq) &#123; mul[root] = 1; add[root] = 0; if (l == r) &#123; sum[root] = seq[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; buildTree(lc(root), l, mid, seq); buildTree(rc(root), mid + 1, r, seq); sum[root] = (sum[lc(root)] + sum[rc(root)]) % CH; &#125; long long int Query(int root, int l, int r, int ll, int rr) &#123; PushTag(root, l, r); if (ll &lt;= l &amp;&amp; r &lt;= rr) return sum[root]; long long int ret = 0; int mid = (l + r) &gt;&gt; 1; if (ll &lt;= mid) ret = (ret + Query(lc(root), l, mid, ll, rr)) % CH; if (mid + 1 &lt;= rr) ret = (ret + Query(rc(root), mid + 1, r, ll, rr)) % CH; return ret; &#125; void Modify(int method, int root, int l, int r, int ll, int rr, long long int k) &#123; PushTag(root, l, r); if (ll &lt;= l &amp;&amp; r &lt;= rr) &#123; if (method == 1) &#123; mul[root] = mul[root] * k % CH; add[root] = add[root] * k % CH; &#125; else &#123; add[root] = (add[root] + k) % CH; &#125; return; &#125; int mid = (l + r) &gt;&gt; 1; if (ll &lt;= mid) Modify(method, lc(root), l, mid, ll, rr, k); if (mid + 1 &lt;= rr) Modify(method, rc(root), mid + 1, r, ll, rr, k); PushTag(lc(root), l, mid); PushTag(rc(root), mid + 1, r); sum[root] = (sum[lc(root)] + sum[rc(root)]) % CH; &#125;&#125; Tree;int main() &#123; n = getint(); CH = getint(); rep (i, 1, n, 1) a[i] = getint(); Tree.buildTree(1, 1, n, a); m = getint(); countdown (m) &#123; int op = getint(); int l = getint(); int r = getint(); switch (op) &#123; case 1: &#123; long long int k = getll(); Tree.Modify(1, 1, 1, n, l, r, k); break; &#125; case 2: &#123; long long int k = getll(); Tree.Modify(2, 1, 1, n, l, r, k); break; &#125; case 3: &#123; printf("%lld\n", Tree.Query(1, 1, n, l, r)); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2016《战略游戏》]]></title>
    <url>%2F2019-05-11%2FLuogu-P2016%2F</url>
    <content type="text"><![CDATA[最典型的树形DP 题目描述Bob喜欢玩电脑游戏，特别是战略游戏。但是他经常无法找到快速玩过游戏的办法。现在他有个问题。 他要建立一个古城堡，城堡中的路形成一棵树。他要在这棵树的结点上放置最少数目的士兵，使得这些士兵能了望到所有的路。 注意，某个士兵在一个结点上时，与该结点相连的所有边将都可以被了望到。 请你编一程序，给定一树，帮Bob计算出他需要放置最少的士兵. 输入输出格式输入格式第一行 N，表示树中结点的数目。 第二行至第N+1行，每行描述每个结点信息，依次为：该结点标号i，k(后面有k条边与结点I相连)。 接下来k个数，分别是每条边的另一个结点标号r1，r2，…，rk。 对于一个n(0&lt;n&lt;=1500)个结点的树，结点标号在0到n-1之间，在输入数据中每条边只出现一次。 输出格式输出文件仅包含一个数，为所求的最少的士兵数目。 例如，对于如下图所示的树： 123 012 3 答案为1（只要一个士兵在结点1上）。 输入输出样例输入样例1234540 1 11 2 2 32 03 0 输出样例11 解题思路这道题，就是这种树形DP最标准的形态「选点DP」 设 dp[i][0/1] 表示选/不选以i为根的子树时的最大值 转移方程很显然dp[root][0] += dp[child][1]dp[root][1] += std::min(dp[child][0], dp[child][1]) 也就是 如果我不选当前点，那么就必须选我儿子，不然我和我儿子之间这条路没人看 如果我选了当前点，我儿子干啥我是不管的，选一个最小的加上 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 1500 + 10;int n, dp[MAXN][2];std::vector&lt;int&gt; G[MAXN];inline void addEdge(int prev, int next) &#123; G[prev].push_back(next); G[next].push_back(prev);&#125;void DFS(int root = 1, int father = 0) &#123; dp[root][1] = 1; dp[root][0] = 0; for (auto v : G[root]) &#123; if (v == father) continue; DFS(v, root); dp[root][1] += std::min(dp[v][0], dp[v][1]); dp[root][0] += dp[v][1]; &#125;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int id = 0, k = 0; cin &gt;&gt; id &gt;&gt; k; ++id; for (int i = 1; i &lt;= k; ++i) &#123; int qwq = 0; cin &gt;&gt; qwq; ++qwq; addEdge(id, qwq); &#125; &#125; DFS(); cout &lt;&lt; std::min(dp[1][0], dp[1][1]) &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2014《选课》]]></title>
    <url>%2F2019-05-11%2FLuogu-P2014%2F</url>
    <content type="text"><![CDATA[森林上的DP 题目描述在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有N门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程a是课程b的先修课即只有学完了课程a，才能学习课程b）。一个学生要从这些课程里选择M门课程学习，问他能获得的最大学分是多少？ 输入输出格式输入格式第一行有两个整数N,M用空格隔开。(1&lt;=N&lt;=300,1&lt;=M&lt;=300) 接下来的N行,第I+1行包含两个整数ki和si, ki表示第I门课的直接先修课，si表示第I门课的学分。若ki=0表示没有直接先修课（1&lt;=ki&lt;=N, 1&lt;=si&lt;=20）。 输出格式只有一行，选M门课程的最大得分。 输入输出样例输入样例123456787 42 20 10 42 17 17 62 2 输出样例113 解题思路注意到题目中的「每门课有一门或没有直接先修课」所以这是一个森林 我们用一个虚拟点0把所有的树根连起来，构成一棵大树接下来这个题目就从一个DAG上DP转化为了一个树形DP但是！它事一个树形背包 设dp[i][j]表示选以i为根的树j个节点 初始化方程：dp[child][i] = dp[root][i] + weight[root](0 &lt;= i &lt; 还能选择的节点数)至于为什么从零开始……因为可以选择的节点是root的子树的节点数减一，毕竟root占掉了一个节点 转移方程：dp[root][i] = std::max(dp[root][k], dp[child][k-1]);(1 &lt;= i &lt;= 还能选择的节点数) 答案：dp[0][m] 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// luogu-judger-enable-o2#include &lt;iostream&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 300 + 10;int dp[MAXN][MAXN];/* * * 首先这是一个森林 * 令 f[i][j] 表示以 i 为根的子树选择前 j 个点的最大价值 * */struct Graph &#123; std::vector&lt;int&gt; head[MAXN]; int weight[MAXN]; void addEdge(int prev, int next, int w) &#123; head[prev].push_back(next); weight[next] = w; &#125; void DFS(int root, int k) &#123; if (k == 0) return; // 没得选了 for (auto now : head[root]) &#123; for (int i = 0; i &lt; k; ++i) &#123; dp[now][i] = dp[root][i] + weight[now]; &#125; DFS(now, k - 1); // 对子树进行选择 for (int i = 1; i &lt;= k; ++i) &#123; dp[root][i] = std::max(dp[root][i], dp[now][i-1]); &#125; &#125; &#125;&#125; G;int main() &#123; IMPROVE_IO(); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; int prev, weight; cin &gt;&gt; prev &gt;&gt; weight; G.addEdge(prev, i, weight); &#125; G.DFS(0, m); cout &lt;&lt; dp[0][m] &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1967「NOIP2013」《货车运输》]]></title>
    <url>%2F2019-03-30%2FLuogu-P1967%2F</url>
    <content type="text"><![CDATA[题目描述A国有n座城市，编号从 1到n，城市之间有 m 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 q 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入格式第一行有两个用一个空格隔开的整数n,m，表示 A 国有n 座城市和 m 条道路。 接下来 m行每行3个整数 x, y, z，每两个整数之间用一个空格隔开，表示从 x号城市到y号城市有一条限重为 z 的道路。注意： x 不等于 y，两座城市之间可能有多条道路 。 接下来一行有一个整数 q，表示有 q 辆货车需要运货。 接下来 q 行，每行两个整数 x、y，之间用一个空格隔开，表示一辆货车需要从 x 城市运输货物到 y 城市，注意： x 不等于 y 。 输出格式共有 q 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出−1。 输入输出样例输入 #1 123456784 31 2 42 3 33 1 131 31 41 3 输出 #1 1233-13 解析题目让我们求对于每个司机，最多能运多少货物，也就是在给定的两点间必经路线中求最大边权，显然我们要最大化这个边权，才能使答案更优。 注意到一些边是无论如何都不会被经过的，这些边通常较小，经过它们会劣化答案。那么一个很显然的贪心就是，排个序，依次选择最大的边加入新图，尽量不选较小的边，直到新图联通且无环，两点间有唯一的不重复经过同一条边的路径 等等……这个是最大生成树？是的。 想一想答案怎么求。既然新图有一个性质「两点间有唯一的不重复经过同一条边的路径」，那么走一遍这条路径不就求出答案了吗！ 为什么不再往上走一走？能运载的最大货物量是由这条路径决定的，往上走只可能有两种结果：上面边权比最小值大，上面边权比最小值小。第一种情况对答案没有什么贡献（因为最大值影响不了最小值），第二种情况则会劣化答案！ 显然这条路径被这两个点的 LCA 分成两段，从一个点向上到 LCA 再向下到另一个点，那么在求 LCA 往上蹦的过程中求一下最小值就行了。可以倍增。 代码实现include include include include define FILE_IN(fname) freopen(fname, “r”, stdin)define FILE_OUT(fname) freopen(fname, “w”, stdout)define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl; const int MAXN = 100000 + 10;const int MAXM = MAXN * 5;const int LOG = 21; int n, m, q; namespace Graph{ struct RawEdge { int prev, next, weight; bool operator &lt; (const RawEdge &amp;that) const { return weight &gt; that.weight; } } redge[MAXM]; struct Edge { int now, next, weight; } edge[MAXM]; int head[MAXN], cnt; bool vis[MAXN]; void addEdge(int prev, int next, int weight) { edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; } struct UnionFind{ int seq[MAXN]; UnionFind() { memset(seq, 0, sizeof seq); } int Find(int x) { if (seq[x] == 0) return x; return seq[x] = Find(seq[x]); } bool Union(int x, int y) { x = Find(x); y = Find(y); if (x == y) return false; seq[x] = y; return true; } } U; void Kruskal() { std::sort(redge + 1, redge + 1 + m); for(int i = 1; i &lt;= m; ++i) { if (U.Union(redge[i].prev, redge[i].next)) { addEdge(redge[i].prev, redge[i].next, redge[i].weight); addEdge(redge[i].next, redge[i].prev, redge[i].weight); } } } } namespace LCAs { using namespace Graph; int depth[MAXN], fa[MAXN][LOG], w[MAXN][LOG]; void Search(int root) { vis[root] = true; for(int e = head[root]; e; e = edge[e].next) { int now = edge[e].now; if (vis[now]) continue; depth[now] = depth[root] + 1; fa[now][0] = root; w[now][0] = edge[e].weight; Search(now); } } int GetAnswer(int x, int y) { if (U.Find(x) != U.Find(y)) return -1; int ans = 0x7f7f7f7f; if (depth[x] &gt; depth[y]) std::swap(x,y); for (int i = LOG - 1; i &gt;= 0; --i) { if (depth[fa[y][i]] &gt;= depth[x]) { ans = std::min(ans, w[y][i]); y = fa[y][i]; } } if (x == y) return ans; for (int i = LOG - 1; i &gt;= 0; --i) { if (fa[x][i] != fa[y][i]) { ans = std::min(ans, std::min(w[x][i], w[y][i])); x = fa[x][i]; y = fa[y][i]; } } ans = std::min(ans, std::min(w[x][0], w[y][0])); return ans; } } int main() { using namespace LCAs; using namespace Graph; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= m; ++i) { int x, y, z; scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z); redge[i].prev = x; redge[i].next = y; redge[i].weight = z; } Kruskal(); for (int i = 1; i &lt;= n; ++i){ if (!vis[i]) { depth[i] = 1; Search(i); fa[i][0] = i; w[i][0] = 0x7f7f7f7f; } } for (int i = 1; i &lt;= LOG - 1; ++i) { for (int j = 1; j &lt;= n; ++j) { fa[j][i] = fa[fa[j][i-1]][i-1]; w[j][i] = std::min(w[j][i-1], w[fa[j][i-1]][i-1]); } } scanf(&quot;%d&quot;, &amp;q); for (int i = 1; i &lt;= q; ++i) { int prev, next; cin &gt;&gt; prev &gt;&gt; next; printf(&quot;%d\n&quot;, GetAnswer(prev, next)); } return 0; }]]></content>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
        <tag>DFS</tag>
        <tag>LCA</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P5018「NOIP2018普及组」《对称二叉树》]]></title>
    <url>%2F2019-03-30%2FNOIP2018-PJ-Tree-Luogu-P5018%2F</url>
    <content type="text"><![CDATA[一个长得像暴力的正解 题目描述一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： 二叉树； 将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。 下图中节点内的数字为权值，节点外的 id 表示节点编号。 现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。 注意：只有树根的树也是对称二叉树。本题中约定，以节点T 为子树根的一棵“子 树”指的是：节点 T 和它的全部后代节点构成的二叉树。 输入输出格式输入格式第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 $1 \sim n$，其中节点 1 是树根。 第二行 n 个正整数，用一个空格分隔，第 i 个正整数 $v_i$​ 代表节点 i 的权值。 接下来 n 行，每行两个正整数 $l_i, r_i$，分别表示节点 i 的左右孩子的编号。如果不存在左 / 右孩子，则以 -1 表示。两个数之间用一个空格隔开。 输出格式输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。 输入输出样例输入样例#112342 1 3 2 -1 -1 -1 输出样例#111 输入样例#212345678910111210 2 2 5 5 5 5 4 4 2 3 9 10 -1 -1 -1 -1 -1 -1 -1 -1 -1 2 3 4 5 6 -1 -1 7 8 输出样例#213 说明【数据规模与约定】共 25 个测试点。$v_i ≤ 1000$。测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。测试点 $4 \sim 8, n ≤ 10$。测试点 $9 \sim 12, n ≤ 10^5$ ，保证输入是一棵“满二叉树” 。测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 1。测试点 $21 \sim 25, n ≤ 10^6$ 。 本题约定： 层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 1。 树的深度：树中节点的最大层次称为树的深度。 满二叉树：设二叉树的深度为 h，且二叉树有 $2h−1$ 个节点，这就是满二叉树。 完全二叉树：设二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大 个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。 解析场上没写这道题真是血亏被T3折磨得心态爆炸&nbsp;也没心情写这题了。。。 首先它求的是满足要求的最大子树的大小那就先 DFS 一遍求出所有子树的大小 1234567891011void DFS(int root = 1) &#123; // nodes[root].treeSize 已经被赋值为1了 if (nodes[root].leftChild != -1) &#123; DFS(nodes[root].leftChild); nodes[root].treeSize += nodes[LC(root)].treeSize; &#125; if (nodes[root].rightChild != -1) &#123; DFS(nodes[root].rightChild); nodes[root].treeSize += nodes[RC(root)].treeSize; &#125;&#125; 然后呢？ 一个很暴力的想法，就是暴力枚举根节点，判断一下这棵子树是否对称，对称就更新答案 判断对称是很好写的，递归即可 12345678910bool CheckSymmetric(int n1, int n2) &#123; if (n1 == -1 &amp;&amp; n2 == -1) return true; // 叶子节点 if ( (n1 != -1 &amp;&amp; n2 != -1) /* 判断是否有完整的节点 */ &amp;&amp; nodes[n1].data == nodes[n2].data /* 判断节点信息是否相同 */ &amp;&amp; CheckSymmetric(LC(n1), RC(n2)) /* 递归判断两边的节点 */ &amp;&amp; CheckSymmetric(LC(n2), RC(n1)) /* 递归判断中间的节点 */ ) return true; return false; // 判断失败&#125; 「递归判断两边 / 中间的节点」，是这么回事 先假装节点id = 2不存在 在进行递归的时候，判断的是(id = 3, id = 6)和(id = 4, id = 5)很明显判断对称的时候，要判断的就是这两个节点（和它们的子树） 代码分析完了，来算算这份暴力的复杂度 DFS 不用说 CheckSymmetric 的最坏情况是原树为完全二叉树，递归次数为树高（即 $\log_2n$），又因为要暴力枚举一共$n$个点，所以复杂度为$O(n\log_2 n)$ 综上，程序复杂度为$O(n\log_2n)$，是能过的 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define LC(x) ((nodes[x].leftChild))#define RC(x) ((nodes[x].rightChild))using std::cin;using std::cout;using std::endl;const int MAXN = 1000000 + 10;struct Node &#123; int data; int leftChild; int rightChild; int treeSize; Node() : data(0), leftChild(0), rightChild(0), treeSize(1) &#123;&#125;&#125; nodes[MAXN];int n;void DFS(int root = 1) &#123; if (nodes[root].leftChild != -1) &#123; DFS(nodes[root].leftChild); nodes[root].treeSize += nodes[LC(root)].treeSize; &#125; if (nodes[root].rightChild != -1) &#123; DFS(nodes[root].rightChild); nodes[root].treeSize += nodes[RC(root)].treeSize; &#125;&#125;bool CheckSymmetric(int n1, int n2) &#123; if (n1 == -1 &amp;&amp; n2 == -1) return true; // leaf node if ( (n1 != -1 &amp;&amp; n2 != -1) &amp;&amp; nodes[n1].data == nodes[n2].data &amp;&amp; CheckSymmetric(LC(n1), RC(n2)) &amp;&amp; CheckSymmetric(LC(n2), RC(n1)) ) return true; return false;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; nodes[i].data; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; nodes[i].leftChild &gt;&gt; nodes[i].rightChild; &#125; DFS(); int ans = 0; // enumerate every subtree for (int i = 1; i &lt;= n; ++i) &#123; if (CheckSymmetric(LC(i), RC(i))) &#123; ans = std::max(ans, nodes[i].treeSize); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>DFS</tag>
        <tag>暴力</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1092「NOIP2004」《虫食算》]]></title>
    <url>%2F2019-03-30%2FLuogu-P1092%2F</url>
    <content type="text"><![CDATA[调换搜索顺序以获得更快时间 题目描述所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的字母。来看一个简单的例子： 123 43#9865#045+ 8468#6633 44445509678 其中$#$号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是5和3，第二行的数字是5。 现在，我们对问题做两个限制： 首先，我们只考虑加法的虫食算。这里的加法是N进制加法，算式中三个数都有N位，允许有前导的0。 其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是N进制的，我们就取英文字母表午的前N个大写字母来表示这个算式中的0到N-1这N个不同的数字：但是这N个字母并不一定顺序地代表0到N−1。输入数据保证N个字母分别至少出现一次。 123 BADC+CBDA DCCC 上面的算式是一个4进制的算式。很显然，我们只要让ABCD分别代表0123，便可以让这个式子成立了。你的任务是，对于给定的N进制加法算式，求出N个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。 输入输出格式输入格式包含四行。第一行有一个正整数$N(N \le 26)$。 后面的三行，每行有一个由大写字母组成的字符串，分别代表两个加数以及和。这3个字符串左右两端都没有空格，从高位到低位，并且恰好有NN位。 输出格式一行，即唯一的那组解。 解是这样表示的：输出N个数字，分别表示A,B,C,…所代表的数字，相邻的两个数字用一个空格隔开，不能有多余的空格。 输入输出样例输入样例12345ABCEDBDACEEBBAA 输出样例11 0 3 4 2 说明对于30％的数据，保证有$N \le 10$； 对于50％的数据，保证有$N \le 15$； 对于全部的数据，保证有$N \le 26$。 noip2004提高组第4题 解题思路考虑暴力枚举每一个数字 肯定是过不去的 考虑枚举算式中的每一个数 用时大大减小 但是可能会填出 1234 1111+1221----- 2333 这样的情况 显然这样的情况是无用的 就需要一个判断 耗时依然较高 换一下搜索顺序，每列每列地填 在填完一列之后判断一下等式是否成立 就差不多了 虽然可能会耗点时间但是省出来的时间是多得多的 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define DDBUG(x,y) std::cerr &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; y;#define MDBUG(comment) std::cerr &lt;&lt; comment;#define getNum(x) ((ans[x]))#define giveNum(x,y) ((ans[x] = y))using std::cin;using std::cout;using std::endl;const int MAXN = 26 + 10;int n, ans[MAXN], col[3 + 2][MAXN];bool vis[MAXN];std::string ol[3];void Init() &#123; // convert the letters to numbers for (int i = 0; i &lt; 3; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; col[i + 1][j + 1] = ol[i][j] - 'A' + 1; &#125; &#125;&#125;namespace Checks &#123; bool check1() &#123; // Check for unfilled letters for (int i = 1; i &lt;= n; ++i) if (ans[i] == -1) return true; return false; &#125; bool check2() &#123; // Check that the equation is correct int nextBit = 0; // addition carry for (int i = n; i &gt;= 1; --i) &#123; // from right to left int A = getNum(col[1][i]); int B = getNum(col[2][i]); int C = getNum(col[3][i]); if ((A + B + nextBit) % n != C) return true; nextBit = (bool) ((A + B + nextBit) &gt;= n); &#125; return false; &#125; bool check3() &#123; // Other equation correction checking if (getNum(col[1][1]) + getNum(col[2][1]) &gt;= n) return true; // The first one needs to be carried for (int i = n; i &gt;= 1; --i) &#123; int A = getNum(col[1][i]); int B = getNum(col[2][i]); int C = getNum(col[3][i]); if (A == -1 || B == -1 || C == -1) continue; if ((A + B) % n != C &amp;&amp; (A + B + 1) % n != C) return true; &#125; return false; &#125;&#125;void DFS(int column = n, int line = 1, int nextBit = 0) &#123; // from right to left if (Checks::check3()) return; if (!Checks::check1()) &#123; if (!Checks::check2()) &#123; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; ' '; cout &lt;&lt; endl; exit(0); &#125; return; &#125; if (getNum(col[line][column]) == -1) &#123; // unfilled letter, fill it for (int i = n - 1; i &gt;= 0; --i) &#123; if (vis[i]) continue; if (line == 3) &#123; int A = getNum(col[1][column]); int B = getNum(col[2][column]); int C = A + B + nextBit; if (C % n != i) continue; vis[i] = true; giveNum(col[line][column], i); DFS(column - 1, 1, (bool) (C &gt;= n)); vis[i] = false; giveNum(col[line][column], -1); &#125; else &#123; vis[i] = true; giveNum(col[line][column], i); DFS(column, line + 1, nextBit); vis[i] = false; giveNum(col[line][column], -1); &#125; &#125; &#125; else &#123; // filled letter if (line != 3) DFS(column, line + 1, nextBit); else &#123; int A = getNum(col[1][column]); int B = getNum(col[2][column]); int C = A + B + nextBit; DFS(column - 1, 1, (bool) (C &gt;= n)); &#125; &#125;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n; cin &gt;&gt; ol[0]; cin &gt;&gt; ol[1]; cin &gt;&gt; ol[2]; Init(); memset(ans, -1, sizeof ans); DFS(); return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>NOIP</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 735D《Taxes》]]></title>
    <url>%2F2019-03-23%2FCF735D%2F</url>
    <content type="text"><![CDATA[这™什么破题 题面大概就是规定一个数的花费为它的最大真因子（除了本身以外的最大因数，如果这个数是质数，花费为1） 现在给你一个数 $n$，要求把它拆成几个数相加的形式（也可以不拆），使得拆完后每一个数的花费的和最小 输出这个最小的和 输入输出样例输入样例#114 输出样例#112 输入样例#2127 输出样例#213 解析别告诉我你脑子里装的都是暴力 我现在来说几个有趣的性质 说完这道题就做完了 哥德巴赫猜想（即任意大于2的偶数都可以被拆成两个质数的和） 对于任意大于5的非质奇数（即不是质数的奇数），都可以被拆成3和两个质数的和（哥德巴赫猜想的一个推论） 好 现在假设哥德巴赫猜想成立 请读者自行证明第二条 依据这两个性质，我们可以对这道题进行如下的分类讨论 当给定的为质数时，花费为1 当给定的为偶数时，根据哥德巴赫猜想可以拆成两个质数，花费为2 当给定的数-2为质数时，这个数可以拆成2和给定的数-2两个质数，花费为2 否则这个数可以拆成3和给定的数-3，因为给定的数是奇数，显然给定的数-3是偶数，可以拆成两个质数，花费为3 代码实现1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;int n;bool isPrime(int x) &#123; if (x &lt;= 1) return false; if (x == 2 || x == 3) return true; for (int i = 2; i * i &lt;= x; ++i) if (x % i == 0) return false; return true;&#125;int main() &#123; // 这什么破题啊 IMPROVE_IO(); cin &gt;&gt; n; if (isPrime(n)) cout &lt;&lt; 1 &lt;&lt; endl; else if ((n &amp; 1) == 0) cout &lt;&lt; 2 &lt;&lt; endl; // 根据哥德巴赫猜想，一个偶数可以被拆成两个质数 else if (isPrime(n - 2)) cout &lt;&lt; 2 &lt;&lt; endl; // 这个数字可以被拆成 2 和另一个质数的和 else cout &lt;&lt; 3 &lt;&lt; endl; // 这个数字可以被拆成 3 和另一个偶数的和，这个偶数又可以被拆成两个质数 return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>数学</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2922《[USACO08DEC]秘密消息Secret Message》]]></title>
    <url>%2F2019-03-23%2FLuogu-P2922%2F</url>
    <content type="text"><![CDATA[在 Trie 中储存两个信息 题目描述Bessie is leading the cows in an attempt to escape! To do this, the cows are sending secret binary messages to each other. Ever the clever counterspy, Farmer John has intercepted the first b_i (1 &lt;= b_i &lt;= 10,000) bits of each of M (1 &lt;= M &lt;= 50,000) of these secret binary messages. He has compiled a list of N (1 &lt;= N &lt;= 50,000) partial codewords that he thinks the cows are using. Sadly, he only knows the first c_j (1 &lt;= c_j &lt;= 10,000) bits of codeword j. For each codeword j, he wants to know how many of the intercepted messages match that codeword (i.e., for codeword j, how many times does a message and the codeword have the same initial bits). Your job is to compute this number. The total number of bits in the input (i.e., the sum of the b_i and the c_j) will not exceed 500,000. Memory Limit: 32MB POINTS: 270 贝茜正在领导奶牛们逃跑．为了联络，奶牛们互相发送秘密信息． 信息是二进制的，共有M(1≤M≤50000)条．反间谍能力很强的约翰已经部分拦截了这些信息，知道了第i条二进制信息的前bi(l《bi≤10000)位．他同时知道，奶牛使用N(1≤N≤50000)条密码．但是，他仅仅了解第J条密码的前cj(1≤cj≤10000)位． 对于每条密码J，他想知道有多少截得的信息能够和它匹配．也就是说，有多少信息和这条密码有着相同的前缀．当然，这个前缀长度必须等于密码和那条信息长度的较小者． 在输入文件中，位的总数（即∑Bi+∑Ci）不会超过500000. 输入输出格式输入格式 Line 1: Two integers: M and N Lines 2..M+1: Line i+1 describes intercepted code i with an integer b_i followed by b_i space-separated 0’s and 1’s Lines M+2..M+N+1: Line M+j+1 describes codeword j with an integer c_j followed by c_j space-separated 0’s and 1’s 输出格式 Lines 1..M: Line j: The number of messages that the jth codeword could match. 输入输出样例输入样例#1123456789104 5 3 0 1 0 1 1 3 1 0 0 3 1 1 0 1 0 1 1 2 0 1 5 0 1 0 0 1 2 1 1 输出样例#1123451 3 1 1 2 说明Four messages; five codewords. The intercepted messages start with 010, 1, 100, and 110. The possible codewords start with 0, 1, 01, 01001, and 11. 0 matches only 010: 1 match 1 matches 1, 100, and 110: 3 matches 01 matches only 010: 1 match 01001 matches 010: 1 match 11 matches 1 and 110: 2 matches 解题思路查询前缀的题很容易想到 Trie 维护两个信息 pass 和 lastspass 表示当前节点有多少条信息经过， lasts 表示有多少以当前节点结尾的信息（不一定没有相同的串） 插入就不说了，说说查询 查询的时候，记一下路径上lasts的和（也就是拿原信息去匹配查询信息） 首先对于每一条查询信息，都分两种情况 这条信息被完美的查询完了 这条信息查到一半断开了 对于第二种情况，什么都不用管，输出统计的lasts的和就行对于第一种情况，则需要减去查询信息的最后一个节点的lasts值，加上pass值再输出 为什么呢？ 这里建议画图理解 首先，如果查到一半断开了，那么答案就是用原信息去匹配查询信息的匹配数，也就是lasts的和 12345678比如下面的例子查询信息：rain_air_txdy原始信息：rainrain_airrain_air_tql（这个也是没法匹配的，后几个字符不同）那么匹配数就是2，即为答案 如果查询完了，那么说明存在能匹配查询信息的原信息，所以「用原信息去匹配查询信息的匹配数」还不够，要再加上「用查询信息去匹配原信息的匹配数」，也就是lasts的总和 + pass 有这么一种情况，就是原信息与查询信息相同，那么它在当前节点的lasts里面算了一次，在当前节点的pass又算了一次！所以要减去当前节点的lasts 1234567891011比如下面的例子查询信息：rain_air_txdy原始信息：rain_air_txdy_tqlrain_air_txdy答案是啥？2注意到y这里的 pass 是2，把两条信息都算上了但同时y这里的 lasts 也是1啊！！！这不就重了吗，所以要减去 lasts 我觉得我说的已经够通俗易懂了吧 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstring&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 500000 + 10;struct Trie &#123; struct Node &#123; int pass, lasts; int next[2 + 1]; Node() &#123; pass = lasts = 0; memset(next, 0, sizeof next); &#125; &#125; node[MAXN]; int cnt; Trie() &#123; cnt = 0; &#125; void SwitchTo(int &amp;now, bool data) &#123; if (node[now].next[data] == 0) &#123; node[now].next[data] = ++cnt; &#125; now = node[now].next[data]; &#125; bool switchTo(int &amp;now, bool data) &#123; if (node[now].next[data] == 0) return false; now = node[now].next[data]; return true; &#125;&#125; t;int m, n;int main() &#123; IMPROVE_IO(); cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= m; ++i) &#123; int f = 0, pos = 0; cin &gt;&gt; f; for (int j = 1; j &lt;= f; ++j) &#123; int nf = 0; cin &gt;&gt; nf; t.SwitchTo(pos, nf); ++t.node[pos].pass; &#125; ++t.node[pos].lasts; &#125; for (int i = 1; i &lt;= n; ++i) &#123; int f = 0, pos = 0, ans = 0; cin &gt;&gt; f; bool cont = true; for (int i = 1; i &lt;= f; ++i) &#123; int nf = 0; cin &gt;&gt; nf; if (cont &amp;&amp; t.switchTo(pos, nf)) &#123; ans += t.node[pos].lasts; &#125; else cont = false; &#125; if (cont) ans = ans - t.node[pos].lasts + t.node[pos].pass; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>USACO</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA1508《Equipment》]]></title>
    <url>%2F2019-03-23%2FUVA1508%2F</url>
    <content type="text"><![CDATA[ProjectDP - 33 状态压缩 + DFS 题面PDF 解题思路首先是这个玄学的数据范围（每个组只有5个元素）很容易让人想到状压 首先把 k &gt;= 5 的情况特判一下可以选择超过5个组那么显然选择最大的就行了 对于每一个组，枚举它的每一种状态对于这个状态，统计一下选择这个状态的总和（被选择了的数的和），与所有组里这个状态的总和取个 max 这样我们就获得了每一种状态总和的最大值对它进行一遍 DFS 这里说一个位运算技巧枚举子集 1for (int s0 = s; s0; s0 = s &amp; (s0 - 1)); s0 即为 s 的某一个子集 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//// 33.cpp// ProjectDP//// Created by HandwerSTD on 2019/3/9.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 10000 + 10 ;int qwq[5 + 5], grps[MAXN][5 + 5], dp[(1 &lt;&lt; 5) - 1 + 10] ;int n, k;int Search(int s, int sum) &#123; if (sum == 0) return 0; int tmp = 0 ; for (int s0 = s; s0; s0 = s &amp; (s0 - 1)) tmp = std::max(tmp, dp[s0] + Search ((s0 ^ s), sum - 1)); return tmp;&#125;int main() &#123; IMPROVE_IO(); int T = 0; cin &gt;&gt; T; while (T --&gt; 0) &#123; memset(qwq, 0, sizeof qwq); cin &gt;&gt; n &gt;&gt; k; for (int i = 1 ; i &lt;= n; ++i) for (int j = 0; j &lt; 5; ++j)&#123; cin &gt;&gt; grps[i][j]; qwq[j] = std::max(qwq[j], grps[i][j]) ; &#125; if (k &gt;= 5) &#123; int ans = 0; for (int i = 0 ; i &lt; 5 ; ++i) ans += qwq[i] ; cout &lt;&lt; ans &lt;&lt; endl; &#125; else &#123; memset(dp, 0, sizeof (dp)) ; for (int i = 1; i &lt;= n; ++i) &#123; for (int stat = 0; stat &lt;= (1 &lt;&lt; 5) - 1; ++stat) &#123; int tmp = 0; for (int sel = 0; sel &lt; 5; ++sel) &#123; if (stat &amp; (1 &lt;&lt; sel)) tmp += grps[i][sel]; &#125; dp[stat] = std::max(dp[stat], tmp); &#125; &#125; cout &lt;&lt; Search((1 &lt;&lt; 5) - 1, k) &lt;&lt; endl; &#125; &#125; return 0 ;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Android 自带的文件管理器打开文件]]></title>
    <url>%2F2019-03-19%2FAndroid-GetFilePathWithDocumentsProvider%2F</url>
    <content type="text"><![CDATA[Storage Access Framework 简介Android4.4中引入了Storage Access Framework存储访问框架，简称（SAF）。SAF为用户浏览手机中存储的内容提供了方便，这些内容不仅包括文档、图片，视频、音频、下载，而且还包括所有由特定ContentProvider（须具有约定的API）提供的内容。不管这些内容来自于哪里，不管是哪个应用调用浏览系统文件内容的命令，系统都会用一个统一的界面让你去浏览。 实现首先我们要传给它一个 Intent 1234Intent intent = new Intent(Intent.ACTION_GET_CONTENT);intent.setType("text/plain"); // 选择文件类型，我设置为了纯文本intent.addCategory(Intent.CATEGORY_OPENABLE);startActivityForResult(intent, 1); 然后回调 1234567@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (resultCode == RESULT_OK) &#123; Uri uri = data.getData(); String filePath = GetFilePath.getPath(this, uri); &#125;&#125; 这个时候的filePath存的就是文件的名称。可以尝试Log一下看看 这个时候看到了一个新的类GetFilePath，它是我复制手写的一个类，内部貌似是没有这个类的 看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import android.content.ContentUris;import android.content.Context;import android.database.Cursor;import android.net.Uri;import android.os.Build;import android.os.Environment;import android.provider.DocumentsContract;import android.provider.MediaStore;public class GetFilePath &#123; public static String getPath(final Context context, final Uri uri) &#123; final boolean isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT; // DocumentProvider if (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(context, uri)) &#123; // ExternalStorageProvider if (isExternalStorageDocument(uri)) &#123; final String docId = DocumentsContract.getDocumentId(uri); final String[] split = docId.split(":"); final String type = split[0]; if ("primary".equalsIgnoreCase(type)) &#123; return Environment.getExternalStorageDirectory() + "/" + split[1]; &#125; &#125; // DownloadsProvider else if (isDownloadsDocument(uri)) &#123; final String id = DocumentsContract.getDocumentId(uri); final Uri contentUri = ContentUris.withAppendedId( Uri.parse("content://downloads/public_downloads"), Long.valueOf(id)); return getDataColumn(context, contentUri, null, null); &#125; // MediaProvider else if (isMediaDocument(uri)) &#123; final String docId = DocumentsContract.getDocumentId(uri); final String[] split = docId.split(":"); final String type = split[0]; Uri contentUri = null; if ("image".equals(type)) &#123; contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; &#125; else if ("video".equals(type)) &#123; contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI; &#125; else if ("audio".equals(type)) &#123; contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI; &#125; final String selection = "_id=?"; final String[] selectionArgs = new String[]&#123;split[1]&#125;; return getDataColumn(context, contentUri, selection, selectionArgs); &#125; &#125; // MediaStore (and general) else if ("content".equalsIgnoreCase(uri.getScheme())) &#123; return getDataColumn(context, uri, null, null); &#125; // File else if ("file".equalsIgnoreCase(uri.getScheme())) &#123; return uri.getPath(); &#125; return null; &#125; /** * Get the value of the data column for this Uri. This is useful for * MediaStore Uris, and other file-based ContentProviders. * * @param context The context. * @param uri The Uri to query. * @param selection (Optional) Filter used in the query. * @param selectionArgs (Optional) Selection arguments used in the query. * @return The value of the _data column, which is typically a file path. */ public static String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123; Cursor cursor = null; final String column = "_data"; final String[] projection = &#123;column&#125;; try &#123; cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; final int column_index = cursor.getColumnIndexOrThrow(column); return cursor.getString(column_index); &#125; &#125; finally &#123; if (cursor != null) cursor.close(); &#125; return null; &#125; /** * @param uri The Uri to check. * @return Whether the Uri authority is ExternalStorageProvider. */ public static boolean isExternalStorageDocument(Uri uri) &#123; return "com.android.externalstorage.documents".equals(uri.getAuthority()); &#125; /** * @param uri The Uri to check. * @return Whether the Uri authority is DownloadsProvider. */ public static boolean isDownloadsDocument(Uri uri) &#123; return "com.android.providers.downloads.documents".equals(uri.getAuthority()); &#125; /** * @param uri The Uri to check. * @return Whether the Uri authority is MediaProvider. */ public static boolean isMediaDocument(Uri uri) &#123; return "com.android.providers.media.documents".equals(uri.getAuthority()); &#125;&#125; 参考链接Android Uri和文件路径互相转换 (转)Android调用系统自带的文件管理器进行文件选择并获得路径 android: startActivityForResult用法详解]]></content>
      <tags>
        <tag>Android 开发</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1868《饥饿的奶牛》]]></title>
    <url>%2F2019-03-09%2FLuogu-P1868%2F</url>
    <content type="text"><![CDATA[ProjectDP - 7 二分查找优化 DP 题目描述有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。 现用汉语翻译为： 有N个区间，每个区间x，y表示提供的x~y共y-x+1堆优质牧草。你可以选择任意区间但不能有重复的部分。 对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。 输入输出格式输入格式第一行，N，如题 接下来N行，每行一个数x，y，如题 输出格式一个数，最多能吃到的牧草堆数 输入输出样例输入样例#131 37 83 4 输出样例#15 说明1&lt;=n&lt;=150000 0&lt;=x&lt;=y&lt;=3000000 解题思路很容易想到设 $dp[i]$ 表示前 $i$ 个区间最多能选多少，转移从最优的 $j\ (j&lt;i)$ 中转移 时间复杂度 $O(n^2)$，过不去 第一维 $\forall i \in [1,n]$ 是雷打不动的，优化不了考虑从第二维下手 首先 $dp[]$ 数组是单调不降的很显然吧那么只需要选择最近的一个「区间无交集」的 $j$ 进行转移即可这个 $j$ 可以二分查找求得 如果找不到这个 $j$ 的话就从上一次转移过来即可 转移方程： $ dp[i] = \text{max}(dp[i-1],dp[j] \ \times\ (\text{j exists == true}) $$ + (\text{segment[i]’s left endpoint} - \text{segment[i]’s right endpoint} + 1)) $ 中间那个 $(\text{j exists == true})$ 是个布尔表达式，它的返回值为0或1 至此，时间复杂度被降为 $O(nlog_2n)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//// 7.cpp// ProjectDP//// Created by HandwerSTD on 2019/3/9.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;algorithm&gt;#include &lt;iostream&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 150000 + 10;struct Segment &#123; int l, r; Segment() &#123; l = r = 0; &#125; bool operator &lt; (const Segment &amp;that) const &#123; if (r == that.r) return l &lt; that.l; return r &lt; that.r; &#125;&#125; seg[MAXN];int n, dp[MAXN];int BinarySearch(int x) &#123; int l = 1, r = x, ans = -2147482333; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (seg[mid].r &lt; seg[x].l) &#123; l = mid + 1; ans = mid; &#125; else r = mid - 1; &#125; return ans;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; seg[i].l &gt;&gt; seg[i].r; &#125; std::sort(seg + 1, seg + 1 + n); for (int i = 1; i &lt;= n; ++i) &#123; int pre = BinarySearch(i); if (pre == -2147482333) dp[i] = std::max(dp[i - 1], seg[i].r - seg[i].l + 1); else dp[i] = std::max(dp[i - 1], dp[pre] + seg[i].r - seg[i].l + 1); &#125; cout &lt;&lt; dp[n] &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分查找</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2292《[HNOI2004]L语言》]]></title>
    <url>%2F2019-03-09%2FLuogu-P2292%2F</url>
    <content type="text"><![CDATA[Trie 的经典应用 题目描述标点符号的出现晚于文字的出现，所以以前的语言都是没有标点的。现在你要处理的就是一段没有标点的文章。 一段文章T是由若干小写字母构成。一个单词W也是由若干小写字母构成。一个字典D是若干个单词的集合。我们称一段文章T在某个字典D下是可以被理解的，是指如果文章T可以被分成若干部分，且每一个部分都是字典D中的单词。 例如字典D中包括单词{‘is’, ‘name’, ‘what’, ‘your’}，则文章‘whatisyourname’是在字典D下可以被理解的，因为它可以分成4个单词：‘what’, ‘is’, ‘your’, ‘name’，且每个单词都属于字典D，而文章‘whatisyouname’在字典D下不能被理解，但可以在字典D’=D+{‘you’}下被理解。这段文章的一个前缀‘whatis’，也可以在字典D下被理解，而且是在字典D下能够被理解的最长的前缀。 给定一个字典D，你的程序需要判断若干段文章在字典D下是否能够被理解。并给出其在字典D下能够被理解的最长前缀的位置。 输入输出格式输入格式输入文件第一行是两个正整数n和m，表示字典D中有n个单词，且有m段文章需要被处理。之后的n行每行描述一个单词，再之后的m行每行描述一段文章。 其中1&lt;=n, m&lt;=20，每个单词长度不超过10，每段文章长度不超过1M。 输出格式对于输入的每一段文章，你需要输出这段文章在字典D可以被理解的最长前缀的位置。 输入输出样例输入样例#1123456784 3 isnamewhatyourwhatisyournamewhatisyounamewhaisyourname 输出样例#112314 （整段文章’whatisyourname’都能被理解）6 （前缀’whatis’能够被理解）0 （没有任何前缀能够被理解） 解题思路这里选用 Trie 来做 首先把所有的单词扔进树里，记一下最长单词的长度 枚举字符串的右端点 $r \in [0, \text{The string’s length} - 1]$字符串的左端点 $l \in [max(r - \text{Max Length}, -1), r]$ 判断一下这个子串$s[l + 1, r]$在 Trie 里是不是一个完整的单词，是的话就把答案更新为 $r + 1$ 并退出枚举左端点的循环 判断单词是否完整只要对每个单词的结尾字母打个标记就行 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define TREE_ROOT 0using std::cin;using std::cout;using std::endl;const int MAXCHAR = 1024 * 1024 + 10;int maxlength;struct Trie&#123; // 日常封装 struct Node &#123; int size; int linkson[26 + 1]; // 直接用它来记子节点的位置，类似于链表 bool last; Node() &#123; size = 0; last = false; memset(linkson, 0, sizeof linkson); &#125; &#125; tree[MAXCHAR]; int cnt; Trie() &#123; cnt = 0; &#125; void Insert(const char *s, int length) &#123; // 插入 int pos = 0; // pos = root maxlength = std::max(maxlength, length); for (int i = 0; i &lt; length; ++i) &#123; int ins = s[i] - 'a'; if (tree[pos].linkson[ins] == 0) &#123; // insert tree[pos].linkson[ins] = ++cnt; ++tree[pos].size; &#125; pos = tree[pos].linkson[ins]; &#125; tree[pos].last = true; &#125; short Find(const char *s, int l, int r) &#123; int pos = 0; // pos = root for (int i = l; i &lt;= r; ++i) &#123; int que = s[i] - 'a'; if (tree[pos].linkson[que] == 0) return 0; pos = tree[pos].linkson[que]; // 这里也是和上边插入一模一样 &#125; return tree[pos].last; &#125;&#125; T;int n, m;bool dp[MAXCHAR];int main() &#123; IMPROVE_IO(); cin &gt;&gt; n &gt;&gt; m; std::string s; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; s; T.Insert(s.c_str(), (int) s.size()); &#125; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; s; memset(dp, 0, sizeof dp); int ans = 0; int len = (int) s.size(); for (int r = 0; r &lt; len; ++r) &#123; // 枚举右端点 for (int l = std::max(r - maxlength, -1); l &lt;= r; ++l) &#123; // 枚举左端点 if ((l == -1 || dp[l]) &amp;&amp; T.Find(s.c_str(), l + 1, r)) &#123; dp[r] = true; ans = r + 1; break; &#125; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>各省省选</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie 树学习笔记]]></title>
    <url>%2F2019-03-02%2FTrie%2F</url>
    <content type="text"><![CDATA[很简单的树形字符串结构 简介在计算机科学中，Trie，又称字典树、单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。 ——百度百科 简单地说，Trie 树就是以字符串的字母为结构建立起来的一棵多根树画出来大概是这样的 其中，这棵树有这些字符串 1234567AAKAKNAKOAKIACACE 操作都很简单。 插入操作给你一个字符串，要求把这个字符串插入到树中 首先指定树根为0，当前位置为树根枚举字符串的每个字符，看一下当前字符在当前深度有没有，有的话就直接把「当前位置」切换为这个字符所处的位置，没有的话就往里插入这个字符再切换 建议配合代码理解 查询操作这里以查询是否被查询过为例 对于每一个字符，记一下以它为结尾的字符串是否被查询过还是像插入一样切换当前位置，如果中间某一字符在那个深度没有，就直接返回字符串不存在切换到字符串最后一个字符之后，看一下刚才记的那个变量是否为真即可 也还是建议配合代码理解 例题这里以洛谷 P2580 于是他错误的点名开始了为例 题目大意就是给你一堆字符串和一堆询问对于每个询问，输出是否存在这个字符串如果存在，输出它有没有被询问过 解题思路本来这是一道std::map的模板题但是我们是来学 Trie 的那么当然要用 Trie 做啊（逃 代码实现也是上面那一题的代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 10000 + 10;struct Trie&#123; // 日常封装 struct Node &#123; int size; int linkson[26 + 1]; // 直接用它来记子节点的位置，类似于链表 bool rep; Node() &#123; size = 0; rep = false; memset(linkson, 0, sizeof linkson); &#125; &#125; tree[MAXN]; int cnt; Trie() &#123; cnt = 0; &#125; void Insert(const char *s, int length) &#123; // 插入 int pos = 0; // pos = root for (int i = 0; i &lt; length; ++i) &#123; int ins = s[i] - 'a'; if (tree[pos].linkson[ins] == 0) &#123; // insert tree[pos].linkson[ins] = ++cnt; ++tree[pos].size; &#125; pos = tree[pos].linkson[ins]; // 前面提到的切换位置 &#125; &#125; // 返回值就0, 1, 2，用不着 int short Find(const char *s, int length) &#123; int pos = 0; // pos = root for (int i = 0; i &lt; length; ++i) &#123; int que = s[i] - 'a'; if (tree[pos].linkson[que] == 0) return 2; // 没找到这个名字 pos = tree[pos].linkson[que]; // 这里也是和上边插入一模一样 &#125; if (tree[pos].rep) return 1; // 重复点名 tree[pos].rep = true; return 0; // 炉石传说真好玩（逃 &#125;&#125; T;int n, m;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; std::string s; cin &gt;&gt; s; T.Insert(s.c_str(), (int) s.size()); &#125; cin &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; std::string s; cin &gt;&gt; s; switch(T.Find(s.c_str(), (int) s.size())) &#123; case 0: &#123; printf("OK\n"); break; &#125; case 1: &#123; printf("REPEAT\n"); break; &#125; case 2: &#123; printf("WRONG\n"); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3067《[USACO12OPEN]平衡的奶牛群Balanced Cow Subsets》]]></title>
    <url>%2F2019-03-02%2FLuogu-P3067%2F</url>
    <content type="text"><![CDATA[Meet in the middle + 状态压缩 题目描述Farmer John’s owns N cows (2 &lt;= N &lt;= 20), where cow i produces M(i) units of milk each day (1 &lt;= M(i) &lt;= 100,000,000). FJ wants to streamline the process of milking his cows every day, so he installs a brand new milking machine in his barn. Unfortunately, the machine turns out to be far too sensitive: it only works properly if the cows on the left side of the barn have the exact same total milk output as the cows on the right side of the barn! Let us call a subset of cows “balanced” if it can be partitioned into two groups having equal milk output. Since only a balanced subset of cows can make the milking machine work, FJ wonders how many subsets of his N cows are balanced. Please help him compute this quantity. 给n个数，从中任意选出一些数，使这些数能分成和相等的两组。 求有多少种选数的方案。 输入输出格式输入格式： Line 1: The integer N. Lines 2..1+N: Line i+1 contains M(i). 输出格式： Line 1: The number of balanced subsets of cows. 输入输出样例输入样例#1123454 1 2 3 4 输出样例#113 说明There are 4 cows, with milk outputs 1, 2, 3, and 4. There are three balanced subsets: the subset {1,2,3}, which can be partitioned into {1,2} and {3}, the subset {1,3,4}, which can be partitioned into {1,3} and {4}, and the subset {1,2,3,4} which can be partitioned into {1,4} and {2,3}. 解题思路先看一眼数据范围 对于每一个数，有三种状态： 放在左边的集合里 放在右边的集合里 不选 好，一个 $O(3^n)$ 的算法就出来了但是过不去 考虑优化可用 Meet in the middle 进行优化 对两个区间 $[1, \frac{n}{2}]$ 和 $[\frac{n}{2} + 1, n]$ 分别搜索，时间复杂度降为 $O(3^{\frac{n}{2}})$ ，或者说 $O(\sqrt{(3^n)})$ 合并答案这部分我在学的时候也不大理解 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;map&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define _DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; " = " &lt;&lt; x &lt;&lt; std::endl;using std::cin;using std::cout;using std::endl;const int MAXN = 20 + 10;const int FIXED_N = 20 + 1;struct S &#123; int sum; int status; S() &#123; sum = status = 0; &#125;&#125; cca[(1 &lt;&lt; FIXED_N)], ccb[(1 &lt;&lt; FIXED_N)];int n, a[MAXN], cnta, cntb, ans;bool uniq[(1 &lt;&lt; FIXED_N)];void Read() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i];&#125;void Search(int l, int r, int sum, int stat, S cc[], int &amp;cnt) &#123; if (l &gt; r) &#123; cc[++cnt].sum = sum; cc[cnt].status = stat; return; &#125; Search(l + 1, r, sum, stat, cc, cnt); // don't choose Search(l + 1, r, sum - a[l], stat + (1 &lt;&lt; (l - 1)), cc, cnt); // put the cow to set1 Search(l + 1, r, sum + a[l], stat + (1 &lt;&lt; (l - 1)), cc, cnt); // put the cow to set2&#125;void mergeAnswer() &#123; // double-pointer int p1 = 1, p2 = 1; while (p1 &lt;= cnta &amp;&amp; p2 &lt;= cntb) &#123; while (-cca[p1].sum &lt; ccb[p2].sum &amp;&amp; p2 &lt;= cntb) ++p2; int originalp2 = p2; while (p2 &lt;= cntb &amp;&amp; -cca[p1].sum == ccb[p2].sum) &#123; if (uniq[cca[p1].status | ccb[p2].status] == false) &#123; uniq[cca[p1].status | ccb[p2].status] = true; ++ans; &#125; ++p2; &#125; if (p1 + 1 &lt;= cnta &amp;&amp; -cca[p1].sum == -cca[p1 + 1].sum) p2 = originalp2; ++p1; &#125;&#125;bool cmpa(S x, S y) &#123; return x.sum &lt; y.sum; &#125;bool cmpb(S x, S y) &#123; return x.sum &gt; y.sum; &#125;int main() &#123; IMPROVE_IO(); Read(); Search(1, n / 2, 0, 0, cca, cnta); Search(n / 2 + 1, n , 0, 0, ccb, cntb); std::sort(cca + 1, cca + 1 + cnta, cmpa); std::sort(ccb + 1, ccb + 1 + cntb, cmpb); mergeAnswer(); cout &lt;&lt; ans - 1 &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>USACO</tag>
        <tag>搜索</tag>
        <tag>Meet in the middle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4799《[CEOI2015 Day2]世界冰球锦标赛》]]></title>
    <url>%2F2019-03-02%2FLuogu-P4799%2F</url>
    <content type="text"><![CDATA[稍微简单的Meet in the middle题目 前言先来介绍一下「Meet in the middle」是个啥 顾名思义，Meet in the middle 就是「在中间相遇」，也就是对前一半状态和后一半状态分别进行搜索，最后合并两次搜索产生的答案 这样的搜索优化（我个人认为这是优化）可以把时间复杂度开一个二次根号 思想和实现都很简单，难度主要是在合并答案这一块，一般是利用单调性进行合并 题面题目描述译自 CEOI2015 Day2 T1「Ice Hockey World Championship」 今年的世界冰球锦标赛在捷克举行。Bobek 已经抵达布拉格，他不是任何团队的粉丝，也没有时间观念。他只是单纯的想去看几场比赛。如果他有足够的钱，他会去看所有的比赛。不幸的是，他的财产十分有限，他决定把所有财产都用来买门票。 给出 Bobek 的预算和每场比赛的票价，试求：如果总票价不超过预算，他有多少种观赛方案。如果存在以其中一种方案观看某场比赛而另一种方案不观看，则认为这两种方案不同。 输入输出格式输入格式第一行，两个正整数 $N$ 和 $M(1 \leq N \leq 40,1 \leq M \leq 10^{18})$，表示比赛的个数和 Bobek 那家徒四壁的财产。 第二行，$N$ 个以空格分隔的正整数，均不超过 $10^{16}$，代表每场比赛门票的价格。 输出格式输出一行，表示方案的个数。由于 $N$ 十分大，注意：答案 $\le 2^{40}$。 输入输出样例输入样例#1125 1000100 1500 500 500 1000 输出样例#118 说明样例解释八种方案分别是： 一场都不看，溜了溜了 价格 100 的比赛 第一场价格 500 的比赛 第二场价格 500 的比赛 价格 100 的比赛和第一场价格 500 的比赛 价格 100 的比赛和第二场价格 500 的比赛 两场价格 500 的比赛 价格 1000 的比赛 解题思路一个很显然的思路就是暴力搜索枚举所有的状态最高要搜索 $2^{40}$ 次 这时候 Meet in the middle 就上场了。我们把整个区间分成 $[1, \frac{n}{2}]$ 和 $[\frac{n}{2} + 1, n]$对这两个区间进行分别搜索，得到两个区间可选的所有方案，分别存在两个数组 $f[i]$ 和 $b[i]$ 中 如何合并答案？ 首先你需要知道 upper_bound() upper_bound()返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个大于value的值 通俗的讲，upper_bound()函数就是用来求第一个大于val的值的下标，内部使用二分查找实现那排序肯定是没跑了（但是只需要对一个序列排序）（当然如果你两个序列都排序的话也没事，upper_bound()这里只用来查找一个序列） 枚举未排序序列的每一个元素（这里记为 $f[i]$，另一个序列中的元素记为 $b[i]$），显然 $m - f[i]$ 为「选择当前方案后剩下的钱数」，记为 $fafa$对另一个序列 $b[i]$ 进行 upper_bound() 查找，找到第一个大于等于它的数的下标（这个数即为在另一个区间搜出来的「当前方案的花费」）又因为这个区间是有序的，那么显然 upper_bound() 出来的下标之前的所有方案都是可选的（所有在它之前的方案花费都是小于等于 $fafa$ 的，自然是可选的），更新一下答案即可 写成代码是这样的： 123456std::sort(b + 1, b + 1 + cntb);for (int i = 1; i &lt;= cnta; ++i) &#123; long long int ext = m - f[i]; // 对应之前的 fafa ans += ((std::upper_bound(b + 1, b + 1 + cntb, ext) - b) - 1);&#125; 至此这道题就做完了。还有一个小的细节：三年 OI 一场空，不开 long long 见祖宗 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;algorithm&gt;#include &lt;iostream&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 40 + 10;const int FIXED_MAX = 20 + 1;long long int suma[(1 &lt;&lt; FIXED_MAX) + 10], sumb[(1 &lt;&lt; FIXED_MAX) + 10], cnta, cntb;long long int seq[MAXN];long long int n, m;void Search(int l, int r, long long int sum, long long int *a, long long int &amp;cnt) &#123; if (sum &gt; m) return; if (l &gt; r) &#123; a[++cnt] = sum; return; &#125; Search(l + 1, r, sum, a, cnt); // don't choose Search(l + 1, r, sum + seq[l], a, cnt);&#125;long long int mergeAnswer() &#123; long long int ret = 0ll; std::sort(sumb + 1, sumb + 1 + cntb); for (int i = 1; i &lt;= cnta; ++i) &#123; ret += (std::upper_bound(sumb + 1, sumb + 1 + cntb, m - suma[i]) - sumb) - 1; // m - suma[i]: the money left when I choose suma[i] &#125; return ret;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; seq[i]; &#125; int mid = (int) n &gt;&gt; 1; Search(1, mid, 0ll, suma, cnta); Search(mid + 1, (int) n, 0ll, sumb, cntb); cout &lt;&lt; mergeAnswer() &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
        <tag>Meet in the middle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「文章」百名学生参训 礼堂“变身”教室]]></title>
    <url>%2F2019-02-16%2FSDWC-Article%2F</url>
    <content type="text"><![CDATA[本文纯属胡扯请勿当真 正&lt;/big&gt;月初八，年味儿正浓。但是，不少全国各地的中学生却来到了泰安。他们不是利用假期前来观光旅游的，而是进城参加竞赛培训。记者暗访发现，某未经教育部批准的机构培训机构打着“竞赛培训”“自主招生”的旗号，开设冬令营，面向全国各地中学招生。这个机构组织学生进行竞赛辅导、模拟考试。七天的培训，学费竟然高达3000元左右。 记者了解到，不少高一、高二甚至初中学生参加这样的冬令营，目的是希望能够获得各类学科竞赛的奖项，从而在高校自主招生、保送生选拔录取中占得先机。为此，记者向多所“双一流”高校招生负责人求证，得到的一致答复是，获得自主招生认定与是否参加过竞赛培训没有任何关系，学生申请自主招生可以通过各种材料证明自己的特长，竞赛获奖证书只是其中很小一部分，并且自主招生最终认定结果，必须经由申请高校考核后确定。 四名学生一个宿舍 教学、食宿均安排在学校之内 正月初八，一辆又一辆大巴车开进泰安一中。一批批满脸稚气的中学生，拉着行李走进学校。工作人员协助学生们办理报到、入住、领取餐券等手续。不少学生家长陪同前来，但是，办完手续后，家长被告知“可以离开了”。工作人员的解释是，这里是封闭式管理，谢绝家长陪住。 此时，这所学校已经摇身变成一家培训教育机构寒假冬令营的营区。工作人员介绍，营区主要开设普通班、高级班两个班级，其中，普通班有学生200人，高级班有学生240人左右。这意味着来自全国各地的百余名学生参加这家机构的培训。 据介绍，营区的教学、食宿均安排在学校之内。每名学生的学费为2400元，另外不需缴纳食宿费。“四名学生一个宿舍。”工作人员说。 学校工作人员告诉记者，培训机构几乎包下了所有的宿舍房间。 从早八点半学到晚九点 后排学生只能看“现场直播” 培训课程已开课几天。营区占用一间大礼堂作为教室，学生们被分成了多个座位区，对应一个投影幕布。因为“教室”里的学生太多，在最后一排已经几乎看不见老师，只能通过听声音、看课件来听老师讲题。到下午4点，后方座位区已经有学生难以专注听课，趴到了桌子上。 记者探访营区，感受到了学生们高强度的学习节奏。现场公布的一份营地作息时间表显示，学生们每天的起床时间为6点至7点，之后有40分钟的早餐时间。8点开始上课，一直到11点半。中午学生有两小时左右的中餐和午休时间，之后又是3个半小时的课程。 入夜后，学生们也不能歇着。记者在营区看到，晚上6点刚过，吃过晚餐的学生陆陆续续回到机房开始自习。工作人员透露，晚上6点到9点是学生的答疑、考试和讲评时间。晚上10点查寝，11点熄灯。 拼竞赛争取进名校 任课教师多是竞赛金牌选手 小王是华北地区一所中学的初二学生。这次，他是由学校老师带队，与同学们一起参加竞赛的培训。小王很明确地告诉记者，上辅导班就是为了拼竞赛，获得进名校的“敲门砖”。“如果能在省赛区拿到一等奖，那么，申请211、985院校自主招生的通过概率就很大。全国学科竞赛夺金牌进国家集训队，就可以直接保送了。” 小王坦言，在老家学校里，大家主要的任务都在应对高考。老师讲课、考试都是围绕高考进行，竞赛生“吃不饱”。因为没有专门的竞赛指导老师，训练主要是靠从网上找习题。“来这里学，确实收获很大，这边老师讲的好几个知识点，一下子打通了我之前一年的困惑。” 培训机构市场部的一位工作人员告诉记者，如果只凭高中课堂学习的知识积累，去拼名校的自主招生，没有多大意义。因此，必须走一轮竞赛，材料才过硬。他透露，竞赛培训的主讲老师大部分是当年竞赛的金牌选手，培训中会有竞赛例题的讲解，还有模拟竞赛考试，学生可以充分熟悉考试的流程。 多所高校招办答复 自招认定与竞赛培训无关 今年1月，教育部印发了《关于做好2019年高校自主招生工作的通知》，从招生政策、招生程序、加强监管等方面提出规范高校自主招生的“十严格”要求。“十严格”中明确高校不得简单以论文、专利、中介机构举办的竞赛活动等作为报考条件和初审通过依据。此外，要严格审核申请材料，高校成立专门自主招生审核专家组，采用多名专家“背靠背”分别独立审核、复核等方式，对考生提交的证明材料进行全覆盖核查。 昨晚，本市多所“双一流”高校的招办负责人向记者表示，绝大多数考生最终能否获得自主招生的认定，与是否参加过竞赛、拿过奖没有必然联系，与竞赛培训更是无关。“我们严格遵守教育部相关规定，学生申请自主招生可以根据自己的兴趣和特长提交相关材料，竞赛成绩只是其中很小一部分。此外学生通过材料初审后，也必须要参加学校组织的自主招生初试和复试，通过并完成公示后才能获得认定。这些流程都与校外培训机构无关，希望学生能展现真实的才华。”一所“双一流”大学招办主任说道。 来源：泰安Fa♂︎报供图：abc1763613206]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>记录</tag>
        <tag>OI相关</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1122《最大子树和》]]></title>
    <url>%2F2019-02-16%2FLuogu-P1122%2F</url>
    <content type="text"><![CDATA[ProjectDP - 35 最简单的树形DP问题 题目描述小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题： 一株奇怪的花卉，上面共连有N N朵花，共有N-1N−1条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。 老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。 输入输出格式输入格式第一行一个整数N(1 ≤ N ≤ 16000)。表示原始的那株花卉上共N朵花。 第二行有N个整数，第I个整数表示第I朵花的美丽指数。 接下来N-1行每行两个整数a,b，表示存在一条连接第a朵花和第b朵花的枝条。 输出格式一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过2147483647。 输入输出样例输入样例#1123456787-1 -1 -1 1 1 1 01 42 53 64 75 76 7 输出样例#1：13 说明【数据规模与约定】 对于60%的数据，有N≤1000； 对于100%的数据，有N≤16000。 解题思路只需要一维 设 $f[i]$ 表示以 $i$ 为根的子树的最大值 初始化：$f[i]$ 为结点 $i$ 的权值 转移： f[u] = f[u] + max(f[v], 0)其中 $v$ 是 $u$ 的儿子 答案：$f$ 数组的最大值 简单吧！ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// 35.cpp// ProjectDP//// Created by HandwerSTD on 2019/2/16.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;vector&gt;using std::cin;using std::cout;using std::endl;const int MAXN = 100000 + 10;std::vector&lt;int&gt; head[MAXN];int flower[MAXN], dp[MAXN], n, id[MAXN], ans;/* * * dp[u] += std::max(0, dp[v]); * */void DFS(int u, int fa) &#123; dp[u] = flower[u]; for (std::vector&lt;int&gt;::iterator it = head[u].begin(); it != head[u].end(); it++) &#123; if ((*it) == fa) continue; DFS((*it), u); dp[u] += std::max(0, dp[(*it)]); &#125; ans = std::max(ans, dp[u]);&#125;int main(int argc, const char * argv[]) &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; flower[i]; for (int i = 1; i &lt;= n - 1; ++i) &#123; int prev = 0, next = 0; cin &gt;&gt; prev &gt;&gt; next; if (prev &gt; next) std::swap(prev, next); head[prev].push_back(next); head[next].push_back(prev); ++id[next]; &#125; int root = 0; for (root = 1; root &lt;= n; ++root) if (id[root] == 0) break; DFS(root, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
        <tag>ProjectDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST算法学习笔记]]></title>
    <url>%2F2019-02-15%2FRMQ-SparseTable%2F</url>
    <content type="text"><![CDATA[$O(1)$查询区间最值 算法简介RMQ (Range Minimum/Maximum Query)问题是指：对于长度为n的数列A，回答若干询问RMQ(A,i,j)(i,j&lt;=n)，返回数列A中下标在i,j里的最小(大）值，也就是说，RMQ问题是指求区间最值的问题。 ——百度百科 ST（Sparse Table，稀疏表）算法是求解RMQ问题的经典在线算法，以O(nlogn)时间预处理，然后在O(1)时间内回答每个查询。 算法流程ST算法实际上采用了DP的思想 初始化定义 $F(i,j)$ 表示区间 $[i, i + 2^j - 1]$ 内的最小值，$P[i]$ 为原序列 那么显然 F(i,0) = P[i]状态转移方程？ 首先，任意一个区间的最小值等于 $min($这个区间前一半的最小值$,$ 这个区间后一半点最小值$)$这个很好理解吧把$F(\ )$结合进去，就是 F(i,j) = min(F(i,j-1),F(i + 2^{j-1}, j - 1)) 还有什么细节？上面的式子看的你很想递归是吧（反正我是）如果你不想递归的话，你八成会： 123for (int i = 1; ...) for (int j = 1; ...) F[i][j] = ... 其实……这样都是错的，这样会导致有几个状态被过早地枚举 我们要把枚举 $j$ 的循环放在外层，至于为什么……你模拟&lt;/small&gt;一下就行了 查询此处的内容可能有点难以理解，请消化不了的同学多看几遍 上面说了查询是 $O(1)$ 的听起来就好简单啊 实现确实是很简单，但是原理就……也是很简单 首先给你一个定理：对于任意 $x \in \mathbb{N^*}$ ，都有 $ 2^{\lfloor log_2(x) \rfloor} &gt; \lfloor \frac{x}{2} \rfloor $ 然后令查询区间$[l,r]$的长度 $\text{len} = r - (l - 1),\ \text{ll} = log_2(\text{len})$那么根据上边可得 $ 2^{\text{ll}} &gt; \lfloor \frac{len}{2} \rfloor $这意味着什么？这意味着查询的区间有重叠！不过这并不能意味啥，重叠又怎么样，只是查询的区间变了 1234567891011原来我们查询区间，都是查询这个区间的一半比如更新[l,r]之间的最小值就是f[l][r] = std::min(f[l][mid], f[mid + 1][r]);但是这次不一样，这次的mid超过了区间的一半那就可以这么写：int Query(int l, int r) &#123; int k = std::log(r - (l - 1)) / std::log(2); return std::min(f[l][k], f[r - ((1 &lt;&lt; k) -1)][k]);&#125; 是 $O(1)$ 的吧 它查询的区间相当于是这样的：（画的不准确，仅供参考） 12345_ _ _ _ _ _ _ _ _ -------==== f[l][k] ====------ f[r - ((1 &lt;&lt; k) - 1)][k] 等号就是两个查询区间的并集 这也就是它为什么不能查询区间和的原因前缀和足够了 伪代码⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ \text{Algorithm 1: Sparse Table} $⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ \text{Init(The Sparse Table } f, \text{The original sequence } a, \text{no return value})$&nbsp;&nbsp;$ 1. \text{For } i \text{ from 1 to n do}$&nbsp;&nbsp;$ 2. \ \ \ \ f[i][0] = a[i] $&nbsp;&nbsp;$ 3. \text{End For} $&nbsp;&nbsp;$ 4. \ j \leftarrow 1, i \leftarrow 1$&nbsp;&nbsp;$ 5. \text{While } 2^j \leq n \text{ do} $&nbsp;&nbsp;$ 6. \ \ \ \ \text{While } i + 2^j - 1 \leq n \text{ do} $&nbsp;&nbsp;$ 7. \ \ \ \ \ \ \ \ f[i][j] = min(f[i][j-1], f[i + 2^{j-1}][j-1]) $&nbsp;&nbsp;$ 8. \ \ \ \ \ \ \ \ i \leftarrow i + 1 $&nbsp;&nbsp;$ 9. \ \ \ \ \text{End While}$$ 10. \ \ \ \ j \leftarrow j + 1 $$ 11. \text{End While} $ $ \text{Query(}l,r\text{,return a value x}) $$ 1. k \leftarrow log_2(r - l + 1)$$ 2. \text{return } x = min(f[l][k], f[r - (2^k - 1)][k]$⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445// luogu-judger-enable-o2#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = (100000 + 10) * 2;const int MAXLOG = 17 + 10; // floor(log2(100000 + 10))int n, q;int Table[MAXN][MAXLOG];void BuildTable() &#123; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; Table[i][j] = std::max(Table[i][j-1], Table[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int Query(int l, int r) &#123; int k = std::log(r - (l - 1)) / std::log(2); return std::max(Table[l][k], Table[r - ((1 &lt;&lt; k) - 1)][k]);&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf("%d", &amp;Table[i][0]); // 这里可以省去seq[i]，对Table[i][0]进行直接写入 BuildTable(); for (int i = 1; i &lt;= q; ++i) &#123; int l = 0, r = 0; scanf("%d %d", &amp;l, &amp;r); printf("%d\n", Query(l, r)); &#125; return 0;&#125; 例题洛谷P3865【模板】ST表]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>算法</tag>
        <tag>ST表</tag>
        <tag>RMQ问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2504《[HAOI2006]聪明的猴子》]]></title>
    <url>%2F2019-02-14%2FLuogu-P2504%2F</url>
    <content type="text"><![CDATA[最小生成树板子题 题目描述在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。 现在，在这个地区露出水面的有N棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。 在这个地区住着的猴子有M个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。 【问题】现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。 输入输出格式输入格式输入文件monkey.in包括： 第1行为一个整数，表示猴子的个数M(2&lt;=M&lt;=500)； 第2行为M个整数，依次表示猴子的最大跳跃距离（每个整数值在1—1000之间）； 第3行为一个整数表示树的总棵数N(2&lt;=N&lt;=1000)； 第4行至第N+3行为N棵树的坐标（横纵坐标均为整数，范围为：-1000—1000）。 （同一行的整数间用空格分开） 输出格式输出文件monkey.out包括一个整数，表示可以在这个地区的所有树冠上觅食的猴子数。 输入输出样例输入样例#11234567894 1 2 3 460 01 01 2-1 -1-2 02 2 输出样例#113 说明【数据规模】 对于40%的数据，保证有2&lt;=N &lt;=100，1&lt;=M&lt;=100 对于全部的数据，保证有2&lt;=N &lt;= 1000，1&lt;=M=500 感谢@charlie003 修正数据 解题思路先构造完全图（边数为初二数学内容），再跑一遍最小生成树 之后枚举每一个猴子，判断它的跳跃距离是否大于等于生成树的最大边权即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 1000 + 10;const int MAXM = 500 + 10;const int MAXE = (MAXN - 1) * MAXN / 2 + 10;struct Node &#123; int x, y; Node() &#123; x = y = 0; &#125;&#125; node[MAXN];struct Edge &#123; int previd, nextid; double weight; Edge() &#123; previd = nextid = 0; weight = 0; &#125; bool operator &lt; (const Edge &amp;that) const &#123; return weight &lt; that.weight; &#125;&#125; edge[MAXE];struct UnionFind &#123; int seq[MAXN]; UnionFind() &#123; memset(seq, 0, sizeof seq); &#125; int Find(int x) &#123; return !seq[x] ? x : (seq[x] = Find(seq[x])); &#125; bool Union(int x, int y) &#123; x = Find(x); y = Find(y); if (x == y) return false; seq[x] = y; return true; &#125;&#125; U;double GetDist(int idx, int idy) &#123; double ret = 0; int absx = std::abs(node[idx].x - node[idy].x); int absy = std::abs(node[idx].y - node[idy].y); ret = sqrt(absx * absx + absy * absy); return ret;&#125;int n, m, cnt;int monkey[MAXM];double Kruskal() &#123; std::sort(edge + 1, edge + 1 + cnt); int tot = 0; double maxWeight = 0; for (int i = 1; i &lt;= cnt; ++i) &#123; if (U.Union(edge[i].previd, edge[i].nextid)) &#123; ++tot; maxWeight = std::max(maxWeight, edge[i].weight); &#125; if (tot == n - 1) break; &#125; return maxWeight;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; monkey[i]; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; node[i].x &gt;&gt; node[i].y; // initialize edges for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; edge[++cnt].previd = i; edge[cnt].nextid = j; edge[cnt].weight = GetDist(i, j); &#125; &#125; double maxW = Kruskal(); int ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (monkey[i] &gt;= maxW) ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>生成树</tag>
        <tag>最小生成树</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3243《[HNOI2015]菜肴制作》]]></title>
    <url>%2F2019-02-14%2FLuogu-P3243%2F</url>
    <content type="text"><![CDATA[反向建图 + 反向输出 题目描述知名美食家小 A被邀请至ATM 大酒店，为其品评菜肴。 ATM 酒店为小 A 准备了 N 道菜肴，酒店按照为菜肴预估的质量从高到低给予1到N的顺序编号，预估质量最高的菜肴编号为1。 由于菜肴之间口味搭配的问题，某些菜肴必须在另一些菜肴之前制作，具体的，一共有 M 条形如”i 号菜肴’必须’先于 j 号菜肴制作“的限制，我们将这样的限制简写为。 现在，酒店希望能求出一个最优的菜肴的制作顺序，使得小 A能尽量先吃到质量高的菜肴： 也就是说， (1)在满足所有限制的前提下，1 号菜肴”尽量“优先制作； (2)在满足所有限制，1号菜肴”尽量“优先制作的前提下，2号菜肴”尽量“优先制作； (3)在满足所有限制，1号和2号菜肴”尽量“优先的前提下，3号菜肴”尽量“优先制作 ；(4)在满足所有限制，1 号和 2 号和 3 号菜肴”尽量“优先的前提下，4 号菜肴”尽量“优先制作； (5)以此类推。 例1：共4 道菜肴，两条限制、，那么制作顺序是 3,4,1,2。 例2：共5道菜肴，两条限制、 ，那么制作顺序是 1,5,2,4,3。 例1里，首先考虑 1，因为有限制和，所以只有制作完 3 和 4 后才能制作 1，而根据(3)，3 号又应”尽量“比 4 号优先，所以当前可确定前三道菜的制作顺序是 3,4,1；接下来考虑2，确定最终的制作顺序是 3,4,1,2。 例 2里，首先制作 1是不违背限制的；接下来考虑 2 时有的限制，所以接下来先制作 5 再制作 2；接下来考虑 3 时有的限制，所以接下来先制作 4再制作 3，从而最终的顺序是 1,5,2,4,3。 现在你需要求出这个最优的菜肴制作顺序。无解输出”Impossible!“ （不含引号，首字母大写，其余字母小写） 输入输出格式输入格式第一行是一个正整数D，表示数据组数。 接下来是D组数据。 对于每组数据： 第一行两个用空格分开的正整数N和M，分别表示菜肴数目和制作顺序限制的条目数。 接下来M行，每行两个正整数x,y，表示”x号菜肴必须先于y号菜肴制作“的限制。（注意：M条限制中可能存在完全相同的限制） 输出格式输出文件仅包含 D 行，每行 N 个整数，表示最优的菜肴制作顺序，或者“Impossible!“表示无解（不含引号）。 输入输出样例输入样例#11234567891011121335 45 45 34 23 23 31 22 33 15 25 24 3 输出样例#11231 5 3 4 2 Impossible! 1 5 2 4 3 说明【样例解释】 第二组数据同时要求菜肴1先于菜肴2制作，菜肴2先于菜肴3制作，菜肴3先于 菜肴1制作，而这是无论如何也不可能满足的，从而导致无解。 100%的数据满足N,M&lt;=100000,D&lt;=3。 解题思路题目要求「“尽量”优先」那么跑字典序最小拓扑肯定是不行的 那么……考虑反向建图。反向建图跑字典序最大拓扑，这时的拓扑序是「一直选择大的，不行再选择小的」，那么反向输出即可 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXNM = 100000 + 10;std::stack&lt;int&gt; rtop;std::vector&lt;int&gt; rhead[MAXNM];int id[MAXNM], n, m;void Topsort() &#123; std::priority_queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) &#123; if (!id[i]) &#123; q.push(i); &#125; &#125; while (!q.empty()) &#123; int u = q.top(); q.pop(); rtop.push(u); int siz = (int) rhead[u].size(); for (int i = 0; i &lt; siz; ++i) &#123; int v = rhead[u][i]; --id[v]; if (id[v]) continue; q.push(v); &#125; &#125;&#125;void Solve() &#123; memset(id, 0, sizeof id); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; int prev = 0, next = 0; cin &gt;&gt; next &gt;&gt; prev; // reverse rhead[prev].push_back(next); ++id[next]; &#125; Topsort(); for (int i = 1; i &lt;= n; ++i) &#123; rhead[i].clear(); &#125; if (rtop.size() &lt; n) &#123; cout &lt;&lt; "Impossible!" &lt;&lt; endl; while (!rtop.empty()) rtop.pop(); return; &#125; while (!rtop.empty()) &#123; cout &lt;&lt; rtop.top() &lt;&lt; ' '; rtop.pop(); &#125; cout &lt;&lt; endl;&#125;int main() &#123; IMPROVE_IO(); int T = 0; cin &gt;&gt; T; while (T --&gt; 0) &#123; Solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>拓扑序</tag>
        <tag>图论</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4047《[JSOI2010]部落划分》]]></title>
    <url>%2F2019-02-14%2FLuogu-P4047%2F</url>
    <content type="text"><![CDATA[最小生成树后删边 题目描述聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。 不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了N个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了K个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法： 对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。 例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。 输入输出格式输入格式输入文件第一行包含两个整数N和K(1&lt;=N&lt;=1000,1&lt;K&lt;=N)，分别代表了野人居住点的数量和部落的数量。 接下来N行，每行包含两个正整数x,y，描述了一个居住点的坐标(0&lt;=x, y&lt;=10000)。 输出格式输出一行，为最优划分时，最近的两个部落的距离，精确到小数点后两位。 输入输出样例输入样例#1123454 20 00 11 11 0 输出样例#111.00 输入样例#2123456789109 32 22 33 23 33 53 64 66 26 3 输出样例#212.00 解题思路我们首先对这几个点构建一个完全图 边数的计算属于初中数学内容（$\frac{n(n-1)}{2}$） 然后对这个图跑一遍最小生成树 删去生成树中最大的 $k-1$ 条边，这时候整个图就变成了 $k$ 个联通块，即为题目要求的部落 输出删去边的最小边权即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 1000 + 10;const int MAXM = (MAXN * (MAXN - 1)) / 2 + 10;struct Node &#123; int x, y; Node() &#123; x = y = 0; &#125;&#125; node[MAXN];struct Edge &#123; int prev; int next; double weight; Edge() &#123; prev = next = 0; weight = 0; &#125; bool operator &lt; (const Edge &amp;that) const &#123; return weight &lt; that.weight; &#125;&#125; edge[MAXM];struct UnionFind &#123; int seq[MAXN]; UnionFind() &#123; memset(seq, 0, sizeof seq); &#125; int Find(int x) &#123; return !seq[x] ? x : (seq[x] = Find(seq[x])); &#125; bool Union(int x, int y) &#123; x = Find(x); y = Find(y); if (x == y) return false; seq[x] = y; return true; &#125;&#125; U;int n, k, cnt;double GetPath(Node x, Node y) &#123; double ret = 0; int X = std::abs(x.x - y.x); int Y = std::abs(x.y - y.y); ret = sqrt(X * X + Y * Y); // 勾股定理，初中数学 return ret;&#125;void Solve() &#123; std::sort(edge + 1, edge + 1 + cnt); int tot = 0; for (int i = 1; i &lt;= cnt; ++i) &#123; bool routput = false; if (tot == n - k) routput = true; // 这里用了一个小技巧，加到 (n - k + 1) 条边的时候就可以输出， // 而不用到最后删边，因为边权是经过排序的 if (U.Union(edge[i].prev, edge[i].next)) &#123; ++tot; if (routput) &#123; cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; edge[i].weight &lt;&lt; endl; return; &#125; &#125; &#125;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; node[i].x &gt;&gt; node[i].y; &#125; // 构造完全图 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; edge[++cnt].prev = i; edge[cnt].next = j; edge[cnt].weight = GetPath(node[i], node[j]); &#125; &#125; Solve(); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1108《低价购买》]]></title>
    <url>%2F2019-02-14%2FLuogu-P1108%2F</url>
    <content type="text"><![CDATA[最长下降子序列套一个玄学计数 题目描述“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价($2^{16}$范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。 这里是某支股票的价格清单： 日期 1,2,3,4,5,6,7,8,9,10,11,12价格 68,69,54,64,68,64,70,67,78,62,98,87最优秀的投资者可以购买最多44次股票，可行方案中的一种是： 日期 2,5,6,10价格 69,68,64,62 输入输出格式输入格式第1行: N(1≤N≤5000)，股票发行天数 第2行: N个数，是每天的股票价格。 输出格式两个数:最大购买次数和拥有最大购买次数的方案数( $\le 2^{31}$ )当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这22种方案被认为是相同的。 输入输出样例输入样例121268 69 54 64 68 64 70 67 78 62 98 87 输出样例14 2 解题思路首先第一问肯定谁都会求跑一遍最长下降子序列算完 关键是第二问 令 $ dp[i] $ 表示以 $i$ 结尾的最长下降子序列的长度，$cdp[i]$ 表示以 $i$ 结尾的最长下降子序列的个数规定 $s[\ ]$ 为「原序列」 那么就有 当 $dp[i] = dp[j]$ 且 $s[i] = s[j]$ 时，就直接把 $cdp[j]$ 记为 $0$，防止重复计数 当 $dp[i] = dp[j] + 1$ 且 $s[i] &lt; s[j]$ 时，说明数列能接上了，$cdp[i] = cdp[i] + cdp[j]$ 最后答案输出 \sum_{i = 1}^{n} cdp[i] \ (dp[i] = \text{The max value of array } dp[i] )即可 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 5000 + 10;int n, a[MAXN], dp[MAXN], cdp[MAXN], maxLen;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; if (a[i] &lt; a[j]) dp[i] = std::max(dp[i], dp[j] + 1); &#125; if (dp[i] == 0) dp[i] = 1; maxLen = std::max(maxLen, dp[i]); for (int j = 1; j &lt; i; ++j) &#123; if (dp[i] == dp[j] &amp;&amp; a[i] == a[j]) cdp[j] = 0; else if (dp[i] == dp[j] + 1 &amp;&amp; a[i] &lt; a[j]) cdp[i] += cdp[j]; &#125; if (cdp[i] == 0) cdp[i] = 1; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (dp[i] == maxLen) ans += cdp[i]; &#125; cout &lt;&lt; maxLen &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>「序列」DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1896《[SCOI2005]互不侵犯》]]></title>
    <url>%2F2019-02-14%2FLuogu-P1896%2F</url>
    <content type="text"><![CDATA[ProjectDP - 27 最基础的状压DP 题目描述在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。 注：数据有加强（2018/4/25） 输入输出格式输入格式只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N） 输出格式所得的方案数 输入输出样例输入样例13 2 输出样例116 解题思路考虑状压DP 我们设 $ dp[i][j][k] $ 表示第 $i$ 行的状态的编号为 $j$，放了 $k$ 个国王 转移方程显然 dp[i][j][pct(stat[j]) + l] = dp[i][j][pct(stat[j]) + l] + dp[i-1][k][l]其中 $pct(x)$ 表示 $x$ 的二进制1的个数 边界条件： dp[1][nowStat][pct(nowStat)] = 1其中 $nowStat$ 表示当前枚举到的合法的状态 剩下的……就没啥好说的了（ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define IMPIO() std::ios::sync_with_stdio(false);#define FILE_IN(__file) freopen(__file, 'r', stdin);#define FILE_OUT(__file) freopen(__file, 'w', stdout);using std::cin;using std::cout;using std::endl;const int MAXN = 9 + 2;const int MAXK = MAXN * MAXN;int n, k;int stats[(1 &lt;&lt; MAXN) - 1 + 10], popc[(1 &lt;&lt; MAXN) - 1 + 10], cnt;long long int dp[MAXN][(1 &lt;&lt; MAXN) - 1 + 10][MAXK];/* * * dp[i][stat][k]: line i, status stat, k kings * */int Popcount(int x) &#123; int ret = 0; while (x) &#123; if (x &amp; 1) ++ret; x &gt;&gt;= 1; &#125; return ret;&#125;bool CheckFailed(int stat1, int stat2) &#123; if ((stat1 &amp; stat2) != 0) return true; if ((stat1 &amp; (stat2 &lt;&lt; 1)) != 0) return true; if (((stat1 &lt;&lt; 1) &amp; stat2) != 0) return true; return false;&#125;int main() &#123; IMPIO(); cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt;= (1 &lt;&lt; n) - 1; ++i) &#123; if ((i &amp; (i &lt;&lt; 1)) != 0) continue; stats[++cnt] = i; dp[1][cnt][Popcount(i)] = 1; &#125; for (int i = 2; i &lt;= n; ++i) &#123; for (int idj = 1; idj &lt;= cnt; ++idj) &#123; for (int idk = 1; idk &lt;= cnt; ++idk) &#123; if (CheckFailed(stats[idj], stats[idk])) continue; for (int l = 0; l &lt;= k; ++l) &#123; dp[i][idj][Popcount(stats[idj]) + l] += dp[i - 1][idk][l]; &#125; &#125; &#125; &#125; long long int ans = 0; for (int i = 1; i &lt;= cnt; ++i) &#123; ans += dp[n][i][k]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于新开的「Handwer's Problems」]]></title>
    <url>%2F2019-02-13%2FMathProblems-NewSite%2F</url>
    <content type="text"><![CDATA[「Handwer’s Problems」主要转载一些经过挑选的文化课题目。 每一道题都会在不久之后更新题解，同时会更新下一道题。 现在主要上数学题，预计不久之后会更新物理以及英语题目。 面向任何人开放，如无特殊情况（包括但不限于考试）不会设置密码。 链接：Handwer’s Problems]]></content>
      <tags>
        <tag>数学</tag>
        <tag>文化课</tag>
        <tag>简介</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2704《[NOI2001]炮兵阵地》]]></title>
    <url>%2F2019-02-04%2FLuogu-P2704%2F</url>
    <content type="text"><![CDATA[ProjectDP - 29 需要维护两行状态的状压DP 题目描述司令部的将军们打算在N*M的网格地图上部署他们的炮兵部队。一个N*M的地图由N行M列组成，地图的每一格可能是山地（用“H” 表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示： 如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。 输入输出格式输入格式第一行包含两个由空格分割开的正整数，分别表示N和M； 接下来的N行，每一行含有连续的M个字符（‘P’或者‘H’），中间没有空格。按顺序表示地图中每一行的数据。N≤100；M≤10。 输出格式仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。 输入输出样例输入样例1234565 4PHPPPPHHPPPPPHPPPHHP 输出样例16 解题思路看到这个玄学的数据范围，第一反应就是状压DP 我们设 $ dp[i][j][k] $ 表示当前正在摆放第 $i$ 行，当前行的状态编号为 $j$，上一行的状态编号为 $k$ 时的最大数量 我们先把所有的可能状态预处理出来，记为 stats[] 初始状态时所有的dp[1][i][1] = Popcount(stats[i])，其中 Popcount(x)表示x的二进制1的个数 转移方程显然，$ dp[i][j][k] = max(dp[i][j][k], dp[i-1][k][l] + $ Popcount(stats[j]) $ ) $，其中 $j$ 表示当前行的状态编号，$k$ 表示上一行的，$l$ 表示再上一行的 注意判一下地形是否符合，方法参见洛谷P1879 我要开滚动数组&lt;/big&gt; 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//// 29.cpp// ProjectDP//// Created by HandwerSTD on 2019/1/29.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 100 + 10;const int MAXM = 10 + 5;const int MAX = (1 &lt;&lt; 10) - 1 + 10;int status[MAX], dp[2][MAX][MAX], can[MAXN];int cnt, n, m;char str[MAXM];inline int pop(int x) &#123; int ret = 0; while(x) &#123; if(x &amp; 1) ret++; x &gt;&gt;= 1; &#125; return ret;&#125;inline int Check(int a, int b) &#123; return a &amp; b;&#125;inline int Check3(int a, int b, int c) &#123; return Check(a,b) || Check(a,c) || Check(b,c);&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s",str + 1); for(int j = 1; j &lt;= m; ++j) if(str[j] == 'H')can[i] = (can[i] &lt;&lt; 1) | 1; else can[i] = can[i] &lt;&lt; 1; &#125; for(int i = 0; i &lt;= (1 &lt;&lt; m) - 1; ++i) &#123; if((!(i &amp; (i &lt;&lt; 2))) &amp;&amp; (!(i &amp; (i &lt;&lt; 1)))) status[++cnt] = i; &#125; for(int i = 1; i &lt;= cnt; ++i) dp[1 % 2][i][1] = pop(status[i]); for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= cnt; ++j) &#123; if (!(status[j] &amp; can[i])) &#123; for (int k = 1; k &lt;= cnt; ++k) &#123; if ((!(status[k] &amp; can[i - 1])) &amp;&amp; (!Check(status[j],status[k]))) &#123; for (int l = 1; l &lt;= cnt; ++l)&#123; if ((!(status[l] &amp; can[i - 2])) &amp;&amp; (!Check3(status[j], status[k], status[l]))) dp[i % 2][j][k] = std::max(dp[i % 2][j][k], dp[(i - 1) % 2][k][l] + pop(status[j])); &#125; &#125; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= cnt; ++i) for(int j = 1; j &lt;= cnt; ++j) ans = std::max(ans, dp[n % 2][i][j]); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
        <tag>状压DP</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3183《[HAOI2016]食物链》]]></title>
    <url>%2F2019-02-04%2FLuogu-P3183%2F</url>
    <content type="text"><![CDATA[本题与[洛谷P4017](https://www.luogu.org/problemnew/show/P4017) 重复 代码通用 题解[传送门](/2019-02-04/Luogu-P4017/)]]></content>
      <tags>
        <tag>拓扑序</tag>
        <tag>图论</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4017《最大食物链计数》]]></title>
    <url>%2F2019-02-04%2FLuogu-P4017%2F</url>
    <content type="text"><![CDATA[七年级上册生物题目 题目背景你知道食物链吗？Delia生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。 题目描述给你一个食物网，你要求出这个食物网中最大食物链的数量。 （这里的“最大食物链”，指的是生物学意义上的食物链，即最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者。） Delia非常急，所以你只有1秒的时间。 由于这个结果可能过大，你只需要输出总数模上80112002的结果。 输入输出格式输入格式第一行，两个正整数n、m，表示生物种类n和吃与被吃的关系数m。 接下来m行，每行两个正整数，表示被吃的生物A和吃A的生物B。 输出格式一行一个整数，为最大食物链数量模上80112002的结果。 输入输出样例输入样例#1123456785 71 21 32 33 52 54 53 4 输出样例#115 说明各测试点满足以下约定： 【补充说明】 数据中不会出现环，满足生物学的要求。（感谢@AKEE ） 解题思路有向无环？拓扑序啊！仔细想一下发现思路可能是对的 正向建一个图，反向建一个图 先把正向图的拓扑序跑出来，放到一个vector&lt;int&gt;里再按照拓扑序来枚举点，这样就保证了枚举的顺序 我们设 dp[node] 表示以编号 node 为结尾的食物链个数那么对于节点 Node， 如果它没有出边，那么dp[node] = 1 如果它有出边，那么枚举每一条出边的邻接点nv，dp[node] += dp[nv] 最后答案是$\sum$dp[所有没有出边的点] 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define ADD(__x) if (__x &gt;= HA) __x -= HA#define DEBUG(__Args,...) printf(__Args,##__VA_ARGS__)using std::cin;using std::cout;using std::endl;using std::max;const int MAXN = 5000 + 10;const int HA = 80112002;std::vector&lt;int&gt; head[MAXN];std::vector&lt;int&gt; reallink[MAXN];std::vector&lt;int&gt; top;int id[MAXN]; // id -&gt; in degreeint n, m, ans; int dp[MAXN]; // dp[i][j] -&gt; the amount of links that the end-node = ivoid Topsort() &#123; std::queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) &#123; if (!id[i]) &#123; q.push(i); top.push_back(i); &#125; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); int amt = head[u].size(); for (int i = 0; i &lt; amt; ++i) &#123; int v = head[u][i]; --id[v]; if (!id[v]) &#123; top.push_back(v); q.push(v); &#125; &#125; &#125;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; int A = 0, B = 0; cin &gt;&gt; A &gt;&gt; B; head[A].push_back(B); reallink[B].push_back(A); ++id[B]; &#125; Topsort(); for (int i = 1; i &lt;= n; ++i) &#123; // enumerate Topsorted-Nodes int nnode = top[i - 1]; if (reallink[nnode].size() == 0) dp[nnode] = 1; // no out-edges connected for (int j = 0; j &lt; reallink[nnode].size(); ++j) &#123; int nenode = reallink[nnode][j]; dp[nnode] += dp[nenode]; ADD(dp[nnode]); &#125; if (!head[nnode].size()) ans += dp[nnode]; ADD(ans); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3060《Tour de Byteotia》]]></title>
    <url>%2F2019-02-04%2FBZOJ3060%2F</url>
    <content type="text"><![CDATA[并查集板子题（雾 题面权限题，题面请自行寻找用小刀刮开涂层来获取题目地址访问 DarkBZOJ 来获取题面 解析用并查集维护一下连通性 下文我们称「编号小于等于k的点」为「奇特点」 显然和奇特点没有关系的边删不删都无所谓，不影响答案，所以我们可以放心地把这些边加入并查集。 然后我们枚举所有的与奇特点相连的边，尝试将这条边加入并查集。如果这条边的两个点不连通，就可以放心地将这条边加入并查集，否则++ans 最后输出ans即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 1000000 + 10;const int MAXM = 2000000 + 10;struct UnionFind &#123; int seq[MAXN]; UnionFind() &#123; memset(seq, 0, sizeof seq); &#125; int Find(int x) &#123; if (seq[x] == 0) return x; return seq[x] = Find(seq[x]); &#125; bool Union(int x, int y) &#123; x = Find(x); y = Find(y); if (x == y) return false; seq[x] = y; return true; &#125;&#125; U;struct Edge &#123; int f, t; // from to Edge() &#123; f = t = 0; &#125;&#125; edge[MAXM &lt;&lt; 1];int n, m, k, cnt;inline void addEdge(int u, int v) &#123; edge[++cnt].f = u; edge[cnt].t = v;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; int prev = 0, next = 0; cin &gt;&gt; prev &gt;&gt; next; addEdge(prev, next); &#125; for (int e = 1; e &lt;= m; ++e) &#123; if (!(edge[e].f &lt;= k || edge[e].t &lt;= k)) &#123; U.Union(edge[e].f, edge[e].t); &#125; &#125; for (int e = 1; e &lt;= m; ++e) &#123; if (edge[e].f &lt;= k || edge[e].t &lt;= k) &#123; if (!U.Union(edge[e].f, edge[e].t)) ++ans; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2619《[国家集训队2]Tree I》]]></title>
    <url>%2F2019-02-04%2FLuogu-P2619%2F</url>
    <content type="text"><![CDATA[年轻人的第一道国家集训队二分答案 + 最小生成树 题目描述给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有need条白色边的生成树。 题目保证有解。 输入输出格式输入格式第一行V,E,need分别表示点数，边数和需要的白色边数。 接下来E行 每行s,t,c,col表示这边的端点(点从0开始标号)，边权，颜色(0白色1黑色)。 输出格式一行表示所求生成树的边权和。 输入输出样例输入样例1232 2 10 1 1 10 1 2 0 输出样例12 说明0:V&lt;=10 1,2,3:V&lt;=15 0,..,19:V&lt;=50000,E&lt;=100000 所有数据边权为[1,100]中的正整数。 By WJMZBMR 解题思路年轻人的第一道国家集训队题目 如果我们不做任何处理，直接跑MST（Minimum Spanning Tree，最小生成树），结果会有三种： 正好跑出 $\text{Need}$ 条白边 白边多了 白边少了 第一种情况自然是最好的 剩下两种情况如何解决？ 引起白边少的原因：黑边的边权相对较小，程序贪心地选择了更多的黑边 引起白边多的原因：白边的边权相对较小，程序贪心地选择了更多的白边 那么如果我们给白边相应地减去/加上一些边权，不就可以达成目标了？ 考虑二分答案。 我们二分一个 $add$ 表示我们当前要给白边加上 $add$ 来达成目标 边界分别是边权最小值（-100）和边权最大值（100） 由于题面保证有答案，所以直接输出 $ ans - add \times \text{Need} $ 即可，其中 $ans$ 为（加上边权后）最小生成树的权值和 Check(mid) 怎么写？ 我们将所有白边的边权加上$add$（即$mid$），跑一遍最小生成树，判断一下拿到的白色边数量是否大于等于要求的数量，如果是就更新一下左边界并记当前的$mid$为$tans$，否则就更新一下右边界 注意不要忘了把边权减回来 （不要在意 $tans$ 是什么意思） 刚才我们不是记录了一下$tans$吗，这个$tans$就相当于是一个正确的、能选出正好 $\text{Need}$ 条白边的 $add$ 值，再将所有白边的边权都加上这个 $tans$，跑一遍最小生成树即可 答案不要忘了减去加上的边权（也就是 $ \text{Need} \times tans $） 那么最后的答案就是 $ \text{Kruskal()} - \text{Need} \times tans $ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define WHITE 0#define BLACK 1using std::cin;using std::cout;using std::endl;using std::max;const int MAXV = 50000 + 10;const int MAXE = 100000 + 10;const int MAXW = 100;struct Edge &#123; int prev, next, weight, add; bool color; // 1 -&gt; black, 0 -&gt; white Edge() &#123; prev = next = weight = color = add = 0; &#125; bool operator &lt; (const Edge &amp;that) const &#123; if (weight == that.weight) return color &lt; that.color; return weight &lt; that.weight; &#125;&#125; edge[MAXE &lt;&lt; 1];int V, E, Need, cnt, ans;int U[MAXV &lt;&lt; 1];int Find(int x) &#123; if (U[x] == x) return U[x]; return U[x] = Find(U[x]);&#125;bool Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return false; U[x] = y; return true;&#125;int Kruskal() &#123; int whiteEdge = 0; for (int i = 1; i &lt;= V; ++i) U[i] = i; std::sort(edge + 1, edge + 1 + E); int tot = 0; ans = 0; for (int i = 1; i &lt;= E; ++i) &#123; if (Union(edge[i].prev, edge[i].next)) ans += edge[i].weight, ++tot, whiteEdge += (edge[i].color == WHITE); if (tot == V - 1) break; &#125; return whiteEdge;&#125;bool Check(int add) &#123; for (int i = 1; i &lt;= E; ++i) &#123; if (edge[i].color == WHITE) edge[i].weight += add; &#125; bool Ans = (Kruskal() &gt;= Need); for (int i = 1; i &lt;= E; ++i) &#123; if (edge[i].color == WHITE) edge[i].weight -= add; &#125; return Ans;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; V &gt;&gt; E &gt;&gt; Need; for (int i = 1; i &lt;= E; ++i) &#123; cin &gt;&gt; edge[i].prev &gt;&gt; edge[i].next &gt;&gt; edge[i].weight &gt;&gt; edge[i].color; ++edge[i].prev; ++edge[i].next; &#125; int l = -MAXW, r = MAXW; int Run = 0; while (l &lt;= r) &#123; int mid = ((l + r) &gt;&gt; 1); if (Check(mid)) &#123; l = mid + 1; Run = mid; &#125; else &#123; r = mid - 1; &#125; &#125; Check(Run); cout &lt;&lt; ans - Need * Run &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>二分答案</tag>
        <tag>生成树</tag>
        <tag>国家集训队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1621《集合》]]></title>
    <url>%2F2019-02-04%2FLuogu-P1621%2F</url>
    <content type="text"><![CDATA[素数筛 + 并查集 题目背景John的农场缺水了！！！ 题目描述Farmer John has decided to bring water to his N (1 &lt;= N &lt;= 300) pastures which are conveniently numbered 1..N. He may bring water to a pasture either by building a well in that pasture or connecting the pasture via a pipe to another pasture which already has water. Digging a well in pasture i costs W_i (1 &lt;= W_i &lt;= 100,000). Connecting pastures i and j with a pipe costs P_ij (1 &lt;= P_ij &lt;= 100,000; P_ij = P_ji; P_ii=0). Determine the minimum amount Farmer John will have to pay to water all of his pastures. POINTS: 400 农民John 决定将水引入到他的n(1&lt;=n&lt;=300)个牧场。他准备通过挖若 干井，并在各块田中修筑水道来连通各块田地以供水。在第i 号田中挖一口井需要花费W_i(1&lt;=W_i&lt;=100,000)元。连接i 号田与j 号田需要P_ij (1 &lt;= P_ij &lt;= 100,000 , P_ji=P_ij)元。 请求出农民John 需要为使所有农场都与有水的农场相连或拥有水井所需要的钱数。 输入输出格式输入格式第1 行为一个整数n。 第2 到n+1 行每行一个整数，从上到下分别为W_1 到W_n。 第n+2 到2n+1 行为一个矩阵，表示需要的经费（P_ij）。 输出格式只有一行，为一个整数，表示所需要的钱数。 输入输出样例输入样例123456789454430 2 2 22 0 3 32 3 0 42 3 4 0 输出样例19 说明John等着用水，你只有1s时间！！！ 解题思路题目中“质数”两个字很是显眼啊 还等啥啊 筛啊 素数筛很好写吧 筛完了，然后呢？ 题目让我们找两个公共质因数 $ \geq P $ 的，不在一个集合里的数，并合并它们。我们不这样找 枚举每一个质数primes[i]，计算出第一个 大于A的primes[i]的倍数（题目要求的）记为$t$，然后从$t+\text{primes[i]}$一直枚举到$B$（每次增长一个$\text{primes[i]}$，毕竟要求必须有$\text{primes[i]}$这个数作为质因数），每次用并查集合并$t$和当前枚举到的这个数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;using std::max;const int MAXB = 100000 + 10;int A, B, P;int primes[MAXB], cnt, ans;bool npm[MAXB]; // n(ot a )p(ri)m(e) -&gt; not a primeint U[MAXB];int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; --ans; // 两个集合变成了一个，答案减一 U[x] = y;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; A &gt;&gt; B &gt;&gt; P; for (int i = 1; i &lt;= B; ++i) U[i] = i; // 并查集初始化 // 筛一波素数 for (int i = 2; i &lt;= B; ++i) &#123; if (!npm[i]) primes[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; primes[j] * i &lt;= B; ++j) &#123; npm[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125; ans = B - A + 1; // r - l + 1 // 原来的答案总数是（右边界 - 左边界 + 1） //（即 B - A + 1），每次合并集合的时候两个集合变成了一个，--ans for (int i = 1; i &lt;= cnt; ++i) &#123; if (primes[i] &lt; P) continue; // 质因数要求大于等于P int np = (A + primes[i] - 1) / primes[i] * primes[i]; // np -&gt; The smallest multiple of primes[i] larger than A // np -&gt; 最小的 比A大的 primes[i]的倍数 for (int j = np + primes[i]; j &lt;= B; j += primes[i]) &#123; Union(np, j); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>筛法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1879《[USACO06NOV]玉米田Corn Fields》]]></title>
    <url>%2F2019-01-29%2FLuogu-P1879%2F</url>
    <content type="text"><![CDATA[ProjectDP - 28 状压DP入门题 题目描述Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant. Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant. 农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。 John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案） 输入输出格式输入格式第一行：两个整数M和N，用空格隔开。 第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。 输出格式一个整数，即牧场分配总方案数除以100,000,000的余数。 输入输出样例输入样例1232 31 1 10 1 0 输出样例19 解题思路一道状压DP入门题 首先我们发现对于每一行，有 N 个状态那么就意味着这是一个N + 1维DP…… 但是我们发现从第二维到第N维都只需要0（不种玉米）和1（种玉米）两个值那么……二进制！比如 1010 就表示第1、3个格种玉米，第2、4个格不种玉米 设 $ f[i][\text{status}] $ 表示第 $i$ 行种玉米的状态是 $\text{status}$转移方程很显然吧 f[i][\text{status}] = f[i][\text{status}] + f[i - 1][ \text{pre_status}]如何判断 $ \text{status} $ 和 $ \text{pre_status} $ 是不是互相合法？ 我们先来看看如何判断两行互相合法。 「合法」指两行种玉米的地方不相邻，也就是两个1不相邻。我们来想想位运算 $and$ 的性质 1234567891011运算法则：1 &amp; 1 = 11 &amp; 0 = 00 &amp; 0 = 0and (aka &amp;) 是按位运算的例如： 10101101 10100100&amp; 10110100 &amp; 01010001---------- ---------- 10100100 00000000 我们发现，第二个例子放在题目中是合法的，它们进行 $and$ 运算的值为 $0$那么方法不就出来了吗！ 123bool Check(int stat1, int stat2) &#123; return (stat1 &amp; stat2) == 0;&#125; 单行的状态也可能不合法，如何对敌怎么解决？ 12345678910stat1 = 01001101 就是一个不合法的状态我们把 stat1 左移一位（ stat1 = stat1 &lt;&lt; 1 ）得到了 stat2 = 10011010我们把他们 and 一下 01001101&amp; 10011010---------- 00001000 &gt; 0 那么方法就出来了 123bool CheckSingleLine(int stat) &#123; return Check(stat, stat &lt;&lt; 1);&#125; 之后处理一下土地的状态 我们将一行土地的利用情况记为二进制0表示荒地，1表示耕地 我们判断一下当前状态与利用情况 and 起来是否还等于当前状况即可正确性证明留作习题 那么我们枚举所有的可能状态，挨个判断即可。注意边界条件 $ f[0][0] = 1 $ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// 28.cpp// ProjectDP//// Created by HandwerSTD on 2019/1/29.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define Stat(__x) FIXED_STATUS[__x]using std::cin;using std::cout;using std::endl;const int MAXSTATUS = (1 &lt;&lt; 12) - 1 + 10;const int MAXMN = 12 + 5;const int HA = 100000000;int m, n;int farm[MAXMN][MAXMN];int dp[MAXMN][MAXSTATUS], FIXED_STATUS[MAXSTATUS];/* * * dp[i][stat]: line = i, status = stat (binary) * */int main() &#123; IMPROVE_IO(); cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; cin &gt;&gt; farm[i][j]; Stat(i) = (Stat(i) &lt;&lt; 1) + farm[i][j]; // 预处理一下土地的状态 &#125; &#125; dp[0][0] = 1; for (int i = 1; i &lt;= m; ++i) &#123; for (int status = 0; status &lt;= (1 &lt;&lt; n) - 1; ++status) &#123; if ((status &amp; (status &lt;&lt; 1)) != 0) continue; // some grass are close to each other if ((status &amp; Stat(i)) != status) continue; // at least one grass planted on a barren place for (int pre_stat = 0; pre_stat &lt;= (1 &lt;&lt; n) - 1; ++pre_stat) &#123; if ((status &amp; pre_stat) == 0) &#123; dp[i][status] += dp[i - 1][pre_stat]; dp[i][status] %= HA; &#125; &#125; &#125; &#125; int ans = 0; for (int i = 0; i &lt;= (1 &lt;&lt; n) - 1; ++i) &#123; ans += dp[m][i]; ans %= HA; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
        <tag>进制</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1352《没有上司的舞会》]]></title>
    <url>%2F2019-01-28%2FLuogu-P1352%2F</url>
    <content type="text"><![CDATA[ProjectDP - 8 树形DP入门题 题目描述某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 输入输出格式输入格式第一行一个整数N。(1&lt;=N&lt;=6000) 接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128&lt;=Ri&lt;=127) 接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。 最后一行输入0 0 输出格式输出最大的快乐指数。 输入输出样例输入样例123456789101112131415711111111 32 36 47 44 53 50 0 输出样例15 解题思路这是一道树形DP板子题。 设 $ f[u][0] $ 表示不选择 $u$ 这个结点时的最大价值，$ f[u][1] $ 表示选择 $u$ 这个结点时的最大价值令 $v$ 为 $u$ 除父节点以外的邻接点，那么我们就能写出这样的伪代码 ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ \text{Algorithm 1: DFS(u)} $⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ 1: f[u][0] = 0 $$ 2: f[u][1] = value[u] $$ 3: \text{while u}$ 有未被遍历的出边 $ (u,v) \text{ do} $$ 4: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{DFS}(v) $$ 5: $ &nbsp;&nbsp;&nbsp;&nbsp; $ f[u][0] = f[u][0] + \text{max}(f[v][0], f[v][1]) $$ 6: $ &nbsp;&nbsp;&nbsp;&nbsp; $ f[u][1] = f[u][1] + f[v][0] $$ 7: \text{end while}$⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ 最后答案即为 $ \text{max}(f[root][0], f[root][1]) $ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//// 8.cpp// ProjectDP//// Created by HandwerSTD on 2019/1/28.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 6000 + 10;/* * * dp[u][true]: Choose Node[u] * dp[u][false]: Don't choose Node[u] * */int val[MAXN], n;int dp[MAXN][2], inDegree[MAXN];std::vector&lt;int&gt; head[MAXN];void DFS(int u) &#123; dp[u][0] = 0; dp[u][1] = val[u]; int siz = (int) head[u].size(); for (int i = 0; i &lt; siz; ++i) &#123; int v = head[u][i]; DFS(v); dp[u][1] += dp[v][0]; dp[u][0] += std::max(dp[v][0], dp[v][1]); &#125;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; val[i]; int maxNode = -1, minNode = MAXN + 1000; for (int i = 1; i &lt;= n - 1; ++i) &#123; int father = 0, child = 0; cin &gt;&gt; child &gt;&gt; father; head[father].push_back(child); ++inDegree[child]; maxNode = std::max(maxNode, std::max(father, child)); minNode = std::min(minNode, std::min(father, child)); &#125; int root = 0; for (int i = minNode; i &lt;= maxNode; ++i) &#123; if (inDegree[i] == false) root = i; if (root != 0) break; &#125; DFS(root); cout &lt;&lt; std::max(dp[root][0], dp[root][1]) &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
        <tag>ProjectDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2089《不要62》]]></title>
    <url>%2F2019-01-28%2FHDU2089%2F</url>
    <content type="text"><![CDATA[ProjectDP - 26 数位DP板子题 Problem Description杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 Output对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input121 1000 0 Sample Output180 Authorqianneng 解析 不会讲啊QAQ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//// 26.cpp// ProjectDP//// Created by HandwerSTD on 2019/1/28.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXLENGTH = 8 + 4;/* * * dp[i][j]: length = i, the start number = j * */int dp[MAXLENGTH][MAXLENGTH];int n, m;void Init() &#123; dp[0][0] = 1; for (int i = 1; i &lt;= 9; ++i) &#123; // enumeration length for (int j = 0; j &lt;= 9; ++j) &#123; if (j == 4) dp[i][j] = 0; else &#123; for (int k = 0; k &lt;= 9; ++k) &#123; dp[i][j] += dp[i - 1][k]; &#125; if (j == 6) dp[i][j] -= dp[i - 1][2]; &#125; &#125; &#125;&#125;int Solve(int x) &#123; // returns the amount in [0, x) int ans = 0; int num[MAXLENGTH] = &#123;0&#125;; // num[0] &lt;=&gt; cnt while (x) &#123; num[++num[0]] = x % 10; x /= 10; &#125; for (int i = num[0]; i &gt;= 1; --i) &#123; for (int j = 0; j &lt; num[i]; ++j) &#123; if (j == 4 || (num[i + 1] == 6 &amp;&amp; j == 2)) continue; ans += dp[i][j]; &#125; if (num[i] == 4) break; if (num[i + 1] == 6 &amp;&amp; num[i] == 2) break; &#125; return ans;&#125;int main() &#123; IMPROVE_IO(); Init(); while (true) &#123; cin &gt;&gt; n &gt;&gt; m; if (n == 0 &amp;&amp; m == 0) break; cout &lt;&lt; Solve((m) + 1) - Solve((n - 1) + 1) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1006《传纸条》]]></title>
    <url>%2F2019-01-28%2FLuogu-P1006%2F</url>
    <content type="text"><![CDATA[ProjectDP - 4 从下往上传 $ \iff $ 从上往下传 诶这里好像没有东西。。。]]></content>
      <tags>
        <tag>ProjectDP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1434《[SHOI2010]滑雪》]]></title>
    <url>%2F2019-01-27%2FLuogu-P1434%2F</url>
    <content type="text"><![CDATA[记忆化搜索好题 题目描述Michael喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子： 123451 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可行的滑坡为24－17－16－1（从24开始，在1结束）。当然25－24－23－…－3－2－1更长。事实上，这是最长的一条。 输入输出格式输入格式输入的第一行为表示区域的二维数组的行数R和列数C（1≤R，C≤100）。下面是R行，每行有C个数，代表高度(两个数字之间用1个空格间隔)。 输出格式输出区域中最长滑坡的长度。 输入输出样例输入样例1234565 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 输出样例125 解题思路一眼就能看出这是搜索题 方法很显然，枚举所有的点，从当前点开始 DFS，每次往四个方向搜索，直到不能搜为止，这时候答案就出来了一个，更新一下。 考虑一下优化。在每次搜索的过程中，我们有很多点是重复走过的，那么就可以把暴搜升级为记忆化搜索。用 $ \text{mem}(x,y) $ 表示从点 $ (x,y) $ 出发的最长路径，在每一次搜索完成之后更新一下当前的答案，记录到 $ \text{mem}(x,y) $ 中即可。等到下一次搜到这个点（记为 $ (x’,y’) $ ），如果 $ \text{mem}(x’,y’) \geq 0 $ （也就是被更新过了），直接返回 $ \text{mem}(x’,y’) $ 就行。 我们也可以把记忆化搜索升级为 DP 不过据说比记忆化搜索还慢DP 做法题解已提上日程。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int dx[] = &#123; 0, 0, -1, 1 &#125;;const int dy[] = &#123; 1, -1, 0, 0 &#125;;const int MAXRC = 100 + 10;int snow[MAXRC][MAXRC];int r, c, ans;int mem[MAXRC][MAXRC];int Search(int x, int y) &#123; int t = 1; if (mem[x][y]) t = mem[x][y]; else &#123; for (int i = 0; i &lt; 4; ++i) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &gt; 0 &amp;&amp; ny &gt; 0 &amp;&amp; nx &lt;= r &amp;&amp; ny &lt;= c &amp;&amp; snow[x][y] &lt; snow[nx][ny]) &#123; t = std::max(t, Search(nx, ny) + 1); &#125; &#125; &#125; mem[x][y] = t; return t;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; r &gt;&gt; c; for (int i = 1; i &lt;= r; ++i) &#123; for (int j = 1; j &lt;= c; ++j) &#123; cin &gt;&gt; snow[i][j]; &#125; &#125; for (int i = 1; i &lt;= r; ++i) &#123; for (int j = 1; j &lt;= c; ++j) &#123; int now = Search(i, j); mem[i][j] = now; ans = std::max(ans, mem[i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>省选</tag>
        <tag>DFS</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2320《[HNOI2006]鬼谷子的钱袋》]]></title>
    <url>%2F2019-01-27%2FLuogu-P2320%2F</url>
    <content type="text"><![CDATA[不断拆分 题目描述鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。 有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。 但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。 鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？ 输入输出格式输入格式包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1 ≤ m ≤ 1000000000。 输出格式两行，第一行一个整数h，表示所用钱袋个数 第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开 输入输出样例输入样例13 输出样例1221 2 解题思路本文已发布于Handwer’s 洛谷博客 本蒟蒻怒写一发题解 收到本校神犇@Herself32 的邀请，过来做这道题 结果被题怒切 不扯了 首先考虑一个弱化版的题目，只输出最小袋子数稍微找一下规律就知道是总钱数的二进制位数 好 那么数据范围就出来了 本题我们还是手动模拟一下 123456781 -&gt; 12 -&gt; 1, 13 -&gt; 1, 24 -&gt; 1, 1, 25 -&gt; 1, 1, 36 -&gt; 1, 2, 37 -&gt; 1, 2, 48 -&gt; 1, 1, 2, 4 我们再把7和8的过程单独拿出来看 127 -&gt; 3, 4 -&gt; 1, 2, 48 -&gt; 4, 4 -&gt; 2, 2, 4 -&gt; 1, 1, 2, 4 我们能发现什么？对于一个数 $n$，我们可以把它用 $ \lceil \frac{n}{2} \rceil + \lfloor \frac{n}{2} \rfloor $ 表示，同时依照题意，$ \lfloor \frac{n}{2} \rfloor $ 也是可以用 $ \lceil \frac{\lfloor \frac{n}{2} \rfloor}{2} \rceil + \lfloor \frac{\lfloor \frac{n}{2} \rfloor}{2} \rfloor $ 进行表示的，这么一直递归下去，直到两个式中至少有一个为 1 ，此时反向（即从小到大）输出答案即可 代码实现1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXANS = 30 + 10;int m;int ans[MAXANS], cnt = 0;void Search(int now) &#123; if (now == 0) return; int mid = now / 2, mid2 = now / 2 + (now % 2); ans[++cnt] = mid2; Search(mid);&#125;int main() &#123; scanf("%d", &amp;m); Search(m); printf("%d\n", cnt); for (int i = cnt; i &gt;= 1; --i) printf("%d ", ans[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>各省省选</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1541「NOIP2010」《乌龟棋》]]></title>
    <url>%2F2019-01-26%2FLuogu-P1541%2F</url>
    <content type="text"><![CDATA[ProjectDP - 3 枚举转移 题目背景小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。 题目描述乌龟棋的棋盘是一行$N$个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第$N$格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。 乌龟棋中$M$张爬行卡片，分成4种不同的类型（$M$张卡片中不一定包含所有4种类型的卡片，见样例），每种类型的卡片上分别标有$1,2,3,4$四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。 游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。 很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。 现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？ 输入输出格式输入格式每行中两个数之间用一个空格隔开。 第1行2个正整数$N,M$，分别表示棋盘格子数和爬行卡片数。 第2行$N$个非负整数，$a_1,a_2,…,a_N$，其中$a_i$表示棋盘第$i$个格子上的分数。 第3行$M$个整数，$b_1,b_2,…,b_M$，表示M张爬行卡片上的数字。 输入数据保证到达终点时刚好用光$M$张爬行卡片。 输出格式11个整数，表示小明最多能得到的分数。 输入输出样例输入样例1239 56 10 14 2 8 8 18 5 171 3 1 2 1 输出样例173 解题思路先来想想五维的 DP 我们设 $ f(i,j,k,l,m) $ 表示当前用了 $i$ 个卡片1， $j$ 个卡片2， $k$ 个卡片3， $l$ 个卡片4，走了 $m$ 步时的最大得分 分别对四种卡片进行转移 Max = f[i-1][j][k][l][m - 1] (i \geq 1)Max = max(Max,f[i][j-1][k][l][m - 2]) (j \geq 1, m \geq 3)Max = max(Max,f[i][j][k-1][l][m - 3]) (k \geq 1, m \geq 4)Max = max(Max,f[i][j][k][l-1][m - 4]) (l \geq 1, m \geq 5)f[i][j][k][l][m] = Max + Score[m] 考虑一下优化。显然 $m$ 是可以通过计算得出的，$ m = i + 2j + 3k + 4l + 1 $ （注意后面的+1，因为是从第一个格开始的），那么就能省去一维 转移方程就变为了 m = i + 2j + 3k + 4l + 1Max = f[i-1][j][k][l] (i \geq 1)Max = max(Max,f[i][j-1][k][l]) (j \geq 1)Max = max(Max,f[i][j][k-1][l]) (k \geq 1)Max = max(Max,f[i][j][k][l-1]) (l \geq 1)f[i][j][k][l] = Max + Score[m]最终答案留做习题见代码 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//// 3.cpp// ProjectDP//// Created by HandwerSTD on 2019/1/25.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;using std::max;/* * * CARD1 means the card that can make the turtle go 1 block. * CARD2, CARD3 and CARD4 too. * dp[i][j][k][l] records the max score when there are i CARD1(s), j CARD2(s), k CARD3(s) and l CARD4(s) have been used. * * Formula: * Step = i * 1 + j * 2 + k * 3 + l * 4 + 1 * Max = dp[i][j][k][k] * Max = max(Max, dp[i-1][j][k][l]) (i &gt;= 1) * Max = max(Max, dp[i][j-1][k][l]) (j &gt;= 1) * Max = max(Max, dp[i][j][k-1][l]) (k &gt;= 1) * Max = max(Max, dp[i][j][k][l-1]) (l &gt;= 1) * dp[i][j][k][l] = Max + score[Step] * * Answer: * dp[a][b][c][d], * a -&gt; the amount of CARD1, b, c, and d too. * */const int MAXN = 350 + 10;const int MAXM = 120 + 10;const int MAXCARD = 40 + 10;int n, m, sc[MAXN], cds[MAXM];int a, b, c, d;int dp[MAXCARD][MAXCARD][MAXCARD][MAXCARD];int main() &#123; IMPROVE_IO(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; sc[i]; &#125; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; cds[i]; if (cds[i] == 1) ++a; if (cds[i] == 2) ++b; if (cds[i] == 3) ++c; if (cds[i] == 4) ++d; &#125; for (int i = 0; i &lt;= a; ++i) &#123; for (int j = 0; j &lt;= b; ++j) &#123; for (int k = 0; k &lt;= c; ++k) &#123; for (int l = 0; l &lt;= d; ++l) &#123; int walked = 1 + i * 1 + j * 2 + k * 3 + l * 4; if (walked &gt; n) break; int Max = dp[i][j][k][l]; if (i - 1 &gt;= 0) Max = max(Max, dp[i-1][j][k][l]); if (j - 1 &gt;= 0) Max = max(Max, dp[i][j-1][k][l]); if (k - 1 &gt;= 0) Max = max(Max, dp[i][j][k-1][l]); if (l - 1 &gt;= 0) Max = max(Max, dp[i][j][k][l-1]); dp[i][j][k][l] = Max + sc[walked]; &#125; &#125; &#125; &#125; cout &lt;&lt; dp[a][b][c][d] &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProjectDP]]></title>
    <url>%2F2019-01-24%2FProjectDP%2F</url>
    <content type="text"><![CDATA[DP计划 为提高自己的DP水平，我创建了一个名为「DP计划」的工程，用它来记录自己的题目完成情况，同时编程、调试、代码储存也使用此工程。 项目地址：View ProjectDP on GitHub]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>ProjectDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1083《借教室》]]></title>
    <url>%2F2019-01-24%2FLuogu-P1083%2F</url>
    <content type="text"><![CDATA[前缀和 + 二分答案 题目描述在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。 面对海量租借教室的信息，我们自然希望编程解决这个问题。 我们需要处理接下来$n$天的借教室信息，其中第$i$天学校有$r_i$个教室可供租借。共有$m$份订单，每份订单用三个正整数描述，分别为$d_j,s_j,t_j$，表示某租借者需要从第$s_j$天到第$t_j$天租借教室（包括第$s_j$天和第$t_j$天），每天需要租借$d_j$个教室。 我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$d_j$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$s_j$天到第$t_j$天中有至少一天剩余的教室数量不足$d_j$个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 输入输出格式输入格式：第一行包含两个正整数$n,m$，表示天数和订单的数量。 第二行包含$n$个正整数，其中第$i$个数为$r_i$，表示第$i$天可用于租借的教室数量。 接下来有$m$行，每行包含三个正整数$d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。 每行相邻的两个数之间均用一个空格隔开。天数与订单均用从$1$开始的整数编号。 输出格式如果所有订单均可满足，则输出只有一行，包含一个整数 $0$。否则（订单无法完全满足） 输出两行，第一行输出一个负整数$−1$，第二行输出需要修改订单的申请人编号。 输入输出样例输入样例123454 3 2 5 4 3 2 1 3 3 2 4 4 2 4 输出样例12-1 2 说明【输入输出样例说明】 第 $1$份订单满足后，$4$天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2$天到第 $4$ 天每天提供 $3$个教室，而第 $3$ 天剩余的教室数为 $2$，因此无法满足。分配停止，通知第$2$ 个申请人修改订单。 【数据范围】 对于10%的数据，有$1≤ n,m≤ 10$； 对于30%的数据，有$1≤ n,m≤1000$； 对于 70%的数据，有$1 ≤ n,m ≤ 10^5$； 对于 100%的数据，有 $ 1 ≤ n,m ≤ 10^6,0 ≤ r_i,d_j≤ 10^9,1 ≤ s_j≤ t_j≤ n​ $。 NOIP 2012 提高组 第二天 第二题 解题思路考虑二分答案 首先我们知道，对于一个订单 $i$，如果它能被批准，那么 $[1,i]$ 都能被批准；如果它不能被批准，那么 $[i,m]$ 都不能被批准（单调性） 那么我们二分订单的编号 $\text{mid}$，每次判一下$[1,\text{mid}]$是否全都能满足，最后如果右边界不是 $m$ 了，说明有订单不能满足，输出右边界即可 如何判断是否能满足？首先我们要$O(1)$实现区间修改（？？？）用前缀和就可以实现！ 想想下面的过程$\downarrow$ 123456789101112131415原数列: 0 0 0 0 0 0 [ 1 2 3 4 5 6 ]前缀和： 0 0 0 0 0 0 [ 1 2 3 4 5 6 ] 我们让[1,3]都增加2于是我们选择让[1]增加2，让[4]（即[3+1]）减去2那么上面的数列就变成了：原数列: 2 0 0 -2 0 0 [ 1 2 3 4 5 6 ]前缀和： 2 2 2 0 0 0 [ 1 2 3 4 5 6 ]这个时候前缀和数组就实现了区间加！ 那么依照上面的思想，我们就能写出Check(int mid) 1234567891011121314151617181920212223struct Order &#123; int amount, l, r; Order() &#123; amount = l = r = 0; &#125;&#125; order[MAXM];int a[MAXN], sum[MAXN];bool Check(int __i) &#123; memset(sum, 0, sizeof sum); for (int i = 1; i &lt;= __i; ++i) &#123; // 像上面一样处理前缀和 sum[order[i].l] += order[i].amount; sum[order[i].r] -= order[i].amount; &#125; for (int i = 1; i &lt;= n; ++i) &#123; // 将前缀和处理一遍 // 判一下是否有超过当天可用教室的值 sum[i] += sum[i - 1]; if (sum[i] &gt; a[i]) return false; // 不合法 &#125; return true; // 合法&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXNM = 1000000 + 10; struct Order &#123; int num; int l, r; Order() &#123; num = l = r = 0; &#125; &#125; order[MAXNM]; int n, m, seq[MAXNM]; int sum[MAXNM]; bool Check(int M) &#123; memset(sum, 0, sizeof sum); for (int i = 1; i &lt;= M; ++i) &#123; sum[order[i].l] += order[i].num; sum[order[i].r + 1] -= order[i].num; &#125; for (int i = 1; i &lt;= n; ++i) &#123; sum[i] += sum[i - 1]; if (sum[i] &gt; seq[i]) return false; &#125; return true; &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; n = getint(); m = getint(); For (i, 1, n) seq[i] = getint(); For (i, 1, m) &#123; order[i].num = getint(); order[i].l = getint(); order[i].r = getint(); &#125; int L = 1, R = m; while (L &lt; R) &#123; int mid = (L + R) &gt;&gt; 1; if (Check(mid)) L = mid + 1; else R = mid; &#125; if (R != m) &#123; printf("-1\n%d\n", R); &#125; else puts("0"); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配学习笔记 & HDU2063 题解]]></title>
    <url>%2F2019-01-24%2FBipartiteGraph%2F</url>
    <content type="text"><![CDATA[原创建时间：2018-07-06 21:36:45 二分图概念设图$G=(V,E)$是一个无向图，若顶点集合$V$可分割为两个互不相交的子集$X$和$Y$，且图中每条边连接的顶点一个在$X$中，一个在$Y$中，则称$G$是一个二分图。 判定若某一图是联通的， 1231. 任选一个点V作为顶点，定义距离标号为02. 将V的邻接点标号设为1，接着将它的未标号的邻接点的标号设为2，以此类推 3. 将所有标号为奇数的点归为X，标号为偶数的点归为Y 以上内容可以采用BFS完成 依次检查每一条边，看看是否满足顶点一个在$X$中，一个在$Y$中 若某一图不连通，就在每个联通块里进行判定 二分图匹配定义给定一个二分图$G$，在$G$的子图$M$中，$M$的边集${E}$中的任意两条边都不依附于同一个顶点，则称$M$是一个匹配。 图中蓝色的边是数量为2的匹配 最大匹配 &amp; 完全匹配选择边数最大的子图称为「二分图的最大匹配问题」 如果一个匹配中图的每一个顶点都和某条边相关联，则称此匹配为「完全匹配」（或「完备匹配」） 图中为一个完全匹配 增广路径定义设$M$为二分图$G$已匹配边的集合，若$P$是$G$上其中一条联通两个未匹配顶点的路径（起点在$X$部，终点在$Y$部），且属$M$的边和不属$M$的边在$P$上交替出现，则称$P$为相对于$M$的一条增广路径 寻找增广路设$M$为二分图$G$所有已匹配边的集合， 如图，蓝色为在$M$里的边，黄色为不在$M$里的边 从$x_4$到$y_2$找一条路径： $x_4 \rightarrow y_3 \rightarrow x_2 \rightarrow y1 \rightarrow x1 \rightarrow y2$ 这条路径就是「增广路径」 其中属于$M$的边有：${x2,y3}, {x1,y1}$ 不属于$M$的边有：${x4,y3}, {x2,y1},{x1,y2}$ 显然，不属于$M$的边比属于$M$的边要多一条 将这条增广路上的边全都「反色」，如图 可以发现，匹配仍然合法，但是匹配数多了一对 另外，单独的一条连接两个未匹配点的边显然也是增广路 那么可知，当不能再找到增广轨时，就得到了一个「最大匹配」，这就是匈牙利算法的基本思路 增广路径性质由增广路的定义可以推出下述三个结论： P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。 P经过取反操作可以得到一个更大的匹配M’。 M为G的最大匹配当且仅当不存在相对于M的增广路径。 匈牙利算法用增广路求最大匹配（称作匈牙利算法，匈牙利数学家Edmonds于1965年提出） 算法步骤 置$M$为空 找出一条增广路$P$，通过取反操作获得更大的匹配$M‘$代替$M$ 重复2直到找不出增广路 找增广路径的算法我们采用DFS的办法找一条增广路径： 从X部一个未匹配的顶点u开始，找一个未访问的邻接点v（v一定是Y部顶点）。 对于$v$，分两种情况： 如果$v$未匹配，则已经找到一条增广路 如果$v$已经匹配，则取出$v$的匹配顶点$w$($w$一定是$X$部顶点)，边$(w,v)$目前是匹配的，根据“取反”的想法，要将$(w,v)$改为未匹配，$(u,v)$设为匹配，能实现这一点的条件是看从$w$为起点能否新找到一条增广路径$P’$。如果行，则$u \rightarrow v \rightarrow P’$就是一条以$u$为起点的增广路径。 伪代码⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ \text{Algorithm 1: } $ 寻找从 $ u $ 出发的增广路径 $ DFS(u) $返回 $ \text{True} $ 表示成功匹配，$ \text{False} $ 反之⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯&nbsp;&nbsp;$ 1: \text{For each } v \in u$的邻接点&nbsp;&nbsp;$ 2: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{If } v $ 未访问过&nbsp;&nbsp;$ 3: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 标记 $ v $ 被访问过&nbsp;&nbsp;$ 4: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{If } v $ 未被匹配 或者 $ \text{DFS(}v$的匹配点$\text{)}$&nbsp;&nbsp;$ 5: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 标记 $v$ 的匹配点为 $u$，$u$ 的匹配点为 $v$&nbsp;&nbsp;$ 6: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{Return True} $&nbsp;&nbsp;$ 7: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{End If}$&nbsp;&nbsp;$ 8: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{End If}$&nbsp;&nbsp;$ 9: \text{End For} $$ 10: \text{Return False} $⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ 代码实现123456789101112131415161718192021int ans[MAXN];// ans 表示 Y 集合中每个顶点的匹配点bool vis[MAXN];memset(px, -1, sizeof px);// 用 -1 表示没有匹配bool DFS(int u) &#123; for (int e = head[u]; e; e = edge[e].next) &#123; int now = edge[e].now; if (!vis[now]) &#123; vis[now] = true; if (px[now] == -1 || DFS(px[now])) &#123; px[u] = now; // 为了方便，可以只标记 Y 到 X return true; &#125; &#125; &#125;&#125; 《HDU2063 过山车》题解题目描述RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？ Input/Output 格式 &amp; 样例Input 输入数据的第一行是三个整数$K , M , N$，分别表示可能的组合数目，女生的人数，男生的人数。$0&lt;K&lt;=1000,1&lt;=N,M&lt;=500$.接下来的$K$行，每行有两个数，分别表示女生$A_i$愿意和男生$B_j$做partner。最后一个$0$结束输入。 Output 对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。 Sample Input 123456786 3 31 11 21 32 12 33 10 Sample Output 13 解析「每个女生必须找个个男生做partner和她同坐」 好了，可以看出这是匹配问题，问你如何匹配 「Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner」 这句话告诉了我们如何建边： 123把所有女生的顶点放到集合X中，所有男生的顶点放到集合Y中，从Rabbit分别建一条到XHD的边和一条到PQK的边，从Grass分别建一条到linle的边和一条到LL的边…… 那么显然这就是一个二分图，而本题要求的就是这个二分图的最大匹配 又是一道模板题 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 500 + 10;int t[MAXN][MAXN], map[MAXN];bool vis[MAXN];int k, m, n;bool dfs(int u) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (t[u][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (!map[i] || dfs(map[i])) &#123; map[i] = u; return true; &#125; &#125; &#125; return false;&#125;int main(int argc, char *const argv[]) &#123; while (scanf("%d %d %d", &amp;k, &amp;m, &amp;n), k != 0) &#123; memset(t, 0, sizeof(t)); memset(vis, 0, sizeof(vis)); memset(map, 0, sizeof(map)); for (int i = 0; i &lt; k; ++i) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); t[x][y] = 1; &#125; int ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; memset(vis, 0, sizeof(vis)); if (dfs(i)) ++ans; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>学习笔记</tag>
        <tag>二分图</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P5019「NOIP 2013 / 2018」《铺设道路》]]></title>
    <url>%2F2019-01-23%2FLuogu-P5019%2F</url>
    <content type="text"><![CDATA[CCF：我&nbsp;抄&nbsp;我&nbsp;自&nbsp;己 本题与[洛谷P1969](https://www.luogu.org/problemnew/show/P1969)重复 代码通用 题解[传送门](/2019-01-22/Luogu-P1969)]]></content>
      <tags>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu-P5020]]></title>
    <url>%2F2019-01-23%2FLuogu-P5020%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1330《封锁阳光大学》]]></title>
    <url>%2F2019-01-23%2FLuogu-P1330%2F</url>
    <content type="text"><![CDATA[对子连通图的染色 题目描述曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。 阳光大学的校园是一张由N个点构成的无向图，N个点之间由M条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在与这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。 询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。 输入输出格式输入格式第一行：两个整数N，M 接下来M行：每行两个整数A，B，表示点A到点B之间有道路相连。 输出格式仅一行：如果河蟹无法封锁所有道路，则输出“Impossible”，否则输出一个整数，表示最少需要多少只河蟹。 输入输出样例输入样例#112343 31 21 32 3 输出样例#11Impossible 输入样例#21233 21 22 3 输出样例#211 说明【数据规模】 1&lt;=N&lt;=10000，1&lt;=M&lt;=100000，任意两点之间最多有一条道路。 解题思路本题的图可能不为连通图（注意这个坑） 阅读题目，我们得到了这样几条信息：「当某个点被封锁后，与这个点相连的道路就被封锁了」「当两只河蟹封锁了相邻的两个点时，他们会发生冲突」「封锁所有道路并且不发生冲突」 总结一下就是：「要求每一条边有且仅有一个点被选择，求最少能选择多少点」 然后我们就可以考虑用染色的方法做这一题 我们枚举每一个点，以当前枚举到的起点为根对这个子连通图进行 DFS 染色（因为图可能不联通），答案累加每次染色的最小数量（黑色点数量和白色点数量中最小的） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)#define head(a) Head[a].id#define nowcolor(a) Head[a].color#define visited(a) Head[a].used// 这样 define 有助于简化代码namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; int n, m, ans; int sum0, sum1; struct Graph &#123; static const int MAXN = 10000 + 10; static const int MAXM = 100000 + 10; struct Node &#123; int color, used, id; // 在一个数组中存储三个数量 Node() &#123; color = used = id = 0; &#125; &#125; Head[MAXN]; struct Edge &#123; int now, next; &#125; edge[MAXM * 2]; int cnt; inline void addEdge(int prev, int next, bool isR = true) &#123; if (isR) &#123; addEdge(next, prev, false); &#125; edge[++cnt].now = next; edge[cnt].next = head(prev); head(prev) = cnt; &#125; inline bool Color(int __id, int nowColor) &#123; // 返回 true 为成功染色， false 反之 if (visited(__id)) &#123; return nowcolor(__id) == nowColor; // 如果当前被染过不同的颜色，就失败 &#125; visited(__id) = true; nowcolor(__id) = nowColor; if (nowColor) ++sum1; else ++sum0; bool __ans = true; for (int e = head(__id); e &amp;&amp; __ans; e = edge[e].next) &#123; int now = edge[e].now; __ans = __ans &amp; Color(now, nowColor ^ 1); // 遍历与当前点相连的每一条边并 DFS &#125; return __ans; &#125; &#125; g1; void __EXIT() &#123; puts("Impossible"); exit(0); &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); m = getint(); For (i, 1, m) &#123; int prev = getint(); int next = getint(); g1.addEdge(prev, next); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (g1.visited(i)) continue; sum0 = sum1 = 0; if (!g1.Color(i, 0)) __EXIT(); ans += std::min(sum0, sum1); &#125; FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1969「NOIP 2013 / 2018」《积木大赛》]]></title>
    <url>%2F2019-01-22%2FLuogu-P1969%2F</url>
    <content type="text"><![CDATA[原&nbsp;题&nbsp;警&nbsp;告 题目描述春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，大厦可以看成由$n$块宽度为1的积木组成，第$i$块积木的最终高度需要是$h_i$。 在搭建开始之前，没有任何积木（可以看成$n$块高度为$0$的积木）。接下来每次操作，小朋友们可以选择一段连续区间$[l, r]$，然后将第 $L$块到第 $R$ 块之间（含第 $L$ 块和第 $R$块）所有积木的高度分别增加$1$。 小 $M$是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。 输入输出格式输入格式包含两行，第一行包含一个整数nn，表示大厦的宽度。 第二行包含$n$个整数，第i个整数为$h_i$。 输出格式建造所需的最少操作数。 输入输出样例输入样例1252 3 4 1 2 输出样例15 说明【样例解释】 其中一种可行的最佳方案，依次选择 $[1,5]$ $[1,3]$ $[2,3]$ $[3,3]$ $[5,5]$ 【数据范围】 对于 30\%30%的数据，有$1 ≤ n ≤ 10$； 对于 70\%70%的数据，有$1 ≤ n ≤ 1000$； 对于 100\%100%的数据，有$1 ≤ n ≤ 100000,0 ≤ h_i≤ 10000$。 解题思路真不敢相信 CCF 居然用了原题 单独把 $h_1$ 读进来，存在 $ans$ 里。 在读剩下的 $n - 1$ 个数的时候，每次判一下当前数与上一个数的关系： 如果比上一个数大，就说明我们还需要再放积木，答案累加当前数与上一个数的差； 如果没有上个数大，就说明我们之前搭积木已经能够把这摞积木放好了，自然就不需要更新了。 然后把「上一个数」更新为当前数即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; &#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; int n = 0; std::cin &gt;&gt; n; int ans = 0; std::cin &gt;&gt; ans; int lastOne = ans; for (int i = 2; i &lt;= n; ++i) &#123; int now; std::cin &gt;&gt; now; if (now &gt; lastOne) ans += (now - lastOne); lastOne = now; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1119《灾后重建》]]></title>
    <url>%2F2019-01-22%2FLuogu-P1119%2F</url>
    <content type="text"><![CDATA[让人加深对 Floyd 的理解 题目背景B地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。 题目描述给出B地区的村庄数$N$，村庄编号从$0$到$N−1$，和所有$M$条公路的长度，公路是双向的。并给出第$i$个村庄重建完成的时间$t_i$，你可以认为是同时开始重建并在第$t_i$​ 天重建完成，并且在当天即可通车。若$t_i$​为$0$则说明地震未对此地区造成损坏，一开始就可以通车。之后有$Q$个询问$(x, y, t)$，对于每个询问你要回答在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄$x$或村庄$y$在第$t$天仍未重建完成 ，则需要返回$-1$。 输入输出格式输入格式第一行包含两个正整数$N,M$，表示了村庄的数目与公路的数量。 第二行包含$N$个非负整数$t0, t_1,…, t{N-1}$，表示了每个村庄重建完成的时间，数据保证了$t0 ≤ t_1 ≤ … ≤ t{N-1}$。 接下来$M$行，每行$3$个非负整数$i, j, w$，$w$为不超过$10000$的正整数，表示了有一条连接村庄$i$与村庄$j$的道路，长度为$w$，保证$i≠j$，且对于任意一对村庄只会存在一条道路。 接下来一行也就是$M+3$行包含一个正整数$Q$，表示$Q$个询问。 接下来$Q$行，每行$3$个非负整数$x, y, t$，询问在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少，数据保证了$t$是不下降的。 输出格式共$Q$行，对每一个询问$(x, y, t)$输出对应的答案，即在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果在第$t$天无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄$x$或村庄$y$在第$t$天仍未修复完成，则输出$-1$。 输入输出样例输入样例1234567891011124 51 2 3 40 2 12 3 13 1 22 1 40 3 542 0 20 1 20 1 30 1 4 输出样例1234-1-154 说明对于$30\%$的数据，有$N≤50$； 对于$30\%$的数据，有$t_i= 0$​，其中有$20\%$的数据有$t_i = 0$且$N&gt;50$； 对于$50\%$的数据，有$Q≤100$； 对于$100\%$的数据，有 $N≤200$，$M≤N \times (N-1)/2$，$Q≤50000$，所有输入数据涉及整数均不超过$100000$。 解题思路首先 $ N \leq 200 $，那么肯定是用 Floyd Floyd 算法的本质是 DP，转移方程为 f_{i,j} = min(f_{i,j},\ f_{i,k} + f_{k,j})其中的这个 $k$ 就是「中转点」，表示当前最大能经过编号为 $k$ 的点。 明确了这些，我们再来看题。 给出每一个点状态转为「可用」的时间和所有的边，让你求任意点到点的距离。我们跑 Floyd 时，$k$ 限制了我们当前能走的点，就相当于是题目中点的「不可用」状态！再加上所有的询问都是按照时间顺序给出的，所以我们就可以利用 Floyd 的性质来做这题。 12/* -- 全局变量 -- */int now = 0; // 当前最多能走第 now 个点，也就是 Floyd 中的 k 12345678910111213141516171819202122/* -- 在函数 main() 里 -- */std::cin &gt;&gt; start &gt;&gt; end &gt;&gt; ti// 读入起止点 start end 和当前时间 tiwhile (Time[now] &lt;= ti) &#123; // 当前的点转为「可用」的时间没有超过当前时间 int k = now; // 方便理解 // 以下为标准的 Floyd for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; dis[x][y] = std::min(dis[x][y], dis[x][k] + dis[k][y]); &#125; &#125; ++now; // 这个点更新完了，往后继续更新，直到超过当前时间&#125;if ( dis[start][end] == __INF /* 无法到达 */ || Time[start] &gt; ti || Time[end] &gt; ti /* 没有转为「可用」 */) puts("-1");else printf("%d\n", dis[start][end]); // 输出答案 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 1000 + 10; int dis[MAXN][MAXN], k; int n, m, q; int ttime[MAXN];&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); m = getint(); memset(ttime, 0x3f, sizeof ttime); memset(dis, 0x3f, sizeof dis); for (int i = 0; i &lt; n; ++i) &#123; ttime[i] = getint(); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int prev = getint(); int next = getint(); int weight = getint(); dis[prev][next] = dis[next][prev] = weight; &#125; for (int i = 0; i &lt;= n; ++i) dis[i][i] = 0; q = getint(); for (int i = 1; i &lt;= q; ++i) &#123; int s = getint(); int t = getint(); int timee = getint(); int ans = 0; while (ttime[k] &lt;= timee) &#123; for (int a = 0; a &lt; n; ++a) &#123; for (int b = 0; b &lt; n; ++b) &#123; dis[a][b] = std::min(dis[a][b], dis[a][k] + dis[k][b]); &#125; &#125; ++k; &#125; if (dis[s][t] == 0x3f3f3f3f || ttime[s] &gt; timee || ttime[t] &gt; timee) ans = -1; else ans = dis[s][t]; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1341《无序字母对》]]></title>
    <url>%2F2019-01-21%2FLuogu-P1341%2F</url>
    <content type="text"><![CDATA[欧拉图板子题 题目描述给定n个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有n+1个字母的字符串使得每个字母对都在这个字符串中出现。 输入输出格式输入格式第一行输入一个正整数n。 以下n行每行两个字母，表示这两个字母需要相邻。 输出格式输出满足要求的字符串。 如果没有满足要求的字符串，请输出“No Solution”。 如果有多种方案，请输出前面的字母的ASCII编码尽可能小的（字典序最小）的方案 输入输出样例输入样例123454aZtZXtaX 输出样例1XaZtX 说明【数据规模与约定】 不同的无序字母对个数有限，n的规模可以通过计算得到。 解题思路我们考虑把每一对字母视为一条边那么这个图就是无向的（因为字母对是无序的） 题目让你求一个串，使得这个串里出现了所有的字母对，实际上就是让你求一条路径，使得所有的边都出现过 那这不就是求欧拉路吗！&lt;/big&gt;&lt;/big&gt;&lt;/big&gt; 所以这道题就完美地被转换为了欧拉路板子题 没学过欧拉路的看这里 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 256 + 233; int n; int G[MAXN][MAXN], deg[MAXN]; char __MIN_NODE = 127, __MAX_NODE = 0; std::stack&lt;char&gt; stk; inline void addEdge(char prev, char next, bool Undirected = true) &#123; ++G[prev][next]; if (Undirected) addEdge(next, prev, false); &#125; inline void deleteEdge(char prev, char next, bool Undirected = true) &#123; --G[prev][next]; if (Undirected) deleteEdge(next, prev, false); &#125; inline void Hierholzer(char s) &#123; for (char i = __MIN_NODE; i &lt;= __MAX_NODE; ++i) &#123; if (G[s][i]) &#123; deleteEdge(s, i); Hierholzer(i); &#125; &#125; stk.push(s); &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; std::ios::sync_with_stdio(false); std::cin &gt;&gt; n; For (i, 1, n) &#123; char prev, next; std::cin &gt;&gt; prev; std::cin &gt;&gt; next; addEdge(prev, next); ++deg[prev]; ++deg[next]; __MIN_NODE = std::min(__MIN_NODE, std::min(prev, next)); __MAX_NODE = std::max(__MAX_NODE, std::max(prev, next)); &#125; int odd = 0; char start = 0; for (char i = __MIN_NODE; i &lt;= __MAX_NODE; ++i) &#123; if (deg[i] != 0 &amp;&amp; deg[i] % 2 == 1) &#123; if (!start) start = i; ++odd; &#125; &#125; if (!start) start = __MIN_NODE; if (odd &amp;&amp; odd != 2) &#123; // 注意不要忘了判无解 std::cout &lt;&lt; "No Solution" &lt;&lt; std::endl; return 0; &#125; Hierholzer(start); while (!stk.empty()) &#123; std::cout &lt;&lt; stk.top(); stk.pop(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2731《骑马修栅栏 Riding the Fences》]]></title>
    <url>%2F2019-01-20%2FLuogu-P2731%2F</url>
    <content type="text"><![CDATA[欧拉图板子题 题目背景Farmer John每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。 题目描述John是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。你必须编一个程序，读入栅栏网络的描述，并计算出一条修栅栏的路径，使每个栅栏都恰好被经过一次。John能从任何一个顶点(即两个栅栏的交点)开始骑马，在任意一个顶点结束。 每一个栅栏连接两个顶点，顶点用1到500标号(虽然有的农场并没有500个顶点)。一个顶点上可连接任意多(&gt;=1)个栅栏。两顶点间可能有多个栅栏。所有栅栏都是连通的(也就是你可以从任意一个栅栏到达另外的所有栅栏)。 你的程序必须输出骑马的路径(用路上依次经过的顶点号码表示)。我们如果把输出的路径看成是一个500进制的数，那么当存在多组解的情况下，输出500进制表示法中最小的一个 (也就是输出第一位较小的，如果还有多组解，输出第二位较小的，等等)。 输入数据保证至少有一个解。 输入输出格式输入格式第1行: 一个整数F(1 &lt;= F &lt;= 1024)，表示栅栏的数目 第2到F+1行: 每行两个整数i, j(1 &lt;= i,j &lt;= 500)表示这条栅栏连接i与j号顶点。 输出格式输出应当有F+1行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。 输入输出样例输入样例1234567891091 22 33 44 24 52 55 65 74 6 输出样例123456789101234254657 说明题目翻译来自NOCOW。 USACO Training Section 3.3 解题思路「使每个栅栏都恰好被经过一次」 妥妥的欧拉路板子题啊 没学过的看这里 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = (500 + 10) &lt;&lt; 1; int G[MAXN][MAXN], n, degree[MAXN]; int __MAX_NODE = -1, __MIN_NODE = 0x7f7f7f7f; std::stack&lt;int&gt; ans; void addEdge(int from, int to) &#123; ++G[from][to]; ++G[to][from]; ++degree[from]; ++degree[to]; &#125; void Hierholzer(int s) &#123; for (int t = __MIN_NODE; t &lt;= __MAX_NODE; ++t) &#123; if (G[s][t]) &#123; --G[s][t]; --G[t][s]; Hierholzer(t); &#125; &#125; ans.push(s); &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; n = getint(); For (i, 1, n) &#123; int prev = getint(); int next = getint(); addEdge(prev, next); __MAX_NODE = std::max(__MAX_NODE, std::max(prev, next)); __MIN_NODE = std::min(__MIN_NODE, std::min(prev, next)); &#125; int start = 1, flag = 0; for (int i = 1; i &lt;= __MAX_NODE; ++i, ++start) &#123; if (degree[i] != 0 &amp;&amp; degree[i] % 2 == 1) &#123; flag = 1; break; &#125; &#125; if (flag) Hierholzer(start); else Hierholzer(1); while (!ans.empty()) &#123; putint(ans.top(), '\n'); ans.pop(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>USACO</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉图学习笔记]]></title>
    <url>%2F2019-01-18%2FEulerPath-EulerCircuit%2F</url>
    <content type="text"><![CDATA[从一个点出发走一走 约定 定义 $ (A,B) $ 表示从 $ A \rightarrow B $ 的一条边（若无特别说明，即为无向边） 定义 $ (A,B) \rightarrow (C,D) $ 表示从 $ A \rightarrow D $ ，经过 $ (A,B), (C,D) $ 两条边的路径 定义「孤立点」表示一个度为 0 的点 定义「奇顶点」表示一个度数为奇数的点 定义对于有向图 G ，将所有的有向边替换为无向边得到图 G 的基图，若图 G 的基图是连通的，则称图 G 是「弱连通图」。 $ Stack_a $ 表示标号为 $ a $ 的栈。 用 $ Stack_x = a]b]c] $ 表示 $ Stack_x $ 的层级结构，其中 $ a $ 为栈顶， $ c $ 为栈底。 $ \text{Foo} \rightarrow \text{Bar} $ 表示 $ \text{Foo} $ 里的元素 $ \text{Bar} $ （表特指） 定义如果图G中的一个路径包括每个边恰好一次，则该路径称为欧拉路径(Euler path)。如果一个回路是欧拉路径，则称为欧拉回路(Euler circuit)。具有欧拉回路的图称为欧拉图（简称E图）。具有欧拉路径但不具有欧拉回路的图称为半欧拉图。 ——百度百科 通俗地说， 对于一个图的某条路径，如果能从一个点出发将这个图的所有边都不重复地走一遍，那么这条路径就被称为欧拉路；对于一个图的某条路径，如果能从一个点出发将这个图的所有边都不重复地走一遍并回到起点，那么这条路径就被称为欧拉回路。 比如下图中的 (A,B) \rightarrow (B,C) \rightarrow (C,D) \rightarrow (D,B)就是一条欧拉路。 比如下图中的 (A,B) \rightarrow (B,C) \rightarrow (D,C) \rightarrow (C,A)就是一条欧拉回路。 判定无向图判定 无孤立点的无向图 G 为欧拉图，当且仅当图 G 连通且所有顶点的度都是偶数。 如果无向连通图有 2k 个奇顶点，则图 G 可以用 k 条路径将图 G 的每一条边经过 一次，且至少要使用 k 条路径。 无孤立点的无向图 G 为半欧拉图，当且仅当图 G 连通且 G 的奇顶点个数为 2 。 此时两个奇顶点分别为欧拉路径的起点和终点。 有向图判定 无孤立点的有向图 G 为欧拉图，当且仅当图 G 弱连通且所有顶点的入度等于出度。 对于连通有向图，所有顶点入度与出度差的绝对值之和为 2k ，则图 G 可以用 k 条路径将图 G 的每一条边经过一次，且至少要使用 k 条路径。 无孤立点的有向图 G 为半欧拉图，当且仅当图 G 弱连通，且恰有一个顶点 u 入度比出度小 1 ，一个顶点 v 入度比出度大 1 ，其余顶点入度等于出度。此时存在 u 作为起点， v 作为终点的欧拉路径。 求解Hierholzier 算法算法流程任选一起点，沿任意未访问的边走到相邻节点，直至无路可走。此时必然回到起点形成了一个回路，此时图中仍有部分边未被访问。在退栈的时候找到仍有未访问边的点，从该点为起点求出另一个回路，将该回路与之前求出的回路拼接。如此反复，直至所有的边都被访问。 比如说我们有这样一张图： 我们随便取一个点，比如说 $ 1 $，把它加入一个栈。 Stack_1 = 1]Path_1 = [\ ]我们用 $ u $ 表示 $ Stack_1 \rightarrow Top $如果当前的 $ u $ 点已没有未访问的出边，就将 $ u $ 从 $ Stack_1 $ 里弹出来，加入到 $ Path_1 $ 的前端 重复上面的过程，直到 $ Stack_1 $ 为空。 在这个过程中， Stack_1 = 2]1],\ Path_1 = [\ ]Stack_1 = 4]2]1],\ Path_1 = [\ ]Stack_1 = 1]4]2]1],\ Path_1 = [\ ]Stack_1 = 5]4]2]1],\ Path_1 = [1]Stack_1 = 6]5]4]2]1],\ Path_1 = [1]Stack_1 = 4]6]5]4]2]1],\ Path_1 = [1]Stack_1 = 2]5]4]2]1],\ Path_1 = [6,4,1]Stack_1 = 3]2]5]4]2]1],\ Path_1 = [6,4,1]Stack_1 = 5]3]2]5]4]2]1],\ Path_1 = [6,4,1] 所有的边都访问了，开始回溯存路径 Stack_1 = \ ],\ Path_1 = [1,2,4,5,2,3,6,4,1]最终答案即为 $ Path_1 $ 伪代码假装自己写的是真正的 $ \LaTeX $ ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ $ \text{Algorithm 1: Hierholzer(s)} $⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ 1: \text{while s} $ 存在未被删除的无向边 $ (s,t)\ \text{do} $$ 2: $ &nbsp;&nbsp;&nbsp;&nbsp;删除无向边 $ (s,t) $$ 3: $ &nbsp;&nbsp;&nbsp;&nbsp;$ \text{Hierholzer(t)} $$ 4: \text{End while} $$ 5: cnt \leftarrow cnt + 1$$ 6: Path[cnt] \leftarrow s$⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ 代码实现真正的代码 123456789101112131415161718const int MAXN_M = 10000;int G[MAXN_M][MAXN_M], ans[MAXN_M], cnt;void Hierholzer(int s) &#123; for (int t = __MIN_NODE; t &lt;= __MAX_NODE; ++t) &#123; // 预防数据中不出现标号为 1 的节点的情况 // __MIN_NODE 指数据中标号最小的节点的标号 // __MAX_NODE 同上 if (G[s][t]) &#123; // 使用邻接矩阵存图，更加易懂 --G[s][t]; --G[t][s]; Hierholzer(t); &#125; &#125; ans[++cnt] = s;&#125; Fluery 算法挖坑待填 例题洛谷 P2731 模板题 题解将会在不久后上传 其他事项参考资料 IOI2018 中国国家候选队论文集 洛谷 P2731 题解]]></content>
      <tags>
        <tag>图论</tag>
        <tag>学习笔记</tag>
        <tag>DFS</tag>
        <tag>图论算法</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1601《[Usaco2008 Oct]灌水》]]></title>
    <url>%2F2019-01-12%2FBZOJ1601%2F</url>
    <content type="text"><![CDATA[最小生成树板子 题目描述Farmer John已经决定把水灌到他的n(1&lt;=n&lt;=300)块农田，农田被数字1到n标记。把一块土地进行灌水有两种方法，从其他农田饮水，或者这块土地建造水库。 建造一个水库需要花费wi(1&lt;=wi&lt;=100000),连接两块土地需要花费Pij(1&lt;=pij&lt;=100000,pij=pji,pii=0). 计算Farmer John所需的最少代价。 输入输出格式输入格式*第一行：一个数n *第二行到第n+1行：第i+1行含有一个数wi *第n+2行到第2n+1行：第n+1+i行有n个被空格分开的数，第j个数代表pij。 输出格式*第一行：一个单独的数代表最小代价. 输入输出样例输入样例123456789454430 2 2 22 0 3 32 3 0 42 3 4 0 输出样例19 输出详解： Farmer John在第四块土地上建立水库，然后把其他的都连向那一个，这样就要花费3+2+2+2=9 解析很显然这道题需要最小生成树 那么是不是我们生成树之后加上根节点的$w$值就可以了？ 显然不！ 很容易就能举出反例：最小生成树的根节点$w_1=99999$，次小生成树的根节点$w_2=1$，两个生成树答案之差$ans_1 - ans_2 = 1$ 那么我们就可以考虑建一个虚拟的编号为$n + 1$的点，对于所有的点$i$以$w_i$为边权进行连接最后直接跑最小生成树即可。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; struct UnionFind &#123; static const int MAX_SIZ = 100000 + 10; int U[MAX_SIZ]; UnionFind() &#123; For (i, 1, MAX_SIZ) U[i] = i; &#125; int Find(int x) &#123; if (U[x] == x) return U[x]; return U[x] = Find(U[x]); &#125; void Union(int x, int y) &#123; int xx = Find(x); int yy = Find(y); if (xx == yy) return; U[x] = y; &#125; &#125;; struct Graph &#123; static const int MAXN = 1000 + 10; static const int MAXM = 100000 + 10; struct Node &#123; int nweight, now; Node() &#123; nweight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return nweight &gt; that.nweight; &#125; &#125;; struct Edge &#123; int now, weight, next; int raw_now, raw_next; bool operator &lt; (const Edge &amp;that) const &#123; return weight &lt; that.weight; &#125; &#125; edge[MAXM * 2]; int head[MAXN], dis[MAXN], cnt; inline void addEdge(int prev, int next, int weight, bool isR = true) &#123; if (isR) &#123; addEdge(next, prev, weight, false); &#125; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; edge[cnt].raw_next = next; edge[cnt].raw_now = prev; &#125; inline Node NewNode(int nowWeight, int now) &#123; Node tmp; tmp.nweight = nowWeight; tmp.now = now; return tmp; &#125; inline void SPFA() &#123; memset(dis, 0x7f, sizeof(dis)); std::priority_queue&lt;Node&gt; q; q.push(NewNode(0, 1)); dis[1] = 0; while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int now = NowNode.now; for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (dis[to] &gt; dis[now] + edge[e].weight) &#123; dis[to] = dis[now] + edge[e].weight; q.push(NewNode(dis[to], to)); &#125; &#125; &#125; &#125; inline int Kruskal() &#123; int ans = 0, tot = 0; UnionFind u; std::sort(edge + 1, edge + 1 + cnt); for (int i = 1; i &lt;= cnt; ++i) &#123; int eu = u.Find(edge[i].raw_now); int ev = u.Find(edge[i].raw_next); if (eu == ev) continue; u.Union(eu, ev); ans += edge[i].weight; ++tot; if (tot == cnt - 1) break; &#125; return ans; &#125; &#125; g1; int n, m;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); For (i, 1, n) g1.addEdge(i, n + 1, getint()); For (i, 1, n) &#123; For (j, 1, n) &#123; int p = getint(); g1.addEdge(i, j, p, false); &#125; &#125; FastIO::putint(g1.Kruskal(), '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>BZOJ</tag>
        <tag>USACO</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1144《最短路计数》]]></title>
    <url>%2F2019-01-12%2FLuogu-P1144%2F</url>
    <content type="text"><![CDATA[最短路“板子” 题目描述给出一个$N$个顶点$M$条边的无向无权图，顶点编号为$1-N$。问从顶点$1$开始，到其他每个点的最短路有几条。 输入输出格式输入格式第一行包含$2$个正整数$N,M$，为图的顶点数与边数。 接下来$M$行，每行$2$个正整数$x,y$，表示有一条顶点$x$连向顶点$y$的边，请注意可能有自环与重边。 输出格式共$N$行，每行一个非负整数，第$i$行输出从顶点$1$到顶点$i$有多少条不同的最短路，由于答案有可能会很大，你只需要输出 $ans \bmod 100003$后的结果即可。如果无法到达顶点$i$则输出$0$。 输入输出样例输入样例123456785 71 21 32 43 42 34 54 5 输出样例1234511124 说明$1$到$5$的最短路有$4$条，分别为$2$条$1-2-4-5$和$2$条$1-3-4-5$（由于$4−5$的边有$2$条）。 对于$20\%$的数据，$N ≤ 100$； 对于$60\%$的数据，$N ≤ 1000$； 对于$100\%$的数据，$N&lt;=1000000,M&lt;=2000000$。 解题思路稍微改一下最短路板子即可 具体就是用 ans[i] 数组记录一下到i点的最短路个数，在更新路径长度的时候判一下两条路径长度的关系即可 1234567891011121314151617const int HA = 100006;/* ... */for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (dis[to] &gt; dis[now] + edge[e].weight) &#123; // 两条路径长度不等，更新答案 dis[to] = dis[now] + edge[e].weight; ans[to] = ans[now]; q.push(NewNode(dis[to], to)); &#125; else if (dis[to] == dis[now] + edge[e].weight) &#123; // 两条路径长度相等，将答案相加 ans[to] += ans[now]; ans[to] %= HA; &#125;&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int HA = 100003; struct Graph &#123; static const int MAXN = 1000000 + 10; static const int MAXM = 2000000 + 10; struct Node &#123; int nweight, now; Node() &#123; nweight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return nweight &gt; that.nweight; &#125; &#125;; struct Edge &#123; int now, weight, next; &#125; edge[MAXM * 2]; int head[MAXN], dis[MAXN], ans[MAXN], cnt; inline void addEdge(int prev, int next, int weight, bool isR = true) &#123; if (isR) &#123; addEdge(next, prev, weight, false); &#125; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline Node NewNode(int nowWeight, int now) &#123; Node tmp; tmp.nweight = nowWeight; tmp.now = now; return tmp; &#125; inline void SPFA() &#123; memset(dis, 0x7f, sizeof(dis)); memset(ans, 0, sizeof ans); std::priority_queue&lt;Node&gt; q; q.push(NewNode(0, 1)); dis[1] = 0; ans[1] = 1; while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int now = NowNode.now; for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (dis[to] &gt; dis[now] + edge[e].weight) &#123; dis[to] = dis[now] + edge[e].weight; ans[to] = ans[now]; q.push(NewNode(dis[to], to)); &#125; else if (dis[to] == dis[now] + edge[e].weight) &#123; ans[to] += ans[now]; ans[to] %= HA; &#125; &#125; &#125; &#125; &#125; g1; int n, m;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); m = getint(); For (i, 1, m) &#123; int prev = getint(); int next = getint(); g1.addEdge(prev, next, 1); &#125; g1.SPFA(); For (i, 1, n) &#123; FastIO::putint(g1.ans[i], '\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1126《机器人搬重物》]]></title>
    <url>%2F2019-01-10%2FLuogu-P1126%2F</url>
    <content type="text"><![CDATA[有直径还写个锤 题目描述机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径$1.6$米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个$N \times M$的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：向前移动$1$步（Creep）；向前移动$2$步（Walk）；向前移动$3$步（Run）；向左转（Left）；向右转（Right）。每个指令所需要的时间为$1$秒。请你计算一下机器人完成任务所需的最少时间。 输入输出格式输入格式第一行为两个正整数$N,M(N,M \le 50)$，下面$N$行是储藏室的构造，$0$表示无障碍，$1$表示有障碍，数字之间用一个空格隔开。接着一行有$4$个整数和$1$个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东$E$，南$S$，西$W$，北$N$），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。 输出格式：一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出$−1$。 输入输出样例输入样例12345678910119 100 0 0 0 0 0 1 0 0 00 0 0 0 0 0 0 0 1 00 0 0 1 0 0 0 0 0 00 0 1 0 0 0 0 0 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 1 0 0 0 00 0 0 1 1 0 0 0 0 00 0 0 0 0 0 0 0 0 01 0 0 0 0 0 0 0 1 07 2 2 7 S 输出样例112 解题思路1.&nbsp;将格子图转为点图 &amp; 障碍物判断要注意这个机器人是有直径的，所以边界和障碍物的四周都不能走 123456789for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int ttt; scanf("%d", &amp;ttt); if (ttt) &#123; map[i][j] = map[i][j - 1] = map[i - 1][j] = map[i - 1][j - 1] = 1; &#125; &#125;&#125; 2.单向 BFS枚举所有的步数和方向 3.三维数组判重要注意本题是有方向的，所以vis数组需要开三维（vis[N][M][方向]） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int dx[] = &#123; 0, 1, 0, -1 &#125;; const int dy[] = &#123; 1, 0, -1, 0 &#125;; const int MAXN_M = 50 + 10; struct Robot &#123; int x, y; int dir; int step; &#125;; std::queue&lt;Robot&gt; q; bool vis[MAXN_M][MAXN_M][4]; bool map[MAXN_M][MAXN_M]; int n, m; int startx, starty, endx, endy, sd; char startdir;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int ttt; scanf("%d", &amp;ttt); if (ttt) &#123; map[i][j] = map[i][j - 1] = map[i - 1][j] = map[i - 1][j - 1] = 1; &#125; &#125; &#125; scanf("%d %d %d %d %c", &amp;startx, &amp;starty, &amp;endx, &amp;endy, &amp;startdir); switch(startdir) &#123; case 'E': &#123; sd = 0; break; &#125; case 'S': &#123; sd = 1; break; &#125; case 'W': &#123; sd = 2; break; &#125; default: &#123; sd = 3; break; &#125; &#125; // 对方向进行处理 if (startx &gt;= n || startx &lt; 1 || starty &gt;= m || starty &lt; 1 || map[startx][starty]) &#123; puts("-1"); return 0; &#125; Robot rb; rb.x = startx; rb.y = starty; rb.dir = sd; rb.step = 0; vis[startx][starty][sd] = true; q.push(rb); // 开始 BFS while (!q.empty()) &#123; rb = q.front(); q.pop(); int newx = rb.x; int newy = rb.y; if (newx == endx &amp;&amp; newy == endy) &#123; printf("%d\n", rb.step); return 0; &#125; // 枚举步数 for (int steps = 1; steps &lt;= 3; ++steps) &#123; newx += dx[rb.dir]; newy += dy[rb.dir]; if (newx &lt; 1 || newx &gt;= n || newy &lt; 1 || newy &gt;= m || map[newx][newy]) &#123; break; &#125; if (!vis[newx][newy][rb.dir]) &#123; vis[newx][newy][rb.dir] = true; Robot nown; nown.x = newx; nown.y = newy; nown.dir = rb.dir; nown.step = rb.step + 1; q.push(nown); &#125; &#125; // 更新步数 Robot nown = rb; ++nown.step; --nown.dir; if (nown.dir == -1) nown.dir = 3; if (!vis[nown.x][nown.y][nown.dir]) &#123; vis[nown.x][nown.y][nown.dir] = true; q.push(nown); &#125; nown.dir = rb.dir + 1; if (nown.dir == 4) nown.dir = 0; if (!vis[nown.x][nown.y][nown.dir]) &#123; vis[nown.x][nown.y][nown.dir] = true; q.push(nown); &#125; &#125; puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>BFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1141《01迷宫》]]></title>
    <url>%2F2019-01-10%2FLuogu-P1141%2F</url>
    <content type="text"><![CDATA[DFS 联通块 题目描述有一个仅由数字$0$与$1$组成的$n \times n$格迷宫。若你位于一格$0$上，那么你可以移动到相邻$4$格中的某一格$1$上，同样若你位于一格$1$上，那么你可以移动到相邻$4$格中的某一格$0$上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入输出格式输入格式第11行为两个正整数$n,m$。 下面$n$行，每行$n$个字符，字符只可能是$0$或者$1$，字符之间没有空格。 接下来$m$行，每行$2$个用空格分隔的正整数$i,j$，对应了迷宫中第$i$行第$j$列的一个格子，询问从这一格开始能移动到多少格。 输出格式$m$行，对于每个询问输出相应答案。 输入输出样例输入样例123452 201101 12 2 输出样例1244 说明所有格子互相可达。 对于$20\%20$的数据，$n≤10$； 对于$40\%$的数据，$n≤50$； 对于$50\%$的数据，$m≤5$； 对于$60\%$的数据，$n≤100,m≤100$； 对于$100\%$的数据，$n≤1000,m≤100000$。 解题思路首先我们可以知道一个联通块内的所有格子的答案相同 那么我们就直接找联通块，这个联通块内的所有格子的答案都是这个联通块的格子个数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int dx[] = &#123;0, 1, -1, 0, 0&#125;; const int dy[] = &#123;0, 0, 0, -1, 1&#125;; const int MAXN = 1000 + 10; char mp[MAXN][MAXN]; bool vis[MAXN][MAXN]; int n, m, nowans; int xans[MAXN * MAXN], yans[MAXN * MAXN]; int ans[MAXN][MAXN]; void Search(int x, int y) &#123; ++nowans; xans[nowans] = x; yans[nowans] = y; for (int i = 1; i &lt;= 4; ++i) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (!(nx &lt;= 0 || nx &gt; n || ny &lt;= 0 || ny &gt; n) &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] != mp[x][y]) &#123; vis[nx][ny] = true; Search(nx, ny); &#125; &#125; &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; scanf("%d %d", &amp;n, &amp;m); For (i, 1, n) &#123; scanf("%s", mp[i] + 1); &#125; For (i, 1, n) &#123; For (j, 1, n) &#123; if (!vis[i][j]) &#123; vis[i][j] = true; nowans = 0; Search(i, j); for (int no = 1; no &lt;= nowans; ++no) &#123; ans[xans[no]][yans[no]] = nowans; &#125; &#125; &#125; &#125; For (i, 1, m) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); printf("%d\n", ans[x][y]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1629《邮递员送信》]]></title>
    <url>%2F2019-01-10%2FLuogu-P1629%2F</url>
    <content type="text"><![CDATA[一个正向图，一个反向图 题目描述有一个邮递员要送东西，邮局在节点1.他总共要送N-1样东西，其目的地分别是2~N。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有M条道路，通过每条道路需要一定的时间。这个邮递员每次只能带一样东西。求送完这N-1样东西并且最终回到邮局最少需要多少时间。 输入输出格式输入格式第一行包括两个整数N和M。 第2到第M+1行，每行三个数字U、V、W，表示从A到B有一条需要W时间的道路。 满足1&lt;=U,V&lt;=N,1&lt;=W&lt;=10000,输入保证任意两点都能互相到达。 【数据规模】 对于30%的数据，有1≤N≤200; 对于100%的数据，有1≤N≤1000,1≤M≤100000。 输出格式输出仅一行，包含一个整数，为最少需要的时间。 输入输出样例输入样例12345678910115 102 3 51 5 53 5 61 2 81 3 85 3 44 1 84 5 33 5 65 4 2 输出样例183 解题思路类似题目：洛谷P1821《[USACO07FEB]银牛派对Sliver Cow Party》题解：洛谷P1821 《[USACO07FEB]银牛派对Silver Cow Party》 对于这类题目，我们考虑建一个反向（所有边的方向都相反）的图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct Graph &#123; static const int MAXN = 1000 + 10; static const int MAXM = 100000 + 10; struct Node &#123; int nweight, now; Node() &#123; nweight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return nweight &gt; that.nweight; &#125; &#125;; struct Edge &#123; int now, weight, next; &#125; edge[MAXM * 2]; int head[MAXN], dis[MAXN], cnt; inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline Node NewNode(int nowWeight, int now) &#123; Node tmp; tmp.nweight = nowWeight; tmp.now = now; return tmp; &#125; inline void SPFA() &#123; // 最短路 // 一块写进去更方便 memset(dis, 0x7f, sizeof(dis)); std::priority_queue&lt;Node&gt; q; q.push(NewNode(0, 1)); dis[1] = 0; while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int now = NowNode.now; for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (dis[to] &gt; dis[now] + edge[e].weight) &#123; dis[to] = dis[now] + edge[e].weight; q.push(NewNode(dis[to], to)); &#125; &#125; &#125; &#125; &#125;; 这里我选择一个稍微懒一点的方法，将图存到一个结构体里面，创建的时候只要 Graph g1, g2; 即可。 最后答案即为 \sum_{i = 1}^{n} \text{g1.dis}[i] + \text{g2.dis}[i]代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; struct Graph &#123; static const int MAXN = 1000 + 10; static const int MAXM = 100000 + 10; struct Node &#123; int nweight, now; Node() &#123; nweight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return nweight &gt; that.nweight; &#125; &#125;; struct Edge &#123; int now, weight, next; &#125; edge[MAXM * 2]; int head[MAXN], dis[MAXN], cnt; inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline Node NewNode(int nowWeight, int now) &#123; Node tmp; tmp.nweight = nowWeight; tmp.now = now; return tmp; &#125; inline void SPFA() &#123; memset(dis, 0x7f, sizeof(dis)); std::priority_queue&lt;Node&gt; q; q.push(NewNode(0, 1)); dis[1] = 0; while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int now = NowNode.now; for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (dis[to] &gt; dis[now] + edge[e].weight) &#123; dis[to] = dis[now] + edge[e].weight; q.push(NewNode(dis[to], to)); &#125; &#125; &#125; &#125; &#125; g1, g2; int n, m;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); m = getint(); For (i, 1, m) &#123; int prev = getint(); int next = getint(); int weight = getint(); g1.addEdge(prev, next, weight); g2.addEdge(next, prev, weight); &#125; g1.SPFA(); g2.SPFA(); int ans = 0; For (i, 1, n) &#123; ans += g1.dis[i] + g2.dis[i]; &#125; FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2984《[USACO10FEB]给巧克力Chocolate Giving》]]></title>
    <url>%2F2019-01-10%2FLuogu-P2984%2F</url>
    <content type="text"><![CDATA[此时一位单身🐂路过 题目描述Farmer John有B头奶牛$(1&lt;=B&lt;=25000)$，有$N(2*B&lt;=N&lt;=50000)$个农场，编号$1\rightarrow N$，有$M(N-1&lt;=M&lt;=100000)$条双向边，第$i$条边连接农场$R_i$和$S_i(1&lt;=R_i&lt;=N;1&lt;=S_i&lt;=N)$，该边的长度是$L_i(1&lt;=L_i&lt;=2000)$。居住在农场$P_i$的奶牛$A(1&lt;=P_i&lt;=N)$，它想送一份新年礼物给居住在农场$Q_i(1&lt;=Q_i&lt;=N)$的奶牛$B$，但是奶牛$A$必须先到FJ(居住在编号$1$的农场)那里取礼物，然后再送给奶牛$B$。你的任务是：奶牛$A$至少需要走多远的路程？ 输入输出格式输入格式第一行：三个用空格隔开的整数$N$,$M$和$B$。 第二到$M+1$行：第$i+1$行用$R_i$，$S_i$和$L_i$三个用空格隔开的整数描述双向边$i$。 第$M+2$到$M+B+1$行：第$M+i+1$行包含两个用空格隔开的整数$P_i$和$Q_i$。 输出格式第一到$B$行：第$i$行包括一个整数，居住在农场$P_i$的公牛从FJ那里取得情人节巧克力后送给他居住在农场$Q_i$的梦中情牛至少需要走的距离。 输入输出样例输入样例12345678910116 7 3 1 2 3 5 4 3 3 1 1 6 1 9 3 4 2 1 4 4 3 2 2 2 4 5 1 3 6 输出样例1236610 解题思路这道题就是给你一张图和多个询问，对于每个询问，求两个点到点$1$的最短路径之和。 由于双向边的最短路可逆，我们可以得出下面的结论： 对于两条边$(i,j)$和$(j,i)$，有 $dis{(i,j)} = dis{(j,i)}$ 所以我们只需要预处理出点$1$到其他所有点的最短路，然后对于每个询问$P,Q$输出 $dis{(1,P)} + dis{(1,Q)}$ 即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 50000 + 10; const int MAXM = 100000 + 10; struct Node &#123; int now, weight; Node() &#123; now = weight = 0; &#125; Node(int now, int weight) : now(now), weight(weight) &#123;&#125; bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125; &#125;; Node NewNode(int now, int weight) &#123; Node tmp; tmp.now = now; tmp.weight = weight; return tmp; &#125; struct Edge &#123; int now, next, weight; &#125; edge[MAXM * 2]; int n, m, b, cnt, head[MAXN], dis[MAXN]; inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline void SFPA(int s) &#123; // 要注意的是 // 据说这题不卡 SPFA // 但为保险起见 // 我还是选择 Dijkstra memset(dis, 0x7f7f7f7f, sizeof dis); dis[s] = 0; std::priority_queue&lt;Node&gt; q; q.push(NewNode(s, 0)); while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int nownode = NowNode.now; for (int e = head[nownode]; e; e = edge[e].next) &#123; int now = edge[e].now; if (dis[now] &gt; dis[nownode] + edge[e].weight) &#123; dis[now] = dis[nownode] + edge[e].weight; q.push(NewNode(now, dis[now])); &#125; &#125; &#125; &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); m = getint(); b = getint(); For (i, 1, m) &#123; int prev = getint(); int next = getint(); int weight = getint(); addEdge(prev, next, weight); addEdge(next, prev, weight); &#125; SFPA(1); // 预处理出最短路 For (i, 1, b) &#123; int a = getint(); int b = getint(); int ans = dis[a] + dis[b]; // 转化过的问题的答案，也是最终答案 FastIO::putint(ans, '\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>USACO</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3879《[TJOI2010]阅读理解》]]></title>
    <url>%2F2018-12-26%2FLuogu-P3879%2F</url>
    <content type="text"><![CDATA[实在是一道练习 std::map 的好题啊 题目链接 题目描述英语老师留了N篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。 输入输出格式输入格式第一行为整数 $N$，表示短文篇数，其中每篇短文只含空格和小写字母。 按下来的 $N$行，每行描述一篇短文。每行的开头是一个整数 $L$，表示这篇短文由 $L$个单词组成。接下来是 $L$个单词，单词之间用一个空格分隔。 然后为一个整数 $M$，表示要做几次询问。后面有 $M$行，每行表示一个要统计的生词。 输出格式对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。 输入输出样例输入样例1234567891039 you are a good boy ha ha o yeah13 o my god you like bleach naruto one piece and so do i11 but i do not think you will get all the points5youioallnaruto 输出样例123451 2 32 31 232 其他说明对于30%的数据，1 ≤ M ≤ 1,000 对于100%的数据，1 ≤ M ≤ 10,000，1 ≤ N ≤ 1000 每篇短文长度（含相邻单词之间的空格） ≤ 5,000 字符，每个单词长度 ≤ 20 字符 解题思路Trie？Hash？KMP？Aho-Corasick Automaton？ 统统不要！&lt;/big&gt;&lt;/big&gt; 这可是练习 std::map 的一道好题啊！ 我们考虑开一个 std::map&lt;std::string, std::vector&lt;int&gt; &gt;，其中下标为每个单词，元素为这个单词对应在哪几个句子中出现过（所以要用 std::vector&lt;int&gt; 啊） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; std::map&lt;std::string, std::vector&lt;int&gt; &gt; mp; int n, m; std::string s;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; std::ios::sync_with_stdio(false); using std::cin; using std::cout; using std::endl; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int p; cin &gt;&gt; p; for (int j = 1; j &lt;= p; ++j) &#123; cin &gt;&gt; s; mp[s].push_back(i); // 记录当前单词在哪几个句子里出现过 &#125; &#125; cin &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; s; int siz = (int) mp[s].size(); for (int j = 0; j &lt; siz; ++j) &#123; if (j != 0 &amp;&amp; mp[s][j] == mp[s][j-1]) continue; // 手动去重 cout &lt;&lt; mp[s][j]; // 输出 if (j != siz - 1) cout &lt;&lt; ' '; // 输出行中空格 &#125; cout &lt;&lt; endl; // 输出回车键 &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图染色学习笔记]]></title>
    <url>%2F2018-12-08%2FUVA10004-Bipartite-Graph-Coloring%2F</url>
    <content type="text"><![CDATA[本质上就是一个 BFS 模板题目地址 算法简介二分图是这样一个图：有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！无向图$G$为二分图的充分必要条件是，$G$至少有两个顶点,且其所有回路的长度均为偶数。判断二分图的常见方法是染色法： 开始对任意一未染色的顶点染色，之后判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色， 若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断，bfs和dfs可以搞定！ ——百度百科 算法流程我一般习惯用 BFS 做二分图染色，因为这样会更好理解。 首先我们确定一个搜索的起点start，一般我确定为$1$。 将这个起点Push()进你的广搜队列中，并将它随便指定为一种颜色（即染色），我一般习惯用1和-1。要注意的是尽量不要使用0，因为染色的color[]数组同时兼顾着vis[]数组的作用。 每次在队列中取出队头，并遍历每一条与它相连的边。 A. 如果当前邻接点 被染过与它相同的颜色，则直接失败。 B. 如果当前节点没被染过色，就将它加入队列。 C. 不管当前邻接点 染没染过色，将它染上与当前节点不同的颜色。 如果整个过程没有失败，则染色成功。 题目描述PDF源文件 输入输出格式输入格式： 输出格式： 输入输出样例1234567891011121314151617181920330 11 22 0320 11 2980 10 20 30 40 50 60 70 80 123NOT BICOLORABLE.BICOLORABLE.BICOLORABLE. 解题思路见上 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)#define RED 1;#define BLUE -1;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 200 + 10; const int MAXM = MAXN * MAXN + 10; struct Node &#123; int now, weight; Node() &#123; now = weight = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125; &#125;; struct Edge &#123; int now, next; Edge() &#123; now = next = 0; &#125; &#125; edge[MAXM]; int head[MAXN], cnt, n, l; short color[MAXN]; inline void Init() &#123; cnt = 0; memset(head, 0, sizeof(head)); memset(color, 0, sizeof(color)); for (int i = 1; i &lt;= cnt + 5; ++i) &#123; Edge tmp; tmp.now = tmp.next = 0; edge[i] = tmp; &#125; &#125; inline void addEdge(int prev, int next) &#123; edge[++cnt].now = next; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline bool BoynextdoorFirstSearch(int start = 1) &#123; std::queue&lt;int&gt; q; q.push(start); color[start] = RED; while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (color[to] == color[now]) return false; if (color[to] == 0) q.push(to); if (color[now] == 1) &#123; color[to] = -1; &#125; else &#123; color[to] = 1; &#125; &#125; &#125; return true; &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; while (true) &#123; n = getint(); if (n == 0) break; l = getint(); Init(); for (int i = 1; i &lt;= l; ++i) &#123; int prev = getint(); int next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; if (BoynextdoorFirstSearch()) puts("BICOLORABLE."); else puts("NOT BICOLORABLE."); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>BFS</tag>
        <tag>图论算法</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1073B 《Vasya and Books》]]></title>
    <url>%2F2018-12-08%2FCF1073B%2F</url>
    <content type="text"><![CDATA[很明显是栈了好吧 题目地址 题目大意给定 $n$ 本书,序号分别为$1$到$n$，现在执行$n$个操作， 第$i$个操作需要从栈内取出编号为$b_i$的书，如果该书已经取出，则输出$0$否则将该书从栈内取出，同时取出在栈内比$b_i$靠上的书，并且输出一共取出了几本书 输入输出格式输入格式The first line contains one integer $n~(1 \le n \le 2 \cdot 10^5)$ — the number of books in the stack. The second line contains $n$ integers $a_1, a_2, \dots, a_n~(1 \le a_i \le n)$ denoting the stack of books. The third line contains n n integers $b_1, b_2, \dots, b_n~(1 \le b_i \le n)$ denoting the steps Vasya is going to perform. All numbers $a_1 \dots a_n$ are distinct, the same goes for $b_1 \dots b_n$ . 输出格式Print $n$ integers. The $i$ -th of them should be equal to the number of books Vasya moves to his backpack during the $i$ -th step. 输入输出样例#112331 2 32 1 3 12 0 1 #212353 1 4 2 54 5 1 3 2 13 2 0 0 0 #312366 5 4 3 2 16 5 3 4 2 1 11 1 2 0 1 1 解析本文同步发布于洛谷博客 粗略看了一下 貌似没人和我的解法相同 那就来写一发题解吧 在读入的时候 我们用另一个数组lead[i]来存编号为i的书在读入的数组book[]的下标 这样我们在检测读入的书是否被取出时就不用遍历一遍book[] 弹出书本的时候，我们首先看一下这个书本是否被取出 如果是就直接输出0 否则就开始弹出书本 我们用一个变量now = 0记录当前弹出了几个书本，用一个数组vis[i]记录第i本书是否被弹出 在弹出之前，用一个变量orin记录一下还没更新的now 接着在每次弹出的时候更新vis[++now]为真，直到遇到当前要弹出的书本编号 最后orin - now即为答案 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;stack&gt;using std::cin;using std::cout;using std::endl;using std::string;const int MAXN = 2e5 + 10;int n;int book[MAXN];int lead[MAXN];bool vis[MAXN];int now = 0;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", book + i); lead[book[i]] = i; // 让lead[]作为book[]的索引，查找的时候快一些 &#125; for (int i = 1; i &lt;= n; ++i) &#123; int o; scanf("%d", &amp;o); if (vis[lead[o]]) printf("0 "); // 被弹过了，输出0 else &#123; int orin = now; while (book[++now] != o) &#123; vis[now] = true; // 循环更新vis（弹出书本） &#125; vis[now] = true; printf("%d ", now - orin); &#125; &#125; return 0;&#125; 总感觉自己的代码能被 Hack]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4568《飞行路线》]]></title>
    <url>%2F2018-11-25%2FBZOJ2763-Luogu-P4568-JLOI2011%2F</url>
    <content type="text"><![CDATA[入门级别的分层图最短路 题目地址双倍经验 前言先介绍一下分层图最短路。 分层图最短路是指在可以进行分层图的图上解决最短路问题。一般模型是：在图上，有k次机会可以直接通过一条边，问起点与终点之间的最短路径。 题目描述Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在nn个城市设有业务，设这些城市分别标记为00到n-1n−1，一共有mm种航线，每种航线连接两个城市，并且航线有一定的价格。 Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多kk种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？ 输入输出格式输入格式数据的第一行有三个整数，n,m,k，分别表示城市数，航线数和免费乘坐次数。 第二行有两个整数，s,t，分别表示他们出行的起点城市编号和终点城市编号。 接下来有m行，每行三个整数，a,b,c，表示存在一种航线，能从城市a到达城市b，或从城市b到达城市a，价格为c。 输出格式只有一行，包含一个整数，为最少花费。 输入输出样例输入样例#1： 123456785 6 10 40 1 51 2 52 3 53 4 52 3 30 2 100 输出样例#1： 18 解题思路这就是分层图最短路的模板但为什么是省选/NOI-呢 我们用DP的思想来看设dis[i][j]表示起点到i点在j层的最短路 如何分层？理解性记忆。例如本题最多有十层，第k层表示免费了k次的最短路 如何跑最短路？洛谷卡SPFA，BZOJ不卡SPFA，但是都要注意把空间开大10倍，不然是过不去的（5次TLE的惨痛经验）在跑 Dijkstra 的时候，我们用了一个pair来存当前到达的点和已走过的路径；这次我们需要多维护一个东西：当前的层数。 1234567891011121314struct Node &#123; int id; // 当前到达的点 int weight; // 已走过的路径 int now; // 当前的层数 Node() &#123; id = weight = now = 0; &#125; // 重载运算符，用于优先队列 bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125;&#125;; 在更新dis的时候，我们需要对这一层的点和下一层的点分别进行更新 123456789if (!vis[to][Floor] &amp;&amp; dis[to][Floor] &gt; dis[now][Floor] + edge[e].weight) &#123; dis[to][Floor] = dis[now][Floor] + edge[e].weight; q.push(NewNode(to, dis[to][Floor], Floor));&#125;if (!vis[to][Floor] &amp;&amp; Floor + 1 &lt;= K &amp;&amp; dis[to][Floor + 1] &gt; dis[now][Floor]) &#123; dis[to][Floor + 1] = dis[now][Floor]; q.push(NewNode(to, dis[to][Floor + 1], Floor + 1));&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; const int MAXM = 500000 + 10; const int MAXK = 10 + 5; struct Node &#123; int id, weight, now; Node() &#123; id = weight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125; &#125; head[MAXN]; struct Edge &#123; int now, next, weight; &#125; edge[MAXM]; int n, m, k, s, t, K, cnt, dis[MAXN][MAXK]; bool vis[MAXN][MAXK]; inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev].id; head[prev].id = cnt; &#125; Node NewNode(int id, int weight, int now) &#123; Node tmp; tmp.id = id; tmp.weight = weight; tmp.now = now; return tmp; &#125; void SPFA() &#123; memset(dis, 0x7f, sizeof(dis)); std::priority_queue&lt;Node&gt; q; For (i, 0, K) dis[s][i] = 0; q.push(NewNode(s, 0, 0)); while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int Floor = NowNode.now; int now = NowNode.id; if (vis[now][Floor]) continue; vis[now][Floor] = true; for (int e = head[now].id; e; e = edge[e].next) &#123; int to = edge[e].now; if (!vis[to][Floor] &amp;&amp; dis[to][Floor] &gt; dis[now][Floor] + edge[e].weight) &#123; dis[to][Floor] = dis[now][Floor] + edge[e].weight; q.push(NewNode(to, dis[to][Floor], Floor)); &#125; if (!vis[to][Floor] &amp;&amp; Floor + 1 &lt;= K &amp;&amp; dis[to][Floor + 1] &gt; dis[now][Floor]) &#123; dis[to][Floor + 1] = dis[now][Floor]; q.push(NewNode(to, dis[to][Floor + 1], Floor + 1)); &#125; &#125; &#125; &#125;&#125;signed main() &#123; using namespace Solution; using FastIO::getint; n = getint(); m = getint(); k = getint(); s = getint(); t = getint(); K = k; For (i, 1, m) &#123; int prev = getint(); int next = getint(); int weight = getint(); addEdge(prev, next, weight); addEdge(next, prev, weight); &#125; SPFA(); int ans = 2147482333; for (int i = 0; i &lt;= k; ++i) &#123; ans = std::min(ans, dis[t][i]); &#125; FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>省选</tag>
        <tag>最短路</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的 PC 更加安全]]></title>
    <url>%2F2018-11-24%2FSecureYourPC%2F</url>
    <content type="text"><![CDATA[Password: 🔑 前言今天（2018.11.24）中午时分我被 Logey 绑住胳膊眼睁睁地看着 RainAir 机惨我RainAir 删除了我的用户密码Shq 修改了我的博客文件折腾了一个中午才恢复过来因为这样 我决定写下这篇文章 简介关于加密┌────────────┐│加密，是以某种特殊的算法││改变原有的信息数据，使得││未授权的用户即使获得了已││加密的信息，但因不知解密││的方法，仍然无法了解信息││的内容。 ——百度百科&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;│└────────────┘ 为什么要加密先不谈什么数据泄露、隐私恶意利用等诸如此类的事，我们来看机惨 一次机惨，轻则「I AK ***」，重则rm -rf / --no-preserve-root 所以锁好自己的电脑是非常重要的 Windows &amp; macOS 通用解决方案当然是设好自己的密码。尽量设复杂且好记的密码，并且保证自己打这个密码的速度足够快，不会让人记住。有生物识别系统的可以考虑安全性高的生物识别系统，像目前已经成熟的「指纹识别」和「Windows Hello」。 macOS 独占解决方案固件密码在开机时按住「⌘+R」，进入恢复模式；点击菜单栏中的「实用工具」，点击「启动安全性实用工具」；输入自己的密码并记牢；最后直接重启即可生效。 用途？设定固件密码之后，进入恢复模式就需要密码了。同样是在恢复模式下，用命令resetpassword可以更改密码！ FileVaultFileVault 会自动直接地对主目录的内容进行加密和解密。真正的安全感来自知道在没有获得允许的时候，没有人可以翻看你的文件。FileVault 使用最新的政府安全标准来保护你的辛勤劳动成果。它保护你主文件夹上的所有信息不被窥测，因此你的商业机密、假期购物单、以及个人财政记录仍然是秘密。FileVault 使用128位高级加密标准 Advanced Encryption Standard 对你主目录下的所有内容进行加密。这个高性能的算法会自动实时加密和解密，因此你甚至不知道它的发生。 ——百度百科 打开方式：「系统偏好设置」→「安全性与隐私」→「文件保险箱」 Time MachineTime Machine 是自动备份功能的一大突破，它内建於 Mac OS X，能为 Mac 上的一切建立最新拷贝，包括数位相片、音乐、家庭影片与文件。现在，只要您有需要，就能轻易回到过去恢复任何资料。 ——百度百科这种方法主要是用来预防被机惨后发生的所有特殊情况，例如博客文件被覆盖，重要文件丢失等等。打开方式：「系统偏好设置」→「时间机器」 加密映像如果有什么东西你想要用密码保护，那加密的映像确实是最好的工具。 方法：「Spotlight Search」Disk Utility.app【文件】【新建映像】【来自文件夹的映像】注意：映像默认只读，如果想让映像可读写，就必须要在「映像格式」里将「压缩」改成「读/写」 Windows 独占解决方案这里其实上面说的东西，Windows 都有替代品。固件密码有 BIOS 里的 Secure Lock，加密映像可以用 UltraISO，磁盘加密可以用 BitLocker ……]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>只有经历过的人才知道的世界</tag>
        <tag>使用指南</tag>
        <tag>优化</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2010《回文日期》]]></title>
    <url>%2F2018-11-10%2FLuogu-P2010%2F</url>
    <content type="text"><![CDATA[枚举+判断 题目描述在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。 牛牛习惯用88位数字表示一个日期，其中，前44位代表年份，接下来22位代表月 份，最后22位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。 牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。现 在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存 在的日期是回文的。 一个88位数字是回文的，当且仅当对于所有的i ( 1 \le i \le 8)i(1≤i≤8)从左向右数的第i个 数字和第9-i9−i个数字（即从右向左数的第ii个数字）是相同的。 例如： •对于2016年11月19日，用88位数字2016111920161119表示，它不是回文的。 •对于2010年1月2日，用88位数字2010010220100102表示，它是回文的。 •对于2010年10月2日，用88位数字2010100220101002表示，它不是回文的。 每一年中都有1212个月份： 其中，1,3,5,7,8,10,121,3,5,7,8,10,12月每个月有3131天；4,6,9,114,6,9,11月每个月有3030天；而对于22月，闰年时有2929天，平年时有2828天。 一个年份是闰年当且仅当它满足下列两种情况其中的一种： 1.这个年份是44的整数倍，但不是100100的整数倍； 2.这个年份是400400的整数倍。 例如： •以下几个年份都是闰年：2000,2012,20162000,2012,2016。 •以下几个年份是平年：1900,2011,20141900,2011,2014。 Input / Output 格式 &amp; 样例输入格式两行，每行包括一个88位数字。 第一行表示牛牛指定的起始日期。 第二行表示牛牛指定的终止日期。 保证 $date_i$和都是真实存在的日期，且年份部分一定为4位数字，且首位数字不为0。 保证 $date_1$—定不晚于 $date_2$ 。 输出格式一个整数，表示在$date_1$和$date_2$之间，有多少个日期是回文的。 输入输出样例输入样例#1： 122011010120111231 输出样例#1： 11 输入样例#2： 122000010120101231 输出样例#2： 12 说明【样例说明】 对于样例1，符合条件的日期是20111102。 对于样例2，符合条件的日期是20011002和20100102。 【子任务】 对于$60\%$的数据，满足$date1 = date2$。 解题思路我们考虑直接枚举月和日。 对于每一个月，我们用M[i]表示第i月有多少天。这里要注意的是不用单独判闰年，2月29对应的是92200229，而9220是闰年。 构建字符串直接参照代码，最后比较一下即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */#define GetMonth(x) ((x / 100) % 100)#define GetDay(x) (x % 100)#define GetYear(x) (x / 10000)#define isFullYear(x) ((GetYear(x) % 400 == 0) || (GetYear(x) % 10 == 0 &amp;&amp; GetYear(x) % 4 != 0))using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int M[12 + 1] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int start; int endd; int ans;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; cin &gt;&gt; start; cin &gt;&gt; endd; for (int i = 1; i &lt;= 12; ++i) &#123; for (int j = 1; j &lt;= M[i]; ++j) &#123; int now = 0; now += j; now += i * 100; now += 10000000 * (j % 10); now += 1000000 * (j / 10); now += 100000 * (i % 10); now += 10000 * (i / 10); if (start &lt;= now &amp;&amp; now &lt;= endd) ++ans; &#125; &#125; FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>枚举</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LYOI初中坑题组」模拟赛#2 题解]]></title>
    <url>%2F2018-11-05%2FLYOI-Mid-KT-Team-Contest2%2F</url>
    <content type="text"><![CDATA[暴力能过的题目 前言题面 &amp; 数据依然来自山河 评测 Powered by 洛谷OnlineJudge T1. 复制-粘贴题目描述小 y 是一个聪明的程序员，但是他懒到了极致，在输入程序时甚至不愿意多打一行代码。 有一次，小 y 发现他的一个程序需要输入 n 行一模一样的代码，怎么办呢？ 他首先输入了第 1 行，然后通过 1 次“复制-粘贴”命令得到了第 2 行，再通过 1 次“复制-粘贴”命令得到了第 3-4 行………..直到完成这 n 行代码的输入。 小 y 懒得得意洋洋，正好遇到初学编程的小 x，他就想考考小 x，顺便为难为难他以炫耀自己的聪明才智和编程水平。于是把“复制-粘贴”的伎俩告诉小 x，并让小 x 编程计算最少通过几次“复制-粘贴”命令可以得到正好 n 行的代码？ 输入输出格式输入格式：一行一个正整数 n, 输出格式：一行一个正整数，表示最少的“复制-粘贴”次数 输入输出样例输入样例#1：4输出样例#1：2 解析简单推一下就可以知道答案是$\lceil log_2n \rceil$ 这里要注意的是C++中的$log$是以$e$为底的求$\lceil log_2n \rceil$的代码为ceil(log(n) / log(2)) 代码实现12345678910#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int a; cin &gt;&gt; a; cout &lt;&lt; ceil(log(a) / log(2)) &lt;&lt; endl; return 0;&#125; T2. 足球联赛题目描述一个足球联赛由 n 只球队构成。在一个赛季中，每只球队都要与其它球队各比赛两场。 一场比赛在主场，一场在客场。赢一场得 3 分，输一场不得分，平局两支队伍各得 1 分。现在，给你一个 n*n 的矩阵表示比赛情况。第 i 行第 j 列的字母表示在第 i 只队伍主场的比赛情况， W 表示主队赢， L 表示主队输， D 表示平局。 需要你求出得分最高的队伍的编号，如果有分数相同的，在一行中按字典序输出队伍编号。 输入输出格式输入格式：第一行，一个整数 n 。 接下来 n 行，每行 n 个字符，表示输赢情况。 第 i 行第 i 列为 - ,因为一只队伍不可能与自己比赛。 输出格式：得分最高的队伍编号。如有多个在一行中输出，用一个空格分开 输入输出样例输入样例#1： 12343 -WWW-WWW- 输出样例#1： 11 2 3 输入样例#2： 1234565 -DWWDL-WLLDD-WDDDL-LDDLL- 输出样例#2： 11 解析直接照题意模拟即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 50 + 10; int n; int score[MAXN]; char sc[MAXN][MAXN]; void Read() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; For (i, 1, n) &#123; For (j, 1, n) &#123; cin &gt;&gt; sc[i][j]; &#125; &#125; &#125; void Work() &#123; ios::sync_with_stdio(false); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j) continue; switch(sc[i][j]) &#123; case 'W': &#123; score[i] += 3; break; &#125; case 'L': &#123; score[j] += 3; break; &#125; case 'D': &#123; score[i] += 1; score[j] += 1; break; &#125; &#125; &#125; &#125; int Max = -2147482333; For (i, 1, n) Max = std::max(Max, score[i]); For (i, 1, n) if (score[i] == Max) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; Read(); Work(); return 0;&#125; T3. 捕食关系题目描述在海洋中，有食肉类的鱼和食草类的鱼，某种食肉类的鱼捕食食草类的鱼当且仅当自己的体重大于对方。 现在给出两类鱼各自的体重，求有多少对捕食关系。 输入输出格式输入格式：每组测试数据有三行。 第一行有两个整数 m， n，分别代表食肉类的鱼的种类数和食草类的鱼的种类数。 第二行 m 个数，第三行 n 个数，代表各自的体重。 输出格式：一个整数，表示有多少对捕食关系。 输入输出样例输入样例#1：5 38 1 7 3 13 6 1输出样例#1：7 解析正解不会 暴力能过 我不知道纯暴力能不能过 反正我们要优化一下 首先把食草鱼体重从小到大排个序那么我们在枚举食肉鱼的时候，就可以遇见在第一个体重更大的食草鱼的时候break掉，做法的正确性是显然的 时间复杂度均摊$O(n^2)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXNM = 20000 + 10; int n, m; int bigFish[MAXNM], smallFish[MAXNM]; void Read() &#123; using FastIO::getint; m = getint(); n = getint(); For (i, 1, m) &#123; bigFish[i] = getint(); &#125; For (i, 1, n) &#123; smallFish[i] = getint(); &#125; &#125; void Work() &#123; int cnt = 0; sort(smallFish + 1, smallFish + 1 + n); For (i, 1, m) &#123; For (j, 1, n) &#123; if (smallFish[j] &gt;= bigFish[i]) break; ++cnt; &#125; &#125; FastIO::putint(cnt, '\n'); &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; Read(); Work(); return 0;&#125; T4. 幻方题目描述大家都知道 n 阶奇数幻方吧？如下为一个 5 阶幻方： 17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9现在，输入奇数 n，输出该奇数幻方最右下角的元素值。 输入输出格式输入格式：一行一个数 n。 输出格式：一行一个数，表示该奇数幻方右下角的值。 输入输出样例输入样例#1：5输出样例#1：9 解析找规律 指点迷津 代码实现不给]]></content>
      <tags>
        <tag>比赛</tag>
        <tag>暴力</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LYOI初中坑题组」模拟赛#1 题解]]></title>
    <url>%2F2018-11-03%2FLYOI-Mid-KT-Team-Contest1%2F</url>
    <content type="text"><![CDATA[当一个选手比你小，还比你强…… 前言题面 &amp; 测试输入来自山河 T1. 求和题面小马克今年成为小学生。不久后她将进行她的第一次考试，其中包括数学考试。 她非常认真地复习，她认为自己已经准备好了。她的哥哥通过给她提出问题并解决的方式帮助她。 他的问题是给定一连串整数：依次由 1 个 1，2 个 2，3 个 3 等组成，即1223334444……。 现在他给马克两个整数 A 和 B； 他的任务是求出由第 A 个到第 B 个数的。如果 A 是 1， B是 3， 答案为 1+2+2=5。 给一个问题， 然后计算它们的和， 马克的哥哥能够验证答案正确与否。 输入输出格式 &amp; 样例输入格式：输入文件 instruckcije.in 只有一行， 包括正整数 A 和 B。 输出格式：输出文件 instruckcije.out 共一行， 为和的值。 输入样例#1：1 3输出样例#1：5 输入样例#2：1 1000输出样例#2：29280 数据范围$1 \leq A,B \leq 1000$ 解析首先这题是一个签到题无误了 数据范围如此之小，我们可以直接把序列初始化出来，再处理出一个前缀和数组，最后输出即可。 时间复杂度……$O(1)$？反正都是常数 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041namespace Solution &#123; const int MAXLENGTH_1 = 1000 + 10; int seq[MAXLENGTH_1], sum[MAXLENGTH_1]; void Init() &#123; int now = 1, cur = 0, i = 0; while (i &lt;= 1001) &#123; ++cur; seq[++i] = now; if (cur == now) &#123; cur = 0; ++now; &#125; &#125; for (int i = 1; i &lt;= 1000; ++i) &#123; sum[i] = sum[i-1] + seq[i]; &#125; &#125; void Work1() &#123; using FastIO::getint; Init(); int x = getint(); int y = getint(); if (x &gt; y) swap(x, y); FastIO::putint(sum[y] - sum[x-1], '\n'); &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work1(); return 0;&#125; T2. 猜歌名题面“Guess the song” 是一项在年轻程序员中非常流行的游戏。它是一种集技能、智慧、 耐性于一体的游戏。这个游戏给玩游戏的人放音乐， 游戏者的目标是尽可能快地猜这首歌 的歌名。 Mirko 可能不是一个很好的程序员， 但他是一个世界级的猜歌者。 Mirko 总是在专辑里的某首歌播放出至少一半歌词的时候猜出歌名。所有歌名的单词是唯一的（没有一个单词会出现一次或更多次）。 写一个程序， 给出歌名和专辑名， 看看 Mirko 在这首歌的哪个点上（在多少个单词之后）猜出歌名。 输入输出格式 &amp; 样例输入格式：第一行：包含一个整数 N， 它是一首歌里的单词数目。接下来的 N 行每一行包含歌名的一个单词。第 N+2 行： 包含一个整数 M， 它是专辑里的单词数目。接下来的 M 行每一行包含专辑里的一个单词。歌名和专辑里的所有单词由 1 到 15 个小写英文字母组成。 输出格式：共一行， 包含一个数， 表示 Mirko 在第几个单词处猜出歌曲名。 输入样例#1：3sedamgladnihpatuljaka7sedamdanasedamnocisedamgladnihgodina 输出样例#1：6 解析我们称输入的N个单词为WN，输入的M个单词为WM 那么题目就是要求我们找出一个最小ANS，使得在WM中的前ANS个单词满足有至少一半的WN中的单词 那么数据范围依然极小，直接暴力算完 当然我看着貌似能二分答案太懒不写单调性显然，当$\text{ANS}$成立的时候，满足$\text{ANS} \leq \text{ANS}_1 \leq \text{M}$的$\text{ANS_1}$都是成立的。 这里要注意的是当N为奇数时，N的一半$=\lfloor\frac{N}{2}\rfloor + 1$，否则N的一半$=\frac{N}{2}$ 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647namespace Solution &#123; const int MAXN = 50 + 10; const int MAXM = 10000 + 10; string song[MAXN]; string album[MAXM]; map&lt;string, bool&gt; vis; int n, m, most; inline bool Check() &#123; int ret = 0; For (i, 1, n) if (vis[song[i]]) ++ret; return ret &gt;= most; &#125; void Work2() &#123; cin &gt;&gt; n; For(i, 1, n) &#123; cin &gt;&gt; song[i]; &#125; cin &gt;&gt; m; most = ((n % 2) == 0 ? n / 2 : n / 2 + 1); For(i, 1, m) &#123; cin &gt;&gt; album[i]; //cout &lt;&lt; album[i] &lt;&lt; endl; vis[album[i]] = true; if (Check()) &#123; printf("%d\n", i); return; &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work2(); return 0;&#125; T3. 黑白棋题面Lagno 是一种二人智力游戏。 游戏设有一个黑方和一个白方。游戏桌面是正方形的， 包含 8 行 8 列。 如果黑方玩家走出这样一步棋：将一枚黑子放在任一空格上， 而在这个空格的八个方向（上、下、左、右和 4 个对角线方向）的至少一个方向上有一排白子被夹在这枚新下的黑子和其他黑子之间， 任何方向， 在新黑子和原来黑子之间的所有白子都要变成黑子。为这个游戏设计一个程序， 计算一步棋中黑方能转变的白子数量的最大值。 输入输出格式 &amp; 样例输入格式：输入文件 lango.in 共 8 行， 每行 8 个字符；“.”代表一个空格；“B”代表黑子，“W” 代表白子。 输出格式：输出文件 lango.out 共一行， 有一个整数， 表示一步中黑方能吃掉白子的最大数， 如果无法吃掉就输出“0”。 输入输出样例输入样例#1： 12345678...........................BW......WB........................... （这个说实话不等宽不行 输出样例#1： 11 解析暴！力！能！过！&lt;/big&gt;&lt;/big&gt;输出0拿9分&lt;/small&gt; 暴力算法数据范围如此之小，我们不如直接枚举所有空格点，对这个点进行八向扩展，累加答案，最后取$max$即可 正解当然是DFS我们还是枚举每一个点，只不过这次不暴力扩展了。我们用dx[]和dy[]来记八个方向，根据它来扩展。dfs(int now, int x, int y)中的now就表示现在是第now个方向 边界肯定是要判的（x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8），当前是不是空格子也要判（s[i][j] == &#39;.&#39;），如果有任意一个满足就直接return -INF如果当前碰到了一个黑格子，说明到头了，return 0即可否则return dfs(now, x + dx[now], y + dy[now]) + 1 想是有点难想的，但是代码很好看懂。 代码实现暴力算法***毒瘤警告*** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125namespace Solution &#123; const int dx[8] = &#123;-1, 1, 0, 0, -1, -1, 1, 1&#125;; const int dy[8] = &#123; 0, 0, -1, 1, -1, 1, -1, 1&#125;; const int MAXX_Y = 8 + 2; short Map[MAXX_Y][MAXX_Y]; // 0: blank // 1: Black // 2: White int ans = 0; void Read() &#123; // 初始化 for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; char c; cin &gt;&gt; c; switch (c) &#123; case '.': &#123; Map[i][j] = 0; break; &#125; case 'B': &#123; Map[i][j] = 1; break; &#125; case 'W': &#123; Map[i][j] = 2; break; &#125; &#125; &#125; &#125; &#125; int getAnswer(int x, int y) &#123; // 获取上下左右的可扩展数量 int ret = 0; int current = 0; int ox = x; int oy = y; while (true) &#123; ++current; ++x; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (x == 8 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --x; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (x == 1 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; ++y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (y == 8 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (y == 1 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; return ret; &#125; int getAnswerAlt(int x, int y) &#123; // 获取四个对角线上的可扩展数量 int ret = 0; int current = 0; int ox = x; int oy = y; while (true) &#123; ++current; ++x; ++y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 8 || y == 8) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --x; --y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 1 || y == 1) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --x; ++y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 1 || y == 8) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; ++x; --y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 8 || y == 1) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; return ret; &#125; void Search() &#123; for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; if (Map[i][j] != 0) continue; ans = std::max(ans, getAnswer(i, j) + getAnswerAlt(i, j)); &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Read(); Search(); putint(ans, '\n'); return 0;&#125; 正解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849namespace Solution &#123; const int dx[8 + 1] = &#123;0, -1, -1, 0, 1, 1, 1, 0, -1&#125;; const int dy[8 + 1] = &#123;0, 0, 1, 1, 1, 0, -1, -1, -1&#125;; const int INF = 2147482333; char s[8 + 2][8 + 2]; int ans, Max; void Init() &#123; for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; cin &gt;&gt; s[i][j]; &#125; &#125; &#125; int DFS(int now, int x, int y) &#123; if (x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8 || s[x][y] == '.') return -INF; if (s[x][y] == 'B') return 0; return DFS(now, x + dx[now], y + dy[now]) + 1; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Init(); for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; for (int k = 1; k &lt;= 8; ++k) &#123; int p = 0; if (s[i][j] == '.') &#123; p = DFS(k, i + dx[k], j + dy[k]); if (p &gt; 0) ans += p; // 累计答案 &#125; &#125; Max = std::max(Max, ans); // 更新答案 ans = 0; &#125; &#125; putint(Max, '\n'); return 0;&#125; T4. 跳格子题面Nikola 现在已经成为一个游戏里的重要人物。这个游戏是由一行 N 个方格， N个方格 用 1 到 N 的数字表示。 Nikola 开始是在 1 号位置， 然后能够跳到其他的位置， Nikola 的第一跳必须跳到 2 号位置。随后的每一跳必须满足两个条件： 1、如果是向前跳， 必须比前面一跳远一个方格。 2、如果是向后跳， 必须和前面一跳一样远。 比如， 在第一跳之后（当在 2 号位置时）， Nikola 能够跳回 1 号位置， 或者向前跳到 4号位置。 每次他跳入一个位置， Nikola 必须付费。 Nikola 的目标是从一号位置尽可能便宜地跳到 N 号位置。 写一个程序， 看看 Nikola 跳到 N 号位置时最小的花费。 输入输出格式 &amp; 样例输入格式：共有 N+1 行。 第一行：包含一个整数 N， 它是位置的编号。 第 2..N+1 行：第 i+1 行表示第 I 个方格的费用， 是一个正整数 输出格式：只有一个数， 表示 Nikola 跳到 N 号位置时最小的花费。 输入输出样例 输入样例#1：6 1 2 3 4 5 6输出样例#1：12 输入样例#2：8 2 3 4 3 1 6 1 4输出样例#2：14 数据范围2≤N≤1000 费用不大于500 解析妥妥的DP 我们设 $\text{f[i][j]}$表示跳到第 $i$ 个格子上，可以向后跳 $j$ 个格子的时候的最小花费 转移方程： $\text{(default) f[i][j] = LESS_INF}$ 上一次向前跳，显然上一次跳了 $j$ 格。$\text{f[i][j] = min(f[i][j], f[i-j][j-1]}$ 上一次向后跳，显然上一次跳了 $j$ 格。 $\text{f[i][j] = min(f[i][j], f[i+j][j]}$ 最后加上本格的花费$\text{cost[i]}$就是$\text{f[i][j]}$ 需要注意的东西有两个，一个是边界，另一个是答案为$\text{min{f[n][i]} }(i \in [1, n-1])$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849namespace Solution &#123; const int MAXN = 1000 + 10; int cost[MAXN]; int f[MAXN][MAXN]; int n; int DFS(int now, int step, int ncost) &#123; // 写挂了的搜索 if (now == n) return ncost; int ret = 2147482333; cout &lt;&lt; "now = " &lt;&lt; now &lt;&lt; endl; cout &lt;&lt; "ncost = " &lt;&lt; ncost &lt;&lt; endl; if (now + step + 1 &lt;= n) ret = std::min(ret, DFS(now + step + 1, step + 1, ncost + cost[now + step + 1])); if (now != 1 &amp;&amp; step != 0 &amp;&amp; now - step &gt; 0) ret = std::min(ret, DFS(now - step, step, ncost + cost[now - step])); return ret; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; n = getint(); For (i, 1, n) cost[i] = getint(); int step = 0; //putint(DFS(1, 0, cost[1]), '\n'); //for (int i = 1; i &lt; n; ++i) &#123; // int now = 2147482333; //&#125; int Min = 2147482333; for (int i = 2; i &lt;= n; ++i) f[i][0] = 0x3f3f3f3f; for (int j = 1; j &lt; n; ++j) &#123; for (int i = n; i &gt;= 1; --i) &#123; f[i][j] = 0x3f3f3f3f; if (i &gt; j) f[i][j] = f[i - j][j - 1]; if (i + j &lt;= n) f[i][j] = std::min(f[i][j], f[i + j][j]); if (f[i][j] != 0x3f3f3f3f) f[i][j] += cost[i]; if (i == n) Min = std::min(Min, f[i][j]); &#125; &#125; putint(Min, '\n'); return 0;&#125; 果然我还是太弱了 这题并没有A掉 差这题就AK了]]></content>
      <tags>
        <tag>比赛</tag>
        <tag>暴力</tag>
        <tag>枚举</tag>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 钦定评测系统 Arbiter 使用指南]]></title>
    <url>%2F2018-11-02%2FArbiter%2F</url>
    <content type="text"><![CDATA[Developed by GAIT 什么是 ArbiterArbiter 是NOI信息学竞赛唯一指定评测工具，分为网络版和单机版，支持目前主流的 Linux 发行版本，多种语言支持（C, C++ 和 Free Pascal），功能多样，配置灵活，并具有精确的时间控制。 下载 &amp; 安装Deb 包我没有找到关于 Deb 包的任何信息，可能 CCF 暂时移除了。 NOI Linux首先，打开这个网址下载 NOI Linux 并安装（实体机虚拟机均可）默认密码 123456 配置打开程序在 NOI Linux 中，你可以在左上角的「应用程序」中找到它。 打开之后，它的主界面是这样的。 新建竞赛点击「NEW」按钮，输入比赛名称，选择存储目录，点击确定。 打开竞赛如果你已经创建过的话，点击「OPEN」，选择竞赛的配置文件(.cfg)，点击确定即可。 配置竞赛试题配置打开竞赛之后，它会显示这样的一个界面。我们右键单击试题概要下面的空白处，选择添加考试，它会添加一场名为「第一场——机试」的考试。如何改名下面会说。 我们右键这场考试，选择添加试题，并点击「+」号展开这场比赛。试题默认的名字是「Unknow1」，可以自己修改。 在这里，你可以修改针对每一个试题的配置。我个人比较偏好的设置如下图。 关于其他的「比较方式」，在「/path/to/your/contest/filter/readme.txt」中可以了解，对应的比较方式也有源代码。 数据配置所有的数据文件都放在「/path/to/your/contest/evaldata/」里，且无任何子文件夹。 所有的输入数据的名称都应该是「题目名称 + 编号 + .in」，如下图。 评测选手文件所有的选手文件夹都放在.../players/里 像 NOIP 一样，所有的选手文件都需要建立子文件夹。 12345678910| .../players/|||--| SD-66666||------| ccf||----------&gt; ccf.cpp||------| cheat||----------&gt; cheat.cpp||------| money||----------&gt; money.cpp| 开始评测切换到「试题评测」界面，点击「添加选手」，输入姓名和编号，点击确定。点击「导入名单」可以进行批量导入我没试过。 这里要注意编号是和文件夹名相同的。 首先我们要将「评测第0场」改一下，再点击「全选」，「评定选定选手」就开始评测了。 统计信息评测完之后，程序会自动显示评测的结果。 更加详细的信息可以到「成绩统计」里看。「成绩统计」分为4个模块：总体统计、分组统计、试题统计和等级统计。总体统计分组统计试题统计等级统计 不得不说分组统计和等级统计就是专门为 NOIP 系列赛事开发的…… 你可以选择导出或打印。 对了，成绩为什么多30pts我也不得而知（ FAQs想问的可以在评论里问或发送邮件到我的邮箱我会抽一些整理出来 Q1：如何给考试改名？A1：当然是万能的配置文件。打开day1.info，更改NAME=后面的内容。]]></content>
      <tags>
        <tag>使用指南</tag>
        <tag>比赛</tag>
        <tag>学习笔记</tag>
        <tag>评测系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018-11-02%2FNOIP2018-PJ%2F</url>
    <content type="text"><![CDATA[&amp;GaiGeKaiFang(40)Nian 随手一记NOIP2018 游记12rp = 0x3f3f3f3f;rp++; 出征！ Day 1上午今天在学生活动中心肝了一个上午又做了几道题 顺便写了一发题解希望能涨涨RP吧 下午等待进场的时间真是漫长。看着队伍一点一点地往前走，我的心也开始激动了起来。 进场发现有人居然动鼠标，监考老师还不管考前5min就发了密码 T1水题，上来5min切了不过我居然奶中了，T1就是求一个字符串中有多少字符 T2是个暴力，最开始想出了$O(n^2)$的做法，后来改了一下就成了一个$O(n)$的做法，没意外应该能拿满 T3……我被T3切了打了个最大计算量$10^{10}$的算法，结果极限大样例答案不对！心态崩了 T4随便判了几个情况，希望能骗一点分 顺便表扬CCF终于换评测机了 正经的Day0 成堆的人在开包，成堆的人出橙了，成堆的人掉rp。 不得不说去昌邑的路真漫长，貌似SDSC的时候都没这么长时间。 下了车第一件事就是拍照，补上SDSC没有拍照的遗憾，毕竟昌邑一中的绿化面积和水系的面积是极大的！这就是我戏称昌邑一中为“昌邑第一自然保护区”的原因。 晚上去试机，不得不说习惯了 Macbook Pro 2017 的蝶式键盘就真的回不来了。还有对应 Alt 键的 ⌘ 键，实在是习惯了，到那保存就是一个劲地按 Alt + S……敲了一遍代码的默认模板，5分钟敲过，和我预想中的差不多快。 Day1 上午去了学生活动中心做题，一口气切了8道题——但是都是「普及-」的题目，这可能是这三天我的活动安排的败笔。我应该做「普及/提高-」的题目的啊…… 中午写了篇题解扔到博客上了，希望能rp++ 下午去的时候手机居然没电了，好自闭啊。还没到2:30就带着一瓶今麦郎的凉白开进了场，居然不到时间就发了密码。第一道题我居然说中了……考试前一天我还在说一道求字符串长度的题，于是用getline5分钟切了。第二题依然是水题，先想到的是$O(n^2)$的做法，发现只能拿80分，于是就开始想正解。很快想到了一个$O(n)$的做法就开始敲，结果最大的样例过不了，然后简单分析了一下发现需要开long long int。不过，我在开了long long int之后只把表示∞的值提高了一点，在Day2的自测中才发现……所以我写$O(n)$的做法跟没写一样，开long long跟没开一样！看到自测的成绩后我心态是真的崩死了。第三题第一眼是DP，但是推不出式子来，于是就开始想贪心做法。写了一个暴力，然后最大的样例死活调不过，浪费了近1个小时。第四题一看就知道不大可做，然后尝试写暴力也没写出来，最后随便判了几个情况算完。 Day2上午在学生活动中心把题目写了一遍，发现第二题∞的值设的过小，预测了一下省一线]]></content>
      <tags>
        <tag>NOIP</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher 算法学习笔记]]></title>
    <url>%2F2018-11-01%2FManacher%2F</url>
    <content type="text"><![CDATA[$O(n)$回文串 Manacher 是什么Manacher 是一种可以在$O(n)$的时间复杂度内求出一个字符串的最长回文子串的算法。 Manacher，中文一般念做「马拉车」。 Manacher Algorithm 的思想首先我们来看一道题洛谷P3805【模板】manacher算法。 考虑一下暴力做法，就是枚举字串的边界并进行验证，时间复杂度$O(n^3)$ 考虑一下优化，我们可以枚举所有“回文子串”的对称轴（尽管它现在不一定是回文子串）并向两边进行扩展，用一个数组external[i]记录第i个字符可向外扩展的数量，显然数组中最大值的二倍就是答案，时间复杂度均摊$O(n^2)$。 但这还不够快……毕竟$\text{|s|} \leq 11000000$ 于是我们考虑在优化的思想基础上进行再次优化。 在此之前，我们首先要解决一个棘手的问题——字符串的长度。一个字符串子串的对称轴是在字母中间还是在字母上，是由子串长度为偶数还是奇数决定的。于是，为了统一对于奇数长度字符串和偶数长度字符串的做法，我们需要对字符串进行修改。（代码见「代码实现」Pre()部分） 1234567就比如说 - - - - - -|%|%|%|w|y|h|我们要用一些无关紧要的字符填一下 - - - - - - - - - - -|%|!|%|!|%|!|w|!|y|!|h|这样更好处理 修改完了之后，就是真正的Manacher()过程了首先，我们要用一个变量maxRight记录「当前的 最靠右的 回文子串的 右端点」，和一个变量mid记录「当前的 最靠右的 回文子串的 对称轴所在的 字符的 下标」，注意这里的mid是可以不赋初值的 我们循环枚举经过处理的字符串的每一个字符。对于每一个字符的下标i，如果i &lt; maxRight，那么我们就可以获取external[i]的部分信息（external[i]的意义和上文相同），否则就只能将external[i]设为1 接着就是和暴力一样的扩展了，我这里选择用for语句实现（ 最后更新一下maxRight和mid即可 最终答案就是external[]的最大值——而不是2倍，因为这是我们扩展过的字符串，最终答案还要$\times \frac{1}{2}$。 Manacher Algorithm 的代码实现同样也是「manacher模版」的代码实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 31000000 + 10; // 没错，就是要开这么大 int n, external[MAXN]; char s[MAXN], str[MAXN &lt;&lt; 1]; void Pre() &#123; str[0] = str[1] = '~'; for (int i = 0; i &lt; n; ++i) &#123; str[i * 2 + 2] = s[i]; str[i * 2 + 3] = '~'; &#125; n = n * 2 + 2; str[n] = 0; &#125; void Manacher() &#123; int maxRight = 0, mid = 0; // mid 初值无所谓 for (int i = 1; i &lt; n; ++i) &#123; if (i &lt; maxRight) &#123; external[i] = std::min(external[(mid &lt;&lt; 1) - i], external[mid] + mid - i); &#125; else &#123; external[i] = 1; &#125; for (; str[i + external[i]] == str[i - external[i]]; ++external[i]); if (external[i] + i &gt; maxRight) &#123; maxRight = external[i] + i; mid = i; &#125; &#125; &#125; void Work() &#123; cin &gt;&gt; s; n = (int) strlen(s); Pre(); Manacher(); int ans = 1; for (int i = 0; i &lt; n; ++i) ans = std::max(ans, external[i]); cout &lt;&lt; ans - 1 &lt;&lt; endl; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work(); return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>学习笔记</tag>
        <tag>回文</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1280《尼克的任务》]]></title>
    <url>%2F2018-11-01%2FLuogu-P1280%2F</url>
    <content type="text"><![CDATA[线性DP 题目🔗 题目描述尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 Input / Output 格式 &amp; 样例输入格式输入数据第一行含两个用空格隔开的整数$N$和$K(1≤N≤10000，1≤K≤10000)$，$N$表示尼克的工作时间，单位为分钟，$K$表示任务总数。 接下来共有$K$行，每一行有两个用空格隔开的整数$P$和$T$，表示该任务从第$P$分钟开始，持续时间为$T$分钟，其中$1≤P≤N$，$1≤P+T-1≤N$。 输出格式输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 输入样例123456715 61 21 64 118 58 111 5 输出样例14 解题思路DP 我们设f[i]表示在前i分钟内的最大空闲时间但是发现第i分钟的空闲时间是由后面的任务决定的所以我们考虑倒着扫一遍 我们设f[i]表示在第i$$\rightarrow$$n分钟内的最大空闲时间转移方程： 当第i分钟没有任务时，f[i] = f[i + 1] + 1 当第i分钟有任务时，f[i] = std::max(f[i], f[i + seq[j]].time)，其中seq[j].time表示第j个任务的耗时 如何判断当前有没有任务？我们开一个数组sum[i]表示第i分钟的任务个数更新就很好更新了——++sum[seq[j].startTime]，其中seq[j].startTime表示第j个任务的开始时间 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; /*/ * * 设f[i]表示i-n的空闲时间 * f[i] = f[i+1] + 1（无任务） * f[i] = max(f[i], f[i + seq[x]])（有任务） * /*/ const int MAXK = 10000 + 10; const int MAXN = MAXK; struct QwQ &#123; int start, time; &#125; qwq[MAXK]; int n, k; int sum[MAXN]; int f[MAXN]; int num = 1; bool stlCmp(QwQ x, QwQ y) &#123; return x.start &gt; y.start; &#125; void Work() &#123; using FastIO::getint; n = getint(); k = getint(); For (i, 1, k) &#123; qwq[i].start = getint(); qwq[i].time = getint(); ++sum[qwq[i].start]; &#125; sort(qwq + 1, qwq + 1 + k, stlCmp); // 既然是倒序，所以输入也要排序 for (int i = n; i &gt;= 1; --i) &#123; if (sum[i] == 0) f[i] = f[i + 1] + 1; // 当前时刻没有任务 else &#123; for (int j = 1; j &lt;= sum[i]; ++j) &#123; f[i] = std::max(f[i], f[i + qwq[num].time]); // 当前时刻有至少一个任务，把它们都扫一遍 ++num; // 用一个变量 num 表示当前扫到的任务 &#125; &#125; &#125; FastIO::putint(f[1], '\n'); // 输出 &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work(); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1577《切绳子》]]></title>
    <url>%2F2018-10-31%2FLuogu-P1577%2F</url>
    <content type="text"><![CDATA[突然想起《割绳子》 题面🔗 题面描述有N条绳子，它们的长度分别为Li。如果从它们中切割出K条长度相同的绳子，这K条绳子每条最长能有多长？答案保留到小数点后2位。 Input / Output 格式 &amp; 样例输入格式第一行两个整数N和K，接下来N行，描述了每条绳子的长度Li。 输出格式切割后每条绳子的最大长度。 输入样例123454 118.027.434.575.39 输出样例12.00 解题思路首先这题涉及到了int和double之间的精度转换 所以我们可以把输入的double都乘100转为int（题目要求保留两位小数） 不难看出来这题可以枚举答案 但是显然会炸 于是我们要想点优化——二分答案！ 我们选择二分绳子的最大长度 这题的单调性是显然的，我就不证了（ Check(int mid)怎么写？ 我们扫一遍绳子长度L[]，令$ ans=\sum_{i=1}^{n}\lfloor\frac{L[i]}{mid}\rfloor $ 即最终绳子被分成的段数 如果$ans \geq k$（题目中的$\text{k}$）则把左边界赋值为mid + 1，否则把右边界赋值为mid - 1 这里要注意的是如果mid == 0就直接退出循环 最后cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (double) r / 100.0 &lt;&lt; endl; 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;using namespace std;const int MAXN = 10000 + 10;const double MAXL = 100000.00;int n, k;int L[MAXN];bool Check(int x) &#123; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += L[i] / x; return ans &gt;= k;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; double P; cin &gt;&gt; P; L[i] = (int) (P * 100.0); &#125; int l = 0, r = 19260817 + 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (mid == 0) break; if (Check(mid)) l = mid + 1; else r = mid - 1; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (double) r / 100.0 &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1032《字串变换》]]></title>
    <url>%2F2018-10-30%2FLuogu-P1032%2F</url>
    <content type="text"><![CDATA[NO ANSWER! 题目描述已知有两个字串$A,B$及一组字串变换的规则（至多$6$个规则）: $A_1 \rightarrow B_1$ $A_2 \rightarrow B_2$​规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $B_1$，$A_2$可以变换为 $B_2 \dots$ 例如：$A=$’$abcdabcd$’，$B＝$’$xyzxyz$’ 变换规则为： ‘$abc$’$\rightarrow$‘$xu$’ ‘$ud$’$\rightarrow$‘$y$’ ‘$y$’$\rightarrow$‘$yz$’ 则此时，$A$可以经过一系列的变换变为$B$，其变换的过程为： ‘$abcd$’$\rightarrow$‘$xud$’$\rightarrow$‘$xy$’$\rightarrow$‘$xyz$’ 共进行了$3$次变换，使得$A$变换为$B$。 Input / Output 格式 &amp; 样例输入格式：输入格式如下： $A$ $B$ $A_1$ $B_1$​$A_2$ $B_2$​$|\rightarrow$ 变换规则 … … / 所有字符串长度的上限为$20$。 输出格式：输出至屏幕。格式如下： 若在$10$步（包含$10$步）以内能将$A$变换为$B$，则输出最少的变换步数；否则输出”NO ANSWER!” 输入样例1234abcd xyzabc xuud yy yz 输出样例13 解题思路这是一个 BFS 题目刚上来就有一个坑 输入不给行数 只知道最多六行 于是我们用一个变量l来记录输入的行数 我这里选择用A[0]和B[0]来存两个原字符串 首先如果l == 0而且A[0] != B[0]，那直接输出NO ANSWER! 否则用一个变量v来记录BFS()的返回值 如何搜索？ www.baidu.com 我们建两个队列q和step，分别存需要修改的字符串和这个字符串所对应的步数 循环的时候就不能只判!q.empty()，还要判q.front() != B[0] /* 字符串还需要修改 */和step.front() &lt;= 10 /* 限制只能修改10次 */ 我们还需要用一个map&lt;string, bool&gt;来判重 剩下的一些解释我直接扔到代码注释里面了 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int MAXN = 6 + 3;map&lt;string, bool&gt; KangShifu;string A[MAXN], B[MAXN];int BoynextdoorFaqSearch(int l) &#123; int ans = 0; queue&lt;string&gt; q; queue&lt;int&gt; step; q.push(A[0]); step.push(0); while (!q.empty() &amp;&amp; q.front() != B[0] &amp;&amp; step.front() &lt;= 10) &#123; if (KangShifu[q.front()]) &#123; q.pop(); step.pop(); continue; // 去重 &#125; KangShifu[q.front()] = true; for (int i = 1; i &lt;= l; ++i) &#123; string s = q.front(); // 用一个string记录下当前需要修改的字符串 while (true) &#123; // 可能不止修改一次 int loc = s.find(A[i]); if (loc == -1) break; // 并没有找到 string ss = q.front(); // 再复制一份需要修改的字符串 ss.replace(loc, A[i].size(), B[i]); // 修改 q.push(ss); // 把它扔进队列 step.push(step.front() + 1); // 步骤数 + 1 s[loc] = '~'; // 把这个能搜到的地方用一个无关紧要的放起来 // 防止下次还能被搜到 &#125; &#125; q.pop(); step.pop(); // 处理完毕 &#125; if (q.empty() || step.front() &gt; 10) ans = -1; // 如果队列空了或超过10步了，输出NO ANSWER! else ans = step.front(); // 否则输出真正的答案 return ans;&#125;int main(int argc, const char * argv[]) &#123; int l = 0; while (cin &gt;&gt; A[l] &gt;&gt; B[l]) ++l; --l; if (l == 0 &amp;&amp; A[0] != B[0]) puts("NO ANSWER!"); else &#123; int v = BoynextdoorFaqSearch(l); // Boy Next Door if (v == -1) puts("NO ANSWER!"); else cout &lt;&lt; v &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>BFS</tag>
        <tag>NOIP</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3952《时间复杂度》]]></title>
    <url>%2F2018-10-29%2FLuogu-P3952%2F</url>
    <content type="text"><![CDATA[继《玩具谜题》后的又一力作 题目地址 题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下： 123F i x y 循环体E 其中 $\text{F i x y}$ 表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i+1$，一旦 $i$ 大于 $y$ 终止循环。 $x​$ 和 $y​$ 可以是正整数（$x​$ 和 $y​$ 的大小关系不定）或变量 $n​$。$n​$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。 “$\text{E}$”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“$O$”表示通常意义下“$Θ$”的概念。 Input / Output 格式 &amp; 样例输入格式：输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 $\text{F i x y}$和$\text{E}$即可计算时间复杂度。注意：循环结构 允许嵌套。 接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为$n^w$，其中$w$是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 $L$ 行代表程序中循环结构中的$\text{F i x y}$或者 $\text{E}$。 程序行若以$\text{F}$开头，表示进入一个循环，之后有空格分离的三个字符（串）$\text{i x y}$， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。 程序行若以$E$开头，则表示循环体结束。 输出格式：输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出Yes或No或者ERR，若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误（其中语法错误只有: ① $\text{F}$ 和 $\text{E}$ 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出ERR 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 输入样例1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 输出样例12345678YesYesERRYesNoYesYesERR 解题思路首先我们肯定一眼就能看出这题是个没有任何优化的大模拟&lt;/big&gt;&lt;/big&gt; 那么如何模拟？ 首先我们为了方便，把循环体离线下来，用字符串存着 根据题意，我们写一个函数GetNumber()把字符串里的数字存下来 具体和快读差不多 我们先把小明给出的时间复杂度的$n$的指数记为$\text{w}$，这里注意$O(1)$的情况要用$0$代替 接着便是求真正的时间复杂度了 首先是判断ERR 这个比较简单 我们用一个栈来储存所有的循环体的变量名 当$\text{E}$已经读完但是栈不空 当$\text{E}$未读完但是栈空 当储存的变量名与现在的变量名冲突 这个过程穿插在代码各处 当读到$\text{F}$的时候往栈里 Push 循环体变量名，注意要一块把记录变量名的数组used进行判断并更新 之后，我们用GetNumber获取一下$x$和$y$两个数，分情况讨论一下 当$y$是$n$的时候，如果这次循环可以执行，++答案 当$y&lt;x$的时候，循环不执行，更新一下「最早不能循环的循环体」 剩下一种情况就是常数，可以不写 当读到$\text{E}$的时候，先检查栈里还有没有东西，再 Pop 出来，注意要检查一下这个变量是不是「最早不能循环的循环体」的变量 最后扫完数据，判一下栈是不是还有东西没 Pop 出来，然后验一下答案，输出 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;stack&gt;using namespace std;const int MAX = 100 + 10;string Code[MAX];int t;int GetNumber(int &amp;X, string s) &#123; int len = s.length(); while (!isdigit(s[X]) &amp;&amp; X &lt; len) &#123; if (s[X] == 'n') &#123; ++X; return 19260817; &#125; ++X; &#125; int ret = 0; while (isdigit(s[X])) &#123; ret = ret * 10 + s[X] - '0'; ++X; &#125; return ret;&#125;int getO(string s) &#123; if (s[2] == 'n') &#123; int _ = 3; // 必须要传实参进去 return GetNumber(_, s); &#125; return 0;&#125;int GetO(int l) &#123; int ret = 0; int now = 0; char earliestVariant = -1; // 「最早不能循环的循环体」 int x = 0, y = 0; stack&lt;int&gt; stk; bool used[27] = &#123; false &#125;; bool ran[27] = &#123; false &#125;; for (int i = 1; i &lt;= l; ++i) &#123; if (Code[i][0] == 'F') &#123; char varName = Code[i][2]; if (used[varName - 'a']) return -1; stk.push(varName); used[varName - 'a'] = true; // Get X int X = 4; x = GetNumber(X, Code[i]); // Get Y y = GetNumber(X, Code[i]); if (y - x &gt; 1000) &#123; // y = n if (earliestVariant == -1) &#123; ++now; ret = std::max(ret, now); ran[varName - 'a'] = true; &#125; &#125; else if (x &gt; y) &#123; if (earliestVariant == -1) earliestVariant = varName; &#125; &#125; else &#123; if (stk.empty()) return -1; char nowVarName = stk.top(); stk.pop(); used[nowVarName - 'a'] = false; if (earliestVariant == nowVarName) earliestVariant = -1; if (ran[nowVarName - 'a']) &#123; ran[nowVarName - 'a'] = false; --now; &#125; &#125; &#125; if (!stk.empty()) return -1; return ret;&#125;int main() &#123; scanf("%d", &amp;t); while (t --&gt; 0) &#123; int w, nw, l; scanf("%d ", &amp;l); string o; getline(cin, o); nw = getO(o); for (int i = 1; i &lt;= l; ++i) &#123; getline(cin, Code[i]); &#125; w = GetO(l); if (w == -1) puts("ERR"); else &#123; if (w == nw) puts("Yes"); else puts("No"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1525《关押罪犯》]]></title>
    <url>%2F2018-10-20%2FLuogu-P1525%2F</url>
    <content type="text"><![CDATA[敌人的敌人就是朋友！ 题目地址 题目描述S城现有两座监狱，一共关押着 N 名罪犯，编号分别为 1−N 。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 c 的冲突事件。 每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。 在详细考察了 N 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。 那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？ Input / Output 格式 &amp; 样例输入格式每行中两个数之间用一个空格隔开。第一行为两个正整数N,M，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的M行每行为三个正整数$a_j,b_j,c_j$，表示$a_j$号和$b_j$号罪犯之间存在仇恨，其怨气值为$c_j$。数据保证$1&lt;aj≤bj≤N,0 &lt; cj≤ 1,000,000,000$，且每对罪犯组合只出现一次。 输出格式共 1 行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 0。 输入样例12345674 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884 输出样例13512 解题思路显然这是一个并查集 首先我们把输入记录下来，按照权值从大到小排个序 然后对于每一条关系，如果它们的祖先相同，就说明发生了冲突，此时直接输出 + return 0就好 否则就进行合并 如何合并？ 根据“敌人的敌人就是朋友”的原则，我们维护一个Enemy[i]表示i的的敌人 然后对于每一个人，更新它的敌人（如果它的敌人目前没被更新过）否则就合并另一个人和他的敌人 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 20000 + 10;const int MAXM = 100000 + 10;struct Relative &#123; int x, y, weight;&#125; rel[MAXM];int n, m, U[MAXM * 2], E[MAXN * 2];inline void Init() &#123; for (int i = 1; i &lt;= n; ++i) U[i] = i;&#125;int Find(int x) &#123; if (x == U[x]) return x; return U[x] = Find(U[x]);&#125;void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] = y;&#125;bool stlCmp(Relative x, Relative y) &#123; return x.weight &gt; y.weight;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; Init(); for (int i = 1; i &lt;= m; ++i) &#123; int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; rel[i].x = x; rel[i].y = y; rel[i].weight = w; &#125; sort(rel + 1, rel + 1 + m, stlCmp); for (int i = 1; i &lt;= m; ++i) &#123; int x = rel[i].x, y = rel[i].y; int fx = Find(x), fy = Find(y); if (fx == fy) &#123; printf("%d", rel[i].weight); return 0; &#125; if (E[x] == 0) E[x] = y; else Union(E[x], y); if (E[y] == 0) E[y] = x; else Union(E[y], x); &#125; printf("0"); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SP3377《A Bug's Life》]]></title>
    <url>%2F2018-10-20%2FSP3377%2F</url>
    <content type="text"><![CDATA[谁闲的没事研究同性恋。。。 题目地址 本文同步发布于：Handwer’s 洛谷博客 题目大意就是一个奇怪的ke学家，他专门研究虫子是否存在同性恋。。。 他为每一只虫子都标上了序号。 通过这个奇怪的ke学家的研究，找出了在这些虫子中的所有关系的虫子，题目询问在这么多有关系的虫子中是否存在“同性恋”。 输入格式 &amp; 样例第一行， 输入一个数，表示有t组数据对于每组数据，第一行输入n,m，表示有n只虫子，有m个关系接下来行每行两个数x,y，表示x,y有关系 1234567823 31 22 31 34 21 23 4 输出格式 &amp; 样例对于每一组数据： 先输出：”Scenario #i” ，表示第i组数据 然后如果有同性恋的输出”Suspicious bugs found!” 否则输出”No suspicious bugs found!” 1234Scenario #1:Suspicious bugs found!Scenario #2:No suspicious bugs found! 解析显然这是一个并查集，但并不是一个裸的并查集 我们要多维护一个数组rel[]，其中rel[i]表示i和它的祖先的关系（relative）。我们定义rel[i]表示两种性别，当根节点相同且rel[]相同时，它们就是同性恋 rel[]的更新方式： 12(in Find(x))rel[x] = (rel[x] + rel[U[x]]) % 2; 1234(in Union(x, y))int fx = Find(x), fy = Find(y);...rel[fx] = (rel[x] + rel[y] + 1) % 2; rel[]的判断方式：12345(in Union(x, y))if (fx == fy) &#123; if (rel[x] == rel[y]) suspiciousFound = true; return;&#125; 剩下的照常写就行 注意路径压缩要分开写，先创建一个变量存它的祖先节点再更新 按秩合并没写过不知道 代码实现你们最喜欢的代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXM = 1000000 + 10;int n, m;int U[MAXM], rel[MAXM];bool flag;int Find(int x) &#123; if (x != U[x]) &#123; // 把路径压缩撑开写 int fux = Find(U[x]); rel[x] = (rel[x] + rel[U[x]]) % 2; // 更新rel数组 // 1 1 -&gt; 0 // 1 0 / 0 1 -&gt; 1 // 0 0 -&gt; 0 // 其实是一个异或的过程 U[x] = fux； // qwq &#125; return U[x];&#125;void Union(int x, int y) &#123; int fx = Find(x), fy = Find(y); if (fx == fy) &#123; if (rel[x] == rel[y]) flag = true; // 判断是否同性 return; &#125; U[fx] = fy; rel[fx] = (rel[x] + rel[y] + 1) % 2; // 更新rel数组&#125;int main(int argc, char *const argv[]) &#123; int t; scanf("%d", &amp;t); int _t = 0; while (t --&gt; 0) &#123; memset(U, 0, sizeof(U)); memset(rel, 0, sizeof(rel)); n = 0, m = 0, flag = false; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) U[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); Union(x, y); &#125; printf("Scenario #%d:\n", ++_t); if (flag) printf("Suspicious bugs found!\n"); else printf("No suspicious bugs found!\n"); &#125; return 3; // qwq&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2866《[USACO06NOV]糟糕的一天Bad Hair Day》]]></title>
    <url>%2F2018-10-06%2FLuogu-P2866%2F</url>
    <content type="text"><![CDATA[有点难想的单调栈模板题 题目地址 暂不提供题面，请自行到洛谷查看题面。 Input / Output 格式 &amp; 样例输入格式第一行：一个数N表示奶牛的数量。 第2到N+1行：第i+1行包含一个整数表示第i头奶牛的高。 输出格式第一行：一个整数，即c1到cN的和 输入样例1234567610374122 输出样例15 解题思路这就是一个单调栈的模板 循环读入，每次push读入的数进一个单调栈并维护这个栈的单调性，最后答案累加栈的大小-1即可（显然题意说明奶牛是看不见自己的发型的，要把自己减去） 以上操作的推导过程： 我们对于当前读进去的奶牛的高度，计算栈中还有多少比它矮的，把它们pop出来（维护单调性） 这个过程其实就是在计算当前的奶牛能被多少奶牛看见 接下来累计答案 最后将当前奶牛的高度push进去 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 80000 + 10; struct Stack &#123; int seq[MAXN]; int tail; Stack() &#123; memset(seq, 0, sizeof(seq)); tail = 0; &#125; void Pop() &#123; tail--; &#125; int Top() &#123; return seq[tail]; &#125; bool isEmpty() &#123; return tail == 0; &#125; void Push(int x) &#123; while (!isEmpty() &amp;&amp; Top() &lt;= x) Pop(); seq[++tail] = x; &#125; int Size() &#123; return tail; &#125; int __tail_location() &#123; return tail; &#125; &#125; stk; // 手写栈无所畏惧 int n;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); long long int ans = 0; For (i, 1, n) &#123; int x = getint(); stk.Push(x); ans += stk.Size() - 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>USACO</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1981《表达式求值》]]></title>
    <url>%2F2018-10-06%2FLuogu-P1981%2F</url>
    <content type="text"><![CDATA[新技能：手写计算器 题目描述给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。 Input / Output 格式 &amp; 样例输入格式一行，为需要你计算的表达式，表达式中只包含数字、加法运算符“$+$”和乘法运算符“ $\times$ ”，且没有括号，所有参与运算的数字均为 $0$ 到 $2^{31}$的整数。 输入数据保证这一行只有 $0−9$、$+$、 $\times$ 这 $12$ 种字符。 输出格式一个整数，表示这个表达式的值。 注意：当答案长度多于 4 位时，请只输出最后 4 位，前导 0 不输出。 输入样例Case #1:11+1*3+4 Case #2:11+1234567890*1 Case #3:11+1000000003*1 输出样例Case #1:18 Case #2:17891 Case #3:14 数据范围对于 30\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100； 对于 80\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤1000； 对于100\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100000。 解题思路我们开两个单调栈，一个栈num来存储数字，一个栈operators来存储符号 其中operators的操作逻辑是这样的： 首先把~push进去，作为一个占位符 我们对运算符标一个优先级，规定~ &lt; + &lt; *且相同运算符优先级低（满足从左到右的运算顺序），写一个判断函数 当push进去的运算符优先级比栈顶的低时，解决所有优先级低的运算符（维护单调性质）再push进去 当push进去的运算符优先级比栈顶的高时，不用管，直接push进去（满足单调性质） 处理完输入之后，我们再对数字栈里剩下的数字进行处理 最后输出即可 代码实现这里面所有的注释都是我在DEBUG的时候手推的样例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; stack&lt;int&gt; num; stack&lt;int&gt; operators; // 1: + - // 2: * / const int MOD = 10000; long long int ans = 0; bool Priority(char op1, char op2) &#123; // false -&gt; op1 is lower // true -&gt; op1 is higher if (op1 == op2) return false; if (op1 == '~') return false; if (op1 == '+' &amp;&amp; op2 == '*') return false; if (op1 == '*' &amp;&amp; op2 == '+') return true; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; // 1+1*3+4 int ans = 0, now = 0; char op = 0; cin &gt;&gt; ans; // 1 num.push(ans % MOD); // &lt; 1 operators.push('~'); // &lt; ~ while (cin &gt;&gt; op &gt;&gt; now) &#123; // +1 // *3 // +4 char op1 = operators.top(); // ~ // + // * while (Priority(op1, op)) &#123; // false // false // true // false int opNum = num.top(); // // // 3 num.pop(); // // // &lt; 1 1 int opNum2 = num.top(); // // // 1 num.pop(); // // // &lt; 1 if (op1 == '+') num.push((opNum + opNum2) % MOD); // // // false if (op1 == '*') num.push(opNum * opNum2 % MOD); // // // &lt; 1 3 operators.pop(); // &lt; + op1 = operators.top(); // + &#125; operators.push(op); // &lt; + // &lt; + * // &lt; + + num.push(now); // &lt; 1 1 // &lt; 1 1 3 // &lt; 1 3 4 &#125; while (num.size() &gt; 1) &#123; // true // true // false int op = num.top(); // 4 // 7 num.pop(); // &lt; 1 3 // &lt; 1 int op2 = num.top(); // 3 // 1 num.pop(); // &lt; 1 // &lt; char ope = operators.top(); operators.pop(); if (ope == '+') num.push((op + op2) % MOD); // &lt; 1 7 // &lt; 8 if (ope == '*') num.push(op * op2 % MOD); &#125; FastIO::putint(num.top() % MOD, '\n'); // 8 return 0;&#125;]]></content>
      <tags>
        <tag>栈</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1750《出栈序列》]]></title>
    <url>%2F2018-10-06%2FLuogu-P1750%2F</url>
    <content type="text"><![CDATA[这题和栈有多少关系 题目描述给定一个由n个元素构成的序列，你需要将其中的元素按顺序压入一个大小为c的栈并弹出。元素按它们的出栈顺序进行排列，会得到一个新的序列。我们知道，这样的序列会有很多种，请输出所有新序列中第一个元素最小的序列（若第一个元素最小的序列有多个，则令第二个尽可能小；若仍有多个，则令第三个最小，以此类推）。 Input / Output 格式 &amp; 样例输入格式第一行，两个数n,c 第二行n个数，为序列中n个元素的值 输出格式输出n个数，为满足要求的序列。 输入样例126 35 2 3 8 7 4 输出样例12 3 5 4 7 8 数据范围对于40%的数据，n&lt;=12 对于100%的数据，c&lt;=n&lt;=10000，元素大小均在2*10^9以内。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 10000 + 10; struct Stack &#123; private: int __builtin_sequence[MAXN]; int tail; public: Stack() &#123; memset(__builtin_sequence, 0, sizeof(__builtin_sequence)); tail = 0; &#125; void push(int x) &#123; __builtin_sequence[++tail] = x; &#125; void pop() &#123; --tail; &#125; int top() &#123; return __builtin_sequence[tail]; &#125; bool empty() &#123; return tail == 0; &#125; int size() &#123; return tail; &#125; &#125; stk; int n, c; int seq[MAXN];&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); c = getint(); int used = 0; int unusedNum = 1; For (i, 1, n) &#123; seq[i] = getint(); &#125; while (stk.size() + used &lt; n) &#123; int inQueue = stk.size(); int origUnusedNum = unusedNum; int minN = 2147482333; int len = c - inQueue; for (int i = origUnusedNum; i &lt;= n &amp;&amp; i &lt; origUnusedNum + len; ++i) &#123; if (seq[i] &lt; minN) &#123; unusedNum = i; minN = seq[i]; &#125; &#125; if (stk.empty() || minN &lt; stk.top()) &#123; For (i, origUnusedNum, unusedNum) &#123; stk.push(seq[i]); &#125; ++unusedNum; &#125; else unusedNum = origUnusedNum; putint(stk.top(), ' '); ++used; stk.pop(); &#125; while (!stk.empty()) &#123; putint(stk.top(), ' '); stk.pop(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day5 题解]]></title>
    <url>%2F2018-10-05%2F2018AutumnQBXTDay5%2F</url>
    <content type="text"><![CDATA[暴力分！暴力分！ Problem A. climb题目描述Bob 在一旁看 Alice 爬台阶玩， Alice 突发奇想让 Bob 闭上眼记录他爬了多少台阶，规则是这样的： Alice每次会想好爬多少级台阶，每爬一级都会数数，爬完之后走回到最底层，注意走回去的那些台阶是不算级数的。 Bob 闭上眼通过 Alice 的报数来统计 Alice 总共爬了几次，每次爬了多少级。 输入格式第一行包含一个整数 N(1 ≤ 100000)，表示 Alice 的报数次数。 第二行包含 N 个正整数 Ai(1 ≤ Ai ≤ 1000)，表示 Alice 的报数序列。 输出格式第一行包含一个整数，表示 Alice 爬的次数 T。第二行包含 T 个整数，第 i 个整数表示 Alice 每 i 次爬的台阶数。 输入样例1271 2 3 1 2 3 4 输出样例1223 4 子任务对于 40% 的数据， N ≤ 20。 对于 70% 的数据， N ≤ 1000。 对于 100% 的数据， N ≤ 100000。 解析A不掉的退役吧 显然这题就是让你求有多少个1和每两个1之间的距离 当然这题题面有点歧义 求每个1之前的数也可以（数据水 就没了 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; int n; int seq[MAXN]; int T; vector&lt;int&gt; cnt; void Work() &#123; For (i, 1, n) &#123; if (seq[i] == 1) ++T, cnt.push_back(seq[i-1]); &#125; cnt.push_back(seq[n]); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("climb.in", "r", stdin); freopen("climb.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); For (i, 1, n) seq[i] = getint(); Work(); putint(T, '\n'); int siz = cnt.size(); Forw (i, 1, siz - 1) putint(cnt[i], ' '); putint(cnt[siz - 1], '\n'); return 0;&#125; Problem B. remove题目描述给出一个字符串 s，字符串中只会包含⼩写字母 a − z。现在需要通过重复下面这个算法符串中删去 k 个字符：• 如果当前字符串中还存在字符 a，就删去字符串中最前面的一个 a 字符，结束算法• 如果当前字符串中还存在字符 b，就删去字符串中最前面的一个 b 字符，结束算法• …• 如果当前字符串中还存在字符 z，就删去字符串中最前面的一个 z 字符，结束算法求删完 k 个字符后的字符串。 输入格式第一行包含两个整数 n; k(1 ≤ k ≤ n ≤ 100000)， n 表示字符串长度， k 表示删去的字符个数。 第二行包含一个字符串 s。 输出格式一行，包含删去k个字符的字符串。 输入样例Case #1:1215 3cccaabababaccbc Case #2:1215 9cccaabababaccbc 输出样例Case #1:1cccbbabaccbc Case #2:1cccccc 子任务对于 40% 的数据， 1 ≤ k ≤ n ≤ 100。 对于 70% 的数据， 1 ≤ k ≤ n ≤ 1000。 对于 100% 的数据， 1 ≤ k ≤ n ≤ 100000。 解析这道题我在考试结束之后20min敲出了正解。。。。。。 我们开一个桶，把所有的字母记录下来 接着把桶扫一遍： 如果当前的k大于当前的字母数alphabet[i]，就让k -= alphabet[i]，然后把alphabet[i]置为0 否则让alphabet[i] -= k，然后把k置为0，最后break掉即可 此时，alphabet的意义已经从字母数量变成了经过删除后的还可输出字母数量 之后，我们开一个bool数组chk[i]表示str[i]是否还能被输出，并倒序（注意是倒序，因为题目要求从前面开始删，显然我们要保留后面几位）枚举 $i\ (0 &lt; i &lt; n)$ 当alphabet[str[i] - &#39;a&#39;] &gt; 0时，将chk[i]设为true并--alphabet[str[i] - &#39;a&#39;] 最后，从头扫一遍chk，如果chk[i] == true就输出str[i] 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; int n, k; string s; bool chk[MAXN]; string Work(string str) &#123; // 此为暴力做法 For (i, 1, k) &#123; Forw (j, 0, 26) &#123; cout &lt;&lt; str &lt;&lt; endl; int findnow = str.find(j + 'a'); // printf("%c\n", j + 'a'); if (findnow != string::npos) &#123; str[findnow] = '-'; break; &#125; &#125; &#125; return str; &#125; void nowWork(string str) &#123; // 此为正解 int alphabet[26 + 2] = &#123; 0 &#125;; bool printal[26] = &#123; true &#125;; Forw (i, 0, n) alphabet[str[i] - 'a']++; Forw (i, 0, 26) &#123; //cerr &lt;&lt; (char)(i + 'a')&lt;&lt; '='; //cerr &lt;&lt; alphabet[i] &lt;&lt; endl; if (alphabet[i] &lt; k) &#123; k -= alphabet[i]; alphabet[i] = 0; &#125; else &#123; alphabet[i] -= k; k = 0; break; &#125; &#125; Bak (i, n-1, 0) &#123; if (alphabet[str[i] - 'a'] == 0) continue; chk[i] = true; --alphabet[str[i] - 'a']; &#125; Forw (i, 0, n) if (chk[i]) putchar(str[i]); &#125; void Print(string str) &#123; // 此为暴力做法的输出 Forw (i, 0, n) if (str[i] != '-') putchar(str[i]); &#125;&#125; int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("remove.in", "r", stdin); freopen("remove.out", "w", stdout); #endif using namespace Solution; ios::sync_with_stdio(false);// int t = clock(); cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; s; //Print(Work(s)); nowWork(s); // cerr &lt;&lt; clock() - t &lt;&lt; endl; return 0;&#125; Problem C. cut题目描述给出一个字符串 s，其中每个字符都是 0 9 的数字。现在需要把字符串 s 分割开，这样每个部分就可以看做一个数，求这些数中最多有多少个数是 3 的倍数。 如对于字符串 3121，可以分割为 3 | 12 | 1，这样会有两个数是 3 的倍数，如果分割为 31 | 2 | 1，这样就没有数是 3 的倍数了。0 是 3 的倍数，如果 1200045 被拆分为 120 | 0045，则认为分割出来的两个数是 120 和 45，即忽略前导零。 输入格式一行包含一个字符串s，$|s|\le100000$ 输出格式一行包含一个整数，表示最多有多少个数是3的倍数。 输入样例Case #1:13121 Case #2:1201920181 输出样例Case #1：12 Case #2:14 样例解释第一个样例中可以拆分为 3 | 12 | 1。 第二个样例中可以拆分为 201 | 9 | 2 | 0 | 18 | 1。 解析首先我们对读进来的序列整体mod 3 接着对这个序列扫一遍 如果当前读到的数是0，根据贪心策略，直接在后面划上一道 否则如果当前读的数的下标大于0，就看前面的数如果这个数与上个数的和能被3整除，而且下个数没有被选过，就在后面划上一道 否则如果当前读的数的下标大于1，继续看前面的数如果这个数与前面两个数的和能被3整除，而且两个数都没有选过，就在后面划上一道 否则什么都不干 最后输出即可 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; bool vis[MAXN]; int seq[MAXN]; int len; int Work() &#123; int ret = 0; For (i, 1, len) &#123; if (seq[i] == 0) &#123; ++ret; vis[i] = true; &#125; else if (i &gt; 0 &amp;&amp; (seq[i] + seq[i - 1]) % 3 == 0 &amp;&amp; !vis[i - 1]) &#123; ++ret; vis[i] = true; &#125; else if (i &gt; 1 &amp;&amp; (seq[i] + seq[i - 1] + seq[i - 2]) % 3 == 0 &amp;&amp; !vis[i - 1] &amp;&amp; !vis[i - 2]) &#123; ++ret; vis[i] = true; &#125; &#125; return ret; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; string s; cin &gt;&gt; s; len = s.length(); For (i, 1, len) seq[i] = (s[i-1] - '0') % 3; int ans = Work(); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Problem D. sum题目描述某些数有奇怪的性质：它十进制下的各位数的平方和的 T 倍等于它本身。求在 [A, B] 范围内的数有多少满足这个性质 输入格式第一行包含三个整数 T, A, B(1 ≤ T; A; B ≤ 10^18; A ≤ B)。 输出格式一个整数，表示满足条件的数量。 输入样例151 5000 10000 输出样例13 子任务对于 40% 的数据， 1 ≤ T; A; B ≤ 100000; A ≤ B。对于 100% 的数据， 1 ≤ T; A; B ≤ 10^18; A ≤ B。 代码实现此为标程12345678long long calc(long long x) &#123; long long ans = 0; while (x) &#123; ans += (x % 10) * (x % 10); x /= 10; &#125; return ans;&#125; 1234567891011long long k, a, b, ans = 0; scanf("%lld%lld%lld", &amp;k, &amp;a, &amp;b); for(int i = 1; i &lt;= 1600; i++) &#123; if (a &lt;= k * i &amp;&amp; i &lt;= b / k) if (calc(k * i) == i) &#123; printf("%lld\n", k * i); ans++; &#125; &#125; printf("%lld\n", ans); return 0;]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>字符串</tag>
        <tag>贪心</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的代码默认模板]]></title>
    <url>%2F2018-10-04%2FMyTemplate%2F</url>
    <content type="text"><![CDATA[运行效率++; &nbsp; 可读性--; 下面是我在写程序时常用的快读/写模板（虽然它不仅仅只是快读/写）不仅提高了运行效率，还让编写时的体验更加舒适。 假如布局安排合理的话，可读性不但不会减少，反而会进一步上升。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; return 0;&#125; Update删掉了大量无用的东西 12345678910111213141516171819202122232425#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define rap(a,s,t,i) for (int a = s; a &lt;= t; a += i)#define basketball(a,t,s,i) for (int a = t; a &gt;= s; a -= i)#define countdown(s) while (s --&gt; 0)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;typedef long long int lli;int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;lli getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125;int main() &#123; return 0;&#125;]]></content>
      <tags>
        <tag>毒瘤</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1886《滑动窗口》]]></title>
    <url>%2F2018-10-04%2FLuogu-P1886%2F</url>
    <content type="text"><![CDATA[单调队列的应用 题目描述现在有一堆数字共N个数字（N&lt;=10^6），以及一个大小为k的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。 例如： The array is [1 3 -1 -3 5 3 6 7], and k = 3. 图片来自洛谷 Input / Output 格式 &amp; 样例输入格式输入一共有两行，第一行为n,k。 第二行为n个数($n&lt;2^{31}-1$). 输出格式输出共两行，第一行为每次窗口滑动的最小值 第二行为每次窗口滑动的最大值 输入样例128 31 3 -1 -3 5 3 6 7 输出样例12-1 -3 -3 -3 3 33 3 5 5 6 7 数据范围50%的数据，n&lt;=10^5 100%的数据，n&lt;=10^6 解题思路最经典的单调队列题目 暴力妥妥的T，不用多说（不过居然有70pts） 我们先研究最大值怎么求 每次往单调队列里面扔一个数，显然不管队列里发生了什么改变，单调性并不变。我们开一个id数组，记录当前的数被push进去的时间 接着扫描id数组，将所有过期的数全都pop出去 最后当循环了至少k次时，输出答案。 最小值同理，把单调队列改一下即可。 （《单调队列学习笔记》将不久后更新） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 1000000 + 10; struct Queue &#123; int q[MAXN]; int head, tail; Queue() &#123; memset(q, 0, sizeof(q)); head = 1; tail = 0; &#125; void push(int s) &#123; // 维护单调递增的队列 while (s &gt;= q[tail] &amp;&amp; head &lt;= tail) --tail; q[++tail] = s; &#125; void push_back(int s) &#123; // 维护单调递减的序列 while (s &lt;= q[tail] &amp;&amp; head &lt;= tail) --tail; q[++tail] = s; &#125; void pop() &#123; ++head; &#125; int front() &#123; return q[head]; &#125; int size() &#123; return tail - head + 1; &#125; bool empty() &#123; return tail - head + 1; &#125; void clear() &#123; Queue(); &#125; int __tail_location() &#123; return tail; &#125; int __head_location() &#123; return head; &#125; &#125; q1, q2; int n, k; int seq[MAXN]; int id[MAXN]; void GetMax() &#123; For (i, 1, n) &#123; q1.push(seq[i]); id[q1.__tail_location()] = i; while (id[q1.__head_location()] &lt;= i - k) q1.pop(); // 清理过期的数 if (i &gt;= k) FastIO::putint(q1.front(), ' '); // 输出 &#125; &#125; void GetMin() &#123; For (i, 1, n) &#123; q2.push_back(seq[i]); id[q2.__tail_location()] = i; while (id[q2.__head_location()] &lt;= i - k) q2.pop(); if (i &gt;= k) FastIO::putint(q2.front(), ' '); &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); k = getint(); For (i, 1, n) &#123; seq[i] = getint(); &#125; GetMin(); puts(""); GetMax(); return 0;&#125;]]></content>
      <tags>
        <tag>单调数据结构</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day4 题解]]></title>
    <url>%2F2018-10-04%2F2018AutumnQBXTDay4%2F</url>
    <content type="text"><![CDATA[没人AC的题目和没人得分的题目 T1. 牛奶没AC的退役吧 问题描述为了增加营养，你决定每天喝牛奶，牛奶的营养含量十分固定，下表示牛奶上写的营养成分表。 项目 每100mL 能量 284kJ 蛋白质 3.2g 脂肪 4.0g 碳水化合物 4.8g 钠 62mg 钙 100mg 这天你喝了N mL的牛奶，那么你摄入的营养成分分别为多少呢？ 输入格式一个整数N 输出格式6个用空格隔开的数字，分别表示6项营养成分的数值，单位和表上单位相同，四舍五入保留一位小数。 输入样例1100 输出样例1284.0 3.2 4.0 4.8 62.0 100.0 数据范围对于30%的数据，N是100的倍数。 对于50%的数据，N&lt;=1000。 对于100%的数据，1&lt;=N&lt;=10000。 解析没什么好说的，浮点数运算而已 这题唯一也是最毒瘤的的坑点就是浮点数运算 代码实现毒瘤代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace Solution &#123; const double energy100 = (double) 284; // kJ const double protein100 = (double) 3.2; // g const double fats100 = (double) 4.0; // g const double carbohydrate100 = (double) 4.8; // g const double sodium100 = (double) 62; // mg const double calcium100 = (double) 100; // mg&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("milk.in", "r", stdin); freopen("milk.out", "w", stdout); #endif using namespace Solution; double n = 1.0; scanf("%lf", &amp;n); n *= 1.0; double anse = (double) n * (double) energy100 * 1.0; double ansp = (double) n * (double) protein100 * 1.0; double ansf = (double) n * (double) fats100 * 1.0; double ansc = (double) n * (double) carbohydrate100 * 1.0; double anss = (double) n * (double) sodium100 * 1.0; double ansl = (double) n * (double) calcium100 * 1.0; printf("%0.1lf %0.1lf %0.1lf %0.1lf %0.1lf %0.1lf\n", anse / 100.0, ansp / 100.0, ansf / 100.0, ansc / 100.0, anss / 100.0, ansl / 100.0 ); return 0;&#125; T2. 上课问题描述这天，学校正上着课，学校有n个教室，每个教室坐着$a_i$个人正在上课。 突然来了m个人也要上课，每个人都可以选择n个教室中的任意一个教室上课，由于学校需要提供教室的座位，学校想知道这m个人来之后，最多人的那个教室人数的最小值和最大值分别为多少。 输入格式第一行两个数n和m，用空格隔开。 第二行n个数字用空格隔开，表示$a_i$。 输出格式两个用空格隔开的数字，分别表示最小值和最大值 输入样例124 61 1 1 1 输出样例13 7 数据范围对于30%的数据，n=1。 对于50%的数据，m&lt;=10000。 对于100%的数据，1&lt;=n,ai&lt;=100,1&lt;=m&lt;=10^9。 解析我们随便想一想就能想出贪心策略 首先最大值是人最多的班级的人数+m 这没什么好说的 最小值也很好求 既然是最小值，那么就要保证m的平均分配 那么我们排个序，从最小的数字依次$O(n)$扫 对于每个数字$a_i$，计算它和最大值的差，记为$d$ 当$d\ge m$时，直接输出$d$（因为将$m$全部安排到这个班里去也不能让这个班的人数比最大值大，所以答案即是最大值）否则让$m$减去$d$，将$a_i$赋值为最大值（把这个班的人数变成最大值） 扫完一遍之后，如果$m$变成0了，就直接输出最大值（m个人被正好安排完了）否则就再把剩下的人一个一个地分别安排到每个班中（可能有一个班分配多人的情况），最后取个max值即可 这里有个小技巧，就是我们把m整除n的结果记为place，然后把整个序列都加上place，表示每个班都还要分配place个人 再把m模n的结果记为 lm，循环把这最后lm个人分别分配到每个班中，最后取max即可 讲起来还是挺麻烦的 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100; int n, m; int seq[MAXN]; bool stlCmp(int x, int y) &#123; return x &gt; y; &#125; void PrintAnswer(int maxAns, int minAns) &#123; FastIO::putint(minAns, ' '); FastIO::putint(maxAns, '\n'); &#125; &#125;int main(int argc, char *const argv[]) &#123; // Wrong Algorithm #ifndef HANDWER_FILE freopen("class.in", "r", stdin); freopen("class.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(), m = getint(); int maxSiz = -233333; For (i, 1, n) &#123; seq[i] = getint(); maxSiz = std::max(seq[i], maxSiz); &#125; sort(seq + 1, seq + 1 + n); int maxAns = m + seq[n]; For (i, 1, n) &#123; int differ = maxSiz - seq[i]; if (differ &gt;= m) &#123; PrintAnswer(maxAns, maxSiz); return 0; &#125; seq[i] = maxSiz; m -= differ; &#125; if (m == 0) &#123; PrintAnswer(maxAns, maxSiz); return 0; &#125; /*/ sort(seq + 1, seq + 1 + n, stlCmp); long long int maxAns = m + seq[n]; long long int minAns = 0; /*/ /*/ int j = n; For (i, 1, m) &#123; ++seq[j--]; if (j == 0) j = n; &#125; /*/ int place = m / n; For (i, 1, n) seq[i] += place; int mod = m % n; int i = n; while (mod --&gt; 0) &#123; ++seq[i--]; &#125; int minAns = *(max_element(seq + 1, seq + 1 + n)); PrintAnswer(maxAns, minAns); return 0;&#125; T3. 维生素问题描述商店里卖着n种果汁，每种果汁都有它的价格ci，每种果汁有一些维生素，维生素有三种类型，维生素A，维生素B，维生素C，每种果汁可以含有其中一种或多种维生素。 你需要3种维生素来保持身体健康，那么你最少需要购买多少价格的果汁才能保证购买的这些果汁包含3种维生素呢？ 输入格式第一行包含一个整数n。 接下来n行，每行包含一个整数ci和一个字符串si，si表示其中蕴含的维生素种类，只包含字母ABC且每个字母最多出现一次。 输出格式输出最小能满足条件的价格，如果不能满足，输出-1。 输入样例1234545 C6 B16 BAC4 A 输出样例115 数据范围对于30%的数据，1&lt;=n&lt;=20。 对于另外20%的数据，所有果汁只包含单种维生素。 对于100%的数据，1&lt;=n&lt;=1000, 1&lt;=ci&lt;=100000。 解析DP 我们设$f_{i,j}$表示前i种果汁状态为j时的价格，其中 $j$的值 代表意思 1 含有维生素A 2 含有维生素B 3 含有维生素C 4 含有维生素AB 5 含有维生素BC 6 含有维生素AC 7 含有维生素ABC 转移方程： `a[i|w] = min(a[i|w], a[i] + c[i])` `w = w | (1 左移 (str[i] - 'A'))`，其中`1 ≤ i ≤ str.length()` 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif int n; cin &gt;&gt; n; int t[8 + 2]; for (int i = 0; i &lt;= 8; ++i) t[i] = 60; t[0] = 0; string s; for (int i = 1; i &lt;= n; ++i) &#123; int x; cin &gt;&gt; x; cin &gt;&gt; s; int len = s.length(); int v = 0; for (int j = 1; j &lt;= len; ++j) v |= (1 &lt;&lt; s[j-1] - 'A'); for (int j = 0; j &lt; 8; ++j) t[j | v] = std::min(t[j | v], t[j] + x); &#125; if (t[7] &gt; 1e8) puts("-1"); else cout &lt;&lt; t[7] &lt;&lt; endl; return 0;&#125; T4. 队列挖坑待填]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>浮点数运算</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3110 《[USACO14DEC]驮运Piggy Back》]]></title>
    <url>%2F2018-10-04%2FLuogu-P3110%2F</url>
    <content type="text"><![CDATA[披着蓝题的皮跑3遍SPFA的绿题 题目链接 题面由于翻译缺失，暂不提供翻译，这里仅提供英文题面。 题目描述Bessie and her sister Elsie graze in different fields during the day, and in the evening they both want to walk back to the barn to rest. Being clever bovines, they come up with a plan to minimize the total amount of energy they both spend while walking. Bessie spends B units of energy when walking from a field to an adjacent field, and Elsie spends E units of energy when she walks to an adjacent field. However, if Bessie and Elsie are together in the same field, Bessie can carry Elsie on her shoulders and both can move to an adjacent field while spending only P units of energy (where P might be considerably less than B+E, the amount Bessie and Elsie would have spent individually walking to the adjacent field). If P is very small, the most energy-efficient solution may involve Bessie and Elsie traveling to a common meeting field, then traveling together piggyback for the rest of the journey to the barn. Of course, if P is large, it may still make the most sense for Bessie and Elsie to travel separately. On a side note, Bessie and Elsie are both unhappy with the term “piggyback”, as they don’t see why the pigs on the farm should deserve all the credit for this remarkable form of transportation. Given B, E, and P, as well as the layout of the farm, please compute the minimum amount of energy required for Bessie and Elsie to reach the barn. 输入输出格式INPUT: (file piggyback.in) The first line of input contains the positive integers B, E, P, N, and M. All of these are at most 40,000. B, E, and P are described above. N is the number of fields in the farm (numbered 1..N, where N &gt;= 3), and M is the number of connections between fields. Bessie and Elsie start in fields 1 and 2, respectively. The barn resides in field N. The next M lines in the input each describe a connection between a pair of different fields, specified by the integer indices of the two fields. Connections are bi-directional. It is always possible to travel from field 1 to field N, and field 2 to field N, along a series of such connections. OUTPUT: (file piggyback.out) A single integer specifying the minimum amount of energy Bessie and Elsie collectively need to spend to reach the barn. In the example shown here, Bessie travels from 1 to 4 and Elsie travels from 2 to 3 to 4. Then, they travel together from 4 to 7 to 8. 输入样例1234567894 4 5 8 8 1 4 2 3 3 4 4 7 2 5 5 6 6 8 7 8 输出样例122 解题思路为什么这是蓝题&nbsp;这应该是绿题啊 首先肯定是跑最短路 两只牛有这样两种选择： 各自走回家 走到任意一点之后 Bessie 背着 Elsie 回家 那么我们就跑3遍SPFA即可 以 Bessie 为起点（即1点） 以 Elsie 为起点（即2点） 以家为起点（即n点） 这里有个小技巧，不需要写3遍不同的SPFA，只需要把3个dis数组当做参数传进去即可 最后暴力枚举图中的所有点$i$ 如果设$(u,v)$为$u\rightarrow v$的最短路长度的话， 答案就是最小的$ (1,i)+(2,i)+(n,i)$ 注意判断点不连通（距离为INF）的情况 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 4000000 + 10; const int MAXM = 4000000 + 10; const int INF = 0x3f3f3f3f; int b, e, p, n, m; int head[MAXN], disB[MAXN], disE[MAXN], disN[MAXN]; bool inQueue[MAXN]; int cnt; struct Edge &#123; int prev, next, weight; &#125; edge[MAXM]; inline void addEdge(int prev, int next) &#123; edge[++cnt].prev = prev; edge[cnt].next = head[next]; head[next] = cnt; edge[cnt].weight = 1; &#125; void SPFA(int dis[], int s) &#123; //memset(dis, 0, sizeof(dis)); For (i, 0, n) dis[i] = INF; dis[s] = 0; queue&lt;int&gt; q; q.push(s); inQueue[s] = true; while (!q.empty()) &#123; int prev = q.front(); q.pop(); inQueue[prev] = false; for (int e = head[prev]; e; e = edge[e].next) &#123; if (dis[edge[e].prev] &gt; dis[prev] + edge[e].weight) &#123; dis[edge[e].prev] = dis[prev] + edge[e].weight; if (!inQueue[edge[e].prev]) &#123; q.push(edge[e].prev); inQueue[edge[e].prev] = true; &#125; &#125; &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; b = getint(); e = getint(); p = getint(); n = getint(); m = getint(); For (i, 1, m) &#123; int prev, next; prev = getint(); next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; SPFA(disB, 1); SPFA(disE, 2); SPFA(disN, n); int ans = 2147482333; For (i, 1, n) &#123; if (disN[1] == INF || disN[2] == INF || disB[i] == INF || disE[i] == INF || disN[i] == INF ) continue; ans = std::min(ans, b * disB[i] + e * disE[i] + p * disN[i]); &#125; putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>USACO</tag>
        <tag>最短路</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day3 题解]]></title>
    <url>%2F2018-10-03%2F2018AutumnQBXTDay3%2F</url>
    <content type="text"><![CDATA[不同寻常的题面 T1. H因子问题描述h因子是一种评价学术成就的新方法。一名科研人员的h因子是指他至少有h篇论文分别被引用了不少于h次。Alice已经发表了很多论文了，现给出一个序列a0，a1，a2，…，an，其中 $a_i$ 表示有 $a_i$ 篇文章分别被引用了i次。 请你求出Alice的h因子。 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含一个正整数n（1≤n≤200,000） 。 每组数据的第二行包含n个正整数a0，a1，a2，……，an（1≤ai≤1000,000,000），表示序列中的每个数。 输出格式对于每组数据，输出一行，包含一个整数，表示该组数据的h因子 。 样例输入1234567311 221 2 330 0 0 0 样例输出123120 解析首先要把题看懂！！！ 首先要把题看懂！！！ 首先要把题看懂！！！ （我就因为题意理解错误而完美爆零） 我们从n开始，从大到小枚举h因子 一个有效的h因子为i当且仅当有大于等于i篇文章被引用了大于等于i次 所以我们可以用一个sum来存当前有多少篇文章被引用了大于等于当前i次 第一个满足sum &gt;= i的i即为最大的h因子 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start */const int MAXN = 200000 + 10;/* Constants End *//* Variants Start */int seq[MAXN];/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace FastIO; int t = getint(); while (t --&gt; 0) &#123; int n = getint(); for (int i = 0; i &lt;= n; ++i) &#123; seq[i] = getint(); &#125; int sum = 0; for (int i = n; i &gt;= 0; --i) &#123; sum += seq[i]; if (sum &gt;= i) &#123; putint(i, '\n'); break; &#125; &#125; &#125; return 0;&#125; T2. 超回文字符串问题描述给出一个只由小写字母的字符串，要求在最少的操作数下将它转成一个超回文字符串。每次操作仅可以改变字符串中的一个字符。 一个字符串被称为超回文字符串，当且仅当它的所有奇数长度的子串都是回文串（回文串是指一个字符串从前往后与从后往前读是一样的）。 输入格式第一行包含一个正整数T（1≤T≤100），表示有多少组数据。 对于每组数据，只有单独一行，包含一个仅由小写字母组成的字符串。保证字符串的长度不超过100。 输出格式对于每组数据，输出一行，包含一个整数，表示最少的操作数。 样例输入12343ncncnaaaabaaaaabb 样例输出123012 解析简单分析之后，我们发现满足题目要求的字符串存在当且仅当这个字符串的奇数位、偶数位分别相同 那么直接暴力就好 我们枚举每一个奇数位上的字母，计算有多少个奇数位上的字母与它不同（即要修改多少次） 取个min即为答案 偶数位同理 将两个min相加即为答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif int t; cin &gt;&gt; t; string s; while (t --&gt; 0) &#123; cin &gt;&gt; s; int len = s.length(); int min1 = len, min2 = len; for (int i = 0; i &lt; len; i += 2) &#123; int now = 0; for (int j = 0; j &lt; len; j += 2) &#123; if (s[i] != s[j]) ++now; &#125; min1 = std::min(min1, now); &#125; if (len == 1) min2 = 0; for (int i = 1; i &lt; len; i += 2) &#123; int now = 0; for (int j = 1; j &lt; len; j += 2) &#123; if (s[i] != s[j]) ++now; &#125; min2 = std::min(min2, now); &#125; cout &lt;&lt; min1 + min2 &lt;&lt; endl; &#125; return 0;&#125; T3. 移动桌子问题描述题面略（表格太多） 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含一个正整数n（1≤n≤200,000），表示要移动n张桌子 。 每组数据的接下来n行，每行包含2个正整数a和b，表示该张桌子原本在房间a，需要移动到房间b。 输出格式对于每组数据，输出一行，包含一个整数，表示移动完n张桌子所需要的最少时间 。 输入样例123456789101112133410 2030 4050 6070 8021 32 200310 10020 8030 50 输出样例123102030 解析我们对于每一个桌子的区间头和区间尾都加一再除以二（将房间化为走廊） 接着开一个长度为250的桶，把走廊长度累计到这个桶里面（暴力区间加1） 最后取最大值，乘以10（一次移动桌子10十分钟）就是最终答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start */int way[250 + 10];/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace FastIO; int t = getint(); while (t --&gt; 0) &#123; memset(way, 0, sizeof(way)); int n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; int s = getint(); int t = getint(); s = (s + 1) &gt;&gt; 1; t = (t + 1) &gt;&gt; 1; for (int j = s; j &lt;= t; ++j) ++way[j]; &#125; int ans = 0; for (int i = 1; i &lt;= 250; ++i) ans = std::max(ans, way[i]); putint(ans * 10, '\n'); &#125; return 0;&#125; T4. 口算问题描述Alice口算能力非常强。Bob为了考考Alice，给了她一个长度为n的正整数序列a1，a2，……，an，同时抛出了m个问题。​每个问题给出三个正整数。​Alice需要快速判断出$al\times a{l+1}\times \dots \times a_{r-1} \times a_r $ 是不是d的倍数。​Alice凭借她强大的口算能力快速给出了答案。然而Bob很菜，他并不知道正确答案是什么。请写一个程序帮助Bob计算这些问题的答案。 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。​每组数据的第一行包含两个正整数n，m（1≤n,m≤100,000），分别表示序列长度以及问题个数。​第二行包含n个正整数a1，a2，……，an（1≤ai≤100,000），表示序列中的每个数。​接下来的m行，每行包含3个正整数l,r,d（1≤l≤r≤n，1≤d≤100,000），表示每个问题。 输出格式对于每个问题，输出一行，若是倍数，输出Yes，否则输出No。 输入样例1234567815 56 4 7 2 51 2 241 3 182 5 173 5 351 3 21 输出样例12345YesNoNoYesYes 数据规模【数据规模】 对于30%数据，1≤T≤5，1≤n,m≤50，且保证对于每一个问题，$al\times a{l+1}\times \dots \times a_{r-1} \times a_r $不超过long long的数据范围。 对于60%数据，1≤T≤10，1≤n,m≤1000，1≤ai≤1000 对于100%数据，1≤T≤10，1≤n,m≤100,000，1≤ai≤100,000 解析暴力做法30pts 的模拟 （伪）正解进行质因数分解，暴力判断 正解在（伪）正解的基础上进行优化 预处理：将所有的数进行质因数分解，按照顺序把所有质数的出现的下标push_back进每个质数专门的vector里 将读入的d进行质因数分解，同上push_back进一个专门的vector里 然后在给定的区间里进行寻找质因数（使用lower_bound和upper_bound） 如果该有的质因数都有，显然可以整除 否则不可以整除 代码实现不提供。]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>玄学题面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3956「NOIP2017普及组」《棋盘》]]></title>
    <url>%2F2018-10-02%2FNOIP2017-PJ-Chess-Luogu-P3958%2F</url>
    <content type="text"><![CDATA[三种搜索剪枝 题目链接 题目描述有一个$m \times m$的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。 任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 1个金币。 另外， 你可以花费 2 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。 现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？ Input / Output 格式 &amp; 样例输入格式第一行包含两个正整数$m, n$，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。 接下来的$n$行，每行三个正整数$x, y, c$， 分别表示坐标为$(x,y)$的格子有颜色$c$。 其中$c=1$ 代表黄色，$c=0$ 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为$(1, 1)$，右下角的坐标为$( m, m)$。 棋盘上其余的格子都是无色。保证棋盘的左上角，也就是 $(1,1)$ 一定是有颜色的。 输出格式一个整数，表示花费的金币的最小值，如果无法到达，输出-1。 输入样例Case #1: 123456785 71 1 01 2 02 2 13 3 13 4 04 4 15 5 0 Case #2: 1234565 51 1 01 2 02 2 13 3 15 5 0 输出样例Case #1: 18 Case #2: 1-1 样例解释 &amp; 其他说明对于 $30\%$的数据, $1 ≤ m ≤ 5, 1 ≤ n ≤ 10$ 对于 $60\%$数据, $1 ≤ m ≤ 20, 1 ≤ n ≤ 200$ 对于 $100\%$的数据, $1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$ 解析我们并不需要维护某一个点是否走过 我们需要判断边界、白格子、最优性剪枝和走到终点四种情况 用$mp$数组存图，规定0表示白色，1表示红色，2表示黄色 用$f_{i,j}$表示$1,1$到$i,j$的最少花费 本题主要的难点在于加入了膜法机制 那么DFS需要传递四个参数： intx坐标和y坐标 int当前使用的金币数量 bool当前是否使用了膜法 在四向DFS中，需要进行以下几点判断： 当前格是否有颜色若无颜色且并未使用膜法，则使用膜法，使用金币数量+2，继续DFS；若无颜色且使用过膜法，没救了 当前格颜色和下一格颜色是否相同若颜色相同，直接进行下一步DFS；若颜色不同，使用金币数量+1，继续DFS 要注意的是，$f$数组的赋值要在判断是否走到终点之前，最优性剪枝之后，不然可能出现赋值不上的情况 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXM = 100 + 10; int f[MAXM][MAXM]; int mp[MAXM][MAXM]; #define WHITE 0 #define RED 1 #define YELLOW 2 const int dx[5] = &#123;0, 0, 0, -1, 1&#125;; const int dy[5] = &#123;0, -1, 1, 0, 0&#125;; int m, n, ans = 2147482333; void DaFaShi(int x, int y, int nowSum, bool usedMogic) &#123; // 苟利国家生死以 // 岂因祸福避趋之 // 你们啊，不要总是想弄个大新闻 // 说什么使用膜法 // 再把我批判一番 if (x &lt; 1 || y &lt; 1 || x &gt; m || y &gt; m) return; // 边界 if (mp[x][y] == WHITE) return; // 走到白格子 if (nowSum &gt;= f[x][y]) return; // 最优性剪枝 f[x][y] = nowSum; if (x == m &amp;&amp; y == m) &#123; ans = std::min(nowSum, ans); return; // 搜索完成 &#125; For (i, 1, 4) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (mp[nx][ny] != WHITE) &#123; // 有颜色 if (mp[nx][ny] == mp[x][y]) DaFaShi(nx, ny, nowSum, false); // 颜色相同，继续往后搜 else DaFaShi(nx, ny, nowSum + 1, false); // 颜色不同，花费金币 &#125; else if (mp[nx][ny] == WHITE &amp;&amp; !usedMogic)&#123; // 没颜色且没用膜法 mp[nx][ny] = mp[x][y]; // 念诗，使用膜法 DaFaShi(nx, ny, nowSum + 2, true); // 使用膜法花费2金币 mp[nx][ny] = WHITE; // 回溯 &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; memset(f, 0x7f, sizeof(f)); m = getint(); n = getint(); For (i, 1, n) &#123; int x, y, c; x = getint(); y = getint(); c = getint(); mp[x][y] = c + 1; &#125; DaFaShi(1, 1, 0, false); if (ans == 2147482333) puts("-1"); else putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>NOIP</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2040《打开所有的灯》]]></title>
    <url>%2F2018-10-02%2FLuogu-P2040%2F</url>
    <content type="text"><![CDATA[益(ruo)智(zhi)的小游戏 题目链接 题目背景pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。 题目描述这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。 例如 0 1 1 1 0 0 1 0 1 点一下最中间的灯【2,2】就变成了 0 0 1 0 1 1 1 1 1 再点一下左上角的灯【1,1】就变成了 1 1 1 1 1 1 1 1 1 达成目标。最少需要2步。 输出2即可。 Input / Output 格式 &amp; 样例输入格式九个数字，3*3的格式输入，每两个数字中间只有一个空格，表示灯初始的开关状态。（0表示关，1表示开） 输出格式1个整数，表示最少打开所有灯所需要的步数。 输入样例1230 1 11 0 01 0 1 输出样例12 解题思路易证得我们对于一个灯的开关，只需要按1或0次 所以只需要考虑这个开关按与不按即可 所以我们可以直接进行搜索，总运算次数不会超过$9^9$ 用$used$数组记录$usedi$这个开关是否已经按过，用$f$数组记录$f{i,j}$的亮灭情况 代码实现（以后就这个码风了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; bool used[3 + 2][3 + 2]; int f[3 + 2][3 + 2], ans = 10; const int dx[5] = &#123;0, 0, 0, -1, 1&#125;; const int dy[5] = &#123;0, -1, 1, 0, 0&#125;; void modify(int x, int y) &#123; for (int i = 0; i &lt;= 4; ++i) &#123; f[x + dx[i]][y + dy[i]] = !f[x + dx[i]][y + dy[i]]; &#125; &#125; bool Check() &#123; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (!f[i][j]) return false; &#125; &#125; return true; &#125; void dfs(int steps) &#123; if (steps &gt;= ans) return; if (Check()) ans = std::min(ans, steps); for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (!used[i][j]) &#123; used[i][j] = true; modify(i, j); dfs(steps+1); modify(i, j); used[i][j] = false; &#125; &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; f[i][j] = FastIO::getint(); &#125; &#125; dfs(0); FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day2 题解]]></title>
    <url>%2F2018-10-02%2F2018AutumnQBXTDay2%2F</url>
    <content type="text"><![CDATA[由于缺少题面，故本篇无内容。 这里仅提供T1. coin的代码实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; // 中国有句古话叫做闷声ACCEPT // 我就什么都不写，才是坠吼的 &#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("coin.in", "r", stdin); freopen("coin.out", "w", stdout); #endif int t; cin &gt;&gt; t; char c; int x = 0, X = 0; while (t --&gt; 0) &#123; cin &gt;&gt; c; switch(c) &#123; case 'x' : ++x; break; case 'X' : ++X; break; &#125; &#125; if (x == X) &#123; puts("0"); return 0; &#125; int cnt = 0; if (x &lt; X) &#123; while (x != X) &#123; ++x, --X, ++cnt; &#125; &#125; if (X &lt; x) &#123; while (x != X) &#123; ++X, --x, ++cnt; &#125; &#125; FastIO::putint(cnt, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>清北学堂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 日记]]></title>
    <url>%2F2018-10-01%2F2018AutumnQBXTDiary%2F</url>
    <content type="text"><![CDATA[Handwer STD 好菜啊 Day1考试150pts 本来能拿200pts的 结果T1写炸了只拿了50pts 靠着这样的成绩居然玄学地拿到了第三名 第一名 200pts 第二名190pts 还拿到了一个有线鼠标 首战告捷（人生中第一次比赛拿奖 在提高被虐惯了） Day2考试140pts T1数据有锅 题面保证数据没有奇数，结果只有3组数据是偶数，导致我只拿了30pts 好在最后重测了 拿到了100pts T2和T3根本没看 T4打了个暴力，枚举边跑Dijkstra，期望得分60pts，结果把m写成n……只拿了40pts 最后还是水到了一个rk5 不过今天并没有鼠标 Day3考试爆炸 只拿了80pts 被zxk吊打 T1阅读题，根本没理清题意，0pt T2规律题 T3贪心，但由于没有认真阅读题目，导致只拿了60pts T4有技巧的数学题，打了个30pts的暴力结果只拿了20pts 最终居然还水进了前10 我好菜啊…… Day4今天的题目 好！简！单！啊！&lt;/big&gt;&lt;/big&gt; 今天的是真的普及组题目了 T1和T2都是水题，T3暴力分也是足够的，凭220pts拿了个rank3 讲T2的时候被老师拉上去讲题，感觉整个人都在抖，毫无准备的就上去了，说话也是语无伦次，真是差点要吓死了 不过重点不在这个 今天下午三点的时候RainAir问我成绩和排名，我如实地告诉了他后面的事应该不需要想了，我被他膜了一下午 但！是！接近八点的时候，Logey先是问了一下「致远星战况如何？」然后就开始膜我……说时迟，那时快，iShq也开始膜我了接着，就是三个人一块膜我，我被膜了一晚上！这群人fAKe起来真是没有底线啊……他们甚至把群名改成了「王太阳fAKe群」！ 我写博客快要写死了，今天T2要不对着代码讲出来真是太麻烦了，果然我水平还是低啊一口气更了三篇博客，感觉自己身体素质越来越差了，熬夜都熬不了了 对了，现在时间是2018年10月5日凌晨0点04分 Day5今天题目暴力分给的真是够多的了 T1 AC，T2应该是90pts，T4应该是70pts，总分250pts，拿到了一个rank6 T2本来能A掉的，但是我正解在考完试20min之后才调出来 难受 又一次忙活到了23点 好累啊qaq Day6今天的题目不知为何我只拿了110pts qaq T1 100pts，T2 0，T3 0, T4只搜到了10pts 看着别人上去拿键盘 拿鼠标 心里有点羡慕（虽然我已经有一个鼠标了 这个句号虽然不够圆满，但是至少是完整的。]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day1 题解]]></title>
    <url>%2F2018-10-01%2F2018AutumnQBXTDay1%2F</url>
    <content type="text"><![CDATA[不知不觉弄了个鼠标回来（雾 T1. 扑克牌题面【题目描述】 这天， 小 Q 来到了小杜家， 找小杜玩起了扑克牌的游戏。 扑克牌有 54 张牌， 分别是数字 A,2,3,4,5,6,7,8,9,10,J,Q,K，每种数字有 4 个花色， 分别为红桃， 黑桃， 方块， 梅花， 还有两张大王和小王。 这天小 Q 和小杜玩起来比大小的游戏， 两人各拿出一张扑克牌比大小， 很显然 3]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 349B 《Color the Fence》]]></title>
    <url>%2F2018-09-30%2FCF349B%2F</url>
    <content type="text"><![CDATA[瞎贪心 题目描述 翻译来自洛谷 Igor深深爱上了Tanya. 现在, Igor想表达他的爱意, 他便在Tanya家对面的墙上写下一串数字. Igor认为, 数字写得越大, Tanya越喜欢他. 不幸的是, 他只有 $v$ 升油漆, 每个数字都会花掉一定的油漆 $a_i$ . Igor不喜欢 $0$ 所以数中不会出现 $0$. 问Igor能得到的最大的数是多少. Input / Output 格式 &amp; 样例输入格式第一行一个整数$v$，意义如题 第二行有九个数字$a_1,\ a_2,\ a_3,\ \dots \ ,\ a_9$，表示第$i$个数字需要$a_i$升油漆 输出格式一行一个整数，表示最大的Igor可以得到的数。 输入样例Case #1: 1255 4 3 2 1 2 3 4 5 Case #2: 1229 11 1 12 5 8 9 10 6 Case #3: 1201 1 1 1 1 1 1 1 1 输出样例Case #1: 155555 Case #2: 133 Case #3: 1-1 解析明显的贪心 先对这个序列排序（优先队列方便快捷），再从小到大依次计算可以画出的数字和画出数字的次数 接着从9到1进行枚举，看一看有没有什么可以替换一下的，替换成花费相对最小的数字 最后输出答案数组 代码实现玄学代码风格（雾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;/* Constants Start *//* Constants End *//* Variants Start */int v;int q[10]; // q[i].first = variant// q[i].second = idint ans[10];priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; pq;/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif v = FastIO::getint(); For (i, 1, 9) &#123; q[i] = FastIO::getint(); pq.push(std::make_pair(q[i], -i)); &#125; // 贪心选择当前最优 while (!pq.empty()) &#123; pair&lt;int, int&gt; pr = pq.top(); pq.pop(); ans[-pr.second] = v / pr.first; v %= pr.first; &#125; q[0] = 2147482333; // 进行替换 Bak (i, 9, 1) &#123; int tmp = 0; Bak (j, i - 1, 1) &#123; if (ans[j] &amp;&amp; q[j] &lt; q[tmp]) tmp = j; &#125; if (!tmp) continue; while (ans[tmp] &amp;&amp; v &amp;&amp; v &gt;= q[i] - q[tmp]) v -= q[i] - q[tmp], ++ans[i], --ans[tmp]; &#125; bool Printed = false; Bak (i, 9, 1) &#123; while (ans[i]) &#123; FastIO::__basic_putint(i); --ans[i]; Printed = true; &#125; &#125; // 程序并没有正确答案，输出-1 if (!Printed) puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 333A 《Secrets》]]></title>
    <url>%2F2018-09-30%2FCF333A%2F</url>
    <content type="text"><![CDATA[枚举 题目链接 题目大意Gerald 在卖一些国家机密，所有机密的花费相同——总价值为 $n$ 的钢镚。所有的钢镚的价值都是 $3^k\ (k ≥ 1)$。 某天来了一个交易者，他不会付出正好的价值，也就是说，Gerald 必须找钱给他。 求一个方案使得交易者付出的钢镚的价值 $≥n$ ，且付出最少额外价值的同时保证花费的钢镚数量最多。 Input / Output 格式 &amp; 样例输入样例一行一个整数 $n$ ，意义如题。 输出样例一行一个整数，即最多花费的钢镚数量。 输入样例Case #1: 11 Case #2: 14 输出样例Case #1: 11 Case #2: 12 解题思路显然，使用的金币面值越小，使用的金币数量就越大 那么答案就是第一个 $i$使得$\frac{n}{i}=1\ (i ≥ 1)$ 又因为交易者不会付出正好为 $n$ 价值的钢镚，所以答案就要 $+1$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; long long int n, now = 1l; cin &gt;&gt; n; while (true) &#123; now *= 3; if (n % now) &#123; cout &lt;&lt; n / now + 1 &lt;&lt; endl; return 0; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 295B 《Greg and Graph》]]></title>
    <url>%2F2018-09-30%2FCF295B%2F</url>
    <content type="text"><![CDATA[开倒车 倒序 Floyd 题目链接 题目描述 翻译来自洛谷 Greg有一个有边权的有向图，包含 $n$ 个点。这个图的每两个点之间都有两个方向的边。Greg喜欢用他的图玩游戏，现在他发明了一种新游戏： 游戏包含 $n$ 步。 第 $i$ 步Greg从图中删掉编号为 $x_i$ 的点。当删除一个点时，这个点的出边和入边都会被删除。 在执行每一步之前，Greg想知道所有点对间最短路长度的和。最短路可以经过任何没删掉的点。换句话说，如果我们假设 $d(i, v, u)$ 是在删掉 $xi$ 前 $v$ 和 $u$ 间的最短路长度，那么Greg想知道下面这个求和的值：$$\sum{v, u, v \neq u} d(i, v, u)$$ 帮帮Greg，输出每一步之前要求的值。 Input / Output 格式 &amp; 样例输入格式第一行包含一个整数 $n \ (1 \leq n \leq 500)$ ，代表图中的点数。 下面 $n$ 行每行包含 $n$ 个整数，代表边权：第 $i$ 行的第 $j$ 个数 $a{ij} \ (1 \leq a{ij} \leq 10^5, a_{ii} = 0)$ 代表从 $i$ 到 $j$ 的边权。 最后一行包含 $n$ 个整数： $x_1, x_2, \dots, x_n \ (1 \leq x_i \leq n)$ ，分别为Greg每一步删掉的点的编号。 输出格式输出 $n$ 个整数，第 $i$ 个数等于游戏的第 $i$ 步之前统计的求和值。 请不要在C++中使用%lld标志来输出64位整数long long，推荐使用cin, cout流或者用%I64d标志。 输入样例Case #1: 123101 Case #2: 123420 54 01 2 Case #3: 12345640 3 1 16 0 400 12 4 0 11 1 1 04 1 2 3 输出格式Case #1: 10 Case #2: 19 0 Case #3: 117 23 404 0 解析$n \le 500$ 很明显跑 Floyd 了 但是 Floyd 不支持删除操作 怎么办？ 开倒车 倒序添加！ 我们记录下删除点的信息，再倒着添加回去，在这个过程中套一个 Floyd 进去 要注意的是累计答案的时候判断点是否存在 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 500 + 10;int f[MAXN][MAXN];int seq[MAXN];long long int ans[MAXN];bool inGraph[MAXN];int n;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline void addEdge(int s, int t, int w) &#123; f[s][t] = f[t][s] = w;&#125;int main(int argc, char *const argv[]) &#123; n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = getint(); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; seq[i] = getint(); &#125; for (int l = n; l &gt; 0; --l) &#123; int k = seq[l]; inGraph[k] = true; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = std::min(f[i][j], f[i][k] + f[k][j]); if (inGraph[i] &amp;&amp; inGraph[j]) ans[l] += f[i][j]; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; ' '; return 0;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
        <tag>图论算法</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1908《逆序对》]]></title>
    <url>%2F2018-09-15%2FLuogu-P1908%2F</url>
    <content type="text"><![CDATA[Based on 归并排序 题目地址 题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 Input / Output 格式输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过$10^9$ 输出格式给定序列中逆序对的数目。 输入样例1265 4 2 6 3 1 输出样例111 数据范围对于25%的数据，$n \leq 2500n$ 对于50%的数据，$n \leq 4 \times 10^4$ 对于所有数据，$n \leq 5 \times 10^5$ 请使用较快的输入输出 解题思路暴力做法$O(n)$枚举所有的点，$O(n)$比较数的大小，求出逆序对的个数 均摊$O(n^2)$ 正解分治 想想归并排序的过程 比如我们要对下面的区间进行归并排序 a_i\ \ mid=4\ \ a_j2\ 4\ 7\ 8\ \ \ \ \ 1\ 5\ 6\ 24我们拿1去比较，此时可以构成的逆序对个数为4，把他放到$r_k$里，那么此时$i$是指向$a_1$的 接着继续比较，直到$a_i &lt; a_j$，就将$a_i$放到$r_k$里 以此类推，最终的逆序对个数就是中间求出的个数的和$=mid-i+1$的和 代码实现1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 5 * 1e5 + 10;int n, a[MAXN], tmp[MAXN];long long int ans;void mergeSort(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; mergeSort(l, mid); mergeSort(mid+1, r); int i = l, j = mid + 1, k = l; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) tmp[k] = a[i++], ++k; else tmp[k] = a[j++], ++k, ans += (long long int) mid - i + 1; &#125; while (i &lt;= mid) tmp[k++] = a[i++]; while (j &lt;= r) tmp[k++] = a[j++]; for (int i = l; i &lt;= r; ++i) a[i] = tmp[i];&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; mergeSort(1, n); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>分治</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度优先搜索]]></title>
    <url>%2F2018-09-15%2FDepthFirstSearch%2F</url>
    <content type="text"><![CDATA[常见算法 / 骗分技巧 洛谷P1605 迷宫题目地址 DFS 入门题 用一个数组mp存图，vis记录是否经过了这个点 12mp[i][j] = 0 表示有障碍mp[i][j] = 1 表示没有障碍 用一个函数dfs(x, y)来搜索 123当坐标为终点时，直接return，方案数++如果这个点没被访问过，而且这个点没有障碍，就把这个点设为访问过，然后dfs这个点 要注意的是起始点是访问过的 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;bool vis[6 + 2][6 + 2];int mp[6 + 2][6 + 2];const int dx[4] = &#123;0, 0, 1, -1&#125;;const int dy[4] = &#123;-1, 1, 0, 0&#125;;int tot, endx, endy, stx, sty, n, m, t;void dfs(int x, int y) &#123; if (x == endx &amp;&amp; y == endy) &#123; ++tot; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; int nowx = x + dx[i]; int nowy = y + dy[i]; if (!vis[nowx][nowy] &amp;&amp; mp[nowx][nowy]) &#123; vis[nowx][nowy] = true; dfs(nowx, nowy); vis[nowx][nowy] = false; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; mp[i][j] = (int) true; &#125; &#125; cin &gt;&gt; stx &gt;&gt; sty; cin &gt;&gt; endx &gt;&gt; endy; for (int i = 1; i &lt;= t; ++i) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; mp[l][r] = false; &#125; vis[stx][sty] = true; dfs(stx, sty); cout &lt;&lt; tot &lt;&lt; endl; return 0;&#125; 洛谷P1162 填涂颜色题目地址 本来这是一道 BFS 的题 但是有一种玄学的做法可以用 DFS 首先开两个mp存图，输入1时在第一个mp里存1，在第二个mp里存-1 具体就是搜索边界（每一行的第一个和第n个，每一列的第一个和第n个），在搜索的同时更新第一个mp为1 搜索完了就进行判断输出 123当第二个mp[i][j]为-1时输出1否则当第一个mp[i][j]为1时就输出2（被更新过了）否则输出0 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 30 + 5;int mp[MAXN][MAXN];int orz[MAXN][MAXN];int n;void dfs(int x, int y) &#123; if (x &gt; n || x &lt; 1 || y &gt; n || y &lt; 1 || mp[x][y] != 0) return; mp[x][y] = true; dfs(x+1, y); dfs(x-1, y); dfs(x, y+1); dfs(x, y-1);&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; cin &gt;&gt; mp[i][j]; if (mp[i][j] == 1) orz[i][j] = -1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (mp[i][1] != 1) dfs(i, 1); if (mp[i][n] != 1) dfs(i, n); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (mp[1][i] != 1) dfs(1, i); if (mp[n][i] != 1) dfs(n, i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (orz[i][j] == -1) cout &lt;&lt; 1 &lt;&lt; ' '; else if (mp[i][j] == 0) cout &lt;&lt; 2 &lt;&lt; ' '; else cout &lt;&lt; 0 &lt;&lt; ' '; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DFS</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「五校联考」Round#1 Day1&amp;Day2 T1]]></title>
    <url>%2F2018-08-26%2F2018FSExamRound1T1%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>自测</tag>
        <tag>五校联考</tag>
        <tag>只有经历过的人才知道的世界</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3884《[JLOI2009]二叉树问题》]]></title>
    <url>%2F2018-08-08%2FLuogu-P3884%2F</url>
    <content type="text"><![CDATA[不用倍增的 almost裸的LCA 题目描述如下图所示的一棵二叉树的深度、宽度及结点间距离分别为： 深度：4 宽度：4（同一层最多结点个数） 结点间距离： ⑧→⑥为8 (3×2+2=8) ⑥→⑦为3 （1×2+1=3） 注：结点间距离的定义：由结点向根方向（上行方向）时的边数×2， 与由根向叶结点方向（下行方向）时的边数之和。 图片来自洛谷&lt;/small&gt; Input / Output 格式 &amp; 样例输入格式输入文件第一行为一个整数n(1≤n≤100)，表示二叉树结点个数。接下来的n-1行，表示从结点x到结点y（约定根结点为1），最后一行两个整数u、v，表示求从结点u到结点v的距离。 输出格式：三个数，每个数占一行，依次表示给定二叉树的深度、宽度及结点u到结点v间距离。 输入输出样例输入样例： 123456789101110 1 2 1 3 2 42 53 63 75 85 96 108 6 输出样例： 123448 解题思路树的深度可以取$max${$depth[i]$} 树的宽度可以在取深度的时候拿一个桶记录下来，再循环取一遍$max$ 两点之间的距离可以先求$LCA$，再用一个公式算出来 distance = (depth[u] - depth[lca]) \times 2 + depth[v] - depth[lca]其中$lca = LCA(u, v)$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 100 + 10;struct Edge &#123; int prev, next;&#125; edge[MAXN * 2];int head[MAXN], father[MAXN][22], lg[MAXN], depth[MAXN];int cnt, n, m, s;int KangShifu[MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline void addEdge(int prev, int next) &#123; edge[++cnt].prev = prev; edge[cnt].next = head[next]; head[next] = cnt; &#125; void dfsInit(int root, int fa) &#123; depth[root] = depth[fa] + 1; father[root][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[root]; ++i) &#123; father[root][i] = father[father[root][i-1]][i-1]; &#125; for (int e = head[root]; e; e = edge[e].next) &#123; if (edge[e].prev != fa) dfsInit(edge[e].prev, root); &#125;&#125;int LCA(int x, int y) &#123; if (depth[x] &lt; depth[y]) swap(x, y); while (depth[x] &gt; depth[y]) x = father[x][lg[depth[x] - depth[y]] - 1]; if (x == y) return x; for (int i = lg[depth[x]]; i &gt;= 0; --i) &#123; if (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i]; &#125; return father[x][0];&#125;int main(int argc, char *const argv[]) &#123; n = getint(); for (int i = 1; i &lt; n; ++i) &#123; int prev = getint(), next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; int u = getint(); int v = getint(); dfsInit(1, 0); for (int i = 1; i &lt;= n; ++i) &#123; lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); &#125; int lca = LCA(u, v); int Depth = -23333; for (int i = 1; i &lt;= n; ++i) &#123; Depth = std::max(Depth, depth[i]); ++KangShifu[depth[i]]; &#125; int width = -23333; for (int i = 1; i &lt;= Depth + 2; ++i) width = std::max(width, KangShifu[i]); putint(Depth, true); putint(width, true); putint((depth[u] - depth[lca]) * 2 + (depth[v] - depth[lca]), true); return 0;&#125;]]></content>
      <tags>
        <tag>LCA</tag>
        <tag>各省省选</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近公共祖先 LCA 算法学习笔记]]></title>
    <url>%2F2018-08-07%2FLeastCommonAncestors%2F</url>
    <content type="text"><![CDATA[两个结点找共同的爸爸 LCA 的概念 在图论和计算机科学中，最近公共祖先（英语：lowest common ancestor）是指在一个树)或者有向无环图中同时拥有v和w作为后代的最深的节点。 ——Wikipedia 看不懂没关系 简单的来说，就是两个节点v和w的最近的祖先节点 如下图 6和7的LCA是2，3和7的LCA是1 LCA 的求法暴力求解让他们一步一步往上爬，直到相遇 节点背着那重重的编号呀 一步一步地往上爬 ——《蜗牛与黄鹂鸟》 显然，这样的算法会T到飞起 所以我们要使用倍增优化 倍增求解 所谓倍增，就是按2的倍数来增大，也就是跳 1、2、4 、8 、16、32 … 但是在这里，我们要考虑开倒车从大到小跳 因为如果我们从小到大跳，就会出现要「回溯」的情况，因为我们不一定能精准地跳，而从大到小跳可以避开这种情况 图源cnblogs 对于上面这一棵更复杂的树，我们考虑17和18的LCA 1217 -&gt;(跳4) 318 -&gt;(跳4) 5 -&gt;(跳1) -&gt; 3 是不是快多了，跳的次数大大减小 时间复杂度$O(nlogn)$ LCA 的代码 &amp; 实现流程实现流程首先我们要记录各个点的深度$depth[\ ]$和它们$2^i$级的祖先$father[\ ][\ ]$ 用$depth[i]$表示$i$点的深度，$father[i][j]$表示$i$点的$2^i$级的祖先 1234567891011// 预处理void dfsInit(int root, int fa) &#123; depth[root] = depth[fa] + 1; father[root][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[root]; ++i) &#123; father[root][i] = father[father[root][i-1]][i-1]; &#125; for (int e = head[root]; e; e = edge[e].next) &#123; if (edge[e].prev != fa) dfsInit(edge[e].prev, root); &#125;&#125; 接着我们就可以找LCA辣 对了，我们可以让它跑得更快 1234// 提前预处理出log2i + 1的值for (int i = 1; i &lt;= n; ++i) &#123; lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i);&#125; 在求 LCA 之前，我们先让两个节点蹦到同一层 但是跳的时候不能直接跳到 LCA 上，要跳到 LCA - 1 上，再输出 当前的父节点 就行了 因为直接蹦到 LCA 上可能会出现「误判」，比如上图中$4$和$8$，若不判断，则在跳的时候会输出1，但是答案是3 所以我们就可以让它们跳到$2$和$5$，然后输出父节点 123456789101112int LCA(int x, int y) &#123; // 我们设x的深度大于y的深度 if (depth[x] &lt; depth[y]) swap(x, y); while (depth[x] &gt; depth[y]) x = father[x][lg[depth[x] - depth[y]] - 1]; if (x == y) return x; // x 是 y 的祖先 for (int i = lg[depth[x]]; i &gt;= 0; --i) &#123; if (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i]; // 不相等就往上跳 &#125; return father[x][0];&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 500000 + 10;const int MAXM = 500000 + 10;struct Edge &#123; int prev, next;&#125; edge[MAXM * 2];int head[MAXN], father[MAXN][22], lg[MAXN], depth[MAXN];int cnt, n, m, s;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline void addEdge(int prev, int next) &#123; edge[++cnt].prev = prev; edge[cnt].next = head[next]; head[next] = cnt; &#125; // 预处理void dfsInit(int root, int fa) &#123; depth[root] = depth[fa] + 1; father[root][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[root]; ++i) &#123; father[root][i] = father[father[root][i-1]][i-1]; &#125; for (int e = head[root]; e; e = edge[e].next) &#123; if (edge[e].prev != fa) dfsInit(edge[e].prev, root); &#125;&#125;int LCA(int x, int y) &#123; // 我们设x的深度大于y的深度 if (depth[x] &lt; depth[y]) swap(x, y); while (depth[x] &gt; depth[y]) x = father[x][lg[depth[x] - depth[y]] - 1]; if (x == y) return x; // x 是 y 的祖先 for (int i = lg[depth[x]]; i &gt;= 0; --i) &#123; if (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i]; // 不相等就往上跳 &#125; return father[x][0];&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(), s = getint(); for (int i = 1; i &lt; n; ++i) &#123; int prev = getint(), next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; dfsInit(s, 0); for (int i = 1; i &lt;= n; ++i) &#123; lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x = getint(), y = getint(); putint(LCA(x, y), true); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>学习笔记</tag>
        <tag>LCA</tag>
        <tag>图论算法</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1531《I Hate It》]]></title>
    <url>%2F2018-08-05%2FLuogu-P1531%2F</url>
    <content type="text"><![CDATA[暴力能过的线段树板子题 题目背景很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 题目描述不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩 Input / Output 格式 &amp; 样例输入格式第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。 当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为’U’的时候，表示这是一条更新操作，如果当前A学生的成绩低于B，则把ID为A的学生的成绩更改为B，否则不改动。 输出格式对于每一次询问操作，在一行里面输出最高成绩 输入输出样例输入样例： 123456785 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 输出样例： 12345659 解题思路单点修改，区间查询 …… 线段树 树状数组！ 对了，注意处理输入，含读入char的题目最好不要用快读 …… 别问我怎么知道的 线段树解法可以说是很裸的一道题了 只需要单点修改，lazyTag什么的不需要的 就简单把区间和查询改成区间最值查询就行了 代码实现线段树解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 200000 + 10;int a[MAXN], segt[MAXN * 4];int n, m;inline int leftChild(int x) &#123; return x &lt;&lt; 1;&#125;inline int rightChild(int x) &#123; return x &lt;&lt; 1 | 1;&#125;inline void pushUp(int root) &#123; segt[root] = std::max(segt[leftChild(root)], segt[rightChild(root)]); // 更新最大值&#125;inline void buildTree(int l, int r, int root) &#123; if (l == r) &#123; segt[root] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; buildTree(l, mid, leftChild(root)); buildTree(mid + 1, r, rightChild(root)); pushUp(root);&#125;inline int query(int l, int r, int ql, int qr, int root) &#123; int res = -2147483640; if (ql &lt;= l &amp;&amp; r &lt;= qr) return segt[root]; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) res = std::max(res, query(l, mid, ql, qr, leftChild(root))); if (mid &lt; qr) res = std::max(res, query(mid + 1, r, ql, qr, rightChild(root))); // 查询最大值 return res;&#125;inline void Modify(int l, int r, int dest, int root, int k) &#123; if (l == r) &#123; segt[root] = std::max(segt[root], k); return; &#125; int mid = (l + r) &gt;&gt; 1; if (dest &lt;= mid) Modify(l, mid, dest, leftChild(root), k); if (mid &lt; dest) Modify(mid + 1, r, dest, rightChild(root), k); pushUp(root);&#125;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; buildTree(1, n, 1); for (int i = 1; i &lt;= m; ++i) &#123; char op; int a, b; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; // 推荐使用std::cin！ switch(op) &#123; case 'Q': &#123; putint(query(1, n, a, b, 1), true); break; &#125; case 'U': &#123; Modify(1, n, a, 1, b); break; &#125; &#125; &#125; return 0;&#125; 暴力代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 200000 + 10;int segt[MAXN]; int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline int query(int l, int r) &#123; int res = -2147483640; for (int i = l; i &lt;= r; ++i) res = std::max(res, segt[i]); return res;&#125;inline void Modify(int r, int k) &#123; segt[r] = std::max(segt[r], k);&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; segt[i]; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; segt[i] &lt;&lt; ' '; cout &lt;&lt; endl; for (int i = 1; i &lt;= m; ++i) &#123; char op; int a, b; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; switch(op) &#123; case 'Q': &#123; cout &lt;&lt; query(a, b) &lt;&lt; endl; break; &#125; case 'U': &#123; Modify(a, b); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>数据结构</tag>
        <tag>暴力</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1563「NOIP2016」《玩具谜题》]]></title>
    <url>%2F2018-08-05%2FLuogu-P1563%2F</url>
    <content type="text"><![CDATA[暴力模拟 题目描述小南有一套可爱的玩具小人, 它们各有不同的职业。 有一天, 这些玩具小人把小南的眼镜藏了起来。 小南发现玩具小人们围成了一个圈,它们有的面朝圈内,有的面朝圈外。如下图: 图片摘自洛谷 这时 singer 告诉小南一个谜題: “眼镜藏在我左数第3个玩具小人的右数第 1 个玩具小人的左数第 2 个玩具小人那里。 ” 小南发现, 这个谜题中玩具小人的朝向非常关键, 因为朝内和朝外的玩具小人的左右方向是相反的: 面朝圈内的玩具小人, 它的左边是顺时针方向, 右边是逆时针方向; 而面向圈外的玩具小人, 它的左边是逆时针方向, 右边是顺时针方向。 小南一边艰难地辨认着玩具小人, 一边数着: singer 朝内, 左数第 3 个是 archer 。 archer 朝外,右数第 1 个是 thinker 。 thinker 朝外, 左数第 2 个是 writer。 所以眼镜藏在 writer这里! 虽然成功找回了眼镜, 但小南并没有放心。 如果下次有更多的玩具小人藏他的眼镜, 或是谜題的长度更长, 他可能就无法找到眼镜了 。 所以小南希望你写程序帮他解决类似的谜題。 这样的谜題具体可以描述为: 有 n 个玩具小人围成一圈, 已知它们的职业和朝向。现在第 1 个玩具小人告诉小南一个包含 m 条指令的谜題, 其中第 z 条指令形如“左数/右数第 s ,个玩具小人”。 你需要输出依次数完这些指令后,到达的玩具小人的职业。 Input / Output 格式 &amp; 样例输入格式输入的第一行包含两个正整数 n,m ，表示玩具小人的个数和指令的条数。 接下来 n 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 0 表示朝向圈内， 1 表示朝向圈外。 保证不会出现其他的数。字符串长度不超过 10 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。 接下来 m 行，其中第 i 行包含两个整数 $ a_i,s_i$ ，表示第 i 条指令。若 $a_i=0$，表示向左数 $s_i$ 个人；若 $a_i=1$，表示向右数 $s_i$ 个人。 保证 $a_i$ 不会出现其他的数， $1 \le s_i &lt; n$ 。 输出格式输出一个字符串，表示从第一个读入的小人开始，依次数完 m 条指令后到达的小人的职业。 输入输出样例输入样例： 12345678910117 30 singer0 reader0 mengbier 1 thinker1 archer0 writer1 mogician 0 31 10 2 输出样例： 1writer 输入样例2： 12345678910111213141516171819202110 101 C0 r0 P1 d1 e1 m1 t1 y1 u0 V1 71 11 40 50 30 11 61 20 80 4 输出样例2： 1y 数据范围$1 \le n,m \le 100000$ 解题思路一看就是大&lt;/big&gt;&lt;/big&gt; 模拟 用一个结构体来存每个玩具的名字和朝向 123456struct Toy &#123; string name; bool faceTo; // 朝向&#125;Toy t[MAXN]; 约定true表示朝向圈外，false表示朝向圈内 在读入操作时，用一个变量now记录当前转到了哪个玩具 最后输出t[now].name即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;map&gt;using namespace std;const int MAXN = 100000 + 10;struct Toy &#123; string name; bool faceTo; // true 表示朝向圈外 // false 表示朝向圈内 &#125;;Toy t[MAXN];int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(); for (int i = 1; i &lt;= n; ++i) &#123; int to; cin &gt;&gt; to; string name; cin &gt;&gt; name; t[i].faceTo = (to == 1 ? true : false); t[i].name = name; &#125; int now = 1; for (int i = 1; i &lt;= m; ++i) &#123; int tA = getint(); bool right = tA == 1 ? true : false; // true 表示在右边 // false 表示在左边 int s = getint(); if (right) &#123; if (t[now].faceTo == true) now -= s; else now += s; &#125; else &#123; if (t[now].faceTo == true) now += s; else now -= s; &#125; if (now &gt; n) now -= n; if (now &lt; 1) &#123; int moved = 1 - now; now = n + 1 - moved; &#125; &#125; cout &lt;&lt; t[now].name &lt;&lt; endl; return 0;&#125; 最后：]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法逆元求法]]></title>
    <url>%2F2018-08-05%2Fmul-inverse-modulo%2F</url>
    <content type="text"><![CDATA[数论中的重要内容 注意：本文只讨论模数为质数的情况，因为当模数为合数时，不一定所有数都有逆元 定义在$\bmod\ p$的意义下，我们把$x$的乘法逆元写作$x^{-1}$。乘法逆元有这样一条性质： x \times x^{-1} \equiv 1\ (\bmod\ p)乘法逆元有什么用呢？ 模意义下的除法运算！ 除法运算对于模运算来说并不是「封闭」的，所以我们可以把除法转化成乘法 费马小定理求法前置知识：「快速幂」 $a^{p-1} \equiv 1 (\bmod\ p)%$ 经过变形，可得 $a \times a^{p-2} \equiv 1(\bmod\ p)$ 由定义可得，$a$的乘法逆元就是$a^{p-2}$ 这就要用到「快速幂」 12345678910111213inline int slowPower(int a, int b, int p) &#123; int ans = 1; while (b) &#123; if (b &amp; 1) ans = 1ll * ans * a % p; a = 1ll * a * a % p; b &gt;&gt;= 1; &#125; return ans;&#125;inline int invMod(int x, int p) &#123; return slowPower(x, p - 2, p);&#125; 代码实现输出1到n的逆元 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline long long int getint() &#123; long long int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10ll + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(long long int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(long long int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 5000000 + 10; long long int n, k, HA, a[MAXN]; long long int fac[MAXN], invf[MAXN]; long long int SlowPower(long long int a, long long int x) &#123; // a^x mod m long long int ret = 1; if (x == 1) return a; while (x) &#123; if (x &amp; 1) ret = ret * a % HA; a = a * a % HA; x &gt;&gt;= 1; &#125; return ret; &#125;&#125;signed main() &#123; using namespace Solution; using namespace FastIO; n = getint(); HA = getint(); fac[0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; fac[i] = (fac[i - 1] * i) % HA; &#125; invf[n] = SlowPower(fac[n], HA - 2); for (long long int i = n - 1; i &gt;= 1; --i) &#123; invf[i] = (invf[i + 1] * (i + 1)) % HA; &#125; for (long long int i = 1; i &lt;= n; ++i) &#123; printf("%lld\n", (invf[i] * fac[i - 1]) % HA); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划练习题代码]]></title>
    <url>%2F2018-08-03%2FDP-Exercise%2F</url>
    <content type="text"><![CDATA[DP 是啥？能吃吗？ 本文内容难度：从普及-到普及+/提高 数字三角形问题给你一个数字三角形，计算出从三角形的顶至底的一条路径，使该路径经过的数字总和最大， 规定每一步只能从一个数走到下一层上和它最近的左边的数或者右边的数 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 100;/* * * 设f[i][j]表示从第i行第j列走到底部的最优答案 * 转移方程：f[i][j] = a[i][j] + max(f[i+1][j], f[i+1][j+1]) * 注意边界 * */int f[MAXN][MAXN];int a[MAXN][MAXN];int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; int ans = -23333333; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; f[i][j] = a[i][j] + std::max(f[i-1][j], f[i-1][j-1]); ans = std::max(ans, f[i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 一维线性动态规划最长上升子序列1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 10000 + 10;/* * * 注意子序列可以不连续 * * 设f[i]表示目前选第i个数时的最长上升子序列的长度 * 也就是以第i个数结尾的最长上升子序列的长度 * f[i] = std::max(1, f[j] + 1) * 其中1 &lt;= j &lt; i, a[j] &lt; a[i] * * 时间复杂度O(n^2) * */int f[MAXN], a[MAXN];int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (a[j] &lt; a[i]) f[i] = std::max(1, f[j] + 1); &#125; &#125; cout &lt;&lt; f[n];&#125; 「NOIP2004」合唱队形1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; std::endl;using namespace std;const int MAXN = 10000 + 10;/* * * 正着求一遍最长上升子序列，反着求一遍最长上升子序列 * （也就是接着求一遍最长下降子序列） * 用f数组存最长上升子序列长度 * 用g数组存最长下降子序列长度 * 答案是n - max(f[i] + g[i] - 1) * */int f[MAXN], g[MAXN], a[MAXN];int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (a[j] &lt; a[i]) f[i] = std::max(f[i], f[j] + 1); &#125; &#125; for (int i = n; i &gt;= 1; --i) &#123; for (int j = n+1; j &gt; i; --j) &#123; if (a[j] &lt; a[i]) g[i] = std::max(g[i], g[j] + 1); &#125; &#125; int ans = -23333333; for (int i = 1; i &lt;= n; ++i) &#123; ans = std::max(ans, f[i] + g[i] - 1); &#125; cout &lt;&lt; n - ans &lt;&lt; endl; return 0;&#125; 线段覆盖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* -- DP 做法 -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000000 + 10;/* * * 先对线段排序 * 再设f[i]表示前i条线段中不重叠的最大数量 * f[i] = max(f[i - 1], f[j] + 1) * 其中1 &lt;= j &lt; i, 第j条线段的右端点 &lt;= 第i条线段的左端点 * *//* 这个时间复杂度洛谷会RE（实为TLE） */struct Line &#123; int left, right;&#125; line[MAXN];int f[MAXN];bool stlCmp(Line x, Line y) &#123; return x.right &lt; y.right;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; line[i].left &gt;&gt; line[i].right; if (line[i].left &gt; line[i].right) swap(line[i].left, line[i].right); &#125; sort(line + 1, line + 1 + n, stlCmp); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; if (line[j].right &lt;= line[i].left) f[i] = std::max(f[i], f[j] + 1); &#125; &#125; int ans = -23333333; for (int i = 1; i &lt;= n; ++i) ans = std::max(ans, f[i]); cout &lt;&lt; ans + 1 &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526272829/* -- 贪心做法 -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000000 + 10;struct Line &#123; int left, right;&#125; line[MAXN];bool stlCmp(Line x, Line y) &#123; return x.right &lt; y.right; &#125;int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; line[i].left &gt;&gt; line[i].right; sort(line + 1, line + 1 + n, stlCmp); int maxRight = -23333333, lines = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (maxRight &lt;= line[i].left) ++lines, maxRight = line[i].right; &#125; cout &lt;&lt; lines &lt;&lt; endl; return 0;&#125; 多维动态规划「NOIP2008」传纸条12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAX = 50 + 5;/*/ * * 设dp[i][j][x][y] 表示第一张纸条传到了(i, j)，第二张纸条传到了(x, y)时 * 的最大答案 * dp[i][j][k][l] = std::max( * std::max( * dp[i-1][j][k-1][l], * dp[i][j-1][k-1][l] * ), * std::max( * dp[i-1][j][k][l-1], * dp[i][j-1][k][l-1] * ) * ) * + a[i][j] * + a[k][l] * * 其中 j+1 &lt;= l &lt;= n * 最终答案是dp[m][n-1][m-1][n] */*/int dp[MAX][MAX][MAX][MAX];int n, m, a[MAX][MAX];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; m = getint(), n = getint(); for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; a[i][j] = getint(); &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; for (int k = 1; k &lt;= m; ++k) &#123; for (int l = j + 1; l &lt;= n; ++l) &#123; dp[i][j][k][l] = std::max(std::max(dp[i-1][j][k-1][l], dp[i-1][j][k][l-1]), std::max(dp[i][j-1][k-1][l], dp[i][j-1][k][l-1])) + a[i][j] + a[k][l]; &#125; &#125; &#125; &#125; putint(dp[m][n-1][m-1][n], true); return 0;&#125; 「NOIP2008 普及」 传球游戏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 30 + 2;const int MAXM = 30 + 2;/*/ * * 设dp[i][j]表示球传到第i次，传到第j个小朋友手中时的方案数 * dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] * 其中dp[0][1] = 1，ans = dp[m][1] /*/int n, m;int dp[MAXM][MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(); dp[0][1] = 1; for (int i = 1; i &lt;= m; ++i) &#123; dp[i][1] = dp[i-1][2] + dp[i-1][n]; dp[i][n] = dp[i-1][1] + dp[i-1][n-1]; for (int j = 2; j &lt; n; ++j) &#123; dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]; &#125; &#125; putint(dp[m][1], true); return 0;&#125; 背包问题NASA 的食物计划普及-，很水 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 50 + 5;const int MAXVolume = 400 + 10;const int MAXWeight = 400;int maxVolume, maxWeight, n;int f[MAXVolume][MAXWeight];struct Food &#123; int Volume; int Weight; int Calories;&#125; food[MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool newLine) &#123; if (x &lt; 0) x = -x; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (newLine) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; maxVolume = getint(); maxWeight = getint(); n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; food[i].Volume = getint(); food[i].Weight = getint(); food[i].Calories = getint(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = maxVolume; j &gt;= food[i].Volume; --j) &#123; for (int k = maxWeight; k &gt;= food[i].Weight; --k) &#123; f[j][k] = std::max(f[j][k], f[j - food[i].Volume][k - food[i].Weight] + food[i].Calories); &#125; &#125; &#125; printf("%d\n", f[maxVolume][maxWeight]); return 0;&#125; 装箱问题真 · 背包问题模板题 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 30 + 5;const int MAXV = 20000; int item[MAXN];int f[MAXN][MAXV];int main(int argc, char *const argv[]) &#123; int n, v; cin &gt;&gt; v; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; item[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= v; ++j) &#123; if (j &gt;= item[i]) f[i][j] = std::max(f[i-1][j], f[i-1][j-item[i]] + item[i]); else f[i][j] = f[i-1][j]; &#125; &#125; cout &lt;&lt; v - f[n][v] &lt;&lt; endl; return 0;&#125; 榨取kkksc03实在想不通这题为啥是普及/提高-，不应该是普及-吗 所以这就是你评普及/提高-的理由？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const bool __RETURN = true;const bool __NO_RETURN = false;const int MAXN = 100 + 10;const int MAXM = 200 + 10;const int MAXT = 200 + 10;int n, m ,T; struct Dream &#123; int time; int cost;&#125; d[MAXN];int dp[MAXN][MAXM][MAXT];/* * * 设dp[i][j][k]表示当选择第i个愿望， * 时间不超过j，金钱不超过k时的最大数量 * dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-d[i].time][k-d[i].cost] + 1) * 其中 j &gt;= d[i].time, k &gt;= d[i].cost * */inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(), T = getint(); for (int i = 1; i &lt;= n; ++i) &#123; d[i].time = getint(); d[i].cost = getint(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; for (int k = 1; k &lt;= T; ++k) &#123; if (j &gt;= d[i].time &amp;&amp; k &gt;= d[i].cost) &#123; dp[i][j][k] = std::max(dp[i-1][j][k], dp[i-1][j - d[i].time][k - d[i].cost] + 1); &#125; else &#123; dp[i][j][k] = dp[i-1][j][k]; &#125; &#125; &#125; &#125; putint(dp[n][m][T], __RETURN); return 0;&#125;]]></content>
      <tags>
        <tag>动态规划，DP</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1892《[BOI2003]团伙》]]></title>
    <url>%2F2018-07-28%2FLuogu-P1892%2F</url>
    <content type="text"><![CDATA[本题来自「2018 SDSC」Day 3 考试题目 题目链接 题目描述1920年的芝加哥，出现了一群强盗。如果两个强盗遇上了，那么他们要么是朋友，要么是敌人。而且有一点是肯定的，就是： 我朋友的朋友是我的朋友； 我敌人的敌人也是我的朋友。 两个强盗是同一团伙的条件是当且仅当他们是朋友。现在给你一些关于强盗们的信息，问你最多有多少个强盗团伙。 Input/Output 格式 &amp; 样例输入格式输入文件gangs.in的第一行是一个整数N(2&lt;=N&lt;=1000)，表示强盗的个数（从1编号到N）。 第二行M(1&lt;=M&lt;=5000)，表示关于强盗的信息条数。 以下M行，每行可能是F p q或是E p q（1&lt;=p q&lt;=N），F表示p和q是朋友，E表示p和q是敌人。输入数据保证不会产生信息的矛盾。 输出格式输出文件gangs.out只有一行，表示最大可能的团伙数。 输入样例12345664E 1 4F 3 5F 4 6E 1 2 输出样例13 解题思路很显然这是一道并查集的题目 初始时我们把每一个人单独列为一个团伙 由题可得，这道题主要有如下合并方式： 我的朋友是我的朋友 我的朋友的朋友是我的朋友 我的敌人的朋友是我的敌人 我的敌人的敌人是我的朋友 那么我们要另开一个$Enemy[\ ]$数组，$Enemy[i]$表示 $i$ 的其中一个敌人 每次合并敌人的时候，先判断是否有记录过敌人： 如果有，那么就把当前的敌人和记录的敌人合并在一个团伙里 如果没有，那么就把当前的敌人记录 最后开一个数组$count[\ ]$进行统计 这里要注意几个点：&lt;/big&gt; 开始时并查集数组要开两倍，因为你要把敌人和朋友存在一个数组里 合并敌人时要注意合并的不是敌人本身，而是$Find($敌人$)$ 最后统计的时候也要统计$Find($敌人$)$ 对了，注意输入…建议使用iostream…别问我为什么会写上这句话 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 1000 + 10;int U[MAXN * 2], Enemy[MAXN * 2], n, m;int count[MAXN * 2], cnt;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x) &#123; if (x &lt; 0) &#123; x = -x; &#125; if (x &gt;= 10) &#123; putint(x / 10); &#125; putchar(x % 10 + '0');&#125;int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] = y; return;&#125;int main(int argc, char *const argv[]) &#123; freopen("P1892.in", "r", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt;= n * 2; ++i) U[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; char c; int x, y; cin &gt;&gt; c &gt;&gt; x &gt;&gt; y; switch(c) &#123; case 'F': &#123; Union(x, y); break; &#125; case 'E': &#123; if (Enemy[x] == 0) Enemy[x] = Find(y); else Union(y, Enemy[x]); if (Enemy[y] == 0) Enemy[y] = Find(x); else Union(x, Enemy[y]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) ++count[Find(i)]; for (int i = 1; i &lt;= n; ++i) if (count[i]) ++cnt; printf("%d\n", cnt); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1821 《[USACO07FEB]银牛派对Silver Cow Party》]]></title>
    <url>%2F2018-07-20%2FLuogu-P1821%2F</url>
    <content type="text"><![CDATA[巧妙地把单终点最短路径问题转化为单源最短路径问题 题目地址 题目描述寒假到了，N头牛都要去参加一场在编号为X（1≤X≤N）的牛的农场举行的派对（1≤N≤1000），农场之间有M（1≤M≤100000）条有向路，每条路长Ti（1≤Ti≤100）。 每头牛参加完派对后都必须回家，无论是去参加派对还是回家，每头牛都会选择最短路径，求这N头牛的最短路径（一个来回）中最长的一条路径长度。 Input/Output 格式 &amp; 样例输入格式：第一行三个整数N，M, X； 第二行到第M+1行：每行有三个整数Ai，Bi, Ti ,表示有一条从Ai农场到Bi农场的道路，长度为Ti。 输出格式：一个整数，表示最长的最短路得长度。 输入样例#1：1234567894 8 21 2 41 3 21 4 72 1 12 3 53 1 23 4 44 2 3 输出样例#1：110 题目说明图片来自洛谷 解题思路单源最短路我们都会做，一遍SPFA或Dijkstra就行了。 单终点最短路呢？ 对于这道题，奶牛们从派对分别回家就是一个单源最短路问题，而奶牛们从家到派对就是一个单终点最短路问题。 如何把单终点最短路转化为单源最短路问题？注意：题目中建的是有向边 实在是想不出来的我翻了一波题解，发现他们都在输入的时候另建了一个图，反向存边，就完美地把一个单终点最短路转化为单源最短路因为单源和单终点的区别仅仅是方向改变，很显然这么做是对的 最后的答案是什么？正向建图的距离+反向建图的距离的最大值 代码实现我们在数组后加上「Reversed」，表示它存的是反向的图 评测记录 AC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; #include &lt;algorithm&gt;#include &lt;queue&gt; using namespace std;const int MAXN = 1000 + 10;const int MAXM = 100000 + 10;struct Edge &#123; int prev; int next; int weight;&#125; edge[MAXM], edgeReversed[MAXM];int n, m, x, cnt, maxWeight = -1;int dis[MAXN], head[MAXN], disReversed[MAXN], headReversed[MAXN];bool inQueue[MAXN], inQueueReversed[MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; (ch == '-') &amp;&amp; (x = -1); ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void addEdgeReversed(int prev, int next, int weight) &#123; edgeReversed[cnt].prev = prev; edgeReversed[cnt].weight = weight; edgeReversed[cnt].next = headReversed[next]; headReversed[next] = cnt;&#125;inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].prev = prev; edge[cnt].weight = weight; edge[cnt].next = head[next]; head[next] = cnt; addEdgeReversed(next, prev, weight);&#125;inline void Dijkstra(int s, int n) &#123; memset(inQueue, 0, sizeof(inQueue)); for (int i = 0; i &lt;= n; ++i) dis[i] = 2147483647; std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q; inQueue[s] = true; q.push(make_pair(s, 0)); dis[s] = 0; while (!q.empty()) &#123; int prev = q.top().first; int weight = q.top().second; q.pop(); inQueue[prev] = false; for (int e = head[prev]; e; e = edge[e].next) &#123; if (dis[edge[e].prev] &gt; edge[e].weight + weight) &#123; dis[edge[e].prev] = edge[e].weight + weight; q.push(make_pair(edge[e].prev, dis[edge[e].prev])); &#125; &#125; &#125;&#125;inline void DijkstraReversed(int s, int n) &#123; memset(inQueueReversed, 0, sizeof(inQueueReversed)); for (int i = 0; i &lt;= n; ++i) disReversed[i] = 2147483647; std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q; inQueueReversed[s] = true; q.push(make_pair(s, 0)); while (!q.empty()) &#123; int prev = q.top().first; int weight = q.top().second; q.pop(); inQueueReversed[prev] = false; for (int e = headReversed[prev]; e; e = edgeReversed[e].next) &#123; if (disReversed[edgeReversed[e].prev] &gt; edgeReversed[e].weight + weight) &#123; disReversed[edgeReversed[e].prev] = edgeReversed[e].weight + weight; q.push(make_pair(edgeReversed[e].prev, disReversed[edgeReversed[e].prev])); &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(), x = getint(); int tm = m; while (tm --&gt; 0) &#123; int prev = getint(), next = getint(), weight = getint(); addEdge(prev, next, weight); &#125; int tn = n; Dijkstra(x, n); DijkstraReversed(x, n); for (int i = 1; i &lt;= n; ++i) &#123; maxWeight = std::max(maxWeight, dis[i] + disReversed[i]); &#125; printf("%d\n", maxWeight); return 0;&#125;]]></content>
      <tags>
        <tag>最短路</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1149《火柴棒等式》]]></title>
    <url>%2F2018-07-15%2FLuogu-P1149%2F</url>
    <content type="text"><![CDATA[「枚举」的入门题目 题目地址 题目描述给你n根火柴棍，你可以拼出多少个形如$ A+B=C$的等式？等式中的 $A 、 B 、 C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$ ）。用火柴棍拼数字 $0-9$ 的拼法如图所示： 图片来自洛谷 注意： 加号与等号各自需要两根火柴棍 如果 $A≠B$ ，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式( $A,B,C&gt;=0$ ) $n$ 根火柴棍必须全部用上 输入输出格式输入格式： 一个整数 $n$($n&lt;=24$) 。 输出格式： 一个整数，能拼成的不同等式的数目。 输入样例#1：114 输出样例#1：12 输入样例#2：118 输出样例#2：19 说明【输入输出样例1解释】 $2$ 个等式为 $0+1=1$ 和 $1+0=1$ 。 【输入输出样例2解释】 $9$ 个等式为： 1234567890+4=40+11=111+10=112+2=42+7=94+0=47+2=910+1=1111+0=11 解题思路枚举思路我们可以枚举$A$和$B$ 上界？ 手算啊 $n&lt;=24$，去掉符号用的4根火柴棒，相当于是「$n&lt;=20$」 再$\frac{n}{2}$（这里只考虑有$A$和$B$两个数字），可得 对于某一个数字，可调用的火柴棒共有10个 由于使用火柴棒数量最少的$1$要使用2根，所以我们假设两个数字都为$11111$，但是显然这样是不成立的，因为$2\times5 + 2 * 5$就已经达到$20$了，没有火柴棒再放第三个数字，那么由此可粗略得出 对于某一个数字，它最高有5位 于是我们可以选择枚举到$9999$，洛谷的评测机上也不会TLE 当然CCF的老爷机就不一定了（ 于是我们可以选择再精确一点 // 未完待续 枚举之后相加，取出所用的火柴棒数，进行判断就好了 预处理思路火柴棒数怎么求？ 新建一个数组 f[10000 * 2 + 10] ，表示i这个数字需要用f[i]根火柴 题目已经给出了f[0~9]，如何处理出f[10~(10000*2)]？ 123456f[i] = f[i/10] + f[i%10]; // (i &gt;= 10)/*这里的i/10可以取它除了个位上其他位的数，在前面已经处理过，所以可以直接使用；这里的i%10可以取它个位上的数，也处理过，可以直接使用。两个火柴棒数目一相加，就能获得火柴棒的总数。*/ 循环一遍就好了 代码实现12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int sticks[10001 * 2];int main(int argc, char *const argv[]) &#123; sticks[0] = sticks[6] = sticks[9] = 6; sticks[1] = 2; sticks[2] = sticks[3] = sticks[5] = 5; sticks[4] = 4; sticks[7] = 3; sticks[8] = 7; int n; cin &gt;&gt; n; int sum = 0; for (int i = 10; i &lt;= 20000; ++i) &#123; sticks[i] = sticks[i/10] + sticks[i%10]; &#125; for (int i = 0; i &lt;= 9999; ++i) &#123; for (int j = 0; j &lt;= 9999; ++j) &#123; if (sticks[i] + 2 + sticks[j] + 2 + sticks[i+j] == n) ++sum; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>暴力</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 国庆清北刷题冲刺班 《角谷猜想》]]></title>
    <url>%2F2018-07-04%2FKakutani%2F</url>
    <content type="text"><![CDATA[不错的字符串模拟 题目描述某个名字末尾是654321的小A同学是个大家眼中公认的学霸（虽然他永远不承认），他对题目的直觉到了一种可怕的地步，一眼看出题目的算法对他而言只是小 Case，他甚至能在看到一个证明的瞬间敏锐地判断出这个证明的真伪。 现在小A同学机缘巧合地看到了角古猜想（即对于$x$当它为奇数则$x=3x+1$,$x$为偶数，则$x=\frac{x}{2}$，一直重复这个步骤，则最终$x$会变为$1$），在看完这个猜想的一瞬间，他的直觉就来了——他认为角古猜想一定是错的！然后——他立刻就能找出反例！ 他立刻在纸上写满了$n$($1&lt;=n&lt;=1000$)个小于$10^L$($0&lt;=L&lt;=10^4$)的正整数，打算放到他的grand super computer 上去跑，可是他突然觉得有些正整数不是很吉利，可能会干扰到他的最终结果，所以他打算把一些正整数加工一下。 小A觉得4、7、13都是不吉利的数字，所以要把所有正整数里的4、7、13都去掉，如果去掉后得到的新数字里依旧有4、7、13，那么就要继续删掉，直到最后的数组不存在4、7、13，它才是一个吉利的数字。例如$1411733=&gt;111733=&gt;11133=&gt;113=&gt;1$特别规定，如果最后所有数字都被删掉了，就输出$0$小A觉得这个枯燥的工作不适合他这样的天才，于是就把这个工作交给了你。 当然，只要你能顺利解决，小A承诺会在那篇将会震惊世界的论文的特别感谢栏上署上你的大名。 Input/Output 格式 &amp; 样例Input 一共$n+1$行。 第一行一个正整数$n$($1&lt;=n&lt;=100$)，表示数字个数。 接下来每行一个正整数$x$。 Output 一共$n$行。 每行一个正整数，表示输入每个$x$对应的答案。 Sample Input 1 123456513713141713133333337258914117332147483647 Sample Output1 123450113333332589121836 数据范围对于$10%$的数据，$0&lt;=x&lt;=2147483647$对于另外的$10%$数据，给定的数字没有数码$3$对于另外的$10%$数据，$n=1$对于全部的数据，$n$($1&lt;=n&lt;=1000$)，$1&lt;=x&lt;=10^L$($0&lt;=L&lt;=10^4$) 解析「$1&lt;=x&lt;=10^L$($0&lt;=L&lt;=10^4$)」 显而易见的高精 进而联想到字符串模拟 这道题有两个点需要注意： 顺序不能乱 1先执行删除4和7的操作，再执行删除13的操作 在删除13时要检查是否残留 1234567样例里有一个数据1411733先删除4和7，得到11133再删除13，得到113假如只删除一次13，那么就会有残留的13出现所以要在删除之后进行检查，否则就需要递归，将13再次删除 代码实现评测记录 AC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;inline string eraseAll4s(string x) &#123; string ret = ""; int len = x.length(); for (int i = 0; i &lt; len; ++i) if (x[i] == '4') x[i] = '-'; // 删除的'4'用'-'表示 for (int i = 0; i &lt; len; ++i) if (isdigit(x[i])) ret += x[i]; // 采集存留的数字，组成一个新的字符串 return ret;&#125;inline string eraseAll7s(string x) &#123; // 代码思想一样，不再赘述 string ret = ""; int len = x.length(); for (int i = 0; i &lt; len; ++i) if (x[i] == '7') x[i] = '-'; for (int i = 0; i &lt; len; ++i) if (isdigit(x[i])) ret += x[i]; return ret;&#125;inline string eraseAll13s(string x) &#123; string ret = ""; int len = x.length(); for (int i = 0; i &lt; len - 1; ++i) &#123; if (x[i] == '1' &amp;&amp; x[i+1] == '3') x[i] = x[i+1] = '-'; // 注意这里要同时检测两个字符 &#125; bool b = false; for (int i = 0; i &lt; len; ++i) if (isdigit(x[i])) ret += x[i]; for (int i = 0; i &lt; len - 1; ++i) &#123; // 重新进行检查 if (ret[i] == '1' &amp;&amp; ret[i+1] == '3') &#123; b = true; break; &#125; &#125; if (b) &#123; ret = eraseAll13s(ret); // 递归删除 &#125; return ret;&#125;string Modify(string x) &#123; string ret = ""; ret = eraseAll4s(x); ret = eraseAll7s(ret); ret = eraseAll13s(ret); // 进行删除 if (ret == "") ret = "0"; return ret;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); int n; string v; cin &gt;&gt; n; while (n --&gt; 0) &#123; /* 这里是一个比较神奇的 while()， 效果相当于 for (int i = 0; i &lt; n; ++i)， 但是会对n进行修改，下标也是从n-1到0 */ cin &gt;&gt; v; cout &lt;&lt; Modify(v) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2330 《[SCOI2005]繁忙的都市》]]></title>
    <url>%2F2018-07-04%2FLuogu-P2330%2F</url>
    <content type="text"><![CDATA[接近裸的最小生成树 题目地址 题目描述城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市C的道路是这样分布的：城市中有n个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求： 1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2．在满足要求1的情况下，改造的道路尽量少。 3．在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。 任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。 Input/Output 格式 &amp; 样例输入格式： 第一行有两个整数n,m表示城市有n个交叉路口，m条道路。 接下来m行是对每条道路的描述，u, v, c表示交叉路口u和v之间有道路相连，分值为c。(1≤n≤300，1≤c≤10000，1≤m≤50000) 输出格式： 两个整数s, max，表示你选出了几条道路，分值最大的那条道路的分值是多少。 输入样例#1：1234564 51 2 31 4 52 4 72 3 63 4 8 输出样例#1：13 6 数据范围前面已经提到过， $1 \le n \le 300, 1 \le c \le 10000, 1 \le m \le 50000$ 解题思路「1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。」 显然这是一道最小生成树的题目 但是题目中并没有要求输出最小的总权值，而是要输出最长边边权 所以它和裸的最小生成树还是有一些区别的 代码实现评测记录 AC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 300 + 10;const int MAXM = 50000 + 10;int U[MAXN];int cnt;int cntTree;int n, m;struct Edge &#123; int prev, next, w;&#125; edge[MAXM * 2];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;bool sortCmp(Edge x, Edge y) &#123; return x.w &lt; y.w;&#125;inline int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;int Kruskal() &#123; int ret = -1; int treeAns = 0; sort(edge + 1, edge + 1 + m, sortCmp); for (int i = 1; i &lt;= MAXN; ++i) U[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int eprev = Find(edge[i].prev); int enext = Find(edge[i].next); if (eprev == enext) continue; treeAns += edge[i].w; U[eprev] = enext; ret = max(ret, edge[i].w); // 更新权值 ++cntTree; if (cntTree == n - 1) break; &#125; return ret;&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(); for (int i = 1; i &lt;= m; ++i) &#123; int v = getint(), next = getint(), w = getint(); edge[i].prev = v; edge[i].next = next; edge[i].w = w; &#125; int ans = Kruskal(); printf("%d %d", n - 1, ans); // 显而易见，生成的树肯定有 n - 1 条边，所以直接输出 n - 1 就好 return 0;&#125;]]></content>
      <tags>
        <tag>生成树</tag>
        <tag>并查集</tag>
        <tag>各省省选</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法]]></title>
    <url>%2F2018-07-03%2FShortestPath%2F</url>
    <content type="text"><![CDATA[较简单的图论算法 最短路算法有很多种，比较著名的有 Bellman-Ford SPFA（队列优化版 Bellman-Ford） Dijkstra Floyd（基于DP思想） 其中 Floyd 只适用于多源最短路径，SPFA 和 Bellman-Ford 代码易于理解但是效率低，Dijkstra 效率高但是不适用于图中有负边权的情况 至于其他算法……我见过某个dalao用线段树写最短路 本文只介绍单源最短路径中的 SPFA 和 Dijkstra （ Bellman-Ford 由于速度慢于 SPFA 所以忽略）。 SPFASPFA 可以处理图含有负边权的情况，同时又因为它效率较低，所以它更适合处理稀疏图 这里给出数组版代码 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int MAXINT = 2147483647;const int MAXN = 2500 + 5;const int MAXM = 6200 + 5;struct Edge &#123; int v, next, w;&#125;edge[MAXM * 2];int head[MAXN];int cnt;int dis[MAXN];bool inQueue[MAXN];inline void addEdge(int u, int v, int w) &#123; edge[++cnt].v = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;inline int SPFA(int s, int t, int n) &#123; for (int i = 1; i &lt;= n; ++i) dis[i] = MAXINT; dis[s] = 0; inQueue[s] = true; std::queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int v = q.front(); q.pop(); inQueue[v] = false; for (int e = head[v]; e; e = edge[e].next) &#123; if (dis[edge[e].v] &gt; edge[e].w + dis[v]) &#123; dis[edge[e].v] = edge[e].w + dis[v]; if (!inQueue[edge[e].v]) &#123; q.push(edge[e].v); inQueue[edge[e].v] = true; &#125; &#125; &#125; &#125; return dis[t];&#125;int main(int argc, char const *argv[]) &#123; int n, m, s, t; /* n for the nodes' count m for the edges' count s for the start node t for the end node */ scanf("%d %d %d %d\n", &amp;n, &amp;m, &amp;s, &amp;t); for (int i = 0; i &lt; m; ++i) &#123; int u, v, w; scanf("%d %d %d\n", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); addEdge(v, u, w); &#125; printf("%d\n", SPFA(s, t, n)); return 0;&#125; DijkstraDijkstra 不能解决图中有负边权的情况，算法效率较高，适合在不含负边权的稠密/稀疏图中使用 这里还是给出数组写法 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#define mp std::make_pairusing namespace std;const int MAXN = 1000 + 7;const int MAXM = 1000000 + 7;const int INF = 0x7fffffff;typedef long long int ll;typedef std::pair&lt;int, int&gt; Pair;int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') x = -x; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;struct Node &#123; int v, next, w;&#125;edge[MAXM];int num = 0, head[MAXN];bool inQueue[MAXN];ll dis[MAXN]; // dis[i] --&gt; the distance from i to ninline void addEdge(int u, int v, int w) &#123; edge[++num].v = v; edge[num].w = w; edge[num].next = head[u]; head[u] = num;&#125;inline int dijkstra(int s, int t, int n) &#123; // s for start, t for end, n for the count of the nodes for (int i = 1; i &lt;= n; ++i) dis[i] = INF; std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q; inQueue[s] = true; dis[1] = 0; q.push(mp(s,0)); while (!q.empty()) &#123; int v = q.top().first; int value = q.top().second; q.pop(); for (int e = head[v]; e; e = edge[e].next) &#123; if (dis[edge[e].v] &gt; value + edge[e].w) &#123; dis[edge[e].v] = (value + edge[e].w) ; q.push(mp(edge[e].v, dis[edge[e].v])); &#125; &#125; &#125; return dis[t];&#125;int main(int argc, char const *argv[]) &#123; n = getint(), m = getint(); for (int i = 0; i &lt; m; ++i) &#123; int x, y, z; x = getint(), y = getint(), z = getint(); addEdge(x, y, z); &#125; printf("%d\n", dijkstra(1, n, n)); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1955 《[NOI2015]程序自动分析》]]></title>
    <url>%2F2018-05-12%2FLuogu-P1955%2F</url>
    <content type="text"><![CDATA[第一道NOI的题目 洛谷 P1955 题解题目描述在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设x1,x2,x3…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 输入输出格式输入格式：从文件prog.in中读入数据。 输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj； 输出格式：输出到文件 prog.out 中。 输出文件包括t行。 输出文件的第 k行输出一个字符串“ YES” 或者“ NO”（不包含引号，字母全部大写），“ YES” 表示输入中的第k个问题判定为可以被满足，“ NO” 表示不可被满足。 输入输出样例输入 #11234567221 2 11 2 021 2 12 1 1 输出 #112NOYES 输入 #212345678910231 2 12 3 13 1 141 2 12 3 13 4 11 4 0 输出 #212YESNO 数据范围（图片来自洛谷） 解题思路把题目中的「x1=x2」看做x1和x2在同一个集合里，「x1≠x2」看做x1和x2不在同一个集合里…… 好了，显而易见这是道并查集的题目 读懂了题目，下手就很简单了 这里要注意：「x1≠x2」是无法进行的操作（因为你不能强制他们不在同一个集合里！若非要实现，就又要维护一个数组），把它看成查询操作。 而且「x1=x2」类似的操作要先做，「x1≠x2」类似的操作要最后做（因为后者对集合没有影响，它是一个查询操作） 1234567如果你遇到了类似这样的数据：...1 2 01 2 1...那么根据我们的思路， 「1 2 0」是一个查询操作，对集合没有影响，那么就相当于少了一个操作！必须要先进行「x1=x2」类似的合并操作，再做「x1≠x2」类似的查询操作 代码实现90分代码 评测记录（未离散化）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;const int MAXN = 100000 + 10;int U[MAXN], n, t;int e[MAXN], e0[MAXN], x[MAXN], y[MAXN];/* 快读 */inline int getInt() &#123; int s = 0, x = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') x = -x; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] = y; return;&#125;bool Main() &#123; n = getInt(); for (int i = 0; i &lt; MAXN; ++i) &#123; U[i] = i; &#125; memset(e, 0, sizeof(e)); memset(x, 0, sizeof(x)); memset(y, 0, sizeof(y)); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = getInt(), y[i] = getInt(), e[i] = getInt(); &#125; int j = 1; // 第一次做 「x1=y1」的合并操作 for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 1) Union(fx, fy); &#125; // 第二次做 「x1≠y1」的查询操作 for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 0) &#123; if(Find(fx) == Find(fy)) return false; &#125; &#125; return true;&#125;int main() &#123; ios::sync_with_stdio(false); t = getInt(); for (int i = 0; i &lt; t; ++i)&#123; if (Main()) puts("YES"); else puts("NO"); &#125;&#125; 离散化简介——引自百度百科12345离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：原数据：1,999,100000,15；处理后：1,3,4,2；原数据：&#123;100,200&#125;，&#123;20,50000&#125;，&#123;1,400&#125;；处理后：&#123;3,4&#125;，&#123;2,6&#125;，&#123;1,5&#125;； 对一堆数据进行离散化， 先排序 [ 推荐 std::sort() ]（针对有序序列进行离散化） 删除重复元素（节省空间） 对数据进行索引（最终目的） 而其中我们要用到STL提供的pair来储存变量。pair提供一个包含两个数据成员的结构体模板，可以快速访问其中的元素，就像一个压缩包一样（ 代码实现AC代码 评测记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#define Pair pair&lt;ll,ll&gt; using namespace std;typedef long long int ll;const int MAXN = 600000 + 10;int U[MAXN], n, t;int e[MAXN], x[MAXN], y[MAXN];Pair p[MAXN];inline int getInt() &#123; int s = 0, x = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') x = -x; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); U[x] = y; return;&#125;bool stlCmp(Pair x, Pair y) &#123; return (x.first &gt; y.first);&#125;void Disc(Pair a[], int A[]) &#123; int tot = 0; sort(a + 1, a + n*2 + 1, stlCmp); for (int i = 1; i &lt;= n*2; ++i) &#123; if (i == 1 || a[i].first != a[i-1].first) tot++; A[a[i].second] = tot; &#125; &#125; bool Main() &#123; n = getInt(); for (int i = 0; i &lt; 500010; ++i) &#123; U[i] = i; &#125; memset(e, 0, sizeof(e)); memset(x, 0, sizeof(x)); memset(y, 0, sizeof(y)); memset(p, 0, sizeof(p)); for (int i = 1; i &lt;= n; ++i) &#123; int ax = getInt(), ay = getInt(), ae = getInt(); e[i] = ae; p[i] = make_pair(ax, i); p[i + n] = make_pair(ay, i+n); &#125; Disc(p, x); for (int i = 1; i &lt;= n; ++i) y[i] = x[n + i]; for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 1) Union(fx, fy); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 0) &#123; if(Find(fx) == Find(fy)) return false; &#125; &#125; return true;&#125;int main() &#123; ios::sync_with_stdio(false); t = getInt(); for (int i = 0; i &lt; t; ++i)&#123; if (Main()) puts("YES"); else puts("NO"); &#125;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集模板]]></title>
    <url>%2F2018-04-14%2Funion-set%2F</url>
    <content type="text"><![CDATA[并查集模板 题目链接 题目描述如题，现在有一个并查集，你需要完成合并和查询操作。 输入输出格式输入格式： 第一行包含两个整数N、M，表示共有N个元素和M个操作。 接下来M行，每行包含三个整数Zi、Xi、Yi 当Zi=1时，将Xi与Yi所在的集合合并 当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N 输出格式： 如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N 输入输出样例输入输出样例1input: 123456784 72 1 21 1 22 1 21 3 42 1 41 2 32 1 4 output: 1234NYNY 数据说明时空限制：1000ms,128M 数据规模： 对于30%的数据，N&lt;=10，M&lt;=20； 对于70%的数据，N&lt;=100，M&lt;=1000； 对于100%的数据，N&lt;=10000，M&lt;=200000。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;const int MAXN = 10000 + 10;int U[MAXN], m, n;inline int Find(int x) &#123; if (U[x] &lt; 0) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] += U[y]; U[y] = x; &#125;int main() &#123; ios::sync_with_stdio(false); scanf("%d %d", &amp;n, &amp;m); for (int i = 1;i &lt; MAXN;i++) U[i] = -1; int z; for (int i = 0;i &lt; m;i++) &#123; scanf("%d", &amp;z); int x, y; switch(z) &#123; case 1:&#123; scanf("%d %d", &amp;x, &amp;y); Union(x, y); break; &#125; case 2:&#123; scanf("%d %d", &amp;x, &amp;y); if (Find(x) == Find(y)) puts("Y"); else puts("N"); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1536 《村村通》]]></title>
    <url>%2F2018-04-14%2FLuogu-P1536%2F</url>
    <content type="text"><![CDATA[并查集的好题目 题目地址 题目描述某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府“村村通工程”的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？ 输入输出格式输入格式：每个输入文件包含若干组测试测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目N（N&lt;1000）和道路数目M；随后的M行对应M条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从1到N编号。 注意：两个城市间可以有多条道路相通。例如： 3 3 1 2 1 2 2 1 这组数据也是合法的。当N为0时，输入结束。 输出格式：对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。 输入输出样例输入样例1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 输出样例1234102998 解题思路这是道并查集的题目，可以说接近是裸的并查集，但是你没法把这题理解为并查集这就很烦了啊喂 我们可以把它的公路理解成一条一条绳子，用来连接各个城市，可以把几个城市绑在一块（雾 那么这样就更像并查集了 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define DEBUG_CERR(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl;using namespace std;const int MAXN = 1000 + 5;int n, m;int u[MAXN];int Find(int x) &#123; if (u[x] &lt; 0) return x; return u[x] = Find(u[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; u[x] += u[y]; u[y] = x;&#125;int main() &#123; ios::sync_with_stdio(false); while (scanf("%d %d", &amp;n, &amp;m) == 2) &#123; for (int i = 1;i &lt; MAXN;i++) u[i] = -1; for (int i = 1;i &lt;= m;i++) &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); a = Find(a), b = Find(b); if (a != b) Union(a, b); &#125; int ans = 0; for (int i = 1;i &lt;= n;i++) &#123; if (u[i] &lt; 0) ans++; &#125; printf("%d\n", ans - 1); &#125; return 0;&#125; 提交记录]]></content>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树学习笔记]]></title>
    <url>%2F2018-04-01%2FSegment-Tree%2F</url>
    <content type="text"><![CDATA[快速查找和修改区间 注：本文包含洛谷 P3372 【模板】线段树 1 题解 线段树模板前言 什么是线段树？ 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 线段树的主要用途及好处？ 线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。 线段树的应用？ 最简单的应用就是记录线段是否被覆盖，随时查询当前被覆盖线段的总长度。 代码基础函数我们选择一个$O(1)$的取儿子函数： 123456789inline int leftChild(int p) &#123; return p &lt;&lt; 1;&#125;// 左子树 inline int rightChild(int p) &#123; return p &lt;&lt; 1 | 1;&#125;// 右子树 线段树的维护： 1234567891011121314void pushUp(int p) &#123; t[p] = t[leftChild(p)] + t[rightChild(p)];&#125;// 向上维护区间void pushUpMin(int p) &#123; t[p] = std::min(t[leftChild(p)], t[rightChild(p)]);&#125; // 向t[p]下放Min标签void pushUpMax(int p) &#123; t[p] = std::max(t[leftChild(p)], t[rightChild(p)]);&#125; // 向t[p]下放Max标签 递归建树： 123456789101112131415typedef long long int lli;void buildTree(lli p, lli l, lli r) &#123; if (l == r) &#123; ans[p] = a[l]; return; &#125; // 如果左右区间相同，则必是叶子节点 lli mid = (l + r) &gt;&gt; 1; buildTree(leftChild(p), l, mid); buildTree(rightChild(p), mid + 1, r); // 递归 pushUp(p); &#125; // 递归 + 二分建树 区间修改函数1234567891011121314151617181920212223242526272829303132inline void Record(lli p, lli l, lli r, lli k) &#123; tag[p] = tag[p] + k; ans[p] = ans[p] + k * (r - l + 1); // 因为是区间统一改变，所以ans要加元素个数 &#125;// 记录当前节点所代表的区间inline void pushDown(lli p, lli l, lli r) &#123; lli mid = (l + r) &gt;&gt; 1; Record(leftChild(p), l, mid, tag[p]); Record(rightChild(p), mid + 1, r, tag[p]); tag[p] = 0; // 每次更新两个儿子节点，不断向下传递 &#125; inline void update(lli nl, lli nr, lli l, lli r, lli p, lli k) &#123; // 将要修改从 nl 到 nr 的区间 // l,r 为当前节点所储存的区间 // p 为当前节点的编号 if (nl &lt;= l &amp;&amp; r &lt;= nr) &#123; ans[p] += k * (r - l + 1); tag[p] += k; return; &#125; pushDown(p, l, r); lli mid = (l + r) &gt;&gt; 1; if (nl &lt;= mid) update(nl, nr, l, mid, leftChild(p), k) if (nr &gt; mid) update(nl, nr,mid + 1, r, rightChild(p), k); pushUp(p);&#125;// 更新区间 查询区间函数12345678910inline lli query(lli qx, lli qy, lli l, lli r, lli p) &#123; lli res = 0; if (qx &lt;= l &amp;&amp; r &lt;= qy) return ans[p]; lli mid = (l + r) &gt;&gt; 1; pushDown(p, l, r); if (qx &lt;= mid) res += query(qx, qy, l, mid, leftChild(p)); if (mid + 1 &lt;= qy) res += query(qx, qy, mid + 1, r, rightChild(p)); return res; &#125;// 查询区间 依然采用二分的形式… 洛谷 P3372 题解题目描述已知一个数列，你需要进行下面两种操作： 1.将某区间每一个数加上x 2.求出某区间每一个数的和 输入格式第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。 第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。 接下来M行每行包含3或4个整数，表示一个操作，具体如下： 操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k 操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和 输出格式输出包含若干行整数，即为所有操作2的结果。 输入样例12345675 51 5 4 2 32 2 41 2 3 22 3 41 1 5 12 1 4 输出样例12311820 解题思路就是把上面的函数都复制下来就行了= = 没什么多解释的 注释见上面代码 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;// using namespace std;typedef long long int ll;typedef unsigned long long int ull;const int MAXN = 1000000 + 1;ull n, m, a[MAXN], ans[MAXN &lt;&lt; 2], tag[MAXN &lt;&lt; 2];inline ll ls(ll x) &#123; return x &lt;&lt; 1; &#125;inline ll rs(ll x) &#123; return x &lt;&lt; 1 | 1;&#125;void scan()&#123; scanf("%lld %lld", &amp;n, &amp;m); for (ll i = 1;i &lt;= n;i++) &#123; scanf("%lld", &amp;a[i]); &#125;&#125;inline void pushUp(ll p) &#123; ans[p] = ans[ls(p)] + ans[rs(p)];&#125; inline void build(ll p, ll l, ll r) &#123; tag[p] = 0; if (l == r) &#123; ans[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(ls(p), l, mid); build(rs(p), mid + 1, r); pushUp(p);&#125;inline void rec(ll p, ll l, ll r, ll k) &#123; tag[p] = tag[p] + k; ans[p] = ans[p] + k * (r - l + 1);&#125;inline void pushDown(ll p,ll l, ll r) &#123; ll mid = (l + r) &gt;&gt; 1; rec(ls(p), l, mid, tag[p]); rec(rs(p), mid + 1, r, tag[p]); tag[p] = 0;&#125;inline void update(ll nl, ll nr, ll l, ll r, ll p, ll k) &#123; if (nl &lt;= l &amp;&amp; r &lt;= nr) &#123; ans[p] += k * (r - l + 1); tag[p] += k; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if (nl &lt;= mid) update(nl, nr, l, mid, ls(p), k); if (nr &gt; mid) update(nl, nr, mid + 1, r, rs(p), k); pushUp(p);&#125;ll query(ll qx, ll qy, ll l, ll r, ll p) &#123; ll res = 0; if (qx &lt;= l &amp;&amp; r &lt;= qy) return ans[p]; ll mid = (l + r) &gt;&gt; 1; pushDown(p, l, r); if (qx &lt;= mid) res += query(qx, qy, l, mid, ls(p)); if (qy &gt; mid) res += query(qx, qy, mid + 1, r, rs(p)); return res;&#125;int main() &#123; // ios::sync_with_stdio(false); ll a1, b, c, d, e, f; scan(); build(1, 1, n); while (m--) &#123; scanf("%lld", &amp;a1); switch(a1) &#123; case 1:&#123; scanf("%lld %lld %lld", &amp;b, &amp;c, &amp;d); update(b, c, 1, n, 1, d); break; &#125; case 2:&#123; scanf("%lld %lld", &amp;e, &amp;f); printf("%lld\n", query(e, f, 1, n, 1)); break; &#125; &#125; &#125; return 0;&#125;// 注意一下，stdio 和 iostream 混用会出现很多奇怪的bug！]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算π]]></title>
    <url>%2F2018-03-31%2Fcalculating-pi%2F</url>
    <content type="text"><![CDATA[计算$π$可不是件容易事 前情提要偶然在WA谷上看到一道题 不得不说很玄学 抱着好奇的心态我点开了题解 发现了一个打表的。。。。 于是心血来潮去搜了一下如何计算π 于是就有了这篇文章 题目描述Handwer STD 要你计算一下圆周率，要求最少为4000位（从小数部分第一位开始算起） 输入描述&amp;样例无输入 输出描述&amp;样例输出$π$，要求保留至少4000位小数。 样例： 13141592653589793...... 其他时限为5000ms 解题解题思路我们需要找到一个合适、可靠且快速的圆周率计算公式 我选择了基于级数的快速收敛公式 这是一个很快、精度也很高的算法 公式为： （懒得写LaTeX码了 代码实现1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;long long n = 16366;long long d[16366 + 2];int main() &#123; ios::sync_with_stdio(false); double cost; long long i = 0; while (n - i) d[++i] = 2000; for (;n;n -= 14) &#123; long long p; for (p = 0,i = n;i;i--) &#123; p = p * i + d[i] * 10000; d[i] = p % (2 * i - 1); p /= 2 * i - 1; &#125; printf("%.4d",d[0] + p / 10000); d[0] = p % 10000; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 快速读入 模板]]></title>
    <url>%2F2018-03-23%2FCPP-Fast-RW%2F</url>
    <content type="text"><![CDATA[比某记者还快！ C++ 快速读入、输出在 C++ 上实现快速读入模板，这里是一个读取int 的示例。123456789101112inline int Quick_Read()&#123; int s = 0,w = 1; char ch = getchar(); while (ch &lt;= '0' || ch &gt; '9')&#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0' , ch = getchar(); return s * w;&#125;// 本代码来自 wyh's Blog// 地址: blog.aor.sd.cn 在 C++ 上实现快速输出模板，这里是一个输出int 的示例。12345678910inline void Quick_Write(int x)&#123; if (x &lt; 0)&#123; putchar('-'); re = -re; &#125; // 判断负数 if (x &gt; 9) Quick_Write(x/10); // 判断是否大于10 putchar(x%10 + '0');&#125; 懒人解决办法听说你不想写超过三行代码？ 12int getint() &#123; int x; scanf("%d", &amp;x); return x; &#125;long long int getll() &#123; long long int x; scanf("%lld", &amp;x); return x; &#125; // lld 按需换成 I64d]]></content>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵乘法]]></title>
    <url>%2F2018-03-10%2Fmatrix-mul%2F</url>
    <content type="text"><![CDATA[“简单”的矩阵乘法 矩阵乘法，就是将两个矩阵相乘 现要求写一个程序，可以实现矩阵相乘。 输入格式第一行三个正整数 $n$、$p$、$m$，表示矩阵的长宽。之后的$n$ 行，每行 $p$ 个整数，表示矩阵 $A$。之后的 $p$ 行，每行 $m$ 个整数，表示矩阵 $B$。 输出格式输出 $n$ 行，每行 $m$ 个整数，表示矩阵 $A×B$ ，每个数模 $10 ^ 9 + 7$ 输出。 输入样例123456783 4 5-2 -8 -9 8-10 0 6 -8-10 -6 6 94 -7 5 -5 910 -2 -10 5 5-3 -7 -3 8 -2-6 7 7 3 -2 良心数据 输出样例123999999898 149 153 999999929 999999951999999997 999999979 999999883 74 999999921 999999835 103 55 95 999999857 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 505;const int INF = 0x3f3f3f3f;const int MOD = 1e9+7;struct Matrix&#123; LL arr[maxn][maxn]; int n,m; Matrix operator * (const Matrix &amp;b)const&#123; // 重载运算符 Matrix res; memset(res.arr,0,sizeof(res.arr)); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; b.m;j++) for(int k = 0;k &lt; m;k++)&#123; (res.arr[i][j] += arr[i][k] * b.arr[k][j] % MOD) %= MOD; &#125; res.n = n;res.m = b.m; return res; &#125;&#125;a,b,ans;// 用结构体来储存矩阵int main()&#123; int n,p,m; scanf("%d %d %d",&amp;n,&amp;p,&amp;m); a.n = n;a.m = p; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; p;j++)&#123; scanf("%lld",&amp;a.arr[i][j]); &#125; // 输入矩阵 b.n = p;b.m = m; for(int i = 0;i &lt; p;i++) for(int j = 0;j &lt; m;j++)&#123; scanf("%lld",&amp;b.arr[i][j]); &#125; ans = a * b; for(int i = 0;i &lt; n;i++)&#123; for(int j = 0;j &lt; m - 1;j++)&#123; (ans.arr[i][j] += MOD) %= MOD; printf("%lld ",ans.arr[i][j]); &#125; (ans.arr[i][m - 1] += MOD) %= MOD; printf("%lld\n",ans.arr[i][m - 1]); &#125; // 输出矩阵 return 0;&#125; 图片 by [simimg.com](https://simimg.com/)]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 体验记]]></title>
    <url>%2F2018-03-05%2Fwindows10%2F</url>
    <content type="text"><![CDATA[Windows 10 从入门到放弃到重拾再到（伪）精通 终于把Windows 10 的更新配置好了，再也不用5分钟开机了（ 先把方法记一下吧1234567891. DiskGenius 激活Windows分区（默认激活deepin 根目录分区）2. 重启之后引导就炸了3. （进入Windows）使用 EasyBCD 重建Windows引导（可以不添加deepin）4. 重启之后引导还是爆炸的5. （进入deepin）执行 sudo grub-install /dev/sda &amp;&amp; sudo update-grub6. 重启之后还是deepin的grub引导，但是活动分区是Windows的7. 下载Fall Creators更新8. 安装更新9. 正常使用 全程惊悚… 2018.3.5Windows 10 可以正常使用的第一天，同时今天也开学了QAQ 开学什么的，体验最差了，况且今天还有什么收心考试 好在今天作业少，终于有时间写代码了（ · v · ） 用 Dev-C++ 写了 P1179 P1420 P1567 这两道大水题 总体感觉还是不错的 Dev-C++ 界面还行，还能看 后台开着一个火萤桌面，一个Chrome和一个Markdown编辑器 不得不说 Dev-C++ 真的是轻量级，占的内存从不超过100MB，Atom开完100MB就没了 对于这种老爷机真的很有用 我好像可以Wine一个Dev-C++出来…但是不能编译 这次体验感觉还不错，或许我可以主力一段时间… 2018.3.13已经是深夜了，洗漱完又上洛谷打了个卡，写了一道入门难度的大水题 周六因为晚上需要写《矩阵乘法》，所以就没更这篇文章 （话说这个矩阵乘法耗了我一下午…我可能真的太弱了 周六我全天都在使用 Windows 10，除了更 Blog 需要重启到Linux 这几天体验下来，感觉还不错，态度慢慢好转 Windows 10 的触摸板手势真的爽！Deepin 15 的触摸板手势太不灵敏了，经常误触或无效操作全靠友商衬托.png （主要是 Windows 10 的电源调配真的比 Linux 好…耗电比 Linux 少 我现在已经是 Windows 10 主力了，Linux 用来更 Blog 等鼓捣好 Windows Subsystem for Linux （WSL） 之后应该就可以在 Windows 10 上更博客了微软强势拉用户.jpg 2018.3.14今天作业少 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 我在学校就完成了几乎全部的作业，到家就只剩下5个小题 做完作业后便欢欢喜喜地来搞 Windows Subsystem for Linux（WSL） 经过不懈的努力（其实就是重启一次）终于弄好了WSL 现在正在装 g++ 网慢死了QAQ PS：由于我没有截任务栏，所以比例有点奇怪 又用 Dev-C++ 写了一道记忆化搜索的大水题，感觉 Dev-C++ 比 Atom 好用多了，毕竟 Core i3 3110m 带不起 Atom 本来打算今天的 Blog 用 WSL 交，想想还是算了吧，出现意外没时间处理 2019.7.12想了一想 决定把这篇文章用来更新 Boot Camp 的使用体验 2019.10.26宣布本文章暂停更新]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找&二分答案]]></title>
    <url>%2F2018-02-06%2FBSAnswer%2F</url>
    <content type="text"><![CDATA[$O(\log_2n)$的优秀算法 二分查找百度百科原话1二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 二分查找的时间复杂度是$O(log_{2}n)$ 要求 查找的序列必须采用顺序存储结构 查找的序列必须是有序排列的 思路 将需要查找的序列进行排序（一般为升序排列） 将序列中间位置记录的元素与关键字比较 如果相等，则返回查找成功如果不相等，则将序列分成左右两个子序列，若元素小于关键字，就到左子序列中查找；否则就到右子序列中查找 代码实现1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;inline bool BinarySearch(int l,int r,int t,int x[])&#123; while (l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if (x[mid] == t) return true; if (x[mid] &lt; t) l = mid + 1; if (x[mid] &gt; t) r = mid - 1; &#125; if (l &gt; r) return false;&#125;int main()&#123; int dest; cin &gt;&gt; dest; int n; cin &gt;&gt; n; int *p = new int[n + 1]; for (int i = 0;i &lt; n;i++) cin &gt;&gt; p[i]; printf("%s\n",BinarySearch(0,n - 1,dest,p)?"YES":"NO"); return 0;&#125; 二分答案看完了二分查找，你会发现二分好像只能用来在有序数列里找数。 对，一些情况二分只能拿来找数，但是从它身上衍生出来的二分答案却是一个很有用的东西！ 二分答案，就是通过二分查找的方式枚举出一个答案来，然后再验证你的查找结果是否正确，从而获取答案 要求&amp;特点 答案具有单调性 题面里包含与“最小的最大，最大的最小”相关的字眼 思路 先将给定的序列排序 参照二分查找，枚举一个答案mid 验证这个答案是否可行 如果可行，更新边界，找寻更佳答案如果不可行，更新边界，继续寻找答案 代码实现一般模板 其中的check函数需要针对每一个题目进行验证 当然你会写暴力枚举的check也可以借鉴过来#(滑稽) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;inline bool check(int x)&#123; /* code here*/ return true;&#125;int main(int argc, char const *argv[]) &#123; int n,m; cin &gt;&gt; n &gt;&gt; m; int *p = new int[n + 2]; for (int i = 0;i &lt; n;i++) cin &gt;&gt; p[i]; // ----------------------------------- int l = 0,r = n - 1; int ans = 0; while (l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if (check(ans))&#123; l = mid + 1; ans = mid; &#125; else r = mid - 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; // ----------------------------------- return 0;&#125; 推荐题目 「洛谷P2678 跳房子」 出处：NOIP2015 提高组 「洛谷P1824 进击的奶牛」 出处：USACO]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>二分查找</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1102 《A-B数对》]]></title>
    <url>%2F2018-02-01%2FLuogu-P1102%2F</url>
    <content type="text"><![CDATA[普及- 的“水”题 题目地址 提前说明：本题难度为普及- 题目描述给出一串数以及一个数字C，要求计算出所有A-B=C的数对的个数。（不同位置的数字一样的数对算不同的数对） 输入输出格式输入格式： 第一行包括2个非负整数N和C，中间用空格隔开。 第二行有N个整数，中间用空格隔开，作为要求处理的那串数。 输出格式： 输出一行，表示该串数中包含的所有满足A-B=C的数对的个数。 输入输出样例输入输出样例1input: 124 11 1 2 3 output: 13 数据说明对于73%的数据，N &lt;= 2000； 对于100%的数据，N &lt;= 200000。 所有输入数据都在longint范围内。 原题目2017/4/29新添数据两组 解析暴力解法粗略一看，这道题是不是特别水？ 只需要用$O(n^2)$的暴力解法不就可以了吗？ ​ 枚举A和B，再判断A-B是否为C 但是！ 你们Naive，没看见那个N&lt;=200000 吗 这样肯定会TLE的啊喂 测试记录 76分 正确解法作为C++选手，我们一定要发扬光大Alexander留给我们的STL 于是我们就可以用std::map映射来做这道题目（注意这是普及-的题目） 将A-B=C转换为A-C=B，然后找这N个数中有几个B就行了 测试记录 AC 代码实现暴力解法1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int *arr,n,c;inline void read()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; c; arr = new int[n]; for (int i = 0;i &lt; n;i++)&#123; cin &gt;&gt; arr[i]; &#125; return;&#125;inline int work()&#123; int ans = 0; for(int i = 0;i &lt; n;i++) for (int j = 0;j &lt; n;j++) if ((arr[i] - arr[j] == c)) ans++; return ans;&#125;int main(int argc, char const *argv[]) &#123; read(); cout &lt;&lt; work() &lt;&lt; endl; return 0;&#125; 正确解法1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int a[200001];inline void LetMeAccept()&#123; int n,c; scanf("%d %d",&amp;n,&amp;c); map&lt;int,int&gt; p; for(int i = 0;i &lt; n;i++)&#123; scanf("%d",a + i); p[a[i]]++; &#125; long long ans=0; for(int i = 0;i &lt; n;i++) ans += p[a[i] + c]; printf("%lld\n",ans);&#125;int main(int argc,char const *argv[])&#123; LetMeAccept(); return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论之建立基础的图]]></title>
    <url>%2F2017-12-31%2FCreateGraph%2F</url>
    <content type="text"><![CDATA[指针建图 学（背）会建立一个基础的图，是写好图论算法的基础。 具体就是写一个循环，通过构造函数来创建一个一个的边和结点附代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define Inf 2e31-1#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl;#define MAXN 2500 + 5//设定图的最大结点值为2500struct Node;struct Edge;struct Node&#123; Edge *firstEdge; int dist; bool inQueue;&#125; node[MAXN];struct Edge&#123; Node *s,*t; int w; //权值 Edge *next; //下一条边 Edge(Node *s,Node *t,int w) : s(s),t(t),w(w),next(s-&gt;firstEdge); //构造函数&#125;;inline void add(const int &amp;s,const int &amp;t,const int &amp;w)&#123; node[s].firstEdge = new Edge(&amp;node[s],&amp;node[t],w); node[t].firstEdge = new Edge(&amp;node[t],&amp;node[s],w);&#125;/* code here * 请在这里写各种的函数 */ int main(int argc, char const *argv[]) &#123; int n,m,s,t; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i = 1;i &lt;= m;i++)&#123; int u,v,w; cin &gt;&gt; u,v,w; add(u,v,w); &#125; /* code here*/ return 0; &#125;]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPFA]]></title>
    <url>%2F2017-12-30%2FSPFA%2F</url>
    <content type="text"><![CDATA[简单的SPFA最短路模板，适用于图的边权有负数的情况。 算法实现：我们用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。运用动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行操作，直至队列空为止。 代码实现：给一个指针实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;#define MAXN 2500 + 5#define DEBUG(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; xconst int Inf = 2e31-1;struct Node;struct Edge;struct Node&#123; Edge *firstEdge; int dist; bool inQueue;&#125; node[MAXN];struct Edge&#123; Node *s,*t; int w; Edge *next; Edge(Node *s,Node *t,int w) : s(s),t(t),w(w),next(s-&gt;firstEdge)&#123;&#125;&#125;;inline void add(const int &amp;s,const int &amp;t,const int &amp;w)&#123; node[s].firstEdge = new Edge(&amp;node[s],&amp;node[t],w); node[t].firstEdge = new Edge(&amp;node[t],&amp;node[s],w);&#125;inline int spfa(const int &amp;s,const int &amp;t,const int &amp;n)&#123; for (int i = 1;i &lt;= n;i++)&#123; node[i].dist = Inf; node[i].inQueue = false; //将所有节点的在队列的情况设为false &#125; queue&lt;Node *&gt; q; q.push(&amp;node[s]); node[s].dist = 0; node[s].inQueue = true; while (!q.empty())&#123; Node *u = q.front(); q.pop(); u-&gt;inQueue = false; for (Edge *e = u-&gt;firstEdge;e;e = e-&gt;next)&#123; Node *v = e-&gt;t; if (v-&gt;dist &gt; u-&gt;dist + e-&gt;w)&#123; v-&gt;dist = u-&gt;dist + e-&gt;w; if (!v-&gt;inQueue)&#123; q.push(v); v-&gt;inQueue = true; &#125; &#125; &#125; &#125; return node[t].dist;&#125;int main(int argc, char const *argv[]) &#123; int n,m,s,t; scanf("%d %d %d %d",&amp;n,&amp;m,&amp;s,&amp;t); for (int i = 1;i &lt;= m;i++)&#123; int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; printf("%d",spfa(s,t,n)); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017-10-25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
