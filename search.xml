<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[公告栏]]></title>
    <url>%2F2019-10-31%2FBulletinBoard%2F</url>
    <content type="text"><![CDATA[这里可能会挂些什么东西。 There may be something here. 博客累计已突破 100 篇文章 New！《「文章」百名学生参训 礼堂“变身”教室》]]></content>
  </entry>
  <entry>
    <title><![CDATA[「文章」百名学生参训 礼堂“变身”教室]]></title>
    <url>%2F2019-02-16%2FSDWC-Article%2F</url>
    <content type="text"><![CDATA[本文纯属胡扯请勿当真 正月初八，年味儿正浓。但是，不少全国各地的中学生却来到了泰安。他们不是利用假期前来观光旅游的，而是进城参加竞赛培训。记者暗访发现，某未经教育部批准的机构培训机构打着“竞赛培训”“自主招生”的旗号，开设冬令营，面向全国各地中学招生。这个机构组织学生进行竞赛辅导、模拟考试。七天的培训，学费竟然高达3000元左右。 记者了解到，不少高一、高二甚至初中学生参加这样的冬令营，目的是希望能够获得各类学科竞赛的奖项，从而在高校自主招生、保送生选拔录取中占得先机。为此，记者向多所“双一流”高校招生负责人求证，得到的一致答复是，获得自主招生认定与是否参加过竞赛培训没有任何关系，学生申请自主招生可以通过各种材料证明自己的特长，竞赛获奖证书只是其中很小一部分，并且自主招生最终认定结果，必须经由申请高校考核后确定。 四名学生一个宿舍教学、食宿均安排在学校之内 正月初八，一辆又一辆大巴车开进泰安一中。一批批满脸稚气的中学生，拉着行李走进学校。工作人员协助学生们办理报到、入住、领取餐券等手续。不少学生家长陪同前来，但是，办完手续后，家长被告知“可以离开了”。工作人员的解释是，这里是封闭式管理，谢绝家长陪住。 此时，这所学校已经摇身变成一家培训教育机构寒假冬令营的营区。工作人员介绍，营区主要开设普通班、高级班两个班级，其中，普通班有学生200人，高级班有学生240人左右。这意味着来自全国各地的百余名学生参加这家机构的培训。 据介绍，营区的教学、食宿均安排在学校之内。每名学生的学费为2400元，另外不需缴纳食宿费。“四名学生一个宿舍。”工作人员说。 学校工作人员告诉记者，培训机构几乎包下了所有的宿舍房间。 从早八点半学到晚九点后排学生只能看“现场直播” 培训课程已开课几天。营区占用一间大礼堂作为教室，学生们被分成了多个座位区，对应一个投影幕布。因为“教室”里的学生太多，在最后一排已经几乎看不见老师，只能通过听声音、看课件来听老师讲题。到下午4点，后方座位区已经有学生难以专注听课，趴到了桌子上。 记者探访营区，感受到了学生们高强度的学习节奏。现场公布的一份营地作息时间表显示，学生们每天的起床时间为6点至7点，之后有40分钟的早餐时间。8点开始上课，一直到11点半。中午学生有两小时左右的中餐和午休时间，之后又是3个半小时的课程。 入夜后，学生们也不能歇着。记者在营区看到，晚上6点刚过，吃过晚餐的学生陆陆续续回到机房开始自习。工作人员透露，晚上6点到9点是学生的答疑、考试和讲评时间。晚上10点查寝，11点熄灯。 拼竞赛争取进名校任课教师多是竞赛金牌选手 小王是华北地区一所中学的初二学生。这次，他是由学校老师带队，与同学们一起参加竞赛的培训。小王很明确地告诉记者，上辅导班就是为了拼竞赛，获得进名校的“敲门砖”。“如果能在省赛区拿到一等奖，那么，申请211、985院校自主招生的通过概率就很大。全国学科竞赛夺金牌进国家集训队，就可以直接保送了。” 小王坦言，在老家学校里，大家主要的任务都在应对高考。老师讲课、考试都是围绕高考进行，竞赛生“吃不饱”。因为没有专门的竞赛指导老师，训练主要是靠从网上找习题。“来这里学，确实收获很大，这边老师讲的好几个知识点，一下子打通了我之前一年的困惑。” 培训机构市场部的一位工作人员告诉记者，如果只凭高中课堂学习的知识积累，去拼名校的自主招生，没有多大意义。因此，必须走一轮竞赛，材料才过硬。他透露，竞赛培训的主讲老师大部分是当年竞赛的金牌选手，培训中会有竞赛例题的讲解，还有模拟竞赛考试，学生可以充分熟悉考试的流程。 多所高校招办答复自招认定与竞赛培训无关 今年1月，教育部印发了《关于做好2019年高校自主招生工作的通知》，从招生政策、招生程序、加强监管等方面提出规范高校自主招生的“十严格”要求。“十严格”中明确高校不得简单以论文、专利、中介机构举办的竞赛活动等作为报考条件和初审通过依据。此外，要严格审核申请材料，高校成立专门自主招生审核专家组，采用多名专家“背靠背”分别独立审核、复核等方式，对考生提交的证明材料进行全覆盖核查。 昨晚，本市多所“双一流”高校的招办负责人向记者表示，绝大多数考生最终能否获得自主招生的认定，与是否参加过竞赛、拿过奖没有必然联系，与竞赛培训更是无关。“我们严格遵守教育部相关规定，学生申请自主招生可以根据自己的兴趣和特长提交相关材料，竞赛成绩只是其中很小一部分。此外学生通过材料初审后，也必须要参加学校组织的自主招生初试和复试，通过并完成公示后才能获得认定。这些流程都与校外培训机构无关，希望学生能展现真实的才华。”一所“双一流”大学招办主任说道。 来源：泰安Fa♂︎报供图：abc1763613206]]></content>
      <tags>
        <tag>记录</tag>
        <tag>毒瘤</tag>
        <tag>OI相关</tag>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1122《最大子树和》]]></title>
    <url>%2F2019-02-16%2FLuogu-P1122%2F</url>
    <content type="text"><![CDATA[ProjectDP - 35 最简单的树形DP问题 题目描述小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题： 一株奇怪的花卉，上面共连有N N朵花，共有N-1N−1条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。 老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。 输入输出格式输入格式第一行一个整数N(1 ≤ N ≤ 16000)。表示原始的那株花卉上共N朵花。 第二行有N个整数，第I个整数表示第I朵花的美丽指数。 接下来N-1行每行两个整数a,b，表示存在一条连接第a朵花和第b朵花的枝条。 输出格式一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过2147483647。 输入输出样例输入样例#1123456787-1 -1 -1 1 1 1 01 42 53 64 75 76 7 输出样例#1：13 说明【数据规模与约定】 对于60%的数据，有N≤1000； 对于100%的数据，有N≤16000。 解题思路只需要一维 设 $f[i]$ 表示以 $i$ 为根的子树的最大值 初始化：$f[i]$ 为结点 $i$ 的权值 转移： $$ f[u] = f[u] + max(f[v], 0) $$ 其中 $v$ 是 $u$ 的儿子 答案：$f$ 数组的最大值 简单吧！ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// 35.cpp// ProjectDP//// Created by HandwerSTD on 2019/2/16.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;vector&gt;using std::cin;using std::cout;using std::endl;const int MAXN = 100000 + 10;std::vector&lt;int&gt; head[MAXN];int flower[MAXN], dp[MAXN], n, id[MAXN], ans;/* * * dp[u] += std::max(0, dp[v]); * */void DFS(int u, int fa) &#123; dp[u] = flower[u]; for (std::vector&lt;int&gt;::iterator it = head[u].begin(); it != head[u].end(); it++) &#123; if ((*it) == fa) continue; DFS((*it), u); dp[u] += std::max(0, dp[(*it)]); &#125; ans = std::max(ans, dp[u]);&#125;int main(int argc, const char * argv[]) &#123; std::ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; flower[i]; for (int i = 1; i &lt;= n - 1; ++i) &#123; int prev = 0, next = 0; cin &gt;&gt; prev &gt;&gt; next; if (prev &gt; next) std::swap(prev, next); head[prev].push_back(next); head[next].push_back(prev); ++id[next]; &#125; int root = 0; for (root = 1; root &lt;= n; ++root) if (id[root] == 0) break; DFS(root, 0); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>DFS</tag>
        <tag>ProjectDP</tag>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ST算法学习笔记]]></title>
    <url>%2F2019-02-15%2FRMQ-SparseTable%2F</url>
    <content type="text"><![CDATA[$O(1)$查询区间最值 算法简介RMQ (Range Minimum/Maximum Query)问题是指：对于长度为n的数列A，回答若干询问RMQ(A,i,j)(i,j&lt;=n)，返回数列A中下标在i,j里的最小(大）值，也就是说，RMQ问题是指求区间最值的问题。 ——百度百科 ST（Sparse Table，稀疏表）算法是求解RMQ问题的经典在线算法，以O(nlogn)时间预处理，然后在O(1)时间内回答每个查询。 算法流程ST算法实际上采用了DP的思想 初始化定义 $F(i,j)$ 表示区间 $[i, i + 2^j - 1]$ 内的最小值，$P[i]$ 为原序列 那么显然$$ F(i,0) = P[i] $$ 状态转移方程？ 首先，任意一个区间的最小值等于 $min($这个区间前一半的最小值$,$ 这个区间后一半点最小值$)$这个很好理解吧把$F(\ )$结合进去，就是 $$ F(i,j) = min(F(i,j-1),F(i + 2^{j-1}, j - 1)) $$ 还有什么细节？上面的式子看的你很想递归是吧（反正我是）如果你不想递归的话，你八成会： 123for (int i = 1; ...) for (int j = 1; ...) F[i][j] = ... 其实……这样都是错的，这样会导致有几个状态被过早地枚举 我们要把枚举 $j$ 的循环放在外层，至于为什么……你模拟一下就行了 查询此处的内容可能有点难以理解，请消化不了的同学多看几遍 上面说了查询是 $O(1)$ 的听起来就好简单啊 实现确实是很简单，但是原理就……也是很简单 首先给你一个定理：对于任意 $x \in \mathbb{N^*}$ ，都有 $ 2^{\lfloor log_2(x) \rfloor} &gt; \lfloor \frac{x}{2} \rfloor $ 然后令查询区间$[l,r]$的长度 $\text{len} = r - (l - 1),\ \text{ll} = log_2(\text{len})$那么根据上边可得 $ 2^{\text{ll}} &gt; \lfloor \frac{len}{2} \rfloor $这意味着什么？这意味着查询的区间有重叠！不过这并不能意味啥，重叠又怎么样，只是查询的区间变了 1234567891011原来我们查询区间，都是查询这个区间的一半比如更新[l,r]之间的最小值就是f[l][r] = std::min(f[l][mid], f[mid + 1][r]);但是这次不一样，这次的mid超过了区间的一半那就可以这么写：int Query(int l, int r) &#123; int k = std::log(r - (l - 1)) / std::log(2); return std::min(f[l][k], f[r - ((1 &lt;&lt; k) -1)][k]);&#125; 是 $O(1)$ 的吧 它查询的区间相当于是这样的：（画的不准确，仅供参考） 12345_ _ _ _ _ _ _ _ _ -------==== f[l][k] ====------ f[r - ((1 &lt;&lt; k) - 1)][k] 等号就是两个查询区间的并集 这也就是它为什么不能查询区间和的原因前缀和足够了 伪代码⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ \text{Algorithm 1: Sparse Table} $⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ \text{Init(The Sparse Table } f, \text{The original sequence } a, \text{no return value})$&nbsp;&nbsp;$ 1. \text{For } i \text{ from 1 to n do}$&nbsp;&nbsp;$ 2. \ \ \ \ f[i][0] = a[i] $&nbsp;&nbsp;$ 3. \text{End For} $&nbsp;&nbsp;$ 4. \ j \leftarrow 1, i \leftarrow 1$&nbsp;&nbsp;$ 5. \text{While } 2^j \leq n \text{ do} $&nbsp;&nbsp;$ 6. \ \ \ \ \text{While } i + 2^j - 1 \leq n \text{ do} $&nbsp;&nbsp;$ 7. \ \ \ \ \ \ \ \ f[i][j] = min(f[i][j-1], f[i + 2^{j-1}][j-1]) $&nbsp;&nbsp;$ 8. \ \ \ \ \ \ \ \ i \leftarrow i + 1 $&nbsp;&nbsp;$ 9. \ \ \ \ \text{End While}$$ 10. \ \ \ \ j \leftarrow j + 1 $$ 11. \text{End While} $ $ \text{Query(}l,r\text{,return a value x}) $$ 1. k \leftarrow log_2(r - l + 1)$$ 2. \text{return } x = min(f[l][k], f[r - (2^k - 1)][k]$⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445// luogu-judger-enable-o2#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = (100000 + 10) * 2;const int MAXLOG = 17 + 10; // floor(log2(100000 + 10))int n, q;int Table[MAXN][MAXLOG];void BuildTable() &#123; for (int j = 1; (1 &lt;&lt; j) &lt;= n; ++j) &#123; for (int i = 1; i + (1 &lt;&lt; j) - 1 &lt;= n; ++i) &#123; Table[i][j] = std::max(Table[i][j-1], Table[i + (1 &lt;&lt; (j - 1))][j - 1]); &#125; &#125;&#125;int Query(int l, int r) &#123; int k = std::log(r - (l - 1)) / std::log(2); return std::max(Table[l][k], Table[r - ((1 &lt;&lt; k) - 1)][k]);&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf("%d", &amp;Table[i][0]); // 这里可以省去seq[i]，对Table[i][0]进行直接写入 BuildTable(); for (int i = 1; i &lt;= q; ++i) &#123; int l = 0, r = 0; scanf("%d %d", &amp;l, &amp;r); printf("%d\n", Query(l, r)); &#125; return 0;&#125; 例题洛谷P3865【模板】ST表]]></content>
      <tags>
        <tag>编程</tag>
        <tag>算法</tag>
        <tag>ST表</tag>
        <tag>RMQ问题</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Handwer's Blog 突破100篇文章]]></title>
    <url>%2F2019-02-14%2F100-articles%2F</url>
    <content type="text"><![CDATA[2019年2月14日22点，在键盘的敲击声中，Handwer’s Blog的第100篇博客诞生了。 第一个里程碑已经达成，下一个里程碑：200篇 2019也要加油啊]]></content>
      <tags>
        <tag>博客相关</tag>
        <tag>只有经历过的人才知道的世界</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2504《[HAOI2006]聪明的猴子》]]></title>
    <url>%2F2019-02-14%2FLuogu-P2504%2F</url>
    <content type="text"><![CDATA[最小生成树板子题 题目描述在一个热带雨林中生存着一群猴子，它们以树上的果子为生。昨天下了一场大雨，现在雨过天晴，但整个雨林的地表还是被大水淹没着，部分植物的树冠露在水面上。猴子不会游泳，但跳跃能力比较强，它们仍然可以在露出水面的不同树冠上来回穿梭，以找到喜欢吃的果实。 现在，在这个地区露出水面的有N棵树，假设每棵树本身的直径都很小，可以忽略不计。我们在这块区域上建立直角坐标系，则每一棵树的位置由其所对应的坐标表示(任意两棵树的坐标都不相同)。 在这个地区住着的猴子有M个，下雨时，它们都躲到了茂密高大的树冠中，没有被大水冲走。由于各个猴子的年龄不同、身体素质不同，它们跳跃的能力不同。有的猴子跳跃的距离比较远(当然也可以跳到较近的树上)，而有些猴子跳跃的距离就比较近。这些猴子非常聪明，它们通过目测就可以准确地判断出自己能否跳到对面的树上。 【问题】现已知猴子的数量及每一个猴子的最大跳跃距离，还知道露出水面的每一棵树的坐标，你的任务是统计有多少个猴子可以在这个地区露出水面的所有树冠上觅食。 输入输出格式输入格式输入文件monkey.in包括： 第1行为一个整数，表示猴子的个数M(2&lt;=M&lt;=500)； 第2行为M个整数，依次表示猴子的最大跳跃距离（每个整数值在1–1000之间）； 第3行为一个整数表示树的总棵数N(2&lt;=N&lt;=1000)； 第4行至第N+3行为N棵树的坐标（横纵坐标均为整数，范围为：-1000–1000）。 （同一行的整数间用空格分开） 输出格式输出文件monkey.out包括一个整数，表示可以在这个地区的所有树冠上觅食的猴子数。 输入输出样例输入样例#11234567894 1 2 3 460 01 01 2-1 -1-2 02 2 输出样例#113 说明【数据规模】 对于40%的数据，保证有2&lt;=N &lt;=100，1&lt;=M&lt;=100 对于全部的数据，保证有2&lt;=N &lt;= 1000，1&lt;=M=500 感谢@charlie003 修正数据 解题思路先构造完全图（边数为初二数学内容），再跑一遍最小生成树 之后枚举每一个猴子，判断它的跳跃距离是否大于等于生成树的最大边权即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 1000 + 10;const int MAXM = 500 + 10;const int MAXE = (MAXN - 1) * MAXN / 2 + 10;struct Node &#123; int x, y; Node() &#123; x = y = 0; &#125;&#125; node[MAXN];struct Edge &#123; int previd, nextid; double weight; Edge() &#123; previd = nextid = 0; weight = 0; &#125; bool operator &lt; (const Edge &amp;that) const &#123; return weight &lt; that.weight; &#125;&#125; edge[MAXE];struct UnionFind &#123; int seq[MAXN]; UnionFind() &#123; memset(seq, 0, sizeof seq); &#125; int Find(int x) &#123; return !seq[x] ? x : (seq[x] = Find(seq[x])); &#125; bool Union(int x, int y) &#123; x = Find(x); y = Find(y); if (x == y) return false; seq[x] = y; return true; &#125;&#125; U;double GetDist(int idx, int idy) &#123; double ret = 0; int absx = std::abs(node[idx].x - node[idy].x); int absy = std::abs(node[idx].y - node[idy].y); ret = sqrt(absx * absx + absy * absy); return ret;&#125;int n, m, cnt;int monkey[MAXM];double Kruskal() &#123; std::sort(edge + 1, edge + 1 + cnt); int tot = 0; double maxWeight = 0; for (int i = 1; i &lt;= cnt; ++i) &#123; if (U.Union(edge[i].previd, edge[i].nextid)) &#123; ++tot; maxWeight = std::max(maxWeight, edge[i].weight); &#125; if (tot == n - 1) break; &#125; return maxWeight;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) cin &gt;&gt; monkey[i]; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; node[i].x &gt;&gt; node[i].y; // initialize edges for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; edge[++cnt].previd = i; edge[cnt].nextid = j; edge[cnt].weight = GetDist(i, j); &#125; &#125; double maxW = Kruskal(); int ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; if (monkey[i] &gt;= maxW) ++ans; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>生成树</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3243《[HNOI2015]菜肴制作》]]></title>
    <url>%2F2019-02-14%2FLuogu-P3243%2F</url>
    <content type="text"><![CDATA[反向建图 + 反向输出 题目描述知名美食家小 A被邀请至ATM 大酒店，为其品评菜肴。 ATM 酒店为小 A 准备了 N 道菜肴，酒店按照为菜肴预估的质量从高到低给予1到N的顺序编号，预估质量最高的菜肴编号为1。 由于菜肴之间口味搭配的问题，某些菜肴必须在另一些菜肴之前制作，具体的，一共有 M 条形如”i 号菜肴’必须’先于 j 号菜肴制作“的限制，我们将这样的限制简写为&lt;i,j&gt;。 现在，酒店希望能求出一个最优的菜肴的制作顺序，使得小 A能尽量先吃到质量高的菜肴： 也就是说， (1)在满足所有限制的前提下，1 号菜肴”尽量“优先制作； (2)在满足所有限制，1号菜肴”尽量“优先制作的前提下，2号菜肴”尽量“优先制作； (3)在满足所有限制，1号和2号菜肴”尽量“优先的前提下，3号菜肴”尽量“优先制作 ；(4)在满足所有限制，1 号和 2 号和 3 号菜肴”尽量“优先的前提下，4 号菜肴”尽量“优先制作； (5)以此类推。 例1：共4 道菜肴，两条限制&lt;3,1&gt;、&lt;4,1&gt;，那么制作顺序是 3,4,1,2。 例2：共5道菜肴，两条限制&lt;5,2&gt;、 &lt;4,3&gt;，那么制作顺序是 1,5,2,4,3。 例1里，首先考虑 1，因为有限制&lt;3,1&gt;和&lt;4,1&gt;，所以只有制作完 3 和 4 后才能制作 1，而根据(3)，3 号又应”尽量“比 4 号优先，所以当前可确定前三道菜的制作顺序是 3,4,1；接下来考虑2，确定最终的制作顺序是 3,4,1,2。 例 2里，首先制作 1是不违背限制的；接下来考虑 2 时有&lt;5,2&gt;的限制，所以接下来先制作 5 再制作 2；接下来考虑 3 时有&lt;4,3&gt;的限制，所以接下来先制作 4再制作 3，从而最终的顺序是 1,5,2,4,3。 现在你需要求出这个最优的菜肴制作顺序。无解输出”Impossible!“ （不含引号，首字母大写，其余字母小写） 输入输出格式输入格式第一行是一个正整数D，表示数据组数。 接下来是D组数据。 对于每组数据： 第一行两个用空格分开的正整数N和M，分别表示菜肴数目和制作顺序限制的条目数。 接下来M行，每行两个正整数x,y，表示”x号菜肴必须先于y号菜肴制作“的限制。（注意：M条限制中可能存在完全相同的限制） 输出格式输出文件仅包含 D 行，每行 N 个整数，表示最优的菜肴制作顺序，或者“Impossible!“表示无解（不含引号）。 输入输出样例输入样例#11234567891011121335 45 45 34 23 23 31 22 33 15 25 24 3 输出样例#11231 5 3 4 2 Impossible! 1 5 2 4 3 说明【样例解释】 第二组数据同时要求菜肴1先于菜肴2制作，菜肴2先于菜肴3制作，菜肴3先于 菜肴1制作，而这是无论如何也不可能满足的，从而导致无解。 100%的数据满足N,M&lt;=100000,D&lt;=3。 解题思路题目要求「“尽量”优先」那么跑字典序最小拓扑肯定是不行的 那么……考虑反向建图。反向建图跑字典序最大拓扑，这时的拓扑序是「一直选择大的，不行再选择小的」，那么反向输出即可 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXNM = 100000 + 10;std::stack&lt;int&gt; rtop;std::vector&lt;int&gt; rhead[MAXNM];int id[MAXNM], n, m;void Topsort() &#123; std::priority_queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) &#123; if (!id[i]) &#123; q.push(i); &#125; &#125; while (!q.empty()) &#123; int u = q.top(); q.pop(); rtop.push(u); int siz = (int) rhead[u].size(); for (int i = 0; i &lt; siz; ++i) &#123; int v = rhead[u][i]; --id[v]; if (id[v]) continue; q.push(v); &#125; &#125;&#125;void Solve() &#123; memset(id, 0, sizeof id); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; int prev = 0, next = 0; cin &gt;&gt; next &gt;&gt; prev; // reverse rhead[prev].push_back(next); ++id[next]; &#125; Topsort(); for (int i = 1; i &lt;= n; ++i) &#123; rhead[i].clear(); &#125; if (rtop.size() &lt; n) &#123; cout &lt;&lt; "Impossible!" &lt;&lt; endl; while (!rtop.empty()) rtop.pop(); return; &#125; while (!rtop.empty()) &#123; cout &lt;&lt; rtop.top() &lt;&lt; ' '; rtop.pop(); &#125; cout &lt;&lt; endl;&#125;int main() &#123; IMPROVE_IO(); int T = 0; cin &gt;&gt; T; while (T --&gt; 0) &#123; Solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>拓扑序</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4047《[JSOI2010]部落划分》]]></title>
    <url>%2F2019-02-14%2FLuogu-P4047%2F</url>
    <content type="text"><![CDATA[最小生成树后删边 题目描述聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。 不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了N个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了K个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法： 对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。 例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。 输入输出格式输入格式输入文件第一行包含两个整数N和K(1&lt;=N&lt;=1000,1&lt;K&lt;=N)，分别代表了野人居住点的数量和部落的数量。 接下来N行，每行包含两个正整数x,y，描述了一个居住点的坐标(0&lt;=x, y&lt;=10000)。 输出格式输出一行，为最优划分时，最近的两个部落的距离，精确到小数点后两位。 输入输出样例输入样例#1123454 20 00 11 11 0 输出样例#111.00 输入样例#2123456789109 32 22 33 23 33 53 64 66 26 3 输出样例#212.00 解题思路我们首先对这几个点构建一个完全图 边数的计算属于初中数学内容（$\frac{n(n-1)}{2}$） 然后对这个图跑一遍最小生成树 删去生成树中最大的 $k-1$ 条边，这时候整个图就变成了 $k$ 个联通块，即为题目要求的部落 输出删去边的最小边权即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 1000 + 10;const int MAXM = (MAXN * (MAXN - 1)) / 2 + 10;struct Node &#123; int x, y; Node() &#123; x = y = 0; &#125;&#125; node[MAXN];struct Edge &#123; int prev; int next; double weight; Edge() &#123; prev = next = 0; weight = 0; &#125; bool operator &lt; (const Edge &amp;that) const &#123; return weight &lt; that.weight; &#125;&#125; edge[MAXM];struct UnionFind &#123; int seq[MAXN]; UnionFind() &#123; memset(seq, 0, sizeof seq); &#125; int Find(int x) &#123; return !seq[x] ? x : (seq[x] = Find(seq[x])); &#125; bool Union(int x, int y) &#123; x = Find(x); y = Find(y); if (x == y) return false; seq[x] = y; return true; &#125;&#125; U;int n, k, cnt;double GetPath(Node x, Node y) &#123; double ret = 0; int X = std::abs(x.x - y.x); int Y = std::abs(x.y - y.y); ret = sqrt(X * X + Y * Y); // 勾股定理，初中数学 return ret;&#125;void Solve() &#123; std::sort(edge + 1, edge + 1 + cnt); int tot = 0; for (int i = 1; i &lt;= cnt; ++i) &#123; bool routput = false; if (tot == n - k) routput = true; // 这里用了一个小技巧，加到 (n - k + 1) 条边的时候就可以输出， // 而不用到最后删边，因为边权是经过排序的 if (U.Union(edge[i].prev, edge[i].next)) &#123; ++tot; if (routput) &#123; cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; edge[i].weight &lt;&lt; endl; return; &#125; &#125; &#125;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; node[i].x &gt;&gt; node[i].y; &#125; // 构造完全图 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; edge[++cnt].prev = i; edge[cnt].next = j; edge[cnt].weight = GetPath(node[i], node[j]); &#125; &#125; Solve(); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1108《低价购买》]]></title>
    <url>%2F2019-02-14%2FLuogu-P1108%2F</url>
    <content type="text"><![CDATA[最长下降子序列套一个玄学计数 题目描述“低价购买”这条建议是在奶牛股票市场取得成功的一半规则。要想被认为是伟大的投资者，你必须遵循以下的问题建议:“低价购买；再低价购买”。每次你购买一支股票,你必须用低于你上次购买它的价格购买它。买的次数越多越好!你的目标是在遵循以上建议的前提下，求你最多能购买股票的次数。你将被给出一段时间内一支股票每天的出售价($2^{16}$范围内的正整数)，你可以选择在哪些天购买这支股票。每次购买都必须遵循“低价购买；再低价购买”的原则。写一个程序计算最大购买次数。 这里是某支股票的价格清单： 日期 1,2,3,4,5,6,7,8,9,10,11,12价格 68,69,54,64,68,64,70,67,78,62,98,87最优秀的投资者可以购买最多44次股票，可行方案中的一种是： 日期 2,5,6,10价格 69,68,64,62 输入输出格式输入格式第1行: N(1≤N≤5000)，股票发行天数 第2行: N个数，是每天的股票价格。 输出格式两个数:最大购买次数和拥有最大购买次数的方案数( $\le 2^{31}$ )当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这22种方案被认为是相同的。 输入输出样例输入样例121268 69 54 64 68 64 70 67 78 62 98 87 输出样例14 2 解题思路首先第一问肯定谁都会求跑一遍最长下降子序列算完 关键是第二问 令 $ dp[i] $ 表示以 $i$ 结尾的最长下降子序列的长度，$cdp[i]$ 表示以 $i$ 结尾的最长下降子序列的个数规定 $s[\ ]$ 为「原序列」 那么就有 当 $dp[i] = dp[j]$ 且 $s[i] = s[j]$ 时，就直接把 $cdp[j]$ 记为 $0$，防止重复计数 当 $dp[i] = dp[j] + 1$ 且 $s[i] &lt; s[j]$ 时，说明数列能接上了，$cdp[i] = cdp[i] + cdp[j]$ 最后答案输出 $$ \sum_{i = 1}^{n} cdp[i] \ (dp[i] = \text{The max value of array } dp[i] ) $$ 即可 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 5000 + 10;int n, a[MAXN], dp[MAXN], cdp[MAXN], maxLen;int main() &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt; i; ++j) &#123; if (a[i] &lt; a[j]) dp[i] = std::max(dp[i], dp[j] + 1); &#125; if (dp[i] == 0) dp[i] = 1; maxLen = std::max(maxLen, dp[i]); for (int j = 1; j &lt; i; ++j) &#123; if (dp[i] == dp[j] &amp;&amp; a[i] == a[j]) cdp[j] = 0; else if (dp[i] == dp[j] + 1 &amp;&amp; a[i] &lt; a[j]) cdp[i] += cdp[j]; &#125; if (cdp[i] == 0) cdp[i] = 1; &#125; int ans = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (dp[i] == maxLen) ans += cdp[i]; &#125; cout &lt;&lt; maxLen &lt;&lt; ' ' &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>动态规划，DP</tag>
        <tag>「序列」DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1896《[SCOI2005]互不侵犯》]]></title>
    <url>%2F2019-02-14%2FLuogu-P1896%2F</url>
    <content type="text"><![CDATA[ProjectDP - 27 最基础的状压DP 题目描述在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。 注：数据有加强（2018/4/25） 输入输出格式输入格式只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N） 输出格式所得的方案数 输入输出样例输入样例13 2 输出样例116 解题思路考虑状压DP 我们设 $ dp[i][j][k] $ 表示第 $i$ 行的状态的编号为 $j$，放了 $k$ 个国王 转移方程显然$$ dp[i][j][pct(stat[j]) + l] = dp[i][j][pct(stat[j]) + l] + dp[i-1][k][l]$$其中 $pct(x)$ 表示 $x$ 的二进制1的个数 边界条件：$$ dp[1][nowStat][pct(nowStat)] = 1 $$其中 $nowStat$ 表示当前枚举到的合法的状态 剩下的……就没啥好说的了（ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define IMPIO() std::ios::sync_with_stdio(false);#define FILE_IN(__file) freopen(__file, 'r', stdin);#define FILE_OUT(__file) freopen(__file, 'w', stdout);using std::cin;using std::cout;using std::endl;const int MAXN = 9 + 2;const int MAXK = MAXN * MAXN;int n, k;int stats[(1 &lt;&lt; MAXN) - 1 + 10], popc[(1 &lt;&lt; MAXN) - 1 + 10], cnt;long long int dp[MAXN][(1 &lt;&lt; MAXN) - 1 + 10][MAXK];/* * * dp[i][stat][k]: line i, status stat, k kings * */int Popcount(int x) &#123; int ret = 0; while (x) &#123; if (x &amp; 1) ++ret; x &gt;&gt;= 1; &#125; return ret;&#125;bool CheckFailed(int stat1, int stat2) &#123; if ((stat1 &amp; stat2) != 0) return true; if ((stat1 &amp; (stat2 &lt;&lt; 1)) != 0) return true; if (((stat1 &lt;&lt; 1) &amp; stat2) != 0) return true; return false;&#125;int main() &#123; IMPIO(); cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt;= (1 &lt;&lt; n) - 1; ++i) &#123; if ((i &amp; (i &lt;&lt; 1)) != 0) continue; stats[++cnt] = i; dp[1][cnt][Popcount(i)] = 1; &#125; for (int i = 2; i &lt;= n; ++i) &#123; for (int idj = 1; idj &lt;= cnt; ++idj) &#123; for (int idk = 1; idk &lt;= cnt; ++idk) &#123; if (CheckFailed(stats[idj], stats[idk])) continue; for (int l = 0; l &lt;= k; ++l) &#123; dp[i][idj][Popcount(stats[idj]) + l] += dp[i - 1][idk][l]; &#125; &#125; &#125; &#125; long long int ans = 0; for (int i = 1; i &lt;= cnt; ++i) &#123; ans += dp[n][i][k]; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>ProjectDP</tag>
        <tag>动态规划，DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于新开的「Handwer's Problems」]]></title>
    <url>%2F2019-02-13%2FMathProblems-NewSite%2F</url>
    <content type="text"><![CDATA[「Handwer’s Problems」主要转载一些经过挑选的文化课题目。 每一道题都会在不久之后更新题解，同时会更新下一道题。 现在主要上数学题，预计不久之后会更新物理以及英语题目。 面向任何人开放，如无特殊情况（包括但不限于考试）不会设置密码。 链接：Handwer’s Problems]]></content>
      <tags>
        <tag>文化课</tag>
        <tag>简介</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2704《[NOI2001]炮兵阵地》]]></title>
    <url>%2F2019-02-04%2FLuogu-P2704%2F</url>
    <content type="text"><![CDATA[ProjectDP - 29 需要维护两行状态的状压DP 题目描述司令部的将军们打算在N*M的网格地图上部署他们的炮兵部队。一个N*M的地图由N行M列组成，地图的每一格可能是山地（用“H” 表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示： 如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。 输入输出格式输入格式第一行包含两个由空格分割开的正整数，分别表示N和M； 接下来的N行，每一行含有连续的M个字符（‘P’或者‘H’），中间没有空格。按顺序表示地图中每一行的数据。N≤100；M≤10。 输出格式仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。 输入输出样例输入样例1234565 4PHPPPPHHPPPPPHPPPHHP 输出样例16 解题思路看到这个玄学的数据范围，第一反应就是状压DP 我们设 $ dp[i][j][k] $ 表示当前正在摆放第 $i$ 行，当前行的状态编号为 $j$，上一行的状态编号为 $k$ 时的最大数量 我们先把所有的可能状态预处理出来，记为 stats[] 初始状态时所有的dp[1][i][1] = Popcount(stats[i])，其中 Popcount(x)表示x的二进制1的个数 转移方程显然，$ dp[i][j][k] = max(dp[i][j][k], dp[i-1][k][l] + $ Popcount(stats[j]) $ ) $，其中 $j$ 表示当前行的状态编号，$k$ 表示上一行的，$l$ 表示再上一行的 注意判一下地形是否符合，方法参见洛谷P1879 我要开滚动数组 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//// 29.cpp// ProjectDP//// Created by HandwerSTD on 2019/1/29.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 100 + 10;const int MAXM = 10 + 5;const int MAX = (1 &lt;&lt; 10) - 1 + 10;int status[MAX], dp[2][MAX][MAX], can[MAXN];int cnt, n, m;char str[MAXM];inline int pop(int x) &#123; int ret = 0; while(x) &#123; if(x &amp; 1) ret++; x &gt;&gt;= 1; &#125; return ret;&#125;inline int Check(int a, int b) &#123; return a &amp; b;&#125;inline int Check3(int a, int b, int c) &#123; return Check(a,b) || Check(a,c) || Check(b,c);&#125;int main() &#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; ++i) &#123; scanf("%s",str + 1); for(int j = 1; j &lt;= m; ++j) if(str[j] == 'H')can[i] = (can[i] &lt;&lt; 1) | 1; else can[i] = can[i] &lt;&lt; 1; &#125; for(int i = 0; i &lt;= (1 &lt;&lt; m) - 1; ++i) &#123; if((!(i &amp; (i &lt;&lt; 2))) &amp;&amp; (!(i &amp; (i &lt;&lt; 1)))) status[++cnt] = i; &#125; for(int i = 1; i &lt;= cnt; ++i) dp[1 % 2][i][1] = pop(status[i]); for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= cnt; ++j) &#123; if (!(status[j] &amp; can[i])) &#123; for (int k = 1; k &lt;= cnt; ++k) &#123; if ((!(status[k] &amp; can[i - 1])) &amp;&amp; (!Check(status[j],status[k]))) &#123; for (int l = 1; l &lt;= cnt; ++l)&#123; if ((!(status[l] &amp; can[i - 2])) &amp;&amp; (!Check3(status[j], status[k], status[l]))) dp[i % 2][j][k] = std::max(dp[i % 2][j][k], dp[(i - 1) % 2][k][l] + pop(status[j])); &#125; &#125; &#125; &#125; &#125; &#125; int ans = 0; for(int i = 1; i &lt;= cnt; ++i) for(int j = 1; j &lt;= cnt; ++j) ans = std::max(ans, dp[n % 2][i][j]); printf("%d\n", ans); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>ProjectDP</tag>
        <tag>动态规划，DP</tag>
        <tag>NOI</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3183《[HAOI2016]食物链》]]></title>
    <url>%2F2019-02-04%2FLuogu-P3183%2F</url>
    <content type="text"><![CDATA[本题与洛谷P4017 重复 代码通用 题解传送门]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>拓扑序</tag>
        <tag>图论</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4017《最大食物链计数》]]></title>
    <url>%2F2019-02-04%2FLuogu-P4017%2F</url>
    <content type="text"><![CDATA[七年级上册生物题目 题目背景你知道食物链吗？Delia生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。 题目描述给你一个食物网，你要求出这个食物网中最大食物链的数量。 （这里的“最大食物链”，指的是生物学意义上的食物链，即最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者。） Delia非常急，所以你只有1秒的时间。 由于这个结果可能过大，你只需要输出总数模上80112002的结果。 输入输出格式输入格式第一行，两个正整数n、m，表示生物种类n和吃与被吃的关系数m。 接下来m行，每行两个正整数，表示被吃的生物A和吃A的生物B。 输出格式一行一个整数，为最大食物链数量模上80112002的结果。 输入输出样例输入样例#1123456785 71 21 32 33 52 54 53 4 输出样例#115 说明各测试点满足以下约定： 【补充说明】 数据中不会出现环，满足生物学的要求。（感谢@AKEE ） 解题思路有向无环？拓扑序啊！仔细想一下发现思路可能是对的 正向建一个图，反向建一个图 先把正向图的拓扑序跑出来，放到一个vector&lt;int&gt;里再按照拓扑序来枚举点，这样就保证了枚举的顺序 我们设 dp[node] 表示以编号 node 为结尾的食物链个数那么对于节点 Node， 如果它没有出边，那么dp[node] = 1 如果它有出边，那么枚举每一条出边的邻接点nv，dp[node] += dp[nv] 最后答案是$\sum$dp[所有没有出边的点] 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define ADD(__x) if (__x &gt;= HA) __x -= HA#define DEBUG(__Args,...) printf(__Args,##__VA_ARGS__)using std::cin;using std::cout;using std::endl;using std::max;const int MAXN = 5000 + 10;const int HA = 80112002;std::vector&lt;int&gt; head[MAXN];std::vector&lt;int&gt; reallink[MAXN];std::vector&lt;int&gt; top;int id[MAXN]; // id -&gt; in degreeint n, m, ans; int dp[MAXN]; // dp[i][j] -&gt; the amount of links that the end-node = ivoid Topsort() &#123; std::queue&lt;int&gt; q; for (int i = 1; i &lt;= n; ++i) &#123; if (!id[i]) &#123; q.push(i); top.push_back(i); &#125; &#125; while (!q.empty()) &#123; int u = q.front(); q.pop(); int amt = head[u].size(); for (int i = 0; i &lt; amt; ++i) &#123; int v = head[u][i]; --id[v]; if (!id[v]) &#123; top.push_back(v); q.push(v); &#125; &#125; &#125;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; int A = 0, B = 0; cin &gt;&gt; A &gt;&gt; B; head[A].push_back(B); reallink[B].push_back(A); ++id[B]; &#125; Topsort(); for (int i = 1; i &lt;= n; ++i) &#123; // enumerate Topsorted-Nodes int nnode = top[i - 1]; if (reallink[nnode].size() == 0) dp[nnode] = 1; // no out-edges connected for (int j = 0; j &lt; reallink[nnode].size(); ++j) &#123; int nenode = reallink[nnode][j]; dp[nnode] += dp[nenode]; ADD(dp[nnode]); &#125; if (!head[nnode].size()) ans += dp[nnode]; ADD(ans); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3060《Tour de Byteotia》]]></title>
    <url>%2F2019-02-04%2FBZOJ3060%2F</url>
    <content type="text"><![CDATA[并查集板子题（雾 题面权限题，题面请自行寻找用小刀刮开涂层来获取题目地址访问 DarkBZOJ 来获取题面 解题思路用并查集维护一下连通性 下文我们称「编号小于等于k的点」为「奇特点」 显然和奇特点没有关系的边删不删都无所谓，不影响答案，所以我们可以放心地把这些边加入并查集。 然后我们枚举所有的与奇特点相连的边，尝试将这条边加入并查集。如果这条边的两个点不连通，就可以放心地将这条边加入并查集，否则++ans 最后输出ans即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 1000000 + 10;const int MAXM = 2000000 + 10;struct UnionFind &#123; int seq[MAXN]; UnionFind() &#123; memset(seq, 0, sizeof seq); &#125; int Find(int x) &#123; if (seq[x] == 0) return x; return seq[x] = Find(seq[x]); &#125; bool Union(int x, int y) &#123; x = Find(x); y = Find(y); if (x == y) return false; seq[x] = y; return true; &#125;&#125; U;struct Edge &#123; int f, t; // from to Edge() &#123; f = t = 0; &#125;&#125; edge[MAXM &lt;&lt; 1];int n, m, k, cnt;inline void addEdge(int u, int v) &#123; edge[++cnt].f = u; edge[cnt].t = v;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; int prev = 0, next = 0; cin &gt;&gt; prev &gt;&gt; next; addEdge(prev, next); &#125; for (int e = 1; e &lt;= m; ++e) &#123; if (!(edge[e].f &lt;= k || edge[e].t &lt;= k)) &#123; U.Union(edge[e].f, edge[e].t); &#125; &#125; for (int e = 1; e &lt;= m; ++e) &#123; if (edge[e].f &lt;= k || edge[e].t &lt;= k) &#123; if (!U.Union(edge[e].f, edge[e].t)) ++ans; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2619《[国家集训队2]Tree I》]]></title>
    <url>%2F2019-02-04%2FLuogu-P2619%2F</url>
    <content type="text"><![CDATA[年轻人的第一道国家集训队二分答案 + 最小生成树 题目描述给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有need条白色边的生成树。 题目保证有解。 输入输出格式输入格式第一行V,E,need分别表示点数，边数和需要的白色边数。 接下来E行 每行s,t,c,col表示这边的端点(点从0开始标号)，边权，颜色(0白色1黑色)。 输出格式一行表示所求生成树的边权和。 输入输出样例输入样例1232 2 10 1 1 10 1 2 0 输出样例12 说明0:V&lt;=10 1,2,3:V&lt;=15 0,..,19:V&lt;=50000,E&lt;=100000 所有数据边权为[1,100]中的正整数。 By WJMZBMR 解题思路年轻人的第一道国家集训队题目 如果我们不做任何处理，直接跑MST（Minimum Spanning Tree，最小生成树），结果会有三种： 正好跑出 $\text{Need}$ 条白边 白边多了 白边少了 第一种情况自然是最好的 剩下两种情况如何解决？ 引起白边少的原因：黑边的边权相对较小，程序贪心地选择了更多的黑边 引起白边多的原因：白边的边权相对较小，程序贪心地选择了更多的白边 那么如果我们给白边相应地减去/加上一些边权，不就可以达成目标了？ 考虑二分答案。 我们二分一个 $add$ 表示我们当前要给白边加上 $add$ 来达成目标 边界分别是边权最小值（-100）和边权最大值（100） 由于题面保证有答案，所以直接输出 $ ans - add \times \text{Need} $ 即可，其中 $ans$ 为（加上边权后）最小生成树的权值和 Check(mid) 怎么写？ 我们将所有白边的边权加上$add$（即$mid$），跑一遍最小生成树，判断一下拿到的白色边数量是否大于等于要求的数量，如果是就更新一下左边界并记当前的$mid$为$tans$，否则就更新一下右边界 注意不要忘了把边权减回来 （不要在意 $tans$ 是什么意思） 刚才我们不是记录了一下$tans$吗，这个$tans$就相当于是一个正确的、能选出正好 $\text{Need}$ 条白边的 $add$ 值，再将所有白边的边权都加上这个 $tans$，跑一遍最小生成树即可 答案不要忘了减去加上的边权（也就是 $ \text{Need} \times tans $） 那么最后的答案就是 $ \text{Kruskal()} - \text{Need} \times tans $ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define WHITE 0#define BLACK 1using std::cin;using std::cout;using std::endl;using std::max;const int MAXV = 50000 + 10;const int MAXE = 100000 + 10;const int MAXW = 100;struct Edge &#123; int prev, next, weight, add; bool color; // 1 -&gt; black, 0 -&gt; white Edge() &#123; prev = next = weight = color = add = 0; &#125; bool operator &lt; (const Edge &amp;that) const &#123; if (weight == that.weight) return color &lt; that.color; return weight &lt; that.weight; &#125;&#125; edge[MAXE &lt;&lt; 1];int V, E, Need, cnt, ans;int U[MAXV &lt;&lt; 1];int Find(int x) &#123; if (U[x] == x) return U[x]; return U[x] = Find(U[x]);&#125;bool Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return false; U[x] = y; return true;&#125;int Kruskal() &#123; int whiteEdge = 0; for (int i = 1; i &lt;= V; ++i) U[i] = i; std::sort(edge + 1, edge + 1 + E); int tot = 0; ans = 0; for (int i = 1; i &lt;= E; ++i) &#123; if (Union(edge[i].prev, edge[i].next)) ans += edge[i].weight, ++tot, whiteEdge += (edge[i].color == WHITE); if (tot == V - 1) break; &#125; return whiteEdge;&#125;bool Check(int add) &#123; for (int i = 1; i &lt;= E; ++i) &#123; if (edge[i].color == WHITE) edge[i].weight += add; &#125; bool Ans = (Kruskal() &gt;= Need); for (int i = 1; i &lt;= E; ++i) &#123; if (edge[i].color == WHITE) edge[i].weight -= add; &#125; return Ans;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; V &gt;&gt; E &gt;&gt; Need; for (int i = 1; i &lt;= E; ++i) &#123; cin &gt;&gt; edge[i].prev &gt;&gt; edge[i].next &gt;&gt; edge[i].weight &gt;&gt; edge[i].color; ++edge[i].prev; ++edge[i].next; &#125; int l = -MAXW, r = MAXW; int Run = 0; while (l &lt;= r) &#123; int mid = ((l + r) &gt;&gt; 1); if (Check(mid)) &#123; l = mid + 1; Run = mid; &#125; else &#123; r = mid - 1; &#125; &#125; Check(Run); cout &lt;&lt; ans - Need * Run &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>生成树</tag>
        <tag>二分答案</tag>
        <tag>国家集训队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1621《集合》]]></title>
    <url>%2F2019-02-04%2FLuogu-P1621%2F</url>
    <content type="text"><![CDATA[素数筛 + 并查集 题目背景John的农场缺水了！！！ 题目描述Farmer John has decided to bring water to his N (1 &lt;= N &lt;= 300) pastures which are conveniently numbered 1..N. He may bring water to a pasture either by building a well in that pasture or connecting the pasture via a pipe to another pasture which already has water. Digging a well in pasture i costs W_i (1 &lt;= W_i &lt;= 100,000). Connecting pastures i and j with a pipe costs P_ij (1 &lt;= P_ij &lt;= 100,000; P_ij = P_ji; P_ii=0). Determine the minimum amount Farmer John will have to pay to water all of his pastures. POINTS: 400 农民John 决定将水引入到他的n(1&lt;=n&lt;=300)个牧场。他准备通过挖若 干井，并在各块田中修筑水道来连通各块田地以供水。在第i 号田中挖一口井需要花费W_i(1&lt;=W_i&lt;=100,000)元。连接i 号田与j 号田需要P_ij (1 &lt;= P_ij &lt;= 100,000 , P_ji=P_ij)元。 请求出农民John 需要为使所有农场都与有水的农场相连或拥有水井所需要的钱数。 输入输出格式输入格式第1 行为一个整数n。 第2 到n+1 行每行一个整数，从上到下分别为W_1 到W_n。 第n+2 到2n+1 行为一个矩阵，表示需要的经费（P_ij）。 输出格式只有一行，为一个整数，表示所需要的钱数。 输入输出样例输入样例123456789454430 2 2 22 0 3 32 3 0 42 3 4 0 输出样例19 说明John等着用水，你只有1s时间！！！ 解题思路题目中“质数”两个字很是显眼啊 还等啥啊 筛啊 素数筛很好写吧 筛完了，然后呢？ 题目让我们找两个公共质因数 $ \geq P $ 的，不在一个集合里的数，并合并它们。我们不这样找 枚举每一个质数primes[i]，计算出第一个 大于A的primes[i]的倍数（题目要求的）记为$t$，然后从$t+\text{primes[i]}$一直枚举到$B$（每次增长一个$\text{primes[i]}$，毕竟要求必须有$\text{primes[i]}$这个数作为质因数），每次用并查集合并$t$和当前枚举到的这个数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;using std::max;const int MAXB = 100000 + 10;int A, B, P;int primes[MAXB], cnt, ans;bool npm[MAXB]; // n(ot a )p(ri)m(e) -&gt; not a primeint U[MAXB];int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; --ans; // 两个集合变成了一个，答案减一 U[x] = y;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; A &gt;&gt; B &gt;&gt; P; for (int i = 1; i &lt;= B; ++i) U[i] = i; // 并查集初始化 // 筛一波素数 for (int i = 2; i &lt;= B; ++i) &#123; if (!npm[i]) primes[++cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; primes[j] * i &lt;= B; ++j) &#123; npm[primes[j] * i] = true; if (i % primes[j] == 0) break; &#125; &#125; ans = B - A + 1; // r - l + 1 // 原来的答案总数是（右边界 - 左边界 + 1） //（即 B - A + 1），每次合并集合的时候两个集合变成了一个，--ans for (int i = 1; i &lt;= cnt; ++i) &#123; if (primes[i] &lt; P) continue; // 质因数要求大于等于P int np = (A + primes[i] - 1) / primes[i] * primes[i]; // np -&gt; The smallest multiple of primes[i] larger than A // np -&gt; 最小的 比A大的 primes[i]的倍数 for (int j = np + primes[i]; j &lt;= B; j += primes[i]) &#123; Union(np, j); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1879《[USACO06NOV]玉米田Corn Fields》]]></title>
    <url>%2F2019-01-29%2FLuogu-P1879%2F</url>
    <content type="text"><![CDATA[ProjectDP - 28 状压DP入门题 题目描述Farmer John has purchased a lush new rectangular pasture composed of M by N (1 ≤ M ≤ 12; 1 ≤ N ≤ 12) square parcels. He wants to grow some yummy corn for the cows on a number of squares. Regrettably, some of the squares are infertile and can’t be planted. Canny FJ knows that the cows dislike eating close to each other, so when choosing which squares to plant, he avoids choosing squares that are adjacent; no two chosen squares share an edge. He has not yet made the final choice as to which squares to plant. Being a very open-minded man, Farmer John wants to consider all possible options for how to choose the squares for planting. He is so open-minded that he considers choosing no squares as a valid option! Please help Farmer John determine the number of ways he can choose the squares to plant. 农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤ 12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。 遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。 John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案） 输入输出格式输入格式第一行：两个整数M和N，用空格隔开。 第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。 输出格式一个整数，即牧场分配总方案数除以100,000,000的余数。 输入输出样例输入样例1232 31 1 10 1 0 输出样例19 解题思路一道状压DP入门题 首先我们发现对于每一行，有 N 个状态那么就意味着这是一个N + 1维DP…… 但是我们发现从第二维到第N维都只需要0（不种玉米）和1（种玉米）两个值那么……二进制！比如 1010 就表示第1、3个格种玉米，第2、4个格不种玉米 设 $ f[i][\text{status}] $ 表示第 $i$ 行种玉米的状态是 $\text{status}$转移方程很显然吧 $$ f[i][\text{status}] = f[i][\text{status}] + f[i - 1][\text{pre_status}] $$ 如何判断 $ \text{status} $ 和 $ \text{pre_status} $ 是不是互相合法？ 我们先来看看如何判断两行互相合法。 「合法」指两行种玉米的地方不相邻，也就是两个1不相邻。我们来想想位运算 $and$ 的性质 1234567891011运算法则：1 &amp; 1 = 11 &amp; 0 = 00 &amp; 0 = 0and (aka &amp;) 是按位运算的例如： 10101101 10100100&amp; 10110100 &amp; 01010001---------- ---------- 10100100 00000000 我们发现，第二个例子放在题目中是合法的，它们进行 $and$ 运算的值为 $0$那么方法不就出来了吗！ 123bool Check(int stat1, int stat2) &#123; return (stat1 &amp; stat2) == 0;&#125; 单行的状态也可能不合法，如何对敌怎么解决？ 12345678910stat1 = 01001101 就是一个不合法的状态我们把 stat1 左移一位（ stat1 = stat1 &lt;&lt; 1 ）得到了 stat2 = 10011010我们把他们 and 一下 01001101&amp; 10011010---------- 00001000 &gt; 0 那么方法就出来了 123bool CheckSingleLine(int stat) &#123; return Check(stat, stat &lt;&lt; 1);&#125; 之后处理一下土地的状态 我们将一行土地的利用情况记为二进制0表示荒地，1表示耕地 我们判断一下当前状态与利用情况 and 起来是否还等于当前状况即可正确性证明留作习题 那么我们枚举所有的可能状态，挨个判断即可。注意边界条件 $ f[0][0] = 1 $ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//// 28.cpp// ProjectDP//// Created by HandwerSTD on 2019/1/29.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)#define Stat(__x) FIXED_STATUS[__x]using std::cin;using std::cout;using std::endl;const int MAXSTATUS = (1 &lt;&lt; 12) - 1 + 10;const int MAXMN = 12 + 5;const int HA = 100000000;int m, n;int farm[MAXMN][MAXMN];int dp[MAXMN][MAXSTATUS], FIXED_STATUS[MAXSTATUS];/* * * dp[i][stat]: line = i, status = stat (binary) * */int main() &#123; IMPROVE_IO(); cin &gt;&gt; m &gt;&gt; n; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; cin &gt;&gt; farm[i][j]; Stat(i) = (Stat(i) &lt;&lt; 1) + farm[i][j]; // 预处理一下土地的状态 &#125; &#125; dp[0][0] = 1; for (int i = 1; i &lt;= m; ++i) &#123; for (int status = 0; status &lt;= (1 &lt;&lt; n) - 1; ++status) &#123; if ((status &amp; (status &lt;&lt; 1)) != 0) continue; // some grass are close to each other if ((status &amp; Stat(i)) != status) continue; // at least one grass planted on a barren place for (int pre_stat = 0; pre_stat &lt;= (1 &lt;&lt; n) - 1; ++pre_stat) &#123; if ((status &amp; pre_stat) == 0) &#123; dp[i][status] += dp[i - 1][pre_stat]; dp[i][status] %= HA; &#125; &#125; &#125; &#125; int ans = 0; for (int i = 0; i &lt;= (1 &lt;&lt; n) - 1; ++i) &#123; ans += dp[m][i]; ans %= HA; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>ProjectDP</tag>
        <tag>动态规划，DP</tag>
        <tag>状压DP</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1352《没有上司的舞会》]]></title>
    <url>%2F2019-01-28%2FLuogu-P1352%2F</url>
    <content type="text"><![CDATA[ProjectDP - 8 树形DP入门题 题目描述某大学有N个职员，编号为1~N。他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数Ri，但是呢，如果某个职员的上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。 输入输出格式输入格式第一行一个整数N。(1&lt;=N&lt;=6000) 接下来N行，第i+1行表示i号职员的快乐指数Ri。(-128&lt;=Ri&lt;=127) 接下来N-1行，每行输入一对整数L,K。表示K是L的直接上司。 最后一行输入0 0 输出格式输出最大的快乐指数。 输入输出样例输入样例123456789101112131415711111111 32 36 47 44 53 50 0 输出样例15 解题思路这是一道树形DP板子题。 设 $ f[u][0] $ 表示不选择 $u$ 这个结点时的最大价值，$ f[u][1] $ 表示选择 $u$ 这个结点时的最大价值令 $v$ 为 $u$ 除父节点以外的邻接点，那么我们就能写出这样的伪代码 ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ \text{Algorithm 1: DFS(u)} $⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ 1: f[u][0] = 0 $$ 2: f[u][1] = value[u] $$ 3: \text{while u}$ 有未被遍历的出边 $ (u,v) \text{ do} $$ 4: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{DFS}(v) $$ 5: $ &nbsp;&nbsp;&nbsp;&nbsp; $ f[u][0] = f[u][0] + \text{max}(f[v][0], f[v][1]) $$ 6: $ &nbsp;&nbsp;&nbsp;&nbsp; $ f[u][1] = f[u][1] + f[v][0] $$ 7: \text{end while}$⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ 最后答案即为 $ \text{max}(f[root][0], f[root][1]) $ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//// 8.cpp// ProjectDP//// Created by HandwerSTD on 2019/1/28.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;vector&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXN = 6000 + 10;/* * * dp[u][true]: Choose Node[u] * dp[u][false]: Don't choose Node[u] * */int val[MAXN], n;int dp[MAXN][2], inDegree[MAXN];std::vector&lt;int&gt; head[MAXN];void DFS(int u) &#123; dp[u][0] = 0; dp[u][1] = val[u]; int siz = (int) head[u].size(); for (int i = 0; i &lt; siz; ++i) &#123; int v = head[u][i]; DFS(v); dp[u][1] += dp[v][0]; dp[u][0] += std::max(dp[v][0], dp[v][1]); &#125;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; val[i]; int maxNode = -1, minNode = MAXN + 1000; for (int i = 1; i &lt;= n - 1; ++i) &#123; int father = 0, child = 0; cin &gt;&gt; child &gt;&gt; father; head[father].push_back(child); ++inDegree[child]; maxNode = std::max(maxNode, std::max(father, child)); minNode = std::min(minNode, std::min(father, child)); &#125; int root = 0; for (int i = minNode; i &lt;= maxNode; ++i) &#123; if (inDegree[i] == false) root = i; if (root != 0) break; &#125; DFS(root); cout &lt;&lt; std::max(dp[root][0], dp[root][1]) &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>ProjectDP</tag>
        <tag>动态规划，DP</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2089《不要62》]]></title>
    <url>%2F2019-01-28%2FHDU2089%2F</url>
    <content type="text"><![CDATA[ProjectDP - 26 数位DP板子题 Problem Description杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 Input输入的都是整数对n、m（0&lt;n≤m&lt;1000000），如果遇到都是0的整数对，则输入结束。 Output对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 Sample Input121 1000 0 Sample Output180 Authorqianneng 解题思路 不会讲啊QAQ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//// 26.cpp// ProjectDP//// Created by HandwerSTD on 2019/1/28.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXLENGTH = 8 + 4;/* * * dp[i][j]: length = i, the start number = j * */int dp[MAXLENGTH][MAXLENGTH];int n, m;void Init() &#123; dp[0][0] = 1; for (int i = 1; i &lt;= 9; ++i) &#123; // enumeration length for (int j = 0; j &lt;= 9; ++j) &#123; if (j == 4) dp[i][j] = 0; else &#123; for (int k = 0; k &lt;= 9; ++k) &#123; dp[i][j] += dp[i - 1][k]; &#125; if (j == 6) dp[i][j] -= dp[i - 1][2]; &#125; &#125; &#125;&#125;int Solve(int x) &#123; // returns the amount in [0, x) int ans = 0; int num[MAXLENGTH] = &#123;0&#125;; // num[0] &lt;=&gt; cnt while (x) &#123; num[++num[0]] = x % 10; x /= 10; &#125; for (int i = num[0]; i &gt;= 1; --i) &#123; for (int j = 0; j &lt; num[i]; ++j) &#123; if (j == 4 || (num[i + 1] == 6 &amp;&amp; j == 2)) continue; ans += dp[i][j]; &#125; if (num[i] == 4) break; if (num[i + 1] == 6 &amp;&amp; num[i] == 2) break; &#125; return ans;&#125;int main() &#123; IMPROVE_IO(); Init(); while (true) &#123; cin &gt;&gt; n &gt;&gt; m; if (n == 0 &amp;&amp; m == 0) break; cout &lt;&lt; Solve((m) + 1) - Solve((n - 1) + 1) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>ProjectDP</tag>
        <tag>动态规划，DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1006《传纸条》]]></title>
    <url>%2F2019-01-28%2FLuogu-P1006%2F</url>
    <content type="text"><![CDATA[ProjectDP - 4 从下往上传 $ \iff $ 从上往下传]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>ProjectDP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1434《[SHOI2010]滑雪》]]></title>
    <url>%2F2019-01-27%2FLuogu-P1434%2F</url>
    <content type="text"><![CDATA[记忆化搜索好题 题目描述Michael喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子： 123451 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可行的滑坡为24－17－16－1（从24开始，在1结束）。当然25－24－23－…－3－2－1更长。事实上，这是最长的一条。 输入输出格式输入格式输入的第一行为表示区域的二维数组的行数R和列数C（1≤R，C≤100）。下面是R行，每行有C个数，代表高度(两个数字之间用1个空格间隔)。 输出格式输出区域中最长滑坡的长度。 输入输出样例输入样例1234565 51 2 3 4 516 17 18 19 615 24 25 20 714 23 22 21 813 12 11 10 9 输出样例125 解题思路一眼就能看出这是搜索题 方法很显然，枚举所有的点，从当前点开始 DFS，每次往四个方向搜索，直到不能搜为止，这时候答案就出来了一个，更新一下。 考虑一下优化。在每次搜索的过程中，我们有很多点是重复走过的，那么就可以把暴搜升级为记忆化搜索。用 $ \text{mem}(x,y) $ 表示从点 $ (x,y) $ 出发的最长路径，在每一次搜索完成之后更新一下当前的答案，记录到 $ \text{mem}(x,y) $ 中即可。等到下一次搜到这个点（记为 $ (x’,y’) $ ），如果 $ \text{mem}(x’,y’) \geq 0 $ （也就是被更新过了），直接返回 $ \text{mem}(x’,y’) $ 就行。 我们也可以把记忆化搜索升级为 DP 不过据说比记忆化搜索还慢DP 做法题解已提上日程。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int dx[] = &#123; 0, 0, -1, 1 &#125;;const int dy[] = &#123; 1, -1, 0, 0 &#125;;const int MAXRC = 100 + 10;int snow[MAXRC][MAXRC];int r, c, ans;int mem[MAXRC][MAXRC];int Search(int x, int y) &#123; int t = 1; if (mem[x][y]) t = mem[x][y]; else &#123; for (int i = 0; i &lt; 4; ++i) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (nx &gt; 0 &amp;&amp; ny &gt; 0 &amp;&amp; nx &lt;= r &amp;&amp; ny &lt;= c &amp;&amp; snow[x][y] &lt; snow[nx][ny]) &#123; t = std::max(t, Search(nx, ny) + 1); &#125; &#125; &#125; mem[x][y] = t; return t;&#125;int main() &#123; IMPROVE_IO(); cin &gt;&gt; r &gt;&gt; c; for (int i = 1; i &lt;= r; ++i) &#123; for (int j = 1; j &lt;= c; ++j) &#123; cin &gt;&gt; snow[i][j]; &#125; &#125; for (int i = 1; i &lt;= r; ++i) &#123; for (int j = 1; j &lt;= c; ++j) &#123; int now = Search(i, j); mem[i][j] = now; ans = std::max(ans, mem[i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>DFS</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2320《[HNOI2006]鬼谷子的钱袋》]]></title>
    <url>%2F2019-01-27%2FLuogu-P2320%2F</url>
    <content type="text"><![CDATA[不断拆分 题目描述鬼谷子非常聪明，正因为这样，他非常繁忙，经常有各诸侯车的特派员前来向他咨询时政。 有一天，他在咸阳游历的时候，朋友告诉他在咸阳最大的拍卖行（聚宝商行）将要举行一场拍卖会，其中有一件宝物引起了他极大的兴趣，那就是无字天书。 但是，他的行程安排得很满，他已经买好了去邯郸的长途马车票，不巧的是出发时间是在拍卖会快要结束的时候。于是，他决定事先做好准备，将自己的金币数好并用一个个的小钱袋装好，以便在他现有金币的支付能力下，任何数目的金币他都能用这些封闭好的小钱的组合来付账。 鬼谷子也是一个非常节俭的人，他想方设法使自己在满足上述要求的前提下，所用的钱袋数最少，并且不有两个钱袋装有相同的大于1的金币数。假设他有m个金币，你能猜到他会用多少个钱袋，并且每个钱袋装多少个金币吗？ 输入输出格式输入格式包含一个整数，表示鬼谷子现有的总的金币数目m。其中，1 ≤ m ≤ 1000000000。 输出格式两行，第一行一个整数h，表示所用钱袋个数 第二行表示每个钱袋所装的金币个数，由小到大输出，空格隔开 输入输出样例输入样例13 输出样例1221 2 解题思路本文已发布于Handwer’s 洛谷博客 本蒟蒻怒写一发题解 收到本校神犇@Herself32 的邀请，过来做这道题 结果被题怒切 不扯了 首先考虑一个弱化版的题目，只输出最小袋子数稍微找一下规律就知道是总钱数的二进制位数 好 那么数据范围就出来了 本题我们还是手动模拟一下 123456781 -&gt; 12 -&gt; 1, 13 -&gt; 1, 24 -&gt; 1, 1, 25 -&gt; 1, 1, 36 -&gt; 1, 2, 37 -&gt; 1, 2, 48 -&gt; 1, 1, 2, 4 我们再把7和8的过程单独拿出来看 127 -&gt; 3, 4 -&gt; 1, 2, 48 -&gt; 4, 4 -&gt; 2, 2, 4 -&gt; 1, 1, 2, 4 我们能发现什么？对于一个数 $n$，我们可以把它用 $ \lceil \frac{n}{2} \rceil + \lfloor \frac{n}{2} \rfloor $ 表示，同时依照题意，$ \lfloor \frac{n}{2} \rfloor $ 也是可以用 $ \lceil \frac{\lfloor \frac{n}{2} \rfloor}{2} \rceil + \lfloor \frac{\lfloor \frac{n}{2} \rfloor}{2} \rfloor $ 进行表示的，这么一直递归下去，直到两个式中至少有一个为 1 ，此时反向（即从小到大）输出答案即可 代码实现1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;const int MAXANS = 30 + 10;int m;int ans[MAXANS], cnt = 0;void Search(int now) &#123; if (now == 0) return; int mid = now / 2, mid2 = now / 2 + (now % 2); ans[++cnt] = mid2; Search(mid);&#125;int main() &#123; scanf("%d", &amp;m); Search(m); printf("%d\n", cnt); for (int i = cnt; i &gt;= 1; --i) printf("%d ", ans[i]); printf("\n"); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>进制</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1541「NOIP2010」《乌龟棋》]]></title>
    <url>%2F2019-01-26%2FLuogu-P1541%2F</url>
    <content type="text"><![CDATA[ProjectDP - 3 枚举转移 题目背景小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。 题目描述乌龟棋的棋盘是一行$N$个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第$N$格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。 乌龟棋中$M$张爬行卡片，分成4种不同的类型（$M$张卡片中不一定包含所有4种类型的卡片，见样例），每种类型的卡片上分别标有$1,2,3,4$四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。 游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。 很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。 现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？ 输入输出格式输入格式每行中两个数之间用一个空格隔开。 第1行2个正整数$N,M$，分别表示棋盘格子数和爬行卡片数。 第2行$N$个非负整数，$a_1,a_2,…,a_N$，其中$a_i$表示棋盘第$i$个格子上的分数。 第3行$M$个整数，$b_1,b_2,…,b_M$，表示M张爬行卡片上的数字。 输入数据保证到达终点时刚好用光$M$张爬行卡片。 输出格式11个整数，表示小明最多能得到的分数。 输入输出样例输入样例1239 56 10 14 2 8 8 18 5 171 3 1 2 1 输出样例173 解题思路先来想想五维的 DP 我们设 $ f(i,j,k,l,m) $ 表示当前用了 $i$ 个卡片1， $j$ 个卡片2， $k$ 个卡片3， $l$ 个卡片4，走了 $m$ 步时的最大得分 分别对四种卡片进行转移 $$ Max = f[i-1][j][k][l][m - 1] (i \geq 1) $$ $$ Max = max(Max,f[i][j-1][k][l][m - 2]) (j \geq 1, m \geq 3) $$ $$ Max = max(Max,f[i][j][k-1][l][m - 3]) (k \geq 1, m \geq 4) $$ $$ Max = max(Max,f[i][j][k][l-1][m - 4]) (l \geq 1, m \geq 5) $$ $$ f[i][j][k][l][m] = Max + Score[m] $$ 考虑一下优化。显然 $m$ 是可以通过计算得出的，$ m = i + 2j + 3k + 4l + 1 $ （注意后面的+1，因为是从第一个格开始的），那么就能省去一维 转移方程就变为了 $$ m = i + 2j + 3k + 4l + 1 $$ $$ Max = f[i-1][j][k][l] (i \geq 1) $$ $$ Max = max(Max,f[i][j-1][k][l]) (j \geq 1) $$ $$ Max = max(Max,f[i][j][k-1][l]) (k \geq 1) $$ $$ Max = max(Max,f[i][j][k][l-1]) (l \geq 1) $$ $$ f[i][j][k][l] = Max + Score[m] $$ 最终答案留做习题见代码 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//// 3.cpp// ProjectDP//// Created by HandwerSTD on 2019/1/25.// Copyright © 2019 Handwer STD. All rights reserved.//#include &lt;iostream&gt;#include &lt;cstdio&gt;#define FILE_IN(__fname) freopen(__fname, "r", stdin)#define FILE_OUT(__fname) freopen(__fname, "w", stdout)#define IMPROVE_IO() std::ios::sync_with_stdio(false)using std::cin;using std::cout;using std::endl;using std::max;/* * * CARD1 means the card that can make the turtle go 1 block. * CARD2, CARD3 and CARD4 too. * dp[i][j][k][l] records the max score when there are i CARD1(s), j CARD2(s), k CARD3(s) and l CARD4(s) have been used. * * Formula: * Step = i * 1 + j * 2 + k * 3 + l * 4 + 1 * Max = dp[i][j][k][k] * Max = max(Max, dp[i-1][j][k][l]) (i &gt;= 1) * Max = max(Max, dp[i][j-1][k][l]) (j &gt;= 1) * Max = max(Max, dp[i][j][k-1][l]) (k &gt;= 1) * Max = max(Max, dp[i][j][k][l-1]) (l &gt;= 1) * dp[i][j][k][l] = Max + score[Step] * * Answer: * dp[a][b][c][d], * a -&gt; the amount of CARD1, b, c, and d too. * */const int MAXN = 350 + 10;const int MAXM = 120 + 10;const int MAXCARD = 40 + 10;int n, m, sc[MAXN], cds[MAXM];int a, b, c, d;int dp[MAXCARD][MAXCARD][MAXCARD][MAXCARD];int main() &#123; IMPROVE_IO(); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; sc[i]; &#125; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; cds[i]; if (cds[i] == 1) ++a; if (cds[i] == 2) ++b; if (cds[i] == 3) ++c; if (cds[i] == 4) ++d; &#125; for (int i = 0; i &lt;= a; ++i) &#123; for (int j = 0; j &lt;= b; ++j) &#123; for (int k = 0; k &lt;= c; ++k) &#123; for (int l = 0; l &lt;= d; ++l) &#123; int walked = 1 + i * 1 + j * 2 + k * 3 + l * 4; if (walked &gt; n) break; int Max = dp[i][j][k][l]; if (i - 1 &gt;= 0) Max = max(Max, dp[i-1][j][k][l]); if (j - 1 &gt;= 0) Max = max(Max, dp[i][j-1][k][l]); if (k - 1 &gt;= 0) Max = max(Max, dp[i][j][k-1][l]); if (l - 1 &gt;= 0) Max = max(Max, dp[i][j][k][l-1]); dp[i][j][k][l] = Max + sc[walked]; &#125; &#125; &#125; &#125; cout &lt;&lt; dp[a][b][c][d] &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>ProjectDP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ProjectDP]]></title>
    <url>%2F2019-01-24%2FProjectDP%2F</url>
    <content type="text"><![CDATA[DP计划 为提高自己的DP水平，我创建了一个名为「DP计划」的工程，用它来记录自己的题目完成情况，同时编程、调试、代码储存也使用此工程。 项目地址：View ProjectDP on GitHub]]></content>
      <tags>
        <tag>编程</tag>
        <tag>ProjectDP</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1083《借教室》]]></title>
    <url>%2F2019-01-24%2FLuogu-P1083%2F</url>
    <content type="text"><![CDATA[前缀和 + 二分答案 题目描述在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。 面对海量租借教室的信息，我们自然希望编程解决这个问题。 我们需要处理接下来$n$天的借教室信息，其中第$i$天学校有$r_i$个教室可供租借。共有$m$份订单，每份订单用三个正整数描述，分别为$d_j,s_j,t_j$，表示某租借者需要从第$s_j$天到第$t_j$天租借教室（包括第$s_j$天和第$t_j$天），每天需要租借$d_j$个教室。 我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供$d_j$个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$s_j$天到第$t_j$天中有至少一天剩余的教室数量不足$d_j$个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 输入输出格式输入格式：第一行包含两个正整数$n,m$，表示天数和订单的数量。 第二行包含$n$个正整数，其中第$i$个数为$r_i$，表示第$i$天可用于租借的教室数量。 接下来有$m$行，每行包含三个正整数$d_j,s_j,t_j$，表示租借的数量，租借开始、结束分别在第几天。 每行相邻的两个数之间均用一个空格隔开。天数与订单均用从$1$开始的整数编号。 输出格式如果所有订单均可满足，则输出只有一行，包含一个整数 $0$。否则（订单无法完全满足） 输出两行，第一行输出一个负整数$−1$，第二行输出需要修改订单的申请人编号。 输入输出样例输入样例123454 3 2 5 4 3 2 1 3 3 2 4 4 2 4 输出样例12-1 2 说明【输入输出样例说明】 第 $1$份订单满足后，$4$天剩余的教室数分别为 $0,3,2,3$。第 $2$ 份订单要求第 $2$天到第 $4$ 天每天提供 $3$个教室，而第 $3$ 天剩余的教室数为 $2$，因此无法满足。分配停止，通知第$2$ 个申请人修改订单。 【数据范围】 对于10%的数据，有$1≤ n,m≤ 10$； 对于30%的数据，有$1≤ n,m≤1000$； 对于 70%的数据，有$1 ≤ n,m ≤ 10^5$； 对于 100%的数据，有 $ 1 ≤ n,m ≤ 10^6,0 ≤ r_i,d_j≤ 10^9,1 ≤ s_j≤ t_j≤ n​ $。 NOIP 2012 提高组 第二天 第二题 解题思路考虑二分答案 首先我们知道，对于一个订单 $i$，如果它能被批准，那么 $[1,i]$ 都能被批准；如果它不能被批准，那么 $[i,m]$ 都不能被批准（单调性） 那么我们二分订单的编号 $\text{mid}$，每次判一下$[1,\text{mid}]$是否全都能满足，最后如果右边界不是 $m$ 了，说明有订单不能满足，输出右边界即可 如何判断是否能满足？首先我们要$O(1)$实现区间修改（？？？）用前缀和就可以实现！ 想想下面的过程$\downarrow$ 123456789101112131415原数列: 0 0 0 0 0 0 [ 1 2 3 4 5 6 ]前缀和： 0 0 0 0 0 0 [ 1 2 3 4 5 6 ] 我们让[1,3]都增加2于是我们选择让[1]增加2，让[4]（即[3+1]）减去2那么上面的数列就变成了：原数列: 2 0 0 -2 0 0 [ 1 2 3 4 5 6 ]前缀和： 2 2 2 0 0 0 [ 1 2 3 4 5 6 ]这个时候前缀和数组就实现了区间加！ 那么依照上面的思想，我们就能写出Check(int mid) 1234567891011121314151617181920212223struct Order &#123; int amount, l, r; Order() &#123; amount = l = r = 0; &#125;&#125; order[MAXM];int a[MAXN], sum[MAXN];bool Check(int __i) &#123; memset(sum, 0, sizeof sum); for (int i = 1; i &lt;= __i; ++i) &#123; // 像上面一样处理前缀和 sum[order[i].l] += order[i].amount; sum[order[i].r] -= order[i].amount; &#125; for (int i = 1; i &lt;= n; ++i) &#123; // 将前缀和处理一遍 // 判一下是否有超过当天可用教室的值 sum[i] += sum[i - 1]; if (sum[i] &gt; a[i]) return false; // 不合法 &#125; return true; // 合法&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXNM = 1000000 + 10; struct Order &#123; int num; int l, r; Order() &#123; num = l = r = 0; &#125; &#125; order[MAXNM]; int n, m, seq[MAXNM]; int sum[MAXNM]; bool Check(int M) &#123; memset(sum, 0, sizeof sum); for (int i = 1; i &lt;= M; ++i) &#123; sum[order[i].l] += order[i].num; sum[order[i].r + 1] -= order[i].num; &#125; for (int i = 1; i &lt;= n; ++i) &#123; sum[i] += sum[i - 1]; if (sum[i] &gt; seq[i]) return false; &#125; return true; &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; n = getint(); m = getint(); For (i, 1, n) seq[i] = getint(); For (i, 1, m) &#123; order[i].num = getint(); order[i].l = getint(); order[i].r = getint(); &#125; int L = 1, R = m; while (L &lt; R) &#123; int mid = (L + R) &gt;&gt; 1; if (Check(mid)) L = mid + 1; else R = mid; &#125; if (R != m) &#123; printf("-1\n%d\n", R); &#125; else puts("0"); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配学习笔记 & HDU2063 题解]]></title>
    <url>%2F2019-01-24%2FBipartiteGraph%2F</url>
    <content type="text"><![CDATA[二分图真是个奇怪又好玩的东西 原创建时间：2018-07-06 21:36:45 二分图概念设图$G=(V,E)$是一个无向图，若顶点集合$V$可分割为两个互不相交的子集$X$和$Y$，且图中每条边连接的顶点一个在$X$中，一个在$Y$中，则称$G$是一个二分图。 判定若某一图是联通的， 1231. 任选一个点V作为顶点，定义距离标号为02. 将V的邻接点标号设为1，接着将它的未标号的邻接点的标号设为2，以此类推 3. 将所有标号为奇数的点归为X，标号为偶数的点归为Y 以上内容可以采用BFS完成 依次检查每一条边，看看是否满足顶点一个在$X$中，一个在$Y$中 若某一图不连通，就在每个联通块里进行判定 二分图匹配定义给定一个二分图$G$，在$G$的子图$M$中，$M$的边集${E}$中的任意两条边都不依附于同一个顶点，则称$M$是一个匹配。 图中蓝色的边是数量为2的匹配 最大匹配 &amp; 完全匹配选择边数最大的子图称为「二分图的最大匹配问题」 如果一个匹配中图的每一个顶点都和某条边相关联，则称此匹配为「完全匹配」（或「完备匹配」） 图中为一个完全匹配 增广路径定义设$M$为二分图$G$已匹配边的集合，若$P$是$G$上其中一条联通两个未匹配顶点的路径（起点在$X$部，终点在$Y$部），且属$M$的边和不属$M$的边在$P$上交替出现，则称$P$为相对于$M$的一条增广路径 寻找增广路设$M$为二分图$G$所有已匹配边的集合， 如图，蓝色为在$M$里的边，黄色为不在$M$里的边 从$x_4$到$y_2$找一条路径： $x_4 \rightarrow y_3 \rightarrow x_2 \rightarrow y1 \rightarrow x1 \rightarrow y2$ 这条路径就是「增广路径」 其中属于$M$的边有：${x2,y3}, {x1,y1}$ 不属于$M$的边有：${x4,y3}, {x2,y1},{x1,y2}$ 显然，不属于$M$的边比属于$M$的边要多一条 将这条增广路上的边全都「反色」，如图 可以发现，匹配仍然合法，但是匹配数多了一对 另外，单独的一条连接两个未匹配点的边显然也是增广路 那么可知，当不能再找到增广轨时，就得到了一个「最大匹配」，这就是匈牙利算法的基本思路 增广路径性质由增广路的定义可以推出下述三个结论： P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。 P经过取反操作可以得到一个更大的匹配M’。 M为G的最大匹配当且仅当不存在相对于M的增广路径。 匈牙利算法用增广路求最大匹配（称作匈牙利算法，匈牙利数学家Edmonds于1965年提出） 算法步骤 置$M$为空 找出一条增广路$P$，通过取反操作获得更大的匹配$M‘$代替$M$ 重复2直到找不出增广路 找增广路径的算法我们采用DFS的办法找一条增广路径： 从X部一个未匹配的顶点u开始，找一个未访问的邻接点v（v一定是Y部顶点）。 对于$v$，分两种情况： 如果$v$未匹配，则已经找到一条增广路 如果$v$已经匹配，则取出$v$的匹配顶点$w$($w$一定是$X$部顶点)，边$(w,v)$目前是匹配的，根据“取反”的想法，要将$(w,v)$改为未匹配，$(u,v)$设为匹配，能实现这一点的条件是看从$w$为起点能否新找到一条增广路径$P’$。如果行，则$u \rightarrow v \rightarrow P’$就是一条以$u$为起点的增广路径。 伪代码⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ \text{Algorithm 1: } $ 寻找从 $ u $ 出发的增广路径 $ DFS(u) $返回 $ \text{True} $ 表示成功匹配，$ \text{False} $ 反之⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯&nbsp;&nbsp;$ 1: \text{For each } v \in u$的邻接点&nbsp;&nbsp;$ 2: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{If } v $ 未访问过&nbsp;&nbsp;$ 3: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 标记 $ v $ 被访问过&nbsp;&nbsp;$ 4: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{If } v $ 未被匹配 或者 $ \text{DFS(}v$的匹配点$\text{)}$&nbsp;&nbsp;$ 5: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 标记 $v$ 的匹配点为 $u$，$u$ 的匹配点为 $v$&nbsp;&nbsp;$ 6: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{Return True} $&nbsp;&nbsp;$ 7: $ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $ \text{End If}$&nbsp;&nbsp;$ 8: $ &nbsp;&nbsp;&nbsp;&nbsp; $ \text{End If}$&nbsp;&nbsp;$ 9: \text{End For} $$ 10: \text{Return False} $⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ 代码实现123456789101112131415161718192021int ans[MAXN];// ans 表示 Y 集合中每个顶点的匹配点bool vis[MAXN];memset(px, -1, sizeof px);// 用 -1 表示没有匹配bool DFS(int u) &#123; for (int e = head[u]; e; e = edge[e].next) &#123; int now = edge[e].now; if (!vis[now]) &#123; vis[now] = true; if (px[now] == -1 || DFS(px[now])) &#123; px[u] = now; // 为了方便，可以只标记 Y 到 X return true; &#125; &#125; &#125;&#125; 《HDU2063 过山车》题解题目描述RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？ Input/Output 格式 &amp; 样例Input 输入数据的第一行是三个整数$K , M , N$，分别表示可能的组合数目，女生的人数，男生的人数。$0&lt;K&lt;=1000,1&lt;=N,M&lt;=500$.接下来的$K$行，每行有两个数，分别表示女生$A_i$愿意和男生$B_j$做partner。最后一个$0$结束输入。 Output 对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。 Sample Input 123456786 3 31 11 21 32 12 33 10 Sample Output 13 解题思路「每个女生必须找个个男生做partner和她同坐」 好了，可以看出这是匹配问题，问你如何匹配 「Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner」 这句话告诉了我们如何建边： 123把所有女生的顶点放到集合X中，所有男生的顶点放到集合Y中，从Rabbit分别建一条到XHD的边和一条到PQK的边，从Grass分别建一条到linle的边和一条到LL的边…… 那么显然这就是一个二分图，而本题要求的就是这个二分图的最大匹配 又是一道模板题 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 500 + 10;int t[MAXN][MAXN], map[MAXN];bool vis[MAXN];int k, m, n;bool dfs(int u) &#123; for (int i = 1; i &lt;= n; ++i) &#123; if (t[u][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (!map[i] || dfs(map[i])) &#123; map[i] = u; return true; &#125; &#125; &#125; return false;&#125;int main(int argc, char *const argv[]) &#123; while (scanf("%d %d %d", &amp;k, &amp;m, &amp;n), k != 0) &#123; memset(t, 0, sizeof(t)); memset(vis, 0, sizeof(vis)); memset(map, 0, sizeof(map)); for (int i = 0; i &lt; k; ++i) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); t[x][y] = 1; &#125; int ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; memset(vis, 0, sizeof(vis)); if (dfs(i)) ++ans; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>BFS</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P5019「NOIP 2013 / 2018」《铺设道路》]]></title>
    <url>%2F2019-01-23%2FLuogu-P5019%2F</url>
    <content type="text"><![CDATA[CCF：我&nbsp;抄&nbsp;我&nbsp;自&nbsp;己 本题与洛谷P1969重复代码通用题解传送门]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luogu-P5020]]></title>
    <url>%2F2019-01-23%2FLuogu-P5020%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1330《封锁阳光大学》]]></title>
    <url>%2F2019-01-23%2FLuogu-P1330%2F</url>
    <content type="text"><![CDATA[对子连通图的染色 题目描述曹是一只爱刷街的老曹，暑假期间，他每天都欢快地在阳光大学的校园里刷街。河蟹看到欢快的曹，感到不爽。河蟹决定封锁阳光大学，不让曹刷街。 阳光大学的校园是一张由N个点构成的无向图，N个点之间由M条道路连接。每只河蟹可以对一个点进行封锁，当某个点被封锁后，与这个点相连的道路就被封锁了，曹就无法在与这些道路上刷街了。非常悲剧的一点是，河蟹是一种不和谐的生物，当两只河蟹封锁了相邻的两个点时，他们会发生冲突。 询问：最少需要多少只河蟹，可以封锁所有道路并且不发生冲突。 输入输出格式输入格式第一行：两个整数N，M 接下来M行：每行两个整数A，B，表示点A到点B之间有道路相连。 输出格式仅一行：如果河蟹无法封锁所有道路，则输出“Impossible”，否则输出一个整数，表示最少需要多少只河蟹。 输入输出样例输入样例#112343 31 21 32 3 输出样例#11Impossible 输入样例#21233 21 22 3 输出样例#211 说明【数据规模】 1&lt;=N&lt;=10000，1&lt;=M&lt;=100000，任意两点之间最多有一条道路。 解题思路本题的图可能不为连通图（注意这个坑） 阅读题目，我们得到了这样几条信息：「当某个点被封锁后，与这个点相连的道路就被封锁了」「当两只河蟹封锁了相邻的两个点时，他们会发生冲突」「封锁所有道路并且不发生冲突」 总结一下就是：「要求每一条边有且仅有一个点被选择，求最少能选择多少点」 然后我们就可以考虑用染色的方法做这一题 我们枚举每一个点，以当前枚举到的起点为根对这个子连通图进行 DFS 染色（因为图可能不联通），答案累加每次染色的最小数量（黑色点数量和白色点数量中最小的） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)#define head(a) Head[a].id#define nowcolor(a) Head[a].color#define visited(a) Head[a].used// 这样 define 有助于简化代码namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; int n, m, ans; int sum0, sum1; struct Graph &#123; static const int MAXN = 10000 + 10; static const int MAXM = 100000 + 10; struct Node &#123; int color, used, id; // 在一个数组中存储三个数量 Node() &#123; color = used = id = 0; &#125; &#125; Head[MAXN]; struct Edge &#123; int now, next; &#125; edge[MAXM * 2]; int cnt; inline void addEdge(int prev, int next, bool isR = true) &#123; if (isR) &#123; addEdge(next, prev, false); &#125; edge[++cnt].now = next; edge[cnt].next = head(prev); head(prev) = cnt; &#125; inline bool Color(int __id, int nowColor) &#123; // 返回 true 为成功染色， false 反之 if (visited(__id)) &#123; return nowcolor(__id) == nowColor; // 如果当前被染过不同的颜色，就失败 &#125; visited(__id) = true; nowcolor(__id) = nowColor; if (nowColor) ++sum1; else ++sum0; bool __ans = true; for (int e = head(__id); e &amp;&amp; __ans; e = edge[e].next) &#123; int now = edge[e].now; __ans = __ans &amp; Color(now, nowColor ^ 1); // 遍历与当前点相连的每一条边并 DFS &#125; return __ans; &#125; &#125; g1; void __EXIT() &#123; puts("Impossible"); exit(0); &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); m = getint(); For (i, 1, m) &#123; int prev = getint(); int next = getint(); g1.addEdge(prev, next); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (g1.visited(i)) continue; sum0 = sum1 = 0; if (!g1.Color(i, 0)) __EXIT(); ans += std::min(sum0, sum1); &#125; FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1969「NOIP 2013 / 2018」《积木大赛》]]></title>
    <url>%2F2019-01-22%2FLuogu-P1969%2F</url>
    <content type="text"><![CDATA[原&nbsp;题&nbsp;警&nbsp;告 题目描述春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为$n$的大厦，大厦可以看成由$n$块宽度为1的积木组成，第$i$块积木的最终高度需要是$h_i$。 在搭建开始之前，没有任何积木（可以看成$n$块高度为$0$的积木）。接下来每次操作，小朋友们可以选择一段连续区间$[l, r]$，然后将第 $L$块到第 $R$ 块之间（含第 $L$ 块和第 $R$块）所有积木的高度分别增加$1$。 小 $M$是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。 输入输出格式输入格式包含两行，第一行包含一个整数nn，表示大厦的宽度。 第二行包含$n$个整数，第i个整数为$h_i$。 输出格式建造所需的最少操作数。 输入输出样例输入样例1252 3 4 1 2 输出样例15 说明【样例解释】 其中一种可行的最佳方案，依次选择 $[1,5]$ $[1,3]$ $[2,3]$ $[3,3]$ $[5,5]$ 【数据范围】 对于 30\%30%的数据，有$1 ≤ n ≤ 10$； 对于 70\%70%的数据，有$1 ≤ n ≤ 1000$； 对于 100\%100%的数据，有$1 ≤ n ≤ 100000,0 ≤ h_i≤ 10000$。 解题思路真不敢相信 CCF 居然用了原题 单独把 $h_1$ 读进来，存在 $ans$ 里。 在读剩下的 $n - 1$ 个数的时候，每次判一下当前数与上一个数的关系： 如果比上一个数大，就说明我们还需要再放积木，答案累加当前数与上一个数的差； 如果没有上个数大，就说明我们之前搭积木已经能够把这摞积木放好了，自然就不需要更新了。 然后把「上一个数」更新为当前数即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; &#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; int n = 0; std::cin &gt;&gt; n; int ans = 0; std::cin &gt;&gt; ans; int lastOne = ans; for (int i = 2; i &lt;= n; ++i) &#123; int now; std::cin &gt;&gt; now; if (now &gt; lastOne) ans += (now - lastOne); lastOne = now; &#125; std::cout &lt;&lt; ans &lt;&lt; std::endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1119《灾后重建》]]></title>
    <url>%2F2019-01-22%2FLuogu-P1119%2F</url>
    <content type="text"><![CDATA[让人加深对 Floyd 的理解 题目背景B地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。 题目描述给出B地区的村庄数$N$，村庄编号从$0$到$N−1$，和所有$M$条公路的长度，公路是双向的。并给出第$i$个村庄重建完成的时间$t_i$，你可以认为是同时开始重建并在第$t_i$​ 天重建完成，并且在当天即可通车。若$t_i$​为$0$则说明地震未对此地区造成损坏，一开始就可以通车。之后有$Q$个询问$(x, y, t)$，对于每个询问你要回答在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄$x$或村庄$y$在第$t$天仍未重建完成 ，则需要返回$-1$。 输入输出格式输入格式第一行包含两个正整数$N,M$，表示了村庄的数目与公路的数量。 第二行包含$N$个非负整数$t_0, t_1,…, t_{N-1}$，表示了每个村庄重建完成的时间，数据保证了$t_0 ≤ t_1 ≤ … ≤ t_{N-1}$。 接下来$M$行，每行$3$个非负整数$i, j, w$，$w$为不超过$10000$的正整数，表示了有一条连接村庄$i$与村庄$j$的道路，长度为$w$，保证$i≠j$，且对于任意一对村庄只会存在一条道路。 接下来一行也就是$M+3$行包含一个正整数$Q$，表示$Q$个询问。 接下来$Q$行，每行$3$个非负整数$x, y, t$，询问在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少，数据保证了$t$是不下降的。 输出格式共$Q$行，对每一个询问$(x, y, t)$输出对应的答案，即在第$t$天，从村庄$x$到村庄$y$的最短路径长度为多少。如果在第$t$天无法找到从$x$村庄到$y$村庄的路径，经过若干个已重建完成的村庄，或者村庄$x$或村庄$y$在第$t$天仍未修复完成，则输出$-1$。 输入输出样例输入样例1234567891011124 51 2 3 40 2 12 3 13 1 22 1 40 3 542 0 20 1 20 1 30 1 4 输出样例1234-1-154 说明对于$30\%$的数据，有$N≤50$； 对于$30\%$的数据，有$t_i= 0$​，其中有$20\%$的数据有$t_i = 0$且$N&gt;50$； 对于$50\%$的数据，有$Q≤100$； 对于$100\%$的数据，有 $N≤200$，$M≤N \times (N-1)/2$，$Q≤50000$，所有输入数据涉及整数均不超过$100000$。 解题思路首先 $ N \leq 200 $，那么肯定是用 Floyd Floyd 算法的本质是 DP，转移方程为 $$ f_{i,j} = min(f_{i,j},\ f_{i,k} + f_{k,j}) $$ 其中的这个 $k$ 就是「中转点」，表示当前最大能经过编号为 $k$ 的点。 明确了这些，我们再来看题。 给出每一个点状态转为「可用」的时间和所有的边，让你求任意点到点的距离。我们跑 Floyd 时，$k$ 限制了我们当前能走的点，就相当于是题目中点的「不可用」状态！再加上所有的询问都是按照时间顺序给出的，所以我们就可以利用 Floyd 的性质来做这题。 12/* -- 全局变量 -- */int now = 0; // 当前最多能走第 now 个点，也就是 Floyd 中的 k 12345678910111213141516171819202122/* -- 在函数 main() 里 -- */std::cin &gt;&gt; start &gt;&gt; end &gt;&gt; ti// 读入起止点 start end 和当前时间 tiwhile (Time[now] &lt;= ti) &#123; // 当前的点转为「可用」的时间没有超过当前时间 int k = now; // 方便理解 // 以下为标准的 Floyd for (int x = 0; x &lt; n; ++x) &#123; for (int y = 0; y &lt; n; ++y) &#123; dis[x][y] = std::min(dis[x][y], dis[x][k] + dis[k][y]); &#125; &#125; ++now; // 这个点更新完了，往后继续更新，直到超过当前时间&#125;if ( dis[start][end] == __INF /* 无法到达 */ || Time[start] &gt; ti || Time[end] &gt; ti /* 没有转为「可用」 */) puts("-1");else printf("%d\n", dis[start][end]); // 输出答案 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 1000 + 10; int dis[MAXN][MAXN], k; int n, m, q; int ttime[MAXN];&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); m = getint(); memset(ttime, 0x3f, sizeof ttime); memset(dis, 0x3f, sizeof dis); for (int i = 0; i &lt; n; ++i) &#123; ttime[i] = getint(); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int prev = getint(); int next = getint(); int weight = getint(); dis[prev][next] = dis[next][prev] = weight; &#125; for (int i = 0; i &lt;= n; ++i) dis[i][i] = 0; q = getint(); for (int i = 1; i &lt;= q; ++i) &#123; int s = getint(); int t = getint(); int timee = getint(); int ans = 0; while (ttime[k] &lt;= timee) &#123; for (int a = 0; a &lt; n; ++a) &#123; for (int b = 0; b &lt; n; ++b) &#123; dis[a][b] = std::min(dis[a][b], dis[a][k] + dis[k][b]); &#125; &#125; ++k; &#125; if (dis[s][t] == 0x3f3f3f3f || ttime[s] &gt; timee || ttime[t] &gt; timee) ans = -1; else ans = dis[s][t]; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1341《无序字母对》]]></title>
    <url>%2F2019-01-21%2FLuogu-P1341%2F</url>
    <content type="text"><![CDATA[欧拉图板子题 题目描述给定n个各不相同的无序字母对（区分大小写，无序即字母对中的两个字母可以位置颠倒）。请构造一个有n+1个字母的字符串使得每个字母对都在这个字符串中出现。 输入输出格式输入格式第一行输入一个正整数n。 以下n行每行两个字母，表示这两个字母需要相邻。 输出格式输出满足要求的字符串。 如果没有满足要求的字符串，请输出“No Solution”。 如果有多种方案，请输出前面的字母的ASCII编码尽可能小的（字典序最小）的方案 输入输出样例输入样例123454aZtZXtaX 输出样例1XaZtX 说明【数据规模与约定】 不同的无序字母对个数有限，n的规模可以通过计算得到。 解题思路我们考虑把每一对字母视为一条边那么这个图就是无向的（因为字母对是无序的） 题目让你求一个串，使得这个串里出现了所有的字母对，实际上就是让你求一条路径，使得所有的边都出现过 那这不就是求欧拉路吗！ 所以这道题就完美地被转换为了欧拉路板子题 没学过欧拉路的看这里 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 256 + 233; int n; int G[MAXN][MAXN], deg[MAXN]; char __MIN_NODE = 127, __MAX_NODE = 0; std::stack&lt;char&gt; stk; inline void addEdge(char prev, char next, bool Undirected = true) &#123; ++G[prev][next]; if (Undirected) addEdge(next, prev, false); &#125; inline void deleteEdge(char prev, char next, bool Undirected = true) &#123; --G[prev][next]; if (Undirected) deleteEdge(next, prev, false); &#125; inline void Hierholzer(char s) &#123; for (char i = __MIN_NODE; i &lt;= __MAX_NODE; ++i) &#123; if (G[s][i]) &#123; deleteEdge(s, i); Hierholzer(i); &#125; &#125; stk.push(s); &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; std::ios::sync_with_stdio(false); std::cin &gt;&gt; n; For (i, 1, n) &#123; char prev, next; std::cin &gt;&gt; prev; std::cin &gt;&gt; next; addEdge(prev, next); ++deg[prev]; ++deg[next]; __MIN_NODE = std::min(__MIN_NODE, std::min(prev, next)); __MAX_NODE = std::max(__MAX_NODE, std::max(prev, next)); &#125; int odd = 0; char start = 0; for (char i = __MIN_NODE; i &lt;= __MAX_NODE; ++i) &#123; if (deg[i] != 0 &amp;&amp; deg[i] % 2 == 1) &#123; if (!start) start = i; ++odd; &#125; &#125; if (!start) start = __MIN_NODE; if (odd &amp;&amp; odd != 2) &#123; // 注意不要忘了判无解 std::cout &lt;&lt; "No Solution" &lt;&lt; std::endl; return 0; &#125; Hierholzer(start); while (!stk.empty()) &#123; std::cout &lt;&lt; stk.top(); stk.pop(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2731《骑马修栅栏 Riding the Fences》]]></title>
    <url>%2F2019-01-20%2FLuogu-P2731%2F</url>
    <content type="text"><![CDATA[欧拉图板子题 题目背景Farmer John每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。 题目描述John是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。你必须编一个程序，读入栅栏网络的描述，并计算出一条修栅栏的路径，使每个栅栏都恰好被经过一次。John能从任何一个顶点(即两个栅栏的交点)开始骑马，在任意一个顶点结束。 每一个栅栏连接两个顶点，顶点用1到500标号(虽然有的农场并没有500个顶点)。一个顶点上可连接任意多(&gt;=1)个栅栏。两顶点间可能有多个栅栏。所有栅栏都是连通的(也就是你可以从任意一个栅栏到达另外的所有栅栏)。 你的程序必须输出骑马的路径(用路上依次经过的顶点号码表示)。我们如果把输出的路径看成是一个500进制的数，那么当存在多组解的情况下，输出500进制表示法中最小的一个 (也就是输出第一位较小的，如果还有多组解，输出第二位较小的，等等)。 输入数据保证至少有一个解。 输入输出格式输入格式第1行: 一个整数F(1 &lt;= F &lt;= 1024)，表示栅栏的数目 第2到F+1行: 每行两个整数i, j(1 &lt;= i,j &lt;= 500)表示这条栅栏连接i与j号顶点。 输出格式输出应当有F+1行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。 输入输出样例输入样例1234567891091 22 33 44 24 52 55 65 74 6 输出样例123456789101234254657 说明题目翻译来自NOCOW。 USACO Training Section 3.3 解题思路「使每个栅栏都恰好被经过一次」 妥妥的欧拉路板子题啊 没学过的看这里 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = (500 + 10) &lt;&lt; 1; int G[MAXN][MAXN], n, degree[MAXN]; int __MAX_NODE = -1, __MIN_NODE = 0x7f7f7f7f; std::stack&lt;int&gt; ans; void addEdge(int from, int to) &#123; ++G[from][to]; ++G[to][from]; ++degree[from]; ++degree[to]; &#125; void Hierholzer(int s) &#123; for (int t = __MIN_NODE; t &lt;= __MAX_NODE; ++t) &#123; if (G[s][t]) &#123; --G[s][t]; --G[t][s]; Hierholzer(t); &#125; &#125; ans.push(s); &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; n = getint(); For (i, 1, n) &#123; int prev = getint(); int next = getint(); addEdge(prev, next); __MAX_NODE = std::max(__MAX_NODE, std::max(prev, next)); __MIN_NODE = std::min(__MIN_NODE, std::min(prev, next)); &#125; int start = 1, flag = 0; for (int i = 1; i &lt;= __MAX_NODE; ++i, ++start) &#123; if (degree[i] != 0 &amp;&amp; degree[i] % 2 == 1) &#123; flag = 1; break; &#125; &#125; if (flag) Hierholzer(start); else Hierholzer(1); while (!ans.empty()) &#123; putint(ans.top(), '\n'); ans.pop(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉图学习笔记]]></title>
    <url>%2F2019-01-18%2FEulerPath-EulerCircuit%2F</url>
    <content type="text"><![CDATA[从一个点出发走一走 约定 定义 $ (A,B) $ 表示从 $ A \rightarrow B $ 的一条边（若无特别说明，即为无向边） 定义 $ (A,B) \rightarrow (C,D) $ 表示从 $ A \rightarrow D $ ，经过 $ (A,B), (C,D) $ 两条边的路径 定义「孤立点」表示一个度为 0 的点 定义「奇顶点」表示一个度数为奇数的点 定义对于有向图 G ，将所有的有向边替换为无向边得到图 G 的基图，若图 G 的基图是连通的，则称图 G 是「弱连通图」。 $ Stack_a $ 表示标号为 $ a $ 的栈。 用 $ Stack_x = a]b]c] $ 表示 $ Stack_x $ 的层级结构，其中 $ a $ 为栈顶， $ c $ 为栈底。 $ \text{Foo} \rightarrow \text{Bar} $ 表示 $ \text{Foo} $ 里的元素 $ \text{Bar} $ （表特指） 定义如果图G中的一个路径包括每个边恰好一次，则该路径称为欧拉路径(Euler path)。如果一个回路是欧拉路径，则称为欧拉回路(Euler circuit)。具有欧拉回路的图称为欧拉图（简称E图）。具有欧拉路径但不具有欧拉回路的图称为半欧拉图。 ——百度百科 通俗地说， 对于一个图的某条路径，如果能从一个点出发将这个图的所有边都不重复地走一遍，那么这条路径就被称为欧拉路；对于一个图的某条路径，如果能从一个点出发将这个图的所有边都不重复地走一遍并回到起点，那么这条路径就被称为欧拉回路。 比如下图中的$$ (A,B) \rightarrow (B,C) \rightarrow (C,D) \rightarrow (D,B) $$就是一条欧拉路。 比如下图中的$$ (A,B) \rightarrow (B,C) \rightarrow (D,C) \rightarrow (C,A) $$就是一条欧拉回路。 判定无向图判定 无孤立点的无向图 G 为欧拉图，当且仅当图 G 连通且所有顶点的度都是偶数。 如果无向连通图有 2k 个奇顶点，则图 G 可以用 k 条路径将图 G 的每一条边经过 一次，且至少要使用 k 条路径。 无孤立点的无向图 G 为半欧拉图，当且仅当图 G 连通且 G 的奇顶点个数为 2 。 此时两个奇顶点分别为欧拉路径的起点和终点。 有向图判定 无孤立点的有向图 G 为欧拉图，当且仅当图 G 弱连通且所有顶点的入度等于出度。 对于连通有向图，所有顶点入度与出度差的绝对值之和为 2k ，则图 G 可以用 k 条路径将图 G 的每一条边经过一次，且至少要使用 k 条路径。 无孤立点的有向图 G 为半欧拉图，当且仅当图 G 弱连通，且恰有一个顶点 u 入度比出度小 1 ，一个顶点 v 入度比出度大 1 ，其余顶点入度等于出度。此时存在 u 作为起点， v 作为终点的欧拉路径。 求解Hierholzier 算法算法流程任选一起点，沿任意未访问的边走到相邻节点，直至无路可走。此时必然回到起点形成了一个回路，此时图中仍有部分边未被访问。在退栈的时候找到仍有未访问边的点，从该点为起点求出另一个回路，将该回路与之前求出的回路拼接。如此反复，直至所有的边都被访问。 比如说我们有这样一张图： 我们随便取一个点，比如说 $ 1 $，把它加入一个栈。 $$ Stack_1 = 1] $$ $$ Path_1 = [\ ] $$ 我们用 $ u $ 表示 $ Stack_1 \rightarrow Top $如果当前的 $ u $ 点已没有未访问的出边，就将 $ u $ 从 $ Stack_1 $ 里弹出来，加入到 $ Path_1 $ 的前端 重复上面的过程，直到 $ Stack_1 $ 为空。 在这个过程中，$$ Stack_1 = 2]1],\ Path_1 = [\ ] $$ $$ Stack_1 = 4]2]1],\ Path_1 = [\ ] $$ $$ Stack_1 = 1]4]2]1],\ Path_1 = [\ ] $$ $$ Stack_1 = 5]4]2]1],\ Path_1 = [1] $$ $$ Stack_1 = 6]5]4]2]1],\ Path_1 = [1] $$ $$ Stack_1 = 4]6]5]4]2]1],\ Path_1 = [1] $$ $$ Stack_1 = 2]5]4]2]1],\ Path_1 = [6,4,1] $$ $$ Stack_1 = 3]2]5]4]2]1],\ Path_1 = [6,4,1] $$ $$ Stack_1 = 5]3]2]5]4]2]1],\ Path_1 = [6,4,1] $$ 所有的边都访问了，开始回溯存路径 $$ Stack_1 = \ ],\ Path_1 = [1,2,4,5,2,3,6,4,1] $$ 最终答案即为 $ Path_1 $ 伪代码假装自己写的是真正的 $ \LaTeX $ ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ $ \text{Algorithm 1: Hierholzer(s)} $⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯$ 1: \text{while s} $ 存在未被删除的无向边 $ (s,t)\ \text{do} $$ 2: $ &nbsp;&nbsp;&nbsp;&nbsp;删除无向边 $ (s,t) $$ 3: $ &nbsp;&nbsp;&nbsp;&nbsp;$ \text{Hierholzer(t)} $$ 4: \text{End while} $$ 5: cnt \leftarrow cnt + 1$$ 6: Path[cnt] \leftarrow s$⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯ 代码实现真正的代码 123456789101112131415161718const int MAXN_M = 10000;int G[MAXN_M][MAXN_M], ans[MAXN_M], cnt;void Hierholzer(int s) &#123; for (int t = __MIN_NODE; t &lt;= __MAX_NODE; ++t) &#123; // 预防数据中不出现标号为 1 的节点的情况 // __MIN_NODE 指数据中标号最小的节点的标号 // __MAX_NODE 同上 if (G[s][t]) &#123; // 使用邻接矩阵存图，更加易懂 --G[s][t]; --G[t][s]; Hierholzer(t); &#125; &#125; ans[++cnt] = s;&#125; Fluery 算法挖坑待填 例题洛谷 P2731 模板题 题解将会在不久后上传 其他事项参考资料 IOI2018 中国国家候选队论文集 洛谷 P2731 题解]]></content>
      <tags>
        <tag>编程</tag>
        <tag>图论</tag>
        <tag>图论算法</tag>
        <tag>DFS</tag>
        <tag>欧拉图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1601《[Usaco2008 Oct]灌水》]]></title>
    <url>%2F2019-01-12%2FBZOJ1601%2F</url>
    <content type="text"><![CDATA[最小生成树板子 题目描述Farmer John已经决定把水灌到他的n(1&lt;=n&lt;=300)块农田，农田被数字1到n标记。把一块土地进行灌水有两种方法，从其他农田饮水，或者这块土地建造水库。 建造一个水库需要花费wi(1&lt;=wi&lt;=100000),连接两块土地需要花费Pij(1&lt;=pij&lt;=100000,pij=pji,pii=0). 计算Farmer John所需的最少代价。 输入输出格式输入格式*第一行：一个数n *第二行到第n+1行：第i+1行含有一个数wi *第n+2行到第2n+1行：第n+1+i行有n个被空格分开的数，第j个数代表pij。 输出格式*第一行：一个单独的数代表最小代价. 输入输出样例输入样例123456789454430 2 2 22 0 3 32 3 0 42 3 4 0 输出样例19 输出详解： Farmer John在第四块土地上建立水库，然后把其他的都连向那一个，这样就要花费3+2+2+2=9 解题思路很显然这道题需要最小生成树 那么是不是我们生成树之后加上根节点的$w$值就可以了？ 显然不！ 很容易就能举出反例：最小生成树的根节点$w_1=99999$，次小生成树的根节点$w_2=1$，两个生成树答案之差$ans_1 - ans_2 = 1$ 那么我们就可以考虑建一个虚拟的编号为$n + 1$的点，对于所有的点$i$以$w_i$为边权进行连接最后直接跑最小生成树即可。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; struct UnionFind &#123; static const int MAX_SIZ = 100000 + 10; int U[MAX_SIZ]; UnionFind() &#123; For (i, 1, MAX_SIZ) U[i] = i; &#125; int Find(int x) &#123; if (U[x] == x) return U[x]; return U[x] = Find(U[x]); &#125; void Union(int x, int y) &#123; int xx = Find(x); int yy = Find(y); if (xx == yy) return; U[x] = y; &#125; &#125;; struct Graph &#123; static const int MAXN = 1000 + 10; static const int MAXM = 100000 + 10; struct Node &#123; int nweight, now; Node() &#123; nweight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return nweight &gt; that.nweight; &#125; &#125;; struct Edge &#123; int now, weight, next; int raw_now, raw_next; bool operator &lt; (const Edge &amp;that) const &#123; return weight &lt; that.weight; &#125; &#125; edge[MAXM * 2]; int head[MAXN], dis[MAXN], cnt; inline void addEdge(int prev, int next, int weight, bool isR = true) &#123; if (isR) &#123; addEdge(next, prev, weight, false); &#125; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; edge[cnt].raw_next = next; edge[cnt].raw_now = prev; &#125; inline Node NewNode(int nowWeight, int now) &#123; Node tmp; tmp.nweight = nowWeight; tmp.now = now; return tmp; &#125; inline void SPFA() &#123; memset(dis, 0x7f, sizeof(dis)); std::priority_queue&lt;Node&gt; q; q.push(NewNode(0, 1)); dis[1] = 0; while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int now = NowNode.now; for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (dis[to] &gt; dis[now] + edge[e].weight) &#123; dis[to] = dis[now] + edge[e].weight; q.push(NewNode(dis[to], to)); &#125; &#125; &#125; &#125; inline int Kruskal() &#123; int ans = 0, tot = 0; UnionFind u; std::sort(edge + 1, edge + 1 + cnt); for (int i = 1; i &lt;= cnt; ++i) &#123; int eu = u.Find(edge[i].raw_now); int ev = u.Find(edge[i].raw_next); if (eu == ev) continue; u.Union(eu, ev); ans += edge[i].weight; ++tot; if (tot == cnt - 1) break; &#125; return ans; &#125; &#125; g1; int n, m;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); For (i, 1, n) g1.addEdge(i, n + 1, getint()); For (i, 1, n) &#123; For (j, 1, n) &#123; int p = getint(); g1.addEdge(i, j, p, false); &#125; &#125; FastIO::putint(g1.Kruskal(), '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>BZOJ</tag>
        <tag>USACO</tag>
        <tag>生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1144《最短路计数》]]></title>
    <url>%2F2019-01-12%2FLuogu-P1144%2F</url>
    <content type="text"><![CDATA[最短路“板子” 题目描述给出一个$N$个顶点$M$条边的无向无权图，顶点编号为$1-N$。问从顶点$1$开始，到其他每个点的最短路有几条。 输入输出格式输入格式第一行包含$2$个正整数$N,M$，为图的顶点数与边数。 接下来$M$行，每行$2$个正整数$x,y$，表示有一条顶点$x$连向顶点$y$的边，请注意可能有自环与重边。 输出格式共$N$行，每行一个非负整数，第$i$行输出从顶点$1$到顶点$i$有多少条不同的最短路，由于答案有可能会很大，你只需要输出 $ans \bmod 100003$后的结果即可。如果无法到达顶点$i$则输出$0$。 输入输出样例输入样例123456785 71 21 32 43 42 34 54 5 输出样例1234511124 说明$1$到$5$的最短路有$4$条，分别为$2$条$1-2-4-5$和$2$条$1-3-4-5$（由于$4−5$的边有$2$条）。 对于$20\%$的数据，$N ≤ 100$； 对于$60\%$的数据，$N ≤ 1000$； 对于$100\%$的数据，$N&lt;=1000000,M&lt;=2000000$。 解题思路稍微改一下最短路板子即可 具体就是用 ans[i] 数组记录一下到i点的最短路个数，在更新路径长度的时候判一下两条路径长度的关系即可 1234567891011121314151617const int HA = 100006;/* ... */for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (dis[to] &gt; dis[now] + edge[e].weight) &#123; // 两条路径长度不等，更新答案 dis[to] = dis[now] + edge[e].weight; ans[to] = ans[now]; q.push(NewNode(dis[to], to)); &#125; else if (dis[to] == dis[now] + edge[e].weight) &#123; // 两条路径长度相等，将答案相加 ans[to] += ans[now]; ans[to] %= HA; &#125;&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int HA = 100003; struct Graph &#123; static const int MAXN = 1000000 + 10; static const int MAXM = 2000000 + 10; struct Node &#123; int nweight, now; Node() &#123; nweight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return nweight &gt; that.nweight; &#125; &#125;; struct Edge &#123; int now, weight, next; &#125; edge[MAXM * 2]; int head[MAXN], dis[MAXN], ans[MAXN], cnt; inline void addEdge(int prev, int next, int weight, bool isR = true) &#123; if (isR) &#123; addEdge(next, prev, weight, false); &#125; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline Node NewNode(int nowWeight, int now) &#123; Node tmp; tmp.nweight = nowWeight; tmp.now = now; return tmp; &#125; inline void SPFA() &#123; memset(dis, 0x7f, sizeof(dis)); memset(ans, 0, sizeof ans); std::priority_queue&lt;Node&gt; q; q.push(NewNode(0, 1)); dis[1] = 0; ans[1] = 1; while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int now = NowNode.now; for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (dis[to] &gt; dis[now] + edge[e].weight) &#123; dis[to] = dis[now] + edge[e].weight; ans[to] = ans[now]; q.push(NewNode(dis[to], to)); &#125; else if (dis[to] == dis[now] + edge[e].weight) &#123; ans[to] += ans[now]; ans[to] %= HA; &#125; &#125; &#125; &#125; &#125; g1; int n, m;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); m = getint(); For (i, 1, m) &#123; int prev = getint(); int next = getint(); g1.addEdge(prev, next, 1); &#125; g1.SPFA(); For (i, 1, n) &#123; FastIO::putint(g1.ans[i], '\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1126《机器人搬重物》]]></title>
    <url>%2F2019-01-10%2FLuogu-P1126%2F</url>
    <content type="text"><![CDATA[有直径还写个锤 题目描述机器人移动学会（RMI）现在正尝试用机器人搬运物品。机器人的形状是一个直径$1.6$米的球。在试验阶段，机器人被用于在一个储藏室中搬运货物。储藏室是一个$N \times M$的网格，有些格子为不可移动的障碍。机器人的中心总是在格点上，当然，机器人必须在最短的时间内把物品搬运到指定的地方。机器人接受的指令有：向前移动$1$步（Creep）；向前移动$2$步（Walk）；向前移动$3$步（Run）；向左转（Left）；向右转（Right）。每个指令所需要的时间为$1$秒。请你计算一下机器人完成任务所需的最少时间。 输入输出格式输入格式第一行为两个正整数$N,M(N,M \le 50)$，下面$N$行是储藏室的构造，$0$表示无障碍，$1$表示有障碍，数字之间用一个空格隔开。接着一行有$4$个整数和$1$个大写字母，分别为起始点和目标点左上角网格的行与列，起始时的面对方向（东$E$，南$S$，西$W$，北$N$），数与数，数与字母之间均用一个空格隔开。终点的面向方向是任意的。 输出格式：一个整数，表示机器人完成任务所需的最少时间。如果无法到达，输出$−1$。 输入输出样例输入样例12345678910119 100 0 0 0 0 0 1 0 0 00 0 0 0 0 0 0 0 1 00 0 0 1 0 0 0 0 0 00 0 1 0 0 0 0 0 0 00 0 0 0 0 0 1 0 0 00 0 0 0 0 1 0 0 0 00 0 0 1 1 0 0 0 0 00 0 0 0 0 0 0 0 0 01 0 0 0 0 0 0 0 1 07 2 2 7 S 输出样例112 解题思路1.&nbsp;将格子图转为点图 &amp; 障碍物判断要注意这个机器人是有直径的，所以边界和障碍物的四周都不能走 123456789for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int ttt; scanf("%d", &amp;ttt); if (ttt) &#123; map[i][j] = map[i][j - 1] = map[i - 1][j] = map[i - 1][j - 1] = 1; &#125; &#125;&#125; 2.单向 BFS枚举所有的步数和方向 3.三维数组判重要注意本题是有方向的，所以vis数组需要开三维（vis[N][M][方向]） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int dx[] = &#123; 0, 1, 0, -1 &#125;; const int dy[] = &#123; 1, 0, -1, 0 &#125;; const int MAXN_M = 50 + 10; struct Robot &#123; int x, y; int dir; int step; &#125;; std::queue&lt;Robot&gt; q; bool vis[MAXN_M][MAXN_M][4]; bool map[MAXN_M][MAXN_M]; int n, m; int startx, starty, endx, endy, sd; char startdir;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; int ttt; scanf("%d", &amp;ttt); if (ttt) &#123; map[i][j] = map[i][j - 1] = map[i - 1][j] = map[i - 1][j - 1] = 1; &#125; &#125; &#125; scanf("%d %d %d %d %c", &amp;startx, &amp;starty, &amp;endx, &amp;endy, &amp;startdir); switch(startdir) &#123; case 'E': &#123; sd = 0; break; &#125; case 'S': &#123; sd = 1; break; &#125; case 'W': &#123; sd = 2; break; &#125; default: &#123; sd = 3; break; &#125; &#125; // 对方向进行处理 if (startx &gt;= n || startx &lt; 1 || starty &gt;= m || starty &lt; 1 || map[startx][starty]) &#123; puts("-1"); return 0; &#125; Robot rb; rb.x = startx; rb.y = starty; rb.dir = sd; rb.step = 0; vis[startx][starty][sd] = true; q.push(rb); // 开始 BFS while (!q.empty()) &#123; rb = q.front(); q.pop(); int newx = rb.x; int newy = rb.y; if (newx == endx &amp;&amp; newy == endy) &#123; printf("%d\n", rb.step); return 0; &#125; // 枚举步数 for (int steps = 1; steps &lt;= 3; ++steps) &#123; newx += dx[rb.dir]; newy += dy[rb.dir]; if (newx &lt; 1 || newx &gt;= n || newy &lt; 1 || newy &gt;= m || map[newx][newy]) &#123; break; &#125; if (!vis[newx][newy][rb.dir]) &#123; vis[newx][newy][rb.dir] = true; Robot nown; nown.x = newx; nown.y = newy; nown.dir = rb.dir; nown.step = rb.step + 1; q.push(nown); &#125; &#125; // 更新步数 Robot nown = rb; ++nown.step; --nown.dir; if (nown.dir == -1) nown.dir = 3; if (!vis[nown.x][nown.y][nown.dir]) &#123; vis[nown.x][nown.y][nown.dir] = true; q.push(nown); &#125; nown.dir = rb.dir + 1; if (nown.dir == 4) nown.dir = 0; if (!vis[nown.x][nown.y][nown.dir]) &#123; vis[nown.x][nown.y][nown.dir] = true; q.push(nown); &#125; &#125; puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1141《01迷宫》]]></title>
    <url>%2F2019-01-10%2FLuogu-P1141%2F</url>
    <content type="text"><![CDATA[DFS 联通块 题目描述有一个仅由数字$0$与$1$组成的$n \times n$格迷宫。若你位于一格$0$上，那么你可以移动到相邻$4$格中的某一格$1$上，同样若你位于一格$1$上，那么你可以移动到相邻$4$格中的某一格$0$上。 你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。 输入输出格式输入格式第11行为两个正整数$n,m$。 下面$n$行，每行$n$个字符，字符只可能是$0$或者$1$，字符之间没有空格。 接下来$m$行，每行$2$个用空格分隔的正整数$i,j$，对应了迷宫中第$i$行第$j$列的一个格子，询问从这一格开始能移动到多少格。 输出格式$m$行，对于每个询问输出相应答案。 输入输出样例输入样例123452 201101 12 2 输出样例1244 说明所有格子互相可达。 对于$20\%20$的数据，$n≤10$； 对于$40\%$的数据，$n≤50$； 对于$50\%$的数据，$m≤5$； 对于$60\%$的数据，$n≤100,m≤100$； 对于$100\%$的数据，$n≤1000,m≤100000$。 解题思路首先我们可以知道一个联通块内的所有格子的答案相同 那么我们就直接找联通块，这个联通块内的所有格子的答案都是这个联通块的格子个数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int dx[] = &#123;0, 1, -1, 0, 0&#125;; const int dy[] = &#123;0, 0, 0, -1, 1&#125;; const int MAXN = 1000 + 10; char mp[MAXN][MAXN]; bool vis[MAXN][MAXN]; int n, m, nowans; int xans[MAXN * MAXN], yans[MAXN * MAXN]; int ans[MAXN][MAXN]; void Search(int x, int y) &#123; ++nowans; xans[nowans] = x; yans[nowans] = y; for (int i = 1; i &lt;= 4; ++i) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (!(nx &lt;= 0 || nx &gt; n || ny &lt;= 0 || ny &gt; n) &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny] != mp[x][y]) &#123; vis[nx][ny] = true; Search(nx, ny); &#125; &#125; &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; scanf("%d %d", &amp;n, &amp;m); For (i, 1, n) &#123; scanf("%s", mp[i] + 1); &#125; For (i, 1, n) &#123; For (j, 1, n) &#123; if (!vis[i][j]) &#123; vis[i][j] = true; nowans = 0; Search(i, j); for (int no = 1; no &lt;= nowans; ++no) &#123; ans[xans[no]][yans[no]] = nowans; &#125; &#125; &#125; &#125; For (i, 1, m) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); printf("%d\n", ans[x][y]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1629《邮递员送信》]]></title>
    <url>%2F2019-01-10%2FLuogu-P1629%2F</url>
    <content type="text"><![CDATA[一个正向图，一个反向图 题目描述有一个邮递员要送东西，邮局在节点1.他总共要送N-1样东西，其目的地分别是2~N。由于这个城市的交通比较繁忙，因此所有的道路都是单行的，共有M条道路，通过每条道路需要一定的时间。这个邮递员每次只能带一样东西。求送完这N-1样东西并且最终回到邮局最少需要多少时间。 输入输出格式输入格式第一行包括两个整数N和M。 第2到第M+1行，每行三个数字U、V、W，表示从A到B有一条需要W时间的道路。 满足1&lt;=U,V&lt;=N,1&lt;=W&lt;=10000,输入保证任意两点都能互相到达。 【数据规模】 对于30%的数据，有1≤N≤200; 对于100%的数据，有1≤N≤1000,1≤M≤100000。 输出格式输出仅一行，包含一个整数，为最少需要的时间。 输入输出样例输入样例12345678910115 102 3 51 5 53 5 61 2 81 3 85 3 44 1 84 5 33 5 65 4 2 输出样例183 解题思路类似题目：洛谷P1821《[USACO07FEB]银牛派对Sliver Cow Party》题解：洛谷P1821 《[USACO07FEB]银牛派对Silver Cow Party》 对于这类题目，我们考虑建一个反向（所有边的方向都相反）的图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455struct Graph &#123; static const int MAXN = 1000 + 10; static const int MAXM = 100000 + 10; struct Node &#123; int nweight, now; Node() &#123; nweight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return nweight &gt; that.nweight; &#125; &#125;; struct Edge &#123; int now, weight, next; &#125; edge[MAXM * 2]; int head[MAXN], dis[MAXN], cnt; inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline Node NewNode(int nowWeight, int now) &#123; Node tmp; tmp.nweight = nowWeight; tmp.now = now; return tmp; &#125; inline void SPFA() &#123; // 最短路 // 一块写进去更方便 memset(dis, 0x7f, sizeof(dis)); std::priority_queue&lt;Node&gt; q; q.push(NewNode(0, 1)); dis[1] = 0; while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int now = NowNode.now; for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (dis[to] &gt; dis[now] + edge[e].weight) &#123; dis[to] = dis[now] + edge[e].weight; q.push(NewNode(dis[to], to)); &#125; &#125; &#125; &#125; &#125;; 这里我选择一个稍微懒一点的方法，将图存到一个结构体里面，创建的时候只要 Graph g1, g2; 即可。 最后答案即为 $$ \sum_{i = 1}^{n} \text{g1.dis}[i] + \text{g2.dis}[i] $$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; struct Graph &#123; static const int MAXN = 1000 + 10; static const int MAXM = 100000 + 10; struct Node &#123; int nweight, now; Node() &#123; nweight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return nweight &gt; that.nweight; &#125; &#125;; struct Edge &#123; int now, weight, next; &#125; edge[MAXM * 2]; int head[MAXN], dis[MAXN], cnt; inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline Node NewNode(int nowWeight, int now) &#123; Node tmp; tmp.nweight = nowWeight; tmp.now = now; return tmp; &#125; inline void SPFA() &#123; memset(dis, 0x7f, sizeof(dis)); std::priority_queue&lt;Node&gt; q; q.push(NewNode(0, 1)); dis[1] = 0; while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int now = NowNode.now; for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (dis[to] &gt; dis[now] + edge[e].weight) &#123; dis[to] = dis[now] + edge[e].weight; q.push(NewNode(dis[to], to)); &#125; &#125; &#125; &#125; &#125; g1, g2; int n, m;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); m = getint(); For (i, 1, m) &#123; int prev = getint(); int next = getint(); int weight = getint(); g1.addEdge(prev, next, weight); g2.addEdge(next, prev, weight); &#125; g1.SPFA(); g2.SPFA(); int ans = 0; For (i, 1, n) &#123; ans += g1.dis[i] + g2.dis[i]; &#125; FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2984《[USACO10FEB]给巧克力Chocolate Giving》]]></title>
    <url>%2F2019-01-10%2FLuogu-P2984%2F</url>
    <content type="text"><![CDATA[此时一位单身🐂路过 题目描述Farmer John有B头奶牛$(1&lt;=B&lt;=25000)$，有$N(2*B&lt;=N&lt;=50000)$个农场，编号$1\rightarrow N$，有$M(N-1&lt;=M&lt;=100000)$条双向边，第$i$条边连接农场$R_i$和$S_i(1&lt;=R_i&lt;=N;1&lt;=S_i&lt;=N)$，该边的长度是$L_i(1&lt;=L_i&lt;=2000)$。居住在农场$P_i$的奶牛$A(1&lt;=P_i&lt;=N)$，它想送一份新年礼物给居住在农场$Q_i(1&lt;=Q_i&lt;=N)$的奶牛$B$，但是奶牛$A$必须先到FJ(居住在编号$1$的农场)那里取礼物，然后再送给奶牛$B$。你的任务是：奶牛$A$至少需要走多远的路程？ 输入输出格式输入格式第一行：三个用空格隔开的整数$N$,$M$和$B$。 第二到$M+1$行：第$i+1$行用$R_i$，$S_i$和$L_i$三个用空格隔开的整数描述双向边$i$。 第$M+2$到$M+B+1$行：第$M+i+1$行包含两个用空格隔开的整数$P_i$和$Q_i$。 输出格式第一到$B$行：第$i$行包括一个整数，居住在农场$P_i$的公牛从FJ那里取得情人节巧克力后送给他居住在农场$Q_i$的梦中情牛至少需要走的距离。 输入输出样例输入样例12345678910116 7 3 1 2 3 5 4 3 3 1 1 6 1 9 3 4 2 1 4 4 3 2 2 2 4 5 1 3 6 输出样例1236610 解题思路这道题就是给你一张图和多个询问，对于每个询问，求两个点到点$1$的最短路径之和。 由于双向边的最短路可逆，我们可以得出下面的结论： 对于两条边$(i,j)$和$(j,i)$，有 $dis_{(i,j)} = dis_{(j,i)}$ 所以我们只需要预处理出点$1$到其他所有点的最短路，然后对于每个询问$P,Q$输出 $dis_{(1,P)} + dis_{(1,Q)}$ 即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 50000 + 10; const int MAXM = 100000 + 10; struct Node &#123; int now, weight; Node() &#123; now = weight = 0; &#125; Node(int now, int weight) : now(now), weight(weight) &#123;&#125; bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125; &#125;; Node NewNode(int now, int weight) &#123; Node tmp; tmp.now = now; tmp.weight = weight; return tmp; &#125; struct Edge &#123; int now, next, weight; &#125; edge[MAXM * 2]; int n, m, b, cnt, head[MAXN], dis[MAXN]; inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline void SFPA(int s) &#123; // 要注意的是 // 据说这题不卡 SPFA // 但为保险起见 // 我还是选择 Dijkstra memset(dis, 0x7f7f7f7f, sizeof dis); dis[s] = 0; std::priority_queue&lt;Node&gt; q; q.push(NewNode(s, 0)); while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int nownode = NowNode.now; for (int e = head[nownode]; e; e = edge[e].next) &#123; int now = edge[e].now; if (dis[now] &gt; dis[nownode] + edge[e].weight) &#123; dis[now] = dis[nownode] + edge[e].weight; q.push(NewNode(now, dis[now])); &#125; &#125; &#125; &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; n = getint(); m = getint(); b = getint(); For (i, 1, m) &#123; int prev = getint(); int next = getint(); int weight = getint(); addEdge(prev, next, weight); addEdge(next, prev, weight); &#125; SFPA(1); // 预处理出最短路 For (i, 1, b) &#123; int a = getint(); int b = getint(); int ans = dis[a] + dis[b]; // 转化过的问题的答案，也是最终答案 FastIO::putint(ans, '\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3879《[TJOI2010]阅读理解》]]></title>
    <url>%2F2018-12-26%2FLuogu-P3879%2F</url>
    <content type="text"><![CDATA[实在是一道练习 std::map 的好题啊 题目链接 题目描述英语老师留了N篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。 输入输出格式输入格式第一行为整数 $N$，表示短文篇数，其中每篇短文只含空格和小写字母。 按下来的 $N$行，每行描述一篇短文。每行的开头是一个整数 $L$，表示这篇短文由 $L$个单词组成。接下来是 $L$个单词，单词之间用一个空格分隔。 然后为一个整数 $M$，表示要做几次询问。后面有 $M$行，每行表示一个要统计的生词。 输出格式对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。 输入输出样例输入样例1234567891039 you are a good boy ha ha o yeah13 o my god you like bleach naruto one piece and so do i11 but i do not think you will get all the points5youioallnaruto 输出样例123451 2 32 31 232 其他说明对于30%的数据，1 ≤ M ≤ 1,000 对于100%的数据，1 ≤ M ≤ 10,000，1 ≤ N ≤ 1000 每篇短文长度（含相邻单词之间的空格） ≤ 5,000 字符，每个单词长度 ≤ 20 字符 解题思路Trie？Hash？KMP？Aho-Corasick Automaton？ 统统不要！ 这可是练习 std::map 的一道好题啊！ 我们考虑开一个 std::map&lt;std::string, std::vector&lt;int&gt; &gt;，其中下标为每个单词，元素为这个单词对应在哪几个句子中出现过（所以要用 std::vector&lt;int&gt; 啊） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; std::map&lt;std::string, std::vector&lt;int&gt; &gt; mp; int n, m; std::string s;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; std::ios::sync_with_stdio(false); using std::cin; using std::cout; using std::endl; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; int p; cin &gt;&gt; p; for (int j = 1; j &lt;= p; ++j) &#123; cin &gt;&gt; s; mp[s].push_back(i); // 记录当前单词在哪几个句子里出现过 &#125; &#125; cin &gt;&gt; m; for (int i = 1; i &lt;= m; ++i) &#123; cin &gt;&gt; s; int siz = (int) mp[s].size(); for (int j = 0; j &lt; siz; ++j) &#123; if (j != 0 &amp;&amp; mp[s][j] == mp[s][j-1]) continue; // 手动去重 cout &lt;&lt; mp[s][j]; // 输出 if (j != siz - 1) cout &lt;&lt; ' '; // 输出行中空格 &#125; cout &lt;&lt; endl; // 输出回车键 &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图染色学习笔记]]></title>
    <url>%2F2018-12-08%2FUVA10004-Bipartite-Graph-Coloring%2F</url>
    <content type="text"><![CDATA[本质上就是一个 BFS 模板题目地址 算法简介二分图是这样一个图：有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！无向图$G$为二分图的充分必要条件是，$G$至少有两个顶点,且其所有回路的长度均为偶数。判断二分图的常见方法是染色法： 开始对任意一未染色的顶点染色，之后判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色， 若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断，bfs和dfs可以搞定！ ——百度百科 算法流程我一般习惯用 BFS 做二分图染色，因为这样会更好理解。 首先我们确定一个搜索的起点start，一般我确定为$1$。 将这个起点Push()进你的广搜队列中，并将它随便指定为一种颜色（即染色），我一般习惯用1和-1。要注意的是尽量不要使用0，因为染色的color[]数组同时兼顾着vis[]数组的作用。 每次在队列中取出队头，并遍历每一条与它相连的边。 A. 如果当前邻接点 被染过与它相同的颜色，则直接失败。 B. 如果当前节点没被染过色，就将它加入队列。 C. 不管当前邻接点 染没染过色，将它染上与当前节点不同的颜色。 如果整个过程没有失败，则染色成功。 题目描述PDF源文件 输入输出格式输入格式： 输出格式： 输入输出样例1234567891011121314151617181920330 11 22 0320 11 2980 10 20 30 40 50 60 70 80 123NOT BICOLORABLE.BICOLORABLE.BICOLORABLE. 解题思路见上 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)#define RED 1;#define BLUE -1;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 200 + 10; const int MAXM = MAXN * MAXN + 10; struct Node &#123; int now, weight; Node() &#123; now = weight = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125; &#125;; struct Edge &#123; int now, next; Edge() &#123; now = next = 0; &#125; &#125; edge[MAXM]; int head[MAXN], cnt, n, l; short color[MAXN]; inline void Init() &#123; cnt = 0; memset(head, 0, sizeof(head)); memset(color, 0, sizeof(color)); for (int i = 1; i &lt;= cnt + 5; ++i) &#123; Edge tmp; tmp.now = tmp.next = 0; edge[i] = tmp; &#125; &#125; inline void addEdge(int prev, int next) &#123; edge[++cnt].now = next; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline bool BoynextdoorFirstSearch(int start = 1) &#123; std::queue&lt;int&gt; q; q.push(start); color[start] = RED; while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (color[to] == color[now]) return false; if (color[to] == 0) q.push(to); if (color[now] == 1) &#123; color[to] = -1; &#125; else &#123; color[to] = 1; &#125; &#125; &#125; return true; &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; while (true) &#123; n = getint(); if (n == 0) break; l = getint(); Init(); for (int i = 1; i &lt;= l; ++i) &#123; int prev = getint(); int next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; if (BoynextdoorFirstSearch()) puts("BICOLORABLE."); else puts("NOT BICOLORABLE."); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>图论算法</tag>
        <tag>BFS</tag>
        <tag>模板</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1073B 《Vasya and Books》]]></title>
    <url>%2F2018-12-08%2FCF1073B%2F</url>
    <content type="text"><![CDATA[很明显是栈了好吧 题目地址 题目大意给定 $n$ 本书,序号分别为$1$到$n$，现在执行$n$个操作， 第$i$个操作需要从栈内取出编号为$b_i$的书，如果该书已经取出，则输出$0$否则将该书从栈内取出，同时取出在栈内比$b_i$靠上的书，并且输出一共取出了几本书 输入输出格式输入格式The first line contains one integer $n~(1 \le n \le 2 \cdot 10^5)$ — the number of books in the stack. The second line contains $n$ integers $a_1, a_2, \dots, a_n~(1 \le a_i \le n)$ denoting the stack of books. The third line contains n n integers $b_1, b_2, \dots, b_n~(1 \le b_i \le n)$ denoting the steps Vasya is going to perform. All numbers $a_1 \dots a_n$ are distinct, the same goes for $b_1 \dots b_n$ . 输出格式Print $n$ integers. The $i$ -th of them should be equal to the number of books Vasya moves to his backpack during the $i$ -th step. 输入输出样例#112331 2 32 1 3 12 0 1 #212353 1 4 2 54 5 1 3 2 13 2 0 0 0 #312366 5 4 3 2 16 5 3 4 2 1 11 1 2 0 1 1 解题思路本文同步发布于洛谷博客 粗略看了一下 貌似没人和我的解法相同 那就来写一发题解吧 在读入的时候 我们用另一个数组lead[i]来存编号为i的书在读入的数组book[]的下标 这样我们在检测读入的书是否被取出时就不用遍历一遍book[] 弹出书本的时候，我们首先看一下这个书本是否被取出 如果是就直接输出0 否则就开始弹出书本 我们用一个变量now = 0记录当前弹出了几个书本，用一个数组vis[i]记录第i本书是否被弹出 在弹出之前，用一个变量orin记录一下还没更新的now 接着在每次弹出的时候更新vis[++now]为真，直到遇到当前要弹出的书本编号 最后orin - now即为答案 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;stack&gt;using std::cin;using std::cout;using std::endl;using std::string;const int MAXN = 2e5 + 10;int n;int book[MAXN];int lead[MAXN];bool vis[MAXN];int now = 0;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", book + i); lead[book[i]] = i; // 让lead[]作为book[]的索引，查找的时候快一些 &#125; for (int i = 1; i &lt;= n; ++i) &#123; int o; scanf("%d", &amp;o); if (vis[lead[o]]) printf("0 "); // 被弹过了，输出0 else &#123; int orin = now; while (book[++now] != o) &#123; vis[now] = true; // 循环更新vis（弹出书本） &#125; vis[now] = true; printf("%d ", now - orin); &#125; &#125; return 0;&#125; 总感觉自己的代码能被 Hack]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4568《飞行路线》]]></title>
    <url>%2F2018-11-25%2FBZOJ2763-Luogu-P4568-JLOI2011%2F</url>
    <content type="text"><![CDATA[入门级别的分层图最短路 题目地址双倍经验 前言先介绍一下分层图最短路。 分层图最短路是指在可以进行分层图的图上解决最短路问题。一般模型是：在图上，有k次机会可以直接通过一条边，问起点与终点之间的最短路径。 题目描述Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在nn个城市设有业务，设这些城市分别标记为00到n-1n−1，一共有mm种航线，每种航线连接两个城市，并且航线有一定的价格。 Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多kk种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？ 输入输出格式输入格式数据的第一行有三个整数，n,m,k，分别表示城市数，航线数和免费乘坐次数。 第二行有两个整数，s,t，分别表示他们出行的起点城市编号和终点城市编号。 接下来有m行，每行三个整数，a,b,c，表示存在一种航线，能从城市a到达城市b，或从城市b到达城市a，价格为c。 输出格式只有一行，包含一个整数，为最少花费。 输入输出样例输入样例#1： 123456785 6 10 40 1 51 2 52 3 53 4 52 3 30 2 100 输出样例#1： 18 解题思路这就是分层图最短路的模板但为什么是省选/NOI-呢 我们用DP的思想来看设dis[i][j]表示起点到i点在j层的最短路 如何分层？理解性记忆。例如本题最多有十层，第k层表示免费了k次的最短路 如何跑最短路？洛谷卡SPFA，BZOJ不卡SPFA，但是都要注意把空间开大10倍，不然是过不去的（5次TLE的惨痛经验）在跑 Dijkstra 的时候，我们用了一个pair来存当前到达的点和已走过的路径；这次我们需要多维护一个东西：当前的层数。 1234567891011121314struct Node &#123; int id; // 当前到达的点 int weight; // 已走过的路径 int now; // 当前的层数 Node() &#123; id = weight = now = 0; &#125; // 重载运算符，用于优先队列 bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125;&#125;; 在更新dis的时候，我们需要对这一层的点和下一层的点分别进行更新 123456789if (!vis[to][Floor] &amp;&amp; dis[to][Floor] &gt; dis[now][Floor] + edge[e].weight) &#123; dis[to][Floor] = dis[now][Floor] + edge[e].weight; q.push(NewNode(to, dis[to][Floor], Floor));&#125;if (!vis[to][Floor] &amp;&amp; Floor + 1 &lt;= K &amp;&amp; dis[to][Floor + 1] &gt; dis[now][Floor]) &#123; dis[to][Floor + 1] = dis[now][Floor]; q.push(NewNode(to, dis[to][Floor + 1], Floor + 1));&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; const int MAXM = 500000 + 10; const int MAXK = 10 + 5; struct Node &#123; int id, weight, now; Node() &#123; id = weight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125; &#125; head[MAXN]; struct Edge &#123; int now, next, weight; &#125; edge[MAXM]; int n, m, k, s, t, K, cnt, dis[MAXN][MAXK]; bool vis[MAXN][MAXK]; inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev].id; head[prev].id = cnt; &#125; Node NewNode(int id, int weight, int now) &#123; Node tmp; tmp.id = id; tmp.weight = weight; tmp.now = now; return tmp; &#125; void SPFA() &#123; memset(dis, 0x7f, sizeof(dis)); std::priority_queue&lt;Node&gt; q; For (i, 0, K) dis[s][i] = 0; q.push(NewNode(s, 0, 0)); while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int Floor = NowNode.now; int now = NowNode.id; if (vis[now][Floor]) continue; vis[now][Floor] = true; for (int e = head[now].id; e; e = edge[e].next) &#123; int to = edge[e].now; if (!vis[to][Floor] &amp;&amp; dis[to][Floor] &gt; dis[now][Floor] + edge[e].weight) &#123; dis[to][Floor] = dis[now][Floor] + edge[e].weight; q.push(NewNode(to, dis[to][Floor], Floor)); &#125; if (!vis[to][Floor] &amp;&amp; Floor + 1 &lt;= K &amp;&amp; dis[to][Floor + 1] &gt; dis[now][Floor]) &#123; dis[to][Floor + 1] = dis[now][Floor]; q.push(NewNode(to, dis[to][Floor + 1], Floor + 1)); &#125; &#125; &#125; &#125;&#125;signed main() &#123; using namespace Solution; using FastIO::getint; n = getint(); m = getint(); k = getint(); s = getint(); t = getint(); K = k; For (i, 1, m) &#123; int prev = getint(); int next = getint(); int weight = getint(); addEdge(prev, next, weight); addEdge(next, prev, weight); &#125; SPFA(); int ans = 2147482333; for (int i = 0; i &lt;= k; ++i) &#123; ans = std::min(ans, dis[t][i]); &#125; FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>省选</tag>
        <tag>最短路</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的 PC 更加安全]]></title>
    <url>%2F2018-11-24%2FSecureYourPC%2F</url>
    <content type="text"><![CDATA[Password: 🔑 前言今天（2018.11.24）中午时分我被 Logey 绑住胳膊眼睁睁地看着 RainAir 机惨我RainAir 删除了我的用户密码Shq 修改了我的博客文件折腾了一个中午才恢复过来因为这样 我决定写下这篇文章 简介关于加密┌────────────┐│加密，是以某种特殊的算法││改变原有的信息数据，使得││未授权的用户即使获得了已││加密的信息，但因不知解密││的方法，仍然无法了解信息││的内容。 ——百度百科&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;│└────────────┘ 为什么要加密先不谈什么数据泄露、隐私恶意利用等诸如此类的事，我们来看机惨 一次机惨，轻则「I AK ***」，重则rm -rf / --no-preserve-root 所以锁好自己的电脑是非常重要的 Windows &amp; macOS 通用解决方案当然是设好自己的密码。尽量设复杂且好记的密码，并且保证自己打这个密码的速度足够快，不会让人记住。有生物识别系统的可以考虑安全性高的生物识别系统，像目前已经成熟的「指纹识别」和「Windows Hello」。 macOS 独占解决方案固件密码在开机时按住「⌘+R」，进入恢复模式；点击菜单栏中的「实用工具」，点击「启动安全性实用工具」；输入自己的密码并记牢；最后直接重启即可生效。 用途？设定固件密码之后，进入恢复模式就需要密码了。同样是在恢复模式下，用命令resetpassword可以更改密码！ FileVaultFileVault 会自动直接地对主目录的内容进行加密和解密。真正的安全感来自知道在没有获得允许的时候，没有人可以翻看你的文件。FileVault 使用最新的政府安全标准来保护你的辛勤劳动成果。它保护你主文件夹上的所有信息不被窥测，因此你的商业机密、假期购物单、以及个人财政记录仍然是秘密。FileVault 使用128位高级加密标准 Advanced Encryption Standard 对你主目录下的所有内容进行加密。这个高性能的算法会自动实时加密和解密，因此你甚至不知道它的发生。 ——百度百科 打开方式：「系统偏好设置」→「安全性与隐私」→「文件保险箱」 Time MachineTime Machine 是自动备份功能的一大突破，它内建於 Mac OS X，能为 Mac 上的一切建立最新拷贝，包括数位相片、音乐、家庭影片与文件。现在，只要您有需要，就能轻易回到过去恢复任何资料。 ——百度百科这种方法主要是用来预防被机惨后发生的所有特殊情况，例如博客文件被覆盖，重要文件丢失等等。打开方式：「系统偏好设置」→「时间机器」 加密映像如果有什么东西你想要用密码保护，那加密的映像确实是最好的工具。 方法：「Spotlight Search」Disk Utility.app【文件】【新建映像】【来自文件夹的映像】注意：映像默认只读，如果想让映像可读写，就必须要在「映像格式」里将「压缩」改成「读/写」 Windows 独占解决方案这里其实上面说的东西，Windows 都有替代品。固件密码有 BIOS 里的 Secure Lock，加密映像可以用 UltraISO，磁盘加密可以用 BitLocker ……]]></content>
      <tags>
        <tag>只有经历过的人才知道的世界</tag>
        <tag>使用指南</tag>
        <tag>毒瘤</tag>
        <tag>优化</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2010《回文日期》]]></title>
    <url>%2F2018-11-10%2FLuogu-P2010%2F</url>
    <content type="text"><![CDATA[枚举+判断 题目描述在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。 牛牛习惯用88位数字表示一个日期，其中，前44位代表年份，接下来22位代表月 份，最后22位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。 牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。现 在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存 在的日期是回文的。 一个88位数字是回文的，当且仅当对于所有的i ( 1 \le i \le 8)i(1≤i≤8)从左向右数的第i个 数字和第9-i9−i个数字（即从右向左数的第ii个数字）是相同的。 例如： •对于2016年11月19日，用88位数字2016111920161119表示，它不是回文的。 •对于2010年1月2日，用88位数字2010010220100102表示，它是回文的。 •对于2010年10月2日，用88位数字2010100220101002表示，它不是回文的。 每一年中都有1212个月份： 其中，1,3,5,7,8,10,121,3,5,7,8,10,12月每个月有3131天；4,6,9,114,6,9,11月每个月有3030天；而对于22月，闰年时有2929天，平年时有2828天。 一个年份是闰年当且仅当它满足下列两种情况其中的一种： 1.这个年份是44的整数倍，但不是100100的整数倍； 2.这个年份是400400的整数倍。 例如： •以下几个年份都是闰年：2000,2012,20162000,2012,2016。 •以下几个年份是平年：1900,2011,20141900,2011,2014。 Input / Output 格式 &amp; 样例输入格式两行，每行包括一个88位数字。 第一行表示牛牛指定的起始日期。 第二行表示牛牛指定的终止日期。 保证 $date_i$和都是真实存在的日期，且年份部分一定为4位数字，且首位数字不为0。 保证 $date_1$—定不晚于 $date_2$ 。 输出格式一个整数，表示在$date_1$和$date_2$之间，有多少个日期是回文的。 输入输出样例输入样例#1： 122011010120111231 输出样例#1： 11 输入样例#2： 122000010120101231 输出样例#2： 12 说明【样例说明】 对于样例1，符合条件的日期是20111102。 对于样例2，符合条件的日期是20011002和20100102。 【子任务】 对于$60\%$的数据，满足$date1 = date2$。 解题思路我们考虑直接枚举月和日。 对于每一个月，我们用M[i]表示第i月有多少天。这里要注意的是不用单独判闰年，2月29对应的是92200229，而9220是闰年。 构建字符串直接参照代码，最后比较一下即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */#define GetMonth(x) ((x / 100) % 100)#define GetDay(x) (x % 100)#define GetYear(x) (x / 10000)#define isFullYear(x) ((GetYear(x) % 400 == 0) || (GetYear(x) % 10 == 0 &amp;&amp; GetYear(x) % 4 != 0))using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int M[12 + 1] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int start; int endd; int ans;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; cin &gt;&gt; start; cin &gt;&gt; endd; for (int i = 1; i &lt;= 12; ++i) &#123; for (int j = 1; j &lt;= M[i]; ++j) &#123; int now = 0; now += j; now += i * 100; now += 10000000 * (j % 10); now += 1000000 * (j / 10); now += 100000 * (i % 10); now += 10000 * (i / 10); if (start &lt;= now &amp;&amp; now &lt;= endd) ++ans; &#125; &#125; FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>枚举</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LYOI初中坑题组」模拟赛#2 题解]]></title>
    <url>%2F2018-11-05%2FLYOI-Mid-KT-Team-Contest2%2F</url>
    <content type="text"><![CDATA[暴力能过的题目 前言题面 &amp; 数据依然来自山河 评测 Powered by 洛谷OnlineJudge T1. 复制-粘贴题目描述小 y 是一个聪明的程序员，但是他懒到了极致，在输入程序时甚至不愿意多打一行代码。 有一次，小 y 发现他的一个程序需要输入 n 行一模一样的代码，怎么办呢？ 他首先输入了第 1 行，然后通过 1 次“复制-粘贴”命令得到了第 2 行，再通过 1 次“复制-粘贴”命令得到了第 3-4 行………..直到完成这 n 行代码的输入。 小 y 懒得得意洋洋，正好遇到初学编程的小 x，他就想考考小 x，顺便为难为难他以炫耀自己的聪明才智和编程水平。于是把“复制-粘贴”的伎俩告诉小 x，并让小 x 编程计算最少通过几次“复制-粘贴”命令可以得到正好 n 行的代码？ 输入输出格式输入格式：一行一个正整数 n, 输出格式：一行一个正整数，表示最少的“复制-粘贴”次数 输入输出样例输入样例#1：4输出样例#1：2 解题思路简单推一下就可以知道答案是$\lceil log_2n \rceil$ 这里要注意的是C++中的$log$是以$e$为底的求$\lceil log_2n \rceil$的代码为ceil(log(n) / log(2)) 代码实现12345678910#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int a; cin &gt;&gt; a; cout &lt;&lt; ceil(log(a) / log(2)) &lt;&lt; endl; return 0;&#125; T2. 足球联赛题目描述一个足球联赛由 n 只球队构成。在一个赛季中，每只球队都要与其它球队各比赛两场。 一场比赛在主场，一场在客场。赢一场得 3 分，输一场不得分，平局两支队伍各得 1 分。现在，给你一个 n*n 的矩阵表示比赛情况。第 i 行第 j 列的字母表示在第 i 只队伍主场的比赛情况， W 表示主队赢， L 表示主队输， D 表示平局。 需要你求出得分最高的队伍的编号，如果有分数相同的，在一行中按字典序输出队伍编号。 输入输出格式输入格式：第一行，一个整数 n 。 接下来 n 行，每行 n 个字符，表示输赢情况。 第 i 行第 i 列为 - ,因为一只队伍不可能与自己比赛。 输出格式：得分最高的队伍编号。如有多个在一行中输出，用一个空格分开 输入输出样例输入样例#1： 12343 -WWW-WWW- 输出样例#1： 11 2 3 输入样例#2： 1234565 -DWWDL-WLLDD-WDDDL-LDDLL- 输出样例#2： 11 解题思路直接照题意模拟即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 50 + 10; int n; int score[MAXN]; char sc[MAXN][MAXN]; void Read() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; For (i, 1, n) &#123; For (j, 1, n) &#123; cin &gt;&gt; sc[i][j]; &#125; &#125; &#125; void Work() &#123; ios::sync_with_stdio(false); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j) continue; switch(sc[i][j]) &#123; case 'W': &#123; score[i] += 3; break; &#125; case 'L': &#123; score[j] += 3; break; &#125; case 'D': &#123; score[i] += 1; score[j] += 1; break; &#125; &#125; &#125; &#125; int Max = -2147482333; For (i, 1, n) Max = std::max(Max, score[i]); For (i, 1, n) if (score[i] == Max) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; Read(); Work(); return 0;&#125; T3. 捕食关系题目描述在海洋中，有食肉类的鱼和食草类的鱼，某种食肉类的鱼捕食食草类的鱼当且仅当自己的体重大于对方。 现在给出两类鱼各自的体重，求有多少对捕食关系。 输入输出格式输入格式：每组测试数据有三行。 第一行有两个整数 m， n，分别代表食肉类的鱼的种类数和食草类的鱼的种类数。 第二行 m 个数，第三行 n 个数，代表各自的体重。 输出格式：一个整数，表示有多少对捕食关系。 输入输出样例输入样例#1：5 38 1 7 3 13 6 1输出样例#1：7 解题思路正解不会 暴力能过 我不知道纯暴力能不能过 反正我们要优化一下 首先把食草鱼体重从小到大排个序那么我们在枚举食肉鱼的时候，就可以遇见在第一个体重更大的食草鱼的时候break掉，做法的正确性是显然的 时间复杂度均摊$O(n^2)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXNM = 20000 + 10; int n, m; int bigFish[MAXNM], smallFish[MAXNM]; void Read() &#123; using FastIO::getint; m = getint(); n = getint(); For (i, 1, m) &#123; bigFish[i] = getint(); &#125; For (i, 1, n) &#123; smallFish[i] = getint(); &#125; &#125; void Work() &#123; int cnt = 0; sort(smallFish + 1, smallFish + 1 + n); For (i, 1, m) &#123; For (j, 1, n) &#123; if (smallFish[j] &gt;= bigFish[i]) break; ++cnt; &#125; &#125; FastIO::putint(cnt, '\n'); &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; Read(); Work(); return 0;&#125; T4. 幻方题目描述大家都知道 n 阶奇数幻方吧？如下为一个 5 阶幻方： 17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9现在，输入奇数 n，输出该奇数幻方最右下角的元素值。 输入输出格式输入格式：一行一个数 n。 输出格式：一行一个数，表示该奇数幻方右下角的值。 输入输出样例输入样例#1：5输出样例#1：9 解题思路找规律 指点迷津 代码实现不给]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>自测</tag>
        <tag>比赛</tag>
        <tag>暴力</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LYOI初中坑题组」模拟赛#1 题解]]></title>
    <url>%2F2018-11-03%2FLYOI-Mid-KT-Team-Contest1%2F</url>
    <content type="text"><![CDATA[当一个选手比你小，还比你强…… 前言题面 &amp; 测试输入来自山河 T1. 求和题面小马克今年成为小学生。不久后她将进行她的第一次考试，其中包括数学考试。 她非常认真地复习，她认为自己已经准备好了。她的哥哥通过给她提出问题并解决的方式帮助她。 他的问题是给定一连串整数：依次由 1 个 1，2 个 2，3 个 3 等组成，即1223334444……。 现在他给马克两个整数 A 和 B； 他的任务是求出由第 A 个到第 B 个数的。如果 A 是 1， B是 3， 答案为 1+2+2=5。 给一个问题， 然后计算它们的和， 马克的哥哥能够验证答案正确与否。 输入输出格式 &amp; 样例输入格式：输入文件 instruckcije.in 只有一行， 包括正整数 A 和 B。 输出格式：输出文件 instruckcije.out 共一行， 为和的值。 输入样例#1：1 3输出样例#1：5 输入样例#2：1 1000输出样例#2：29280 数据范围$1 \leq A,B \leq 1000$ 解题思路首先这题是一个签到题无误了 数据范围如此之小，我们可以直接把序列初始化出来，再处理出一个前缀和数组，最后输出即可。 时间复杂度……$O(1)$？反正都是常数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXLENGTH_1 = 1000 + 10; int seq[MAXLENGTH_1], sum[MAXLENGTH_1]; void Init() &#123; int now = 1, cur = 0, i = 0; while (i &lt;= 1001) &#123; ++cur; seq[++i] = now; if (cur == now) &#123; cur = 0; ++now; &#125; &#125; for (int i = 1; i &lt;= 1000; ++i) &#123; sum[i] = sum[i-1] + seq[i]; &#125; &#125; void Work1() &#123; using FastIO::getint; Init(); int x = getint(); int y = getint(); if (x &gt; y) swap(x, y); FastIO::putint(sum[y] - sum[x-1], '\n'); &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work1(); return 0;&#125; T2. 猜歌名题面“Guess the song” 是一项在年轻程序员中非常流行的游戏。它是一种集技能、智慧、 耐性于一体的游戏。这个游戏给玩游戏的人放音乐， 游戏者的目标是尽可能快地猜这首歌 的歌名。 Mirko 可能不是一个很好的程序员， 但他是一个世界级的猜歌者。 Mirko 总是在专辑里的某首歌播放出至少一半歌词的时候猜出歌名。所有歌名的单词是唯一的（没有一个单词会出现一次或更多次）。 写一个程序， 给出歌名和专辑名， 看看 Mirko 在这首歌的哪个点上（在多少个单词之后）猜出歌名。 输入输出格式 &amp; 样例输入格式：第一行：包含一个整数 N， 它是一首歌里的单词数目。接下来的 N 行每一行包含歌名的一个单词。第 N+2 行： 包含一个整数 M， 它是专辑里的单词数目。接下来的 M 行每一行包含专辑里的一个单词。歌名和专辑里的所有单词由 1 到 15 个小写英文字母组成。 输出格式：共一行， 包含一个数， 表示 Mirko 在第几个单词处猜出歌曲名。 输入样例#1：3sedamgladnihpatuljaka7sedamdanasedamnocisedamgladnihgodina 输出样例#1：6 解题思路我们称输入的N个单词为WN，输入的M个单词为WM 那么题目就是要求我们找出一个最小ANS，使得在WM中的前ANS个单词满足有至少一半的WN中的单词 那么数据范围依然极小，直接暴力算完 当然我看着貌似能二分答案太懒不写单调性显然，当$\text{ANS}$成立的时候，满足$\text{ANS} \leq \text{ANS}_1 \leq \text{M}$的$\text{ANS_1}$都是成立的。 这里要注意的是当N为奇数时，N的一半$=\lfloor\frac{N}{2}\rfloor + 1$，否则N的一半$=\frac{N}{2}$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 50 + 10; const int MAXM = 10000 + 10; string song[MAXN]; string album[MAXM]; map&lt;string, bool&gt; vis; int n, m, most; inline bool Check() &#123; int ret = 0; For (i, 1, n) if (vis[song[i]]) ++ret; return ret &gt;= most; &#125; void Work2() &#123; cin &gt;&gt; n; For(i, 1, n) &#123; cin &gt;&gt; song[i]; &#125; cin &gt;&gt; m; most = ((n % 2) == 0 ? n / 2 : n / 2 + 1); For(i, 1, m) &#123; cin &gt;&gt; album[i]; //cout &lt;&lt; album[i] &lt;&lt; endl; vis[album[i]] = true; if (Check()) &#123; printf("%d\n", i); return; &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work2(); return 0;&#125; T3. 黑白棋题面Lagno 是一种二人智力游戏。 游戏设有一个黑方和一个白方。游戏桌面是正方形的， 包含 8 行 8 列。 如果黑方玩家走出这样一步棋：将一枚黑子放在任一空格上， 而在这个空格的八个方向（上、下、左、右和 4 个对角线方向）的至少一个方向上有一排白子被夹在这枚新下的黑子和其他黑子之间， 任何方向， 在新黑子和原来黑子之间的所有白子都要变成黑子。为这个游戏设计一个程序， 计算一步棋中黑方能转变的白子数量的最大值。 输入输出格式 &amp; 样例输入格式：输入文件 lango.in 共 8 行， 每行 8 个字符；“.”代表一个空格；“B”代表黑子，“W” 代表白子。 输出格式：输出文件 lango.out 共一行， 有一个整数， 表示一步中黑方能吃掉白子的最大数， 如果无法吃掉就输出“0”。 输入输出样例输入样例#1： 12345678...........................BW......WB........................... （这个说实话不等宽不行 输出样例#1： 11 解题思路暴！力！能！过！输出0拿9分 暴力算法数据范围如此之小，我们不如直接枚举所有空格点，对这个点进行八向扩展，累加答案，最后取$max$即可 正解当然是DFS我们还是枚举每一个点，只不过这次不暴力扩展了。我们用dx[]和dy[]来记八个方向，根据它来扩展。dfs(int now, int x, int y)中的now就表示现在是第now个方向 边界肯定是要判的（x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8），当前是不是空格子也要判（s[i][j] == &#39;.&#39;），如果有任意一个满足就直接return -INF如果当前碰到了一个黑格子，说明到头了，return 0即可否则return dfs(now, x + dx[now], y + dy[now]) + 1 想是有点难想的，但是代码很好看懂。 代码实现暴力算法***毒瘤警告*** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int dx[8] = &#123;-1, 1, 0, 0, -1, -1, 1, 1&#125;; const int dy[8] = &#123; 0, 0, -1, 1, -1, 1, -1, 1&#125;; const int MAXX_Y = 8 + 2; short Map[MAXX_Y][MAXX_Y]; // 0: blank // 1: Black // 2: White int ans = 0; void Read() &#123; // 初始化 for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; char c; cin &gt;&gt; c; switch (c) &#123; case '.': &#123; Map[i][j] = 0; break; &#125; case 'B': &#123; Map[i][j] = 1; break; &#125; case 'W': &#123; Map[i][j] = 2; break; &#125; &#125; &#125; &#125; &#125; int getAnswer(int x, int y) &#123; // 获取上下左右的可扩展数量 int ret = 0; int current = 0; int ox = x; int oy = y; while (true) &#123; ++current; ++x; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (x == 8 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --x; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (x == 1 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; ++y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (y == 8 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (y == 1 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; return ret; &#125; int getAnswerAlt(int x, int y) &#123; // 获取四个对角线上的可扩展数量 int ret = 0; int current = 0; int ox = x; int oy = y; while (true) &#123; ++current; ++x; ++y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 8 || y == 8) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --x; --y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 1 || y == 1) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --x; ++y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 1 || y == 8) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; ++x; --y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 8 || y == 1) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; return ret; &#125; void Search() &#123; for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; if (Map[i][j] != 0) continue; ans = std::max(ans, getAnswer(i, j) + getAnswerAlt(i, j)); &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Read(); Search(); putint(ans, '\n'); return 0;&#125; 正解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int dx[8 + 1] = &#123;0, -1, -1, 0, 1, 1, 1, 0, -1&#125;; const int dy[8 + 1] = &#123;0, 0, 1, 1, 1, 0, -1, -1, -1&#125;; const int INF = 2147482333; char s[8 + 2][8 + 2]; int ans, Max; void Init() &#123; for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; cin &gt;&gt; s[i][j]; &#125; &#125; &#125; int DFS(int now, int x, int y) &#123; if (x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8 || s[x][y] == '.') return -INF; if (s[x][y] == 'B') return 0; return DFS(now, x + dx[now], y + dy[now]) + 1; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Init(); for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; for (int k = 1; k &lt;= 8; ++k) &#123; int p = 0; if (s[i][j] == '.') &#123; p = DFS(k, i + dx[k], j + dy[k]); if (p &gt; 0) ans += p; // 累计答案 &#125; &#125; Max = std::max(Max, ans); // 更新答案 ans = 0; &#125; &#125; putint(Max, '\n'); return 0;&#125; T4. 跳格子题面Nikola 现在已经成为一个游戏里的重要人物。这个游戏是由一行 N 个方格， N个方格 用 1 到 N 的数字表示。 Nikola 开始是在 1 号位置， 然后能够跳到其他的位置， Nikola 的第一跳必须跳到 2 号位置。随后的每一跳必须满足两个条件： 1、如果是向前跳， 必须比前面一跳远一个方格。 2、如果是向后跳， 必须和前面一跳一样远。 比如， 在第一跳之后（当在 2 号位置时）， Nikola 能够跳回 1 号位置， 或者向前跳到 4号位置。 每次他跳入一个位置， Nikola 必须付费。 Nikola 的目标是从一号位置尽可能便宜地跳到 N 号位置。 写一个程序， 看看 Nikola 跳到 N 号位置时最小的花费。 输入输出格式 &amp; 样例输入格式：共有 N+1 行。 第一行：包含一个整数 N， 它是位置的编号。 第 2..N+1 行：第 i+1 行表示第 I 个方格的费用， 是一个正整数 输出格式：只有一个数， 表示 Nikola 跳到 N 号位置时最小的花费。 输入输出样例 输入样例#1：6 1 2 3 4 5 6输出样例#1：12 输入样例#2：8 2 3 4 3 1 6 1 4输出样例#2：14 数据范围2≤N≤1000 费用不大于500 解题思路妥妥的DP 我们设 $\text{f[i][j]}$表示跳到第 $i$ 个格子上，可以向后跳 $j$ 个格子的时候的最小花费 转移方程： $\text{(default) f[i][j] = LESS_INF}$ 上一次向前跳，显然上一次跳了 $j$ 格。$\text{f[i][j] = min(f[i][j], f[i-j][j-1]}$ 上一次向后跳，显然上一次跳了 $j$ 格。 $\text{f[i][j] = min(f[i][j], f[i+j][j]}$ 最后加上本格的花费$\text{cost[i]}$就是$\text{f[i][j]}$ 需要注意的东西有两个，一个是边界，另一个是答案为$\text{min{f[n][i]} }(i \in [1, n-1])$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 1000 + 10; int cost[MAXN]; int f[MAXN][MAXN]; int n; int DFS(int now, int step, int ncost) &#123; // 写挂了的搜索 if (now == n) return ncost; int ret = 2147482333; cout &lt;&lt; "now = " &lt;&lt; now &lt;&lt; endl; cout &lt;&lt; "ncost = " &lt;&lt; ncost &lt;&lt; endl; if (now + step + 1 &lt;= n) ret = std::min(ret, DFS(now + step + 1, step + 1, ncost + cost[now + step + 1])); if (now != 1 &amp;&amp; step != 0 &amp;&amp; now - step &gt; 0) ret = std::min(ret, DFS(now - step, step, ncost + cost[now - step])); return ret; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; n = getint(); For (i, 1, n) cost[i] = getint(); int step = 0; //putint(DFS(1, 0, cost[1]), '\n'); //for (int i = 1; i &lt; n; ++i) &#123; // int now = 2147482333; //&#125; int Min = 2147482333; for (int i = 2; i &lt;= n; ++i) f[i][0] = 0x3f3f3f3f; for (int j = 1; j &lt; n; ++j) &#123; for (int i = n; i &gt;= 1; --i) &#123; f[i][j] = 0x3f3f3f3f; if (i &gt; j) f[i][j] = f[i - j][j - 1]; if (i + j &lt;= n) f[i][j] = std::min(f[i][j], f[i + j][j]); if (f[i][j] != 0x3f3f3f3f) f[i][j] += cost[i]; if (i == n) Min = std::min(Min, f[i][j]); &#125; &#125; putint(Min, '\n'); return 0;&#125; 果然我还是太弱了 这题并没有A掉 差这题就AK了]]></content>
      <tags>
        <tag>编程</tag>
        <tag>自测</tag>
        <tag>比赛</tag>
        <tag>枚举</tag>
        <tag>自测题</tag>
        <tag>动态规划，DP</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 钦定评测系统 Arbiter 使用指南]]></title>
    <url>%2F2018-11-02%2FArbiter%2F</url>
    <content type="text"><![CDATA[Developed by GAIT 什么是 ArbiterArbiter 是NOI信息学竞赛唯一指定评测工具，分为网络版和单机版，支持目前主流的 Linux 发行版本，多种语言支持（C, C++ 和 Free Pascal），功能多样，配置灵活，并具有精确的时间控制。 下载 &amp; 安装Deb 包我没有找到关于 Deb 包的任何信息，可能 CCF 暂时移除了。 NOI Linux首先，打开这个网址下载 NOI Linux 并安装（实体机虚拟机均可）默认密码 123456 配置打开程序在 NOI Linux 中，你可以在左上角的「应用程序」中找到它。 打开之后，它的主界面是这样的。 新建竞赛点击「NEW」按钮，输入比赛名称，选择存储目录，点击确定。 打开竞赛如果你已经创建过的话，点击「OPEN」，选择竞赛的配置文件(.cfg)，点击确定即可。 配置竞赛试题配置打开竞赛之后，它会显示这样的一个界面。我们右键单击试题概要下面的空白处，选择添加考试，它会添加一场名为「第一场——机试」的考试。如何改名下面会说。 我们右键这场考试，选择添加试题，并点击「+」号展开这场比赛。试题默认的名字是「Unknow1」，可以自己修改。 在这里，你可以修改针对每一个试题的配置。我个人比较偏好的设置如下图。 关于其他的「比较方式」，在「/path/to/your/contest/filter/readme.txt」中可以了解，对应的比较方式也有源代码。 数据配置所有的数据文件都放在「/path/to/your/contest/evaldata/」里，且无任何子文件夹。 所有的输入数据的名称都应该是「题目名称 + 编号 + .in」，如下图。 评测选手文件所有的选手文件夹都放在.../players/里 像 NOIP 一样，所有的选手文件都需要建立子文件夹。 12345678910| .../players/|||--| SD-66666||------| ccf||----------&gt; ccf.cpp||------| cheat||----------&gt; cheat.cpp||------| money||----------&gt; money.cpp| 开始评测切换到「试题评测」界面，点击「添加选手」，输入姓名和编号，点击确定。点击「导入名单」可以进行批量导入我没试过。 这里要注意编号是和文件夹名相同的。 首先我们要将「评测第0场」改一下，再点击「全选」，「评定选定选手」就开始评测了。 统计信息评测完之后，程序会自动显示评测的结果。 更加详细的信息可以到「成绩统计」里看。「成绩统计」分为4个模块：总体统计、分组统计、试题统计和等级统计。总体统计分组统计试题统计等级统计 不得不说分组统计和等级统计就是专门为 NOIP 系列赛事开发的…… 你可以选择导出或打印。 对了，成绩为什么多30pts我也不得而知（ FAQs想问的可以在评论里问或发送邮件到我的邮箱我会抽一些整理出来 Q1：如何给考试改名？A1：当然是万能的配置文件。打开day1.info，更改NAME=后面的内容。]]></content>
      <tags>
        <tag>使用指南</tag>
        <tag>比赛</tag>
        <tag>评测系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018-11-02%2FNOIP2018-PJ%2F</url>
    <content type="text"><![CDATA[&amp;GaiGeKaiFang(40)Nian 随手一记NOIP2018 游记12rp = 0x3f3f3f3f;rp++; 出征！ Day 1上午今天在学生活动中心肝了一个上午又做了几道题 顺便写了一发题解希望能涨涨RP吧 下午等待进场的时间真是漫长。看着队伍一点一点地往前走，我的心也开始激动了起来。 进场发现有人居然动鼠标，监考老师还不管考前5min就发了密码 T1水题，上来5min切了不过我居然奶中了，T1就是求一个字符串中有多少字符 T2是个暴力，最开始想出了$O(n^2)$的做法，后来改了一下就成了一个$O(n)$的做法，没意外应该能拿满 T3……我被T3切了打了个最大计算量$10^{10}$的算法，结果极限大样例答案不对！心态崩了 T4随便判了几个情况，希望能骗一点分 顺便表扬CCF终于换评测机了 正经的Day0 成堆的人在开包，成堆的人出橙了，成堆的人掉rp。 不得不说去昌邑的路真漫长，貌似SDSC的时候都没这么长时间。 下了车第一件事就是拍照，补上SDSC没有拍照的遗憾，毕竟昌邑一中的绿化面积和水系的面积是极大的！这就是我戏称昌邑一中为“昌邑第一自然保护区”的原因。 晚上去试机，不得不说习惯了 Macbook Pro 2017 的蝶式键盘就真的回不来了。还有对应 Alt 键的 ⌘ 键，实在是习惯了，到那保存就是一个劲地按 Alt + S……敲了一遍代码的默认模板，5分钟敲过，和我预想中的差不多快。 Day1 上午去了学生活动中心做题，一口气切了8道题——但是都是「普及-」的题目，这可能是这三天我的活动安排的败笔。我应该做「普及/提高-」的题目的啊…… 中午写了篇题解扔到博客上了，希望能rp++ 下午去的时候手机居然没电了，好自闭啊。还没到2:30就带着一瓶今麦郎的凉白开进了场，居然不到时间就发了密码。第一道题我居然说中了……考试前一天我还在说一道求字符串长度的题，于是用getline5分钟切了。第二题依然是水题，先想到的是$O(n^2)$的做法，发现只能拿80分，于是就开始想正解。很快想到了一个$O(n)$的做法就开始敲，结果最大的样例过不了，然后简单分析了一下发现需要开long long int。不过，我在开了long long int之后只把表示∞的值提高了一点，在Day2的自测中才发现……所以我写$O(n)$的做法跟没写一样，开long long跟没开一样！看到自测的成绩后我心态是真的崩死了。第三题第一眼是DP，但是推不出式子来，于是就开始想贪心做法。写了一个暴力，然后最大的样例死活调不过，浪费了近1个小时。第四题一看就知道不大可做，然后尝试写暴力也没写出来，最后随便判了几个情况算完。 Day2上午在学生活动中心把题目写了一遍，发现第二题∞的值设的过小，预测了一下省一线]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>NOIP</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher 算法介绍]]></title>
    <url>%2F2018-11-01%2FManacher%2F</url>
    <content type="text"><![CDATA[$O(n)$回文串 Manacher 是什么Manacher 是一种可以在$O(n)$的时间复杂度内求出一个字符串的最长回文子串的算法。 Manacher，中文一般念做「马拉车」。 Manacher Algorithm 的思想首先我们来看一道题洛谷P3805【模板】manacher算法。 考虑一下暴力做法，就是枚举字串的边界并进行验证，时间复杂度$O(n^3)$ 考虑一下优化，我们可以枚举所有“回文子串”的对称轴（尽管它现在不一定是回文子串）并向两边进行扩展，用一个数组external[i]记录第i个字符可向外扩展的数量，显然数组中最大值的二倍就是答案，时间复杂度均摊$O(n^2)$。 但这还不够快……毕竟$\text{|s|} \leq 11000000$ 于是我们考虑在优化的思想基础上进行再次优化。 在此之前，我们首先要解决一个棘手的问题——字符串的长度。一个字符串子串的对称轴是在字母中间还是在字母上，是由子串长度为偶数还是奇数决定的。于是，为了统一对于奇数长度字符串和偶数长度字符串的做法，我们需要对字符串进行修改。（代码见「代码实现」Pre()部分） 1234567就比如说 - - - - - -|%|%|%|w|y|h|我们要用一些无关紧要的字符填一下 - - - - - - - - - - -|%|!|%|!|%|!|w|!|y|!|h|这样更好处理 修改完了之后，就是真正的Manacher()过程了首先，我们要用一个变量maxRight记录「当前的 最靠右的 回文子串的 右端点」，和一个变量mid记录「当前的 最靠右的 回文子串的 对称轴所在的 字符的 下标」，注意这里的mid是可以不赋初值的 我们循环枚举经过处理的字符串的每一个字符。对于每一个字符的下标i，如果i &lt; maxRight，那么我们就可以获取external[i]的部分信息（external[i]的意义和上文相同），否则就只能将external[i]设为1 接着就是和暴力一样的扩展了，我这里选择用for语句实现（ 最后更新一下maxRight和mid即可 最终答案就是external[]的最大值——而不是2倍，因为这是我们扩展过的字符串，最终答案还要$\times \frac{1}{2}$。 Manacher Algorithm 的代码实现同样也是「manacher模版」的代码实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 31000000 + 10; // 没错，就是要开这么大 int n, external[MAXN]; char s[MAXN], str[MAXN &lt;&lt; 1]; void Pre() &#123; str[0] = str[1] = '~'; for (int i = 0; i &lt; n; ++i) &#123; str[i * 2 + 2] = s[i]; str[i * 2 + 3] = '~'; &#125; n = n * 2 + 2; str[n] = 0; &#125; void Manacher() &#123; int maxRight = 0, mid = 0; // mid 初值无所谓 for (int i = 1; i &lt; n; ++i) &#123; if (i &lt; maxRight) &#123; external[i] = std::min(external[(mid &lt;&lt; 1) - i], external[mid] + mid - i); &#125; else &#123; external[i] = 1; &#125; for (; str[i + external[i]] == str[i - external[i]]; ++external[i]); if (external[i] + i &gt; maxRight) &#123; maxRight = external[i] + i; mid = i; &#125; &#125; &#125; void Work() &#123; cin &gt;&gt; s; n = (int) strlen(s); Pre(); Manacher(); int ans = 1; for (int i = 0; i &lt; n; ++i) ans = std::max(ans, external[i]); cout &lt;&lt; ans - 1 &lt;&lt; endl; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work(); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1280《尼克的任务》]]></title>
    <url>%2F2018-11-01%2FLuogu-P1280%2F</url>
    <content type="text"><![CDATA[线性DP 题目🔗 题目描述尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 Input / Output 格式 &amp; 样例输入格式输入数据第一行含两个用空格隔开的整数$N$和$K(1≤N≤10000，1≤K≤10000)$，$N$表示尼克的工作时间，单位为分钟，$K$表示任务总数。 接下来共有$K$行，每一行有两个用空格隔开的整数$P$和$T$，表示该任务从第$P$分钟开始，持续时间为$T$分钟，其中$1≤P≤N$，$1≤P+T-1≤N$。 输出格式输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 输入样例123456715 61 21 64 118 58 111 5 输出样例14 解题思路DP 我们设f[i]表示在前i分钟内的最大空闲时间但是发现第i分钟的空闲时间是由后面的任务决定的所以我们考虑倒着扫一遍 我们设f[i]表示在第i$\rightarrow$n分钟内的最大空闲时间转移方程： 当第i分钟没有任务时，f[i] = f[i + 1] + 1 当第i分钟有任务时，f[i] = std::max(f[i], f[i + seq[j]].time)，其中seq[j].time表示第j个任务的耗时 如何判断当前有没有任务？我们开一个数组sum[i]表示第i分钟的任务个数更新就很好更新了——++sum[seq[j].startTime]，其中seq[j].startTime表示第j个任务的开始时间 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; /*/ * * 设f[i]表示i-n的空闲时间 * f[i] = f[i+1] + 1（无任务） * f[i] = max(f[i], f[i + seq[x]])（有任务） * /*/ const int MAXK = 10000 + 10; const int MAXN = MAXK; struct QwQ &#123; int start, time; &#125; qwq[MAXK]; int n, k; int sum[MAXN]; int f[MAXN]; int num = 1; bool stlCmp(QwQ x, QwQ y) &#123; return x.start &gt; y.start; &#125; void Work() &#123; using FastIO::getint; n = getint(); k = getint(); For (i, 1, k) &#123; qwq[i].start = getint(); qwq[i].time = getint(); ++sum[qwq[i].start]; &#125; sort(qwq + 1, qwq + 1 + k, stlCmp); // 既然是倒序，所以输入也要排序 for (int i = n; i &gt;= 1; --i) &#123; if (sum[i] == 0) f[i] = f[i + 1] + 1; // 当前时刻没有任务 else &#123; for (int j = 1; j &lt;= sum[i]; ++j) &#123; f[i] = std::max(f[i], f[i + qwq[num].time]); // 当前时刻有至少一个任务，把它们都扫一遍 ++num; // 用一个变量 num 表示当前扫到的任务 &#125; &#125; &#125; FastIO::putint(f[1], '\n'); // 输出 &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work(); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1577《切绳子》]]></title>
    <url>%2F2018-10-31%2FLuogu-P1577%2F</url>
    <content type="text"><![CDATA[突然想起《割绳子》 题面🔗 题面描述有N条绳子，它们的长度分别为Li。如果从它们中切割出K条长度相同的绳子，这K条绳子每条最长能有多长？答案保留到小数点后2位。 Input / Output 格式 &amp; 样例输入格式第一行两个整数N和K，接下来N行，描述了每条绳子的长度Li。 输出格式切割后每条绳子的最大长度。 输入样例123454 118.027.434.575.39 输出样例12.00 解题思路首先这题涉及到了int和double之间的精度转换 所以我们可以把输入的double都乘100转为int（题目要求保留两位小数） 不难看出来这题可以枚举答案 但是显然会炸 于是我们要想点优化——二分答案！ 我们选择二分绳子的最大长度 这题的单调性是显然的，我就不证了（ Check(int mid)怎么写？ 我们扫一遍绳子长度L[]，令$ ans=\sum_{i=1}^{n}\lfloor\frac{L[i]}{mid}\rfloor $ 即最终绳子被分成的段数 如果$ans \geq k$（题目中的$\text{k}$）则把左边界赋值为mid + 1，否则把右边界赋值为mid - 1 这里要注意的是如果mid == 0就直接退出循环 最后cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (double) r / 100.0 &lt;&lt; endl; 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;using namespace std;const int MAXN = 10000 + 10;const double MAXL = 100000.00;int n, k;int L[MAXN];bool Check(int x) &#123; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += L[i] / x; return ans &gt;= k;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; double P; cin &gt;&gt; P; L[i] = (int) (P * 100.0); &#125; int l = 0, r = 19260817 + 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (mid == 0) break; if (Check(mid)) l = mid + 1; else r = mid - 1; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (double) r / 100.0 &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1032《字串变换》]]></title>
    <url>%2F2018-10-30%2FLuogu-P1032%2F</url>
    <content type="text"><![CDATA[NO ANSWER! 题目描述已知有两个字串$A,B$及一组字串变换的规则（至多$6$个规则）: $A_1 \rightarrow B_1$ $A_2 \rightarrow B_2$​规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $B_1$，$A_2$可以变换为 $B_2 \dots$ 例如：$A=$’$abcdabcd$’，$B＝$’$xyzxyz$’ 变换规则为： ‘$abc$’$\rightarrow$‘$xu$’ ‘$ud$’$\rightarrow$‘$y$’ ‘$y$’$\rightarrow$‘$yz$’ 则此时，$A$可以经过一系列的变换变为$B$，其变换的过程为： ‘$abcd$’$\rightarrow$‘$xud$’$\rightarrow$‘$xy$’$\rightarrow$‘$xyz$’ 共进行了$3$次变换，使得$A$变换为$B$。 Input / Output 格式 &amp; 样例输入格式：输入格式如下： $A$ $B$ $A_1$ $B_1$​$A_2$ $B_2$​$|\rightarrow$ 变换规则 … … / 所有字符串长度的上限为$20$。 输出格式：输出至屏幕。格式如下： 若在$10$步（包含$10$步）以内能将$A$变换为$B$，则输出最少的变换步数；否则输出”NO ANSWER!” 输入样例1234abcd xyzabc xuud yy yz 输出样例13 解题思路这是一个 BFS 题目刚上来就有一个坑 输入不给行数 只知道最多六行 于是我们用一个变量l来记录输入的行数 我这里选择用A[0]和B[0]来存两个原字符串 首先如果l == 0而且A[0] != B[0]，那直接输出NO ANSWER! 否则用一个变量v来记录BFS()的返回值 如何搜索？ www.baidu.com 我们建两个队列q和step，分别存需要修改的字符串和这个字符串所对应的步数 循环的时候就不能只判!q.empty()，还要判q.front() != B[0] /* 字符串还需要修改 */和step.front() &lt;= 10 /* 限制只能修改10次 */ 我们还需要用一个map&lt;string, bool&gt;来判重 剩下的一些解释我直接扔到代码注释里面了 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int MAXN = 6 + 3;map&lt;string, bool&gt; KangShifu;string A[MAXN], B[MAXN];int BoynextdoorFaqSearch(int l) &#123; int ans = 0; queue&lt;string&gt; q; queue&lt;int&gt; step; q.push(A[0]); step.push(0); while (!q.empty() &amp;&amp; q.front() != B[0] &amp;&amp; step.front() &lt;= 10) &#123; if (KangShifu[q.front()]) &#123; q.pop(); step.pop(); continue; // 去重 &#125; KangShifu[q.front()] = true; for (int i = 1; i &lt;= l; ++i) &#123; string s = q.front(); // 用一个string记录下当前需要修改的字符串 while (true) &#123; // 可能不止修改一次 int loc = s.find(A[i]); if (loc == -1) break; // 并没有找到 string ss = q.front(); // 再复制一份需要修改的字符串 ss.replace(loc, A[i].size(), B[i]); // 修改 q.push(ss); // 把它扔进队列 step.push(step.front() + 1); // 步骤数 + 1 s[loc] = '~'; // 把这个能搜到的地方用一个无关紧要的放起来 // 防止下次还能被搜到 &#125; &#125; q.pop(); step.pop(); // 处理完毕 &#125; if (q.empty() || step.front() &gt; 10) ans = -1; // 如果队列空了或超过10步了，输出NO ANSWER! else ans = step.front(); // 否则输出真正的答案 return ans;&#125;int main(int argc, const char * argv[]) &#123; int l = 0; while (cin &gt;&gt; A[l] &gt;&gt; B[l]) ++l; --l; if (l == 0 &amp;&amp; A[0] != B[0]) puts("NO ANSWER!"); else &#123; int v = BoynextdoorFaqSearch(l); // Boy Next Door if (v == -1) puts("NO ANSWER!"); else cout &lt;&lt; v &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>字符串</tag>
        <tag>BFS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3952《时间复杂度》]]></title>
    <url>%2F2018-10-29%2FLuogu-P3952%2F</url>
    <content type="text"><![CDATA[继《玩具谜题》后的又一力作 题目地址 题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下： 123F i x y 循环体E 其中 $\text{F i x y}$ 表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i+1$，一旦 $i$ 大于 $y$ 终止循环。 $x​$ 和 $y​$ 可以是正整数（$x​$ 和 $y​$ 的大小关系不定）或变量 $n​$。$n​$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。 “$\text{E}$”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“$O$”表示通常意义下“$Θ$”的概念。 Input / Output 格式 &amp; 样例输入格式：输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 $\text{F i x y}$和$\text{E}$即可计算时间复杂度。注意：循环结构 允许嵌套。 接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为$n^w$，其中$w$是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 $L$ 行代表程序中循环结构中的$\text{F i x y}$或者 $\text{E}$。 程序行若以$\text{F}$开头，表示进入一个循环，之后有空格分离的三个字符（串）$\text{i x y}$， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。 程序行若以$E$开头，则表示循环体结束。 输出格式：输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出Yes或No或者ERR，若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误（其中语法错误只有: ① $\text{F}$ 和 $\text{E}$ 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出ERR 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 输入样例1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 输出样例12345678YesYesERRYesNoYesYesERR 解题思路首先我们肯定一眼就能看出这题是个没有任何优化的大模拟 那么如何模拟？ 首先我们为了方便，把循环体离线下来，用字符串存着 根据题意，我们写一个函数GetNumber()把字符串里的数字存下来 具体和快读差不多 我们先把小明给出的时间复杂度的$n$的指数记为$\text{w}$，这里注意$O(1)$的情况要用$0$代替 接着便是求真正的时间复杂度了 首先是判断ERR 这个比较简单 我们用一个栈来储存所有的循环体的变量名 当$\text{E}$已经读完但是栈不空 当$\text{E}$未读完但是栈空 当储存的变量名与现在的变量名冲突 这个过程穿插在代码各处 当读到$\text{F}$的时候往栈里 Push 循环体变量名，注意要一块把记录变量名的数组used进行判断并更新 之后，我们用GetNumber获取一下$x$和$y$两个数，分情况讨论一下 当$y$是$n$的时候，如果这次循环可以执行，++答案 当$y&lt;x$的时候，循环不执行，更新一下「最早不能循环的循环体」 剩下一种情况就是常数，可以不写 当读到$\text{E}$的时候，先检查栈里还有没有东西，再 Pop 出来，注意要检查一下这个变量是不是「最早不能循环的循环体」的变量 最后扫完数据，判一下栈是不是还有东西没 Pop 出来，然后验一下答案，输出 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;stack&gt;using namespace std;const int MAX = 100 + 10;string Code[MAX];int t;int GetNumber(int &amp;X, string s) &#123; int len = s.length(); while (!isdigit(s[X]) &amp;&amp; X &lt; len) &#123; if (s[X] == 'n') &#123; ++X; return 19260817; &#125; ++X; &#125; int ret = 0; while (isdigit(s[X])) &#123; ret = ret * 10 + s[X] - '0'; ++X; &#125; return ret;&#125;int getO(string s) &#123; if (s[2] == 'n') &#123; int _ = 3; // 必须要传实参进去 return GetNumber(_, s); &#125; return 0;&#125;int GetO(int l) &#123; int ret = 0; int now = 0; char earliestVariant = -1; // 「最早不能循环的循环体」 int x = 0, y = 0; stack&lt;int&gt; stk; bool used[27] = &#123; false &#125;; bool ran[27] = &#123; false &#125;; for (int i = 1; i &lt;= l; ++i) &#123; if (Code[i][0] == 'F') &#123; char varName = Code[i][2]; if (used[varName - 'a']) return -1; stk.push(varName); used[varName - 'a'] = true; // Get X int X = 4; x = GetNumber(X, Code[i]); // Get Y y = GetNumber(X, Code[i]); if (y - x &gt; 1000) &#123; // y = n if (earliestVariant == -1) &#123; ++now; ret = std::max(ret, now); ran[varName - 'a'] = true; &#125; &#125; else if (x &gt; y) &#123; if (earliestVariant == -1) earliestVariant = varName; &#125; &#125; else &#123; if (stk.empty()) return -1; char nowVarName = stk.top(); stk.pop(); used[nowVarName - 'a'] = false; if (earliestVariant == nowVarName) earliestVariant = -1; if (ran[nowVarName - 'a']) &#123; ran[nowVarName - 'a'] = false; --now; &#125; &#125; &#125; if (!stk.empty()) return -1; return ret;&#125;int main() &#123; scanf("%d", &amp;t); while (t --&gt; 0) &#123; int w, nw, l; scanf("%d ", &amp;l); string o; getline(cin, o); nw = getO(o); for (int i = 1; i &lt;= l; ++i) &#123; getline(cin, Code[i]); &#125; w = GetO(l); if (w == -1) puts("ERR"); else &#123; if (w == nw) puts("Yes"); else puts("No"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>NOIP</tag>
        <tag>毒瘤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1525《关押罪犯》]]></title>
    <url>%2F2018-10-20%2FLuogu-P1525%2F</url>
    <content type="text"><![CDATA[敌人的敌人就是朋友！ 题目地址 题目描述S城现有两座监狱，一共关押着 N 名罪犯，编号分别为 1−N 。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 c 的冲突事件。 每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。 在详细考察了 N 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。 那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？ Input / Output 格式 &amp; 样例输入格式每行中两个数之间用一个空格隔开。第一行为两个正整数N,M，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的M行每行为三个正整数$a_j,b_j,c_j$，表示$a_j$号和$b_j$号罪犯之间存在仇恨，其怨气值为$c_j$。数据保证$1&lt;aj≤bj≤N,0 &lt; cj≤ 1,000,000,000$，且每对罪犯组合只出现一次。 输出格式共 1 行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 0。 输入样例12345674 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884 输出样例13512 解题思路显然这是一个并查集 首先我们把输入记录下来，按照权值从大到小排个序 然后对于每一条关系，如果它们的祖先相同，就说明发生了冲突，此时直接输出 + return 0就好 否则就进行合并 如何合并？ 根据“敌人的敌人就是朋友”的原则，我们维护一个Enemy[i]表示i的的敌人 然后对于每一个人，更新它的敌人（如果它的敌人目前没被更新过）否则就合并另一个人和他的敌人 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 20000 + 10;const int MAXM = 100000 + 10;struct Relative &#123; int x, y, weight;&#125; rel[MAXM];int n, m, U[MAXM * 2], E[MAXN * 2];inline void Init() &#123; for (int i = 1; i &lt;= n; ++i) U[i] = i;&#125;int Find(int x) &#123; if (x == U[x]) return x; return U[x] = Find(U[x]);&#125;void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] = y;&#125;bool stlCmp(Relative x, Relative y) &#123; return x.weight &gt; y.weight;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; Init(); for (int i = 1; i &lt;= m; ++i) &#123; int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; rel[i].x = x; rel[i].y = y; rel[i].weight = w; &#125; sort(rel + 1, rel + 1 + m, stlCmp); for (int i = 1; i &lt;= m; ++i) &#123; int x = rel[i].x, y = rel[i].y; int fx = Find(x), fy = Find(y); if (fx == fy) &#123; printf("%d", rel[i].weight); return 0; &#125; if (E[x] == 0) E[x] = y; else Union(E[x], y); if (E[y] == 0) E[y] = x; else Union(E[y], x); &#125; printf("0"); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SP3377《A Bug's Life》]]></title>
    <url>%2F2018-10-20%2FSP3377%2F</url>
    <content type="text"><![CDATA[谁闲的没事研究同性恋。。。 题目地址 本文同步发布于：Handwer’s 洛谷博客 题目大意就是一个奇怪的ke学家，他专门研究虫子是否存在同性恋。。。 他为每一只虫子都标上了序号。 通过这个奇怪的ke学家的研究，找出了在这些虫子中的所有关系的虫子，题目询问在这么多有关系的虫子中是否存在“同性恋”。 输入格式 &amp; 样例第一行， 输入一个数，表示有t组数据对于每组数据，第一行输入n,m，表示有n只虫子，有m个关系接下来行每行两个数x,y，表示x,y有关系 1234567823 31 22 31 34 21 23 4 输出格式 &amp; 样例对于每一组数据： 先输出：”Scenario #i” ，表示第i组数据 然后如果有同性恋的输出”Suspicious bugs found!” 否则输出”No suspicious bugs found!” 1234Scenario #1:Suspicious bugs found!Scenario #2:No suspicious bugs found! 解题思路显然这是一个并查集，但并不是一个裸的并查集 我们要多维护一个数组rel[]，其中rel[i]表示i和它的祖先的关系（relative）。我们定义rel[i]表示两种性别，当根节点相同且rel[]相同时，它们就是同性恋 rel[]的更新方式： 12(in Find(x))rel[x] = (rel[x] + rel[U[x]]) % 2; 1234(in Union(x, y))int fx = Find(x), fy = Find(y);...rel[fx] = (rel[x] + rel[y] + 1) % 2; rel[]的判断方式：12345(in Union(x, y))if (fx == fy) &#123; if (rel[x] == rel[y]) suspiciousFound = true; return;&#125; 剩下的照常写就行 注意路径压缩要分开写，先创建一个变量存它的祖先节点再更新 按秩合并没写过不知道 代码实现你们最喜欢的代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXM = 1000000 + 10;int n, m;int U[MAXM], rel[MAXM];bool flag;int Find(int x) &#123; if (x != U[x]) &#123; // 把路径压缩撑开写 int fux = Find(U[x]); rel[x] = (rel[x] + rel[U[x]]) % 2; // 更新rel数组 // 1 1 -&gt; 0 // 1 0 / 0 1 -&gt; 1 // 0 0 -&gt; 0 // 其实是一个异或的过程 U[x] = fux； // qwq &#125; return U[x];&#125;void Union(int x, int y) &#123; int fx = Find(x), fy = Find(y); if (fx == fy) &#123; if (rel[x] == rel[y]) flag = true; // 判断是否同性 return; &#125; U[fx] = fy; rel[fx] = (rel[x] + rel[y] + 1) % 2; // 更新rel数组&#125;int main(int argc, char *const argv[]) &#123; int t; scanf("%d", &amp;t); int _t = 0; while (t --&gt; 0) &#123; memset(U, 0, sizeof(U)); memset(rel, 0, sizeof(rel)); n = 0, m = 0, flag = false; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) U[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); Union(x, y); &#125; printf("Scenario #%d:\n", ++_t); if (flag) printf("Suspicious bugs found!\n"); else printf("No suspicious bugs found!\n"); &#125; return 3; // qwq&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2866《[USACO06NOV]糟糕的一天Bad Hair Day》]]></title>
    <url>%2F2018-10-06%2FLuogu-P2866%2F</url>
    <content type="text"><![CDATA[有点难想的单调栈模板题 题目地址 暂不提供题面，请自行到洛谷查看题面。 Input / Output 格式 &amp; 样例输入格式第一行：一个数N表示奶牛的数量。 第2到N+1行：第i+1行包含一个整数表示第i头奶牛的高。 输出格式第一行：一个整数，即c1到cN的和 输入样例1234567610374122 输出样例15 解题思路这就是一个单调栈的模板 循环读入，每次push读入的数进一个单调栈并维护这个栈的单调性，最后答案累加栈的大小-1即可（显然题意说明奶牛是看不见自己的发型的，要把自己减去） 以上操作的推导过程： 我们对于当前读进去的奶牛的高度，计算栈中还有多少比它矮的，把它们pop出来（维护单调性） 这个过程其实就是在计算当前的奶牛能被多少奶牛看见 接下来累计答案 最后将当前奶牛的高度push进去 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 80000 + 10; struct Stack &#123; int seq[MAXN]; int tail; Stack() &#123; memset(seq, 0, sizeof(seq)); tail = 0; &#125; void Pop() &#123; tail--; &#125; int Top() &#123; return seq[tail]; &#125; bool isEmpty() &#123; return tail == 0; &#125; void Push(int x) &#123; while (!isEmpty() &amp;&amp; Top() &lt;= x) Pop(); seq[++tail] = x; &#125; int Size() &#123; return tail; &#125; int __tail_location() &#123; return tail; &#125; &#125; stk; // 手写栈无所畏惧 int n;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); long long int ans = 0; For (i, 1, n) &#123; int x = getint(); stk.Push(x); ans += stk.Size() - 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>USACO</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1981《表达式求值》]]></title>
    <url>%2F2018-10-06%2FLuogu-P1981%2F</url>
    <content type="text"><![CDATA[新技能：手写计算器 题目描述给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。 Input / Output 格式 &amp; 样例输入格式一行，为需要你计算的表达式，表达式中只包含数字、加法运算符“$+$”和乘法运算符“ $\times$ ”，且没有括号，所有参与运算的数字均为 $0$ 到 $2^{31}$的整数。 输入数据保证这一行只有 $0−9$、$+$、 $\times$ 这 $12$ 种字符。 输出格式一个整数，表示这个表达式的值。 注意：当答案长度多于 4 位时，请只输出最后 4 位，前导 0 不输出。 输入样例Case #1:11+1*3+4 Case #2:11+1234567890*1 Case #3:11+1000000003*1 输出样例Case #1:18 Case #2:17891 Case #3:14 数据范围对于 30\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100； 对于 80\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤1000； 对于100\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100000。 解题思路我们开两个单调栈，一个栈num来存储数字，一个栈operators来存储符号 其中operators的操作逻辑是这样的： 首先把~push进去，作为一个占位符 我们对运算符标一个优先级，规定~ &lt; + &lt; *且相同运算符优先级低（满足从左到右的运算顺序），写一个判断函数 当push进去的运算符优先级比栈顶的低时，解决所有优先级低的运算符（维护单调性质）再push进去 当push进去的运算符优先级比栈顶的高时，不用管，直接push进去（满足单调性质） 处理完输入之后，我们再对数字栈里剩下的数字进行处理 最后输出即可 代码实现这里面所有的注释都是我在DEBUG的时候手推的样例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; stack&lt;int&gt; num; stack&lt;int&gt; operators; // 1: + - // 2: * / const int MOD = 10000; long long int ans = 0; bool Priority(char op1, char op2) &#123; // false -&gt; op1 is lower // true -&gt; op1 is higher if (op1 == op2) return false; if (op1 == '~') return false; if (op1 == '+' &amp;&amp; op2 == '*') return false; if (op1 == '*' &amp;&amp; op2 == '+') return true; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; // 1+1*3+4 int ans = 0, now = 0; char op = 0; cin &gt;&gt; ans; // 1 num.push(ans % MOD); // &lt; 1 operators.push('~'); // &lt; ~ while (cin &gt;&gt; op &gt;&gt; now) &#123; // +1 // *3 // +4 char op1 = operators.top(); // ~ // + // * while (Priority(op1, op)) &#123; // false // false // true // false int opNum = num.top(); // // // 3 num.pop(); // // // &lt; 1 1 int opNum2 = num.top(); // // // 1 num.pop(); // // // &lt; 1 if (op1 == '+') num.push((opNum + opNum2) % MOD); // // // false if (op1 == '*') num.push(opNum * opNum2 % MOD); // // // &lt; 1 3 operators.pop(); // &lt; + op1 = operators.top(); // + &#125; operators.push(op); // &lt; + // &lt; + * // &lt; + + num.push(now); // &lt; 1 1 // &lt; 1 1 3 // &lt; 1 3 4 &#125; while (num.size() &gt; 1) &#123; // true // true // false int op = num.top(); // 4 // 7 num.pop(); // &lt; 1 3 // &lt; 1 int op2 = num.top(); // 3 // 1 num.pop(); // &lt; 1 // &lt; char ope = operators.top(); operators.pop(); if (ope == '+') num.push((op + op2) % MOD); // &lt; 1 7 // &lt; 8 if (ope == '*') num.push(op * op2 % MOD); &#125; FastIO::putint(num.top() % MOD, '\n'); // 8 return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>栈</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1750《出栈序列》]]></title>
    <url>%2F2018-10-06%2FLuogu-P1750%2F</url>
    <content type="text"><![CDATA[这题和栈有多少关系 题目描述给定一个由n个元素构成的序列，你需要将其中的元素按顺序压入一个大小为c的栈并弹出。元素按它们的出栈顺序进行排列，会得到一个新的序列。我们知道，这样的序列会有很多种，请输出所有新序列中第一个元素最小的序列（若第一个元素最小的序列有多个，则令第二个尽可能小；若仍有多个，则令第三个最小，以此类推）。 Input / Output 格式 &amp; 样例输入格式第一行，两个数n,c 第二行n个数，为序列中n个元素的值 输出格式输出n个数，为满足要求的序列。 输入样例126 35 2 3 8 7 4 输出样例12 3 5 4 7 8 数据范围对于40%的数据，n&lt;=12 对于100%的数据，c&lt;=n&lt;=10000，元素大小均在2*10^9以内。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 10000 + 10; struct Stack &#123; private: int __builtin_sequence[MAXN]; int tail; public: Stack() &#123; memset(__builtin_sequence, 0, sizeof(__builtin_sequence)); tail = 0; &#125; void push(int x) &#123; __builtin_sequence[++tail] = x; &#125; void pop() &#123; --tail; &#125; int top() &#123; return __builtin_sequence[tail]; &#125; bool empty() &#123; return tail == 0; &#125; int size() &#123; return tail; &#125; &#125; stk; int n, c; int seq[MAXN];&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); c = getint(); int used = 0; int unusedNum = 1; For (i, 1, n) &#123; seq[i] = getint(); &#125; while (stk.size() + used &lt; n) &#123; int inQueue = stk.size(); int origUnusedNum = unusedNum; int minN = 2147482333; int len = c - inQueue; for (int i = origUnusedNum; i &lt;= n &amp;&amp; i &lt; origUnusedNum + len; ++i) &#123; if (seq[i] &lt; minN) &#123; unusedNum = i; minN = seq[i]; &#125; &#125; if (stk.empty() || minN &lt; stk.top()) &#123; For (i, origUnusedNum, unusedNum) &#123; stk.push(seq[i]); &#125; ++unusedNum; &#125; else unusedNum = origUnusedNum; putint(stk.top(), ' '); ++used; stk.pop(); &#125; while (!stk.empty()) &#123; putint(stk.top(), ' '); stk.pop(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day5 题解]]></title>
    <url>%2F2018-10-05%2F2018AutumnQBXTDay5%2F</url>
    <content type="text"><![CDATA[暴力分！暴力分！ Problem A. climb题目描述Bob 在一旁看 Alice 爬台阶玩， Alice 突发奇想让 Bob 闭上眼记录他爬了多少台阶，规则是这样的： Alice每次会想好爬多少级台阶，每爬一级都会数数，爬完之后走回到最底层，注意走回去的那些台阶是不算级数的。 Bob 闭上眼通过 Alice 的报数来统计 Alice 总共爬了几次，每次爬了多少级。 输入格式第一行包含一个整数 N(1 ≤ 100000)，表示 Alice 的报数次数。 第二行包含 N 个正整数 Ai(1 ≤ Ai ≤ 1000)，表示 Alice 的报数序列。 输出格式第一行包含一个整数，表示 Alice 爬的次数 T。第二行包含 T 个整数，第 i 个整数表示 Alice 每 i 次爬的台阶数。 输入样例1271 2 3 1 2 3 4 输出样例1223 4 子任务对于 40% 的数据， N ≤ 20。 对于 70% 的数据， N ≤ 1000。 对于 100% 的数据， N ≤ 100000。 解题思路A不掉的退役吧 显然这题就是让你求有多少个1和每两个1之间的距离 当然这题题面有点歧义 求每个1之前的数也可以（数据水 就没了 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; int n; int seq[MAXN]; int T; vector&lt;int&gt; cnt; void Work() &#123; For (i, 1, n) &#123; if (seq[i] == 1) ++T, cnt.push_back(seq[i-1]); &#125; cnt.push_back(seq[n]); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("climb.in", "r", stdin); freopen("climb.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); For (i, 1, n) seq[i] = getint(); Work(); putint(T, '\n'); int siz = cnt.size(); Forw (i, 1, siz - 1) putint(cnt[i], ' '); putint(cnt[siz - 1], '\n'); return 0;&#125; Problem B. remove题目描述给出一个字符串 s，字符串中只会包含⼩写字母 a − z。现在需要通过重复下面这个算法符串中删去 k 个字符：• 如果当前字符串中还存在字符 a，就删去字符串中最前面的一个 a 字符，结束算法• 如果当前字符串中还存在字符 b，就删去字符串中最前面的一个 b 字符，结束算法• …• 如果当前字符串中还存在字符 z，就删去字符串中最前面的一个 z 字符，结束算法求删完 k 个字符后的字符串。 输入格式第一行包含两个整数 n; k(1 ≤ k ≤ n ≤ 100000)， n 表示字符串长度， k 表示删去的字符个数。 第二行包含一个字符串 s。 输出格式一行，包含删去k个字符的字符串。 输入样例Case #1:1215 3cccaabababaccbc Case #2:1215 9cccaabababaccbc 输出样例Case #1:1cccbbabaccbc Case #2:1cccccc 子任务对于 40% 的数据， 1 ≤ k ≤ n ≤ 100。 对于 70% 的数据， 1 ≤ k ≤ n ≤ 1000。 对于 100% 的数据， 1 ≤ k ≤ n ≤ 100000。 解题思路这道题我在考试结束之后20min敲出了正解。。。。。。 我们开一个桶，把所有的字母记录下来 接着把桶扫一遍： 如果当前的k大于当前的字母数alphabet[i]，就让k -= alphabet[i]，然后把alphabet[i]置为0 否则让alphabet[i] -= k，然后把k置为0，最后break掉即可 此时，alphabet的意义已经从字母数量变成了经过删除后的还可输出字母数量 之后，我们开一个bool数组chk[i]表示str[i]是否还能被输出，并倒序（注意是倒序，因为题目要求从前面开始删，显然我们要保留后面几位）枚举 $i\ (0 &lt; i &lt; n)$ 当alphabet[str[i] - &#39;a&#39;] &gt; 0时，将chk[i]设为true并--alphabet[str[i] - &#39;a&#39;] 最后，从头扫一遍chk，如果chk[i] == true就输出str[i] 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; int n, k; string s; bool chk[MAXN]; string Work(string str) &#123; // 此为暴力做法 For (i, 1, k) &#123; Forw (j, 0, 26) &#123; cout &lt;&lt; str &lt;&lt; endl; int findnow = str.find(j + 'a'); // printf("%c\n", j + 'a'); if (findnow != string::npos) &#123; str[findnow] = '-'; break; &#125; &#125; &#125; return str; &#125; void nowWork(string str) &#123; // 此为正解 int alphabet[26 + 2] = &#123; 0 &#125;; bool printal[26] = &#123; true &#125;; Forw (i, 0, n) alphabet[str[i] - 'a']++; Forw (i, 0, 26) &#123; //cerr &lt;&lt; (char)(i + 'a')&lt;&lt; '='; //cerr &lt;&lt; alphabet[i] &lt;&lt; endl; if (alphabet[i] &lt; k) &#123; k -= alphabet[i]; alphabet[i] = 0; &#125; else &#123; alphabet[i] -= k; k = 0; break; &#125; &#125; Bak (i, n-1, 0) &#123; if (alphabet[str[i] - 'a'] == 0) continue; chk[i] = true; --alphabet[str[i] - 'a']; &#125; Forw (i, 0, n) if (chk[i]) putchar(str[i]); &#125; void Print(string str) &#123; // 此为暴力做法的输出 Forw (i, 0, n) if (str[i] != '-') putchar(str[i]); &#125;&#125; int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("remove.in", "r", stdin); freopen("remove.out", "w", stdout); #endif using namespace Solution; ios::sync_with_stdio(false);// int t = clock(); cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; s; //Print(Work(s)); nowWork(s); // cerr &lt;&lt; clock() - t &lt;&lt; endl; return 0;&#125; Problem C. cut题目描述给出一个字符串 s，其中每个字符都是 0 9 的数字。现在需要把字符串 s 分割开，这样每个部分就可以看做一个数，求这些数中最多有多少个数是 3 的倍数。 如对于字符串 3121，可以分割为 3 | 12 | 1，这样会有两个数是 3 的倍数，如果分割为 31 | 2 | 1，这样就没有数是 3 的倍数了。0 是 3 的倍数，如果 1200045 被拆分为 120 | 0045，则认为分割出来的两个数是 120 和 45，即忽略前导零。 输入格式一行包含一个字符串s，$|s|\le100000$ 输出格式一行包含一个整数，表示最多有多少个数是3的倍数。 输入样例Case #1:13121 Case #2:1201920181 输出样例Case #1：12 Case #2:14 样例解释第一个样例中可以拆分为 3 | 12 | 1。 第二个样例中可以拆分为 201 | 9 | 2 | 0 | 18 | 1。 解题思路首先我们对读进来的序列整体mod 3 接着对这个序列扫一遍 如果当前读到的数是0，根据贪心策略，直接在后面划上一道 否则如果当前读的数的下标大于0，就看前面的数如果这个数与上个数的和能被3整除，而且下个数没有被选过，就在后面划上一道 否则如果当前读的数的下标大于1，继续看前面的数如果这个数与前面两个数的和能被3整除，而且两个数都没有选过，就在后面划上一道 否则什么都不干 最后输出即可 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; bool vis[MAXN]; int seq[MAXN]; int len; int Work() &#123; int ret = 0; For (i, 1, len) &#123; if (seq[i] == 0) &#123; ++ret; vis[i] = true; &#125; else if (i &gt; 0 &amp;&amp; (seq[i] + seq[i - 1]) % 3 == 0 &amp;&amp; !vis[i - 1]) &#123; ++ret; vis[i] = true; &#125; else if (i &gt; 1 &amp;&amp; (seq[i] + seq[i - 1] + seq[i - 2]) % 3 == 0 &amp;&amp; !vis[i - 1] &amp;&amp; !vis[i - 2]) &#123; ++ret; vis[i] = true; &#125; &#125; return ret; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; string s; cin &gt;&gt; s; len = s.length(); For (i, 1, len) seq[i] = (s[i-1] - '0') % 3; int ans = Work(); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Problem D. sum题目描述某些数有奇怪的性质：它十进制下的各位数的平方和的 T 倍等于它本身。求在 [A, B] 范围内的数有多少满足这个性质 输入格式第一行包含三个整数 T, A, B(1 ≤ T; A; B ≤ 10^18; A ≤ B)。 输出格式一个整数，表示满足条件的数量。 输入样例151 5000 10000 输出样例13 子任务对于 40% 的数据， 1 ≤ T; A; B ≤ 100000; A ≤ B。对于 100% 的数据， 1 ≤ T; A; B ≤ 10^18; A ≤ B。 代码实现此为标程12345678long long calc(long long x) &#123; long long ans = 0; while (x) &#123; ans += (x % 10) * (x % 10); x /= 10; &#125; return ans;&#125; 1234567891011long long k, a, b, ans = 0; scanf("%lld%lld%lld", &amp;k, &amp;a, &amp;b); for(int i = 1; i &lt;= 1600; i++) &#123; if (a &lt;= k * i &amp;&amp; i &lt;= b / k) if (calc(k * i) == i) &#123; printf("%lld\n", k * i); ans++; &#125; &#125; printf("%lld\n", ans); return 0;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>清北学堂</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的代码默认模板]]></title>
    <url>%2F2018-10-04%2FMyTemplate%2F</url>
    <content type="text"><![CDATA[运行效率++; &nbsp; 可读性--; 下面是我在写程序时常用的快读/写模板（虽然它不仅仅只是快读/写）不仅提高了运行效率，还让编写时的体验更加舒适。 假如布局安排合理的话，可读性不但不会减少，反而会进一步上升。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>毒瘤</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1886《滑动窗口》]]></title>
    <url>%2F2018-10-04%2FLuogu-P1886%2F</url>
    <content type="text"><![CDATA[单调队列的应用 题目描述现在有一堆数字共N个数字（N&lt;=10^6），以及一个大小为k的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。 例如： The array is [1 3 -1 -3 5 3 6 7], and k = 3. 图片来自洛谷 Input / Output 格式 &amp; 样例输入格式输入一共有两行，第一行为n,k。 第二行为n个数($n&lt;2^{31}-1$). 输出格式输出共两行，第一行为每次窗口滑动的最小值 第二行为每次窗口滑动的最大值 输入样例128 31 3 -1 -3 5 3 6 7 输出样例12-1 -3 -3 -3 3 33 3 5 5 6 7 数据范围50%的数据，n&lt;=10^5 100%的数据，n&lt;=10^6 解题思路最经典的单调队列题目 暴力妥妥的T，不用多说（不过居然有70pts） 我们先研究最大值怎么求 每次往单调队列里面扔一个数，显然不管队列里发生了什么改变，单调性并不变。我们开一个id数组，记录当前的数被push进去的时间 接着扫描id数组，将所有过期的数全都pop出去 最后当循环了至少k次时，输出答案。 最小值同理，把单调队列改一下即可。 （《单调队列学习笔记》将不久后更新） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 1000000 + 10; struct Queue &#123; int q[MAXN]; int head, tail; Queue() &#123; memset(q, 0, sizeof(q)); head = 1; tail = 0; &#125; void push(int s) &#123; // 维护单调递增的队列 while (s &gt;= q[tail] &amp;&amp; head &lt;= tail) --tail; q[++tail] = s; &#125; void push_back(int s) &#123; // 维护单调递减的序列 while (s &lt;= q[tail] &amp;&amp; head &lt;= tail) --tail; q[++tail] = s; &#125; void pop() &#123; ++head; &#125; int front() &#123; return q[head]; &#125; int size() &#123; return tail - head + 1; &#125; bool empty() &#123; return tail - head + 1; &#125; void clear() &#123; Queue(); &#125; int __tail_location() &#123; return tail; &#125; int __head_location() &#123; return head; &#125; &#125; q1, q2; int n, k; int seq[MAXN]; int id[MAXN]; void GetMax() &#123; For (i, 1, n) &#123; q1.push(seq[i]); id[q1.__tail_location()] = i; while (id[q1.__head_location()] &lt;= i - k) q1.pop(); // 清理过期的数 if (i &gt;= k) FastIO::putint(q1.front(), ' '); // 输出 &#125; &#125; void GetMin() &#123; For (i, 1, n) &#123; q2.push_back(seq[i]); id[q2.__tail_location()] = i; while (id[q2.__head_location()] &lt;= i - k) q2.pop(); if (i &gt;= k) FastIO::putint(q2.front(), ' '); &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); k = getint(); For (i, 1, n) &#123; seq[i] = getint(); &#125; GetMin(); puts(""); GetMax(); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day4 题解]]></title>
    <url>%2F2018-10-04%2F2018AutumnQBXTDay4%2F</url>
    <content type="text"><![CDATA[没人AC的题目和没人得分的题目 T1. 牛奶没AC的退役吧 问题描述为了增加营养，你决定每天喝牛奶，牛奶的营养含量十分固定，下表示牛奶上写的营养成分表。 项目 每100mL 能量 284kJ 蛋白质 3.2g 脂肪 4.0g 碳水化合物 4.8g 钠 62mg 钙 100mg 这天你喝了N mL的牛奶，那么你摄入的营养成分分别为多少呢？ 输入格式一个整数N 输出格式6个用空格隔开的数字，分别表示6项营养成分的数值，单位和表上单位相同，四舍五入保留一位小数。 输入样例1100 输出样例1284.0 3.2 4.0 4.8 62.0 100.0 数据范围对于30%的数据，N是100的倍数。 对于50%的数据，N&lt;=1000。 对于100%的数据，1&lt;=N&lt;=10000。 解题思路没什么好说的，浮点数运算而已 这题唯一也是最毒瘤的的坑点就是浮点数运算 代码实现毒瘤代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace Solution &#123; const double energy100 = (double) 284; // kJ const double protein100 = (double) 3.2; // g const double fats100 = (double) 4.0; // g const double carbohydrate100 = (double) 4.8; // g const double sodium100 = (double) 62; // mg const double calcium100 = (double) 100; // mg&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("milk.in", "r", stdin); freopen("milk.out", "w", stdout); #endif using namespace Solution; double n = 1.0; scanf("%lf", &amp;n); n *= 1.0; double anse = (double) n * (double) energy100 * 1.0; double ansp = (double) n * (double) protein100 * 1.0; double ansf = (double) n * (double) fats100 * 1.0; double ansc = (double) n * (double) carbohydrate100 * 1.0; double anss = (double) n * (double) sodium100 * 1.0; double ansl = (double) n * (double) calcium100 * 1.0; printf("%0.1lf %0.1lf %0.1lf %0.1lf %0.1lf %0.1lf\n", anse / 100.0, ansp / 100.0, ansf / 100.0, ansc / 100.0, anss / 100.0, ansl / 100.0 ); return 0;&#125; T2. 上课问题描述这天，学校正上着课，学校有n个教室，每个教室坐着$a_i$个人正在上课。 突然来了m个人也要上课，每个人都可以选择n个教室中的任意一个教室上课，由于学校需要提供教室的座位，学校想知道这m个人来之后，最多人的那个教室人数的最小值和最大值分别为多少。 输入格式第一行两个数n和m，用空格隔开。 第二行n个数字用空格隔开，表示$a_i$。 输出格式两个用空格隔开的数字，分别表示最小值和最大值 输入样例124 61 1 1 1 输出样例13 7 数据范围对于30%的数据，n=1。 对于50%的数据，m&lt;=10000。 对于100%的数据，1&lt;=n,ai&lt;=100,1&lt;=m&lt;=10^9。 解题思路我们随便想一想就能想出贪心策略 首先最大值是人最多的班级的人数+m 这没什么好说的 最小值也很好求 既然是最小值，那么就要保证m的平均分配 那么我们排个序，从最小的数字依次$O(n)$扫 对于每个数字$a_i$，计算它和最大值的差，记为$d$ 当$d\ge m$时，直接输出$d$（因为将$m$全部安排到这个班里去也不能让这个班的人数比最大值大，所以答案即是最大值）否则让$m$减去$d$，将$a_i$赋值为最大值（把这个班的人数变成最大值） 扫完一遍之后，如果$m$变成0了，就直接输出最大值（m个人被正好安排完了）否则就再把剩下的人一个一个地分别安排到每个班中（可能有一个班分配多人的情况），最后取个max值即可 这里有个小技巧，就是我们把m整除n的结果记为place，然后把整个序列都加上place，表示每个班都还要分配place个人 再把m模n的结果记为 lm，循环把这最后lm个人分别分配到每个班中，最后取max即可 讲起来还是挺麻烦的 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100; int n, m; int seq[MAXN]; bool stlCmp(int x, int y) &#123; return x &gt; y; &#125; void PrintAnswer(int maxAns, int minAns) &#123; FastIO::putint(minAns, ' '); FastIO::putint(maxAns, '\n'); &#125; &#125;int main(int argc, char *const argv[]) &#123; // Wrong Algorithm #ifndef HANDWER_FILE freopen("class.in", "r", stdin); freopen("class.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(), m = getint(); int maxSiz = -233333; For (i, 1, n) &#123; seq[i] = getint(); maxSiz = std::max(seq[i], maxSiz); &#125; sort(seq + 1, seq + 1 + n); int maxAns = m + seq[n]; For (i, 1, n) &#123; int differ = maxSiz - seq[i]; if (differ &gt;= m) &#123; PrintAnswer(maxAns, maxSiz); return 0; &#125; seq[i] = maxSiz; m -= differ; &#125; if (m == 0) &#123; PrintAnswer(maxAns, maxSiz); return 0; &#125; /*/ sort(seq + 1, seq + 1 + n, stlCmp); long long int maxAns = m + seq[n]; long long int minAns = 0; /*/ /*/ int j = n; For (i, 1, m) &#123; ++seq[j--]; if (j == 0) j = n; &#125; /*/ int place = m / n; For (i, 1, n) seq[i] += place; int mod = m % n; int i = n; while (mod --&gt; 0) &#123; ++seq[i--]; &#125; int minAns = *(max_element(seq + 1, seq + 1 + n)); PrintAnswer(maxAns, minAns); return 0;&#125; T3. 维生素问题描述商店里卖着n种果汁，每种果汁都有它的价格ci，每种果汁有一些维生素，维生素有三种类型，维生素A，维生素B，维生素C，每种果汁可以含有其中一种或多种维生素。 你需要3种维生素来保持身体健康，那么你最少需要购买多少价格的果汁才能保证购买的这些果汁包含3种维生素呢？ 输入格式第一行包含一个整数n。 接下来n行，每行包含一个整数ci和一个字符串si，si表示其中蕴含的维生素种类，只包含字母ABC且每个字母最多出现一次。 输出格式输出最小能满足条件的价格，如果不能满足，输出-1。 输入样例1234545 C6 B16 BAC4 A 输出样例115 数据范围对于30%的数据，1&lt;=n&lt;=20。 对于另外20%的数据，所有果汁只包含单种维生素。 对于100%的数据，1&lt;=n&lt;=1000, 1&lt;=ci&lt;=100000。 解题思路DP 我们设$f_{i,j}$表示前i种果汁状态为j时的价格，其中 $j$的值 代表意思 1 含有维生素A 2 含有维生素B 3 含有维生素C 4 含有维生素AB 5 含有维生素BC 6 含有维生素AC 7 含有维生素ABC 转移方程： a[i|w] = min(a[i|w], a[i] + c[i]) w = w | (1 左移 (str[i] - &#39;A&#39;))，其中1 ≤ i ≤ str.length() 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif int n; cin &gt;&gt; n; int t[8 + 2]; for (int i = 0; i &lt;= 8; ++i) t[i] = 60; t[0] = 0; string s; for (int i = 1; i &lt;= n; ++i) &#123; int x; cin &gt;&gt; x; cin &gt;&gt; s; int len = s.length(); int v = 0; for (int j = 1; j &lt;= len; ++j) v |= (1 &lt;&lt; s[j-1] - 'A'); for (int j = 0; j &lt; 8; ++j) t[j | v] = std::min(t[j | v], t[j] + x); &#125; if (t[7] &gt; 1e8) puts("-1"); else cout &lt;&lt; t[7] &lt;&lt; endl; return 0;&#125; T4. 队列挖坑待填]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>清北学堂</tag>
        <tag>贪心</tag>
        <tag>浮点数运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3110 《[USACO14DEC]驮运Piggy Back》]]></title>
    <url>%2F2018-10-04%2FLuogu-P3110%2F</url>
    <content type="text"><![CDATA[披着蓝题的皮跑3遍SPFA的绿题 题目链接 题面由于翻译缺失，暂不提供翻译，这里仅提供英文题面。 题目描述Bessie and her sister Elsie graze in different fields during the day, and in the evening they both want to walk back to the barn to rest. Being clever bovines, they come up with a plan to minimize the total amount of energy they both spend while walking. Bessie spends B units of energy when walking from a field to an adjacent field, and Elsie spends E units of energy when she walks to an adjacent field. However, if Bessie and Elsie are together in the same field, Bessie can carry Elsie on her shoulders and both can move to an adjacent field while spending only P units of energy (where P might be considerably less than B+E, the amount Bessie and Elsie would have spent individually walking to the adjacent field). If P is very small, the most energy-efficient solution may involve Bessie and Elsie traveling to a common meeting field, then traveling together piggyback for the rest of the journey to the barn. Of course, if P is large, it may still make the most sense for Bessie and Elsie to travel separately. On a side note, Bessie and Elsie are both unhappy with the term “piggyback”, as they don’t see why the pigs on the farm should deserve all the credit for this remarkable form of transportation. Given B, E, and P, as well as the layout of the farm, please compute the minimum amount of energy required for Bessie and Elsie to reach the barn. 输入输出格式INPUT: (file piggyback.in) The first line of input contains the positive integers B, E, P, N, and M. All of these are at most 40,000. B, E, and P are described above. N is the number of fields in the farm (numbered 1..N, where N &gt;= 3), and M is the number of connections between fields. Bessie and Elsie start in fields 1 and 2, respectively. The barn resides in field N. The next M lines in the input each describe a connection between a pair of different fields, specified by the integer indices of the two fields. Connections are bi-directional. It is always possible to travel from field 1 to field N, and field 2 to field N, along a series of such connections. OUTPUT: (file piggyback.out) A single integer specifying the minimum amount of energy Bessie and Elsie collectively need to spend to reach the barn. In the example shown here, Bessie travels from 1 to 4 and Elsie travels from 2 to 3 to 4. Then, they travel together from 4 to 7 to 8. 输入样例1234567894 4 5 8 8 1 4 2 3 3 4 4 7 2 5 5 6 6 8 7 8 输出样例122 解题思路为什么这是蓝题&nbsp;这应该是绿题啊 首先肯定是跑最短路 两只牛有这样两种选择： 各自走回家 走到任意一点之后 Bessie 背着 Elsie 回家 那么我们就跑3遍SPFA即可 以 Bessie 为起点（即1点） 以 Elsie 为起点（即2点） 以家为起点（即n点） 这里有个小技巧，不需要写3遍不同的SPFA，只需要把3个dis数组当做参数传进去即可 最后暴力枚举图中的所有点$i$ 如果设$(u,v)$为$u\rightarrow v$的最短路长度的话， 答案就是最小的$ (1,i)+(2,i)+(n,i)$ 注意判断点不连通（距离为INF）的情况 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 4000000 + 10; const int MAXM = 4000000 + 10; const int INF = 0x3f3f3f3f; int b, e, p, n, m; int head[MAXN], disB[MAXN], disE[MAXN], disN[MAXN]; bool inQueue[MAXN]; int cnt; struct Edge &#123; int prev, next, weight; &#125; edge[MAXM]; inline void addEdge(int prev, int next) &#123; edge[++cnt].prev = prev; edge[cnt].next = head[next]; head[next] = cnt; edge[cnt].weight = 1; &#125; void SPFA(int dis[], int s) &#123; //memset(dis, 0, sizeof(dis)); For (i, 0, n) dis[i] = INF; dis[s] = 0; queue&lt;int&gt; q; q.push(s); inQueue[s] = true; while (!q.empty()) &#123; int prev = q.front(); q.pop(); inQueue[prev] = false; for (int e = head[prev]; e; e = edge[e].next) &#123; if (dis[edge[e].prev] &gt; dis[prev] + edge[e].weight) &#123; dis[edge[e].prev] = dis[prev] + edge[e].weight; if (!inQueue[edge[e].prev]) &#123; q.push(edge[e].prev); inQueue[edge[e].prev] = true; &#125; &#125; &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; b = getint(); e = getint(); p = getint(); n = getint(); m = getint(); For (i, 1, m) &#123; int prev, next; prev = getint(); next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; SPFA(disB, 1); SPFA(disE, 2); SPFA(disN, n); int ans = 2147482333; For (i, 1, n) &#123; if (disN[1] == INF || disN[2] == INF || disB[i] == INF || disE[i] == INF || disN[i] == INF ) continue; ans = std::min(ans, b * disB[i] + e * disE[i] + p * disN[i]); &#125; putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>USACO</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day3 题解]]></title>
    <url>%2F2018-10-03%2F2018AutumnQBXTDay3%2F</url>
    <content type="text"><![CDATA[不同寻常的题面 T1. H因子问题描述h因子是一种评价学术成就的新方法。一名科研人员的h因子是指他至少有h篇论文分别被引用了不少于h次。Alice已经发表了很多论文了，现给出一个序列a0，a1，a2，…，an，其中 $a_i$ 表示有 $a_i$ 篇文章分别被引用了i次。 请你求出Alice的h因子。 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含一个正整数n（1≤n≤200,000） 。 每组数据的第二行包含n个正整数a0，a1，a2，……，an（1≤ai≤1000,000,000），表示序列中的每个数。 输出格式对于每组数据，输出一行，包含一个整数，表示该组数据的h因子 。 样例输入1234567311 221 2 330 0 0 0 样例输出123120 解题思路首先要把题看懂！！！ 首先要把题看懂！！！ 首先要把题看懂！！！ （我就因为题意理解错误而完美爆零） 我们从n开始，从大到小枚举h因子 一个有效的h因子为i当且仅当有大于等于i篇文章被引用了大于等于i次 所以我们可以用一个sum来存当前有多少篇文章被引用了大于等于当前i次 第一个满足sum &gt;= i的i即为最大的h因子 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start */const int MAXN = 200000 + 10;/* Constants End *//* Variants Start */int seq[MAXN];/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace FastIO; int t = getint(); while (t --&gt; 0) &#123; int n = getint(); for (int i = 0; i &lt;= n; ++i) &#123; seq[i] = getint(); &#125; int sum = 0; for (int i = n; i &gt;= 0; --i) &#123; sum += seq[i]; if (sum &gt;= i) &#123; putint(i, '\n'); break; &#125; &#125; &#125; return 0;&#125; T2. 超回文字符串问题描述给出一个只由小写字母的字符串，要求在最少的操作数下将它转成一个超回文字符串。每次操作仅可以改变字符串中的一个字符。 一个字符串被称为超回文字符串，当且仅当它的所有奇数长度的子串都是回文串（回文串是指一个字符串从前往后与从后往前读是一样的）。 输入格式第一行包含一个正整数T（1≤T≤100），表示有多少组数据。 对于每组数据，只有单独一行，包含一个仅由小写字母组成的字符串。保证字符串的长度不超过100。 输出格式对于每组数据，输出一行，包含一个整数，表示最少的操作数。 样例输入12343ncncnaaaabaaaaabb 样例输出123012 解题思路简单分析之后，我们发现满足题目要求的字符串存在当且仅当这个字符串的奇数位、偶数位分别相同 那么直接暴力就好 我们枚举每一个奇数位上的字母，计算有多少个奇数位上的字母与它不同（即要修改多少次） 取个min即为答案 偶数位同理 将两个min相加即为答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif int t; cin &gt;&gt; t; string s; while (t --&gt; 0) &#123; cin &gt;&gt; s; int len = s.length(); int min1 = len, min2 = len; for (int i = 0; i &lt; len; i += 2) &#123; int now = 0; for (int j = 0; j &lt; len; j += 2) &#123; if (s[i] != s[j]) ++now; &#125; min1 = std::min(min1, now); &#125; if (len == 1) min2 = 0; for (int i = 1; i &lt; len; i += 2) &#123; int now = 0; for (int j = 1; j &lt; len; j += 2) &#123; if (s[i] != s[j]) ++now; &#125; min2 = std::min(min2, now); &#125; cout &lt;&lt; min1 + min2 &lt;&lt; endl; &#125; return 0;&#125; T3. 移动桌子问题描述题面略（表格太多） 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含一个正整数n（1≤n≤200,000），表示要移动n张桌子 。 每组数据的接下来n行，每行包含2个正整数a和b，表示该张桌子原本在房间a，需要移动到房间b。 输出格式对于每组数据，输出一行，包含一个整数，表示移动完n张桌子所需要的最少时间 。 输入样例123456789101112133410 2030 4050 6070 8021 32 200310 10020 8030 50 输出样例123102030 解题思路我们对于每一个桌子的区间头和区间尾都加一再除以二（将房间化为走廊） 接着开一个长度为250的桶，把走廊长度累计到这个桶里面（暴力区间加1） 最后取最大值，乘以10（一次移动桌子10十分钟）就是最终答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start */int way[250 + 10];/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace FastIO; int t = getint(); while (t --&gt; 0) &#123; memset(way, 0, sizeof(way)); int n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; int s = getint(); int t = getint(); s = (s + 1) &gt;&gt; 1; t = (t + 1) &gt;&gt; 1; for (int j = s; j &lt;= t; ++j) ++way[j]; &#125; int ans = 0; for (int i = 1; i &lt;= 250; ++i) ans = std::max(ans, way[i]); putint(ans * 10, '\n'); &#125; return 0;&#125; T4. 口算问题描述Alice口算能力非常强。Bob为了考考Alice，给了她一个长度为n的正整数序列a1，a2，……，an，同时抛出了m个问题。 每个问题给出三个正整数。 Alice需要快速判断出$a_l\times a_{l+1}\times \dots \times a_{r-1} \times a_r $ 是不是d的倍数。 Alice凭借她强大的口算能力快速给出了答案。然而Bob很菜，他并不知道正确答案是什么。请写一个程序帮助Bob计算这些问题的答案。 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含两个正整数n，m（1≤n,m≤100,000），分别表示序列长度以及问题个数。 第二行包含n个正整数a1，a2，……，an（1≤ai≤100,000），表示序列中的每个数。 接下来的m行，每行包含3个正整数l,r,d（1≤l≤r≤n，1≤d≤100,000），表示每个问题。 输出格式对于每个问题，输出一行，若是倍数，输出Yes，否则输出No。 输入样例1234567815 56 4 7 2 51 2 241 3 182 5 173 5 351 3 21 输出样例12345YesNoNoYesYes 数据规模【数据规模】 对于30%数据，1≤T≤5，1≤n,m≤50，且保证对于每一个问题，$a_l\times a_{l+1}\times \dots \times a_{r-1} \times a_r $不超过long long的数据范围。 对于60%数据，1≤T≤10，1≤n,m≤1000，1≤ai≤1000 对于100%数据，1≤T≤10，1≤n,m≤100,000，1≤ai≤100,000 解题思路暴力做法30pts 的模拟 （伪）正解进行质因数分解，暴力判断 正解在（伪）正解的基础上进行优化 预处理：将所有的数进行质因数分解，按照顺序把所有质数的出现的下标push_back进每个质数专门的vector里 将读入的d进行质因数分解，同上push_back进一个专门的vector里 然后在给定的区间里进行寻找质因数（使用lower_bound和upper_bound） 如果该有的质因数都有，显然可以整除 否则不可以整除 代码实现不提供。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>清北学堂</tag>
        <tag>玄学题面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day3 题解]]></title>
    <url>%2F2018-10-03%2F2018AutumnQBXTDay3%20(1)%2F</url>
    <content type="text"><![CDATA[不同寻常的题面 T1. H因子问题描述h因子是一种评价学术成就的新方法。一名科研人员的h因子是指他至少有h篇论文分别被引用了不少于h次。Alice已经发表了很多论文了，现给出一个序列a0，a1，a2，…，an，其中 $a_i$ 表示有 $a_i$ 篇文章分别被引用了i次。 请你求出Alice的h因子。 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含一个正整数n（1≤n≤200,000） 。 每组数据的第二行包含n个正整数a0，a1，a2，……，an（1≤ai≤1000,000,000），表示序列中的每个数。 输出格式对于每组数据，输出一行，包含一个整数，表示该组数据的h因子 。 样例输入1234567311 221 2 330 0 0 0 样例输出123120 解题思路首先要把题看懂！！！ 首先要把题看懂！！！ 首先要把题看懂！！！ （我就因为题意理解错误而完美爆零） 我们从n开始，从大到小枚举h因子 一个有效的h因子为i当且仅当有大于等于i篇文章被引用了大于等于i次 所以我们可以用一个sum来存当前有多少篇文章被引用了大于等于当前i次 第一个满足sum &gt;= i的i即为最大的h因子 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start */const int MAXN = 200000 + 10;/* Constants End *//* Variants Start */int seq[MAXN];/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace FastIO; int t = getint(); while (t --&gt; 0) &#123; int n = getint(); for (int i = 0; i &lt;= n; ++i) &#123; seq[i] = getint(); &#125; int sum = 0; for (int i = n; i &gt;= 0; --i) &#123; sum += seq[i]; if (sum &gt;= i) &#123; putint(i, '\n'); break; &#125; &#125; &#125; return 0;&#125; T2. 超回文字符串问题描述给出一个只由小写字母的字符串，要求在最少的操作数下将它转成一个超回文字符串。每次操作仅可以改变字符串中的一个字符。 一个字符串被称为超回文字符串，当且仅当它的所有奇数长度的子串都是回文串（回文串是指一个字符串从前往后与从后往前读是一样的）。 输入格式第一行包含一个正整数T（1≤T≤100），表示有多少组数据。 对于每组数据，只有单独一行，包含一个仅由小写字母组成的字符串。保证字符串的长度不超过100。 输出格式对于每组数据，输出一行，包含一个整数，表示最少的操作数。 样例输入12343ncncnaaaabaaaaabb 样例输出123012 解题思路简单分析之后，我们发现满足题目要求的字符串存在当且仅当这个字符串的奇数位、偶数位分别相同 那么直接暴力就好 我们枚举每一个奇数位上的字母，计算有多少个奇数位上的字母与它不同（即要修改多少次） 取个min即为答案 偶数位同理 将两个min相加即为答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif int t; cin &gt;&gt; t; string s; while (t --&gt; 0) &#123; cin &gt;&gt; s; int len = s.length(); int min1 = len, min2 = len; for (int i = 0; i &lt; len; i += 2) &#123; int now = 0; for (int j = 0; j &lt; len; j += 2) &#123; if (s[i] != s[j]) ++now; &#125; min1 = std::min(min1, now); &#125; if (len == 1) min2 = 0; for (int i = 1; i &lt; len; i += 2) &#123; int now = 0; for (int j = 1; j &lt; len; j += 2) &#123; if (s[i] != s[j]) ++now; &#125; min2 = std::min(min2, now); &#125; cout &lt;&lt; min1 + min2 &lt;&lt; endl; &#125; return 0;&#125; T3. 移动桌子问题描述题面略（表格太多） 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含一个正整数n（1≤n≤200,000），表示要移动n张桌子 。 每组数据的接下来n行，每行包含2个正整数a和b，表示该张桌子原本在房间a，需要移动到房间b。 输出格式对于每组数据，输出一行，包含一个整数，表示移动完n张桌子所需要的最少时间 。 输入样例123456789101112133410 2030 4050 6070 8021 32 200310 10020 8030 50 输出样例123102030 解题思路我们对于每一个桌子的区间头和区间尾都加一再除以二（将房间化为走廊） 接着开一个长度为250的桶，把走廊长度累计到这个桶里面（暴力区间加1） 最后取最大值，乘以10（一次移动桌子10十分钟）就是最终答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start */int way[250 + 10];/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace FastIO; int t = getint(); while (t --&gt; 0) &#123; memset(way, 0, sizeof(way)); int n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; int s = getint(); int t = getint(); s = (s + 1) &gt;&gt; 1; t = (t + 1) &gt;&gt; 1; for (int j = s; j &lt;= t; ++j) ++way[j]; &#125; int ans = 0; for (int i = 1; i &lt;= 250; ++i) ans = std::max(ans, way[i]); putint(ans * 10, '\n'); &#125; return 0;&#125; T4. 口算问题描述Alice口算能力非常强。Bob为了考考Alice，给了她一个长度为n的正整数序列a1，a2，……，an，同时抛出了m个问题。 每个问题给出三个正整数。 Alice需要快速判断出$a_l\times a_{l+1}\times \dots \times a_{r-1} \times a_r $ 是不是d的倍数。 Alice凭借她强大的口算能力快速给出了答案。然而Bob很菜，他并不知道正确答案是什么。请写一个程序帮助Bob计算这些问题的答案。 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含两个正整数n，m（1≤n,m≤100,000），分别表示序列长度以及问题个数。 第二行包含n个正整数a1，a2，……，an（1≤ai≤100,000），表示序列中的每个数。 接下来的m行，每行包含3个正整数l,r,d（1≤l≤r≤n，1≤d≤100,000），表示每个问题。 输出格式对于每个问题，输出一行，若是倍数，输出Yes，否则输出No。 输入样例1234567815 56 4 7 2 51 2 241 3 182 5 173 5 351 3 21 输出样例12345YesNoNoYesYes 数据规模【数据规模】 对于30%数据，1≤T≤5，1≤n,m≤50，且保证对于每一个问题，$a_l\times a_{l+1}\times \dots \times a_{r-1} \times a_r $不超过long long的数据范围。 对于60%数据，1≤T≤10，1≤n,m≤1000，1≤ai≤1000 对于100%数据，1≤T≤10，1≤n,m≤100,000，1≤ai≤100,000 解题思路暴力做法30pts 的模拟 （伪）正解进行质因数分解，暴力判断 正解在（伪）正解的基础上进行优化 预处理：将所有的数进行质因数分解，按照顺序把所有质数的出现的下标push_back进每个质数专门的vector里 将读入的d进行质因数分解，同上push_back进一个专门的vector里 然后在给定的区间里进行寻找质因数（使用lower_bound和upper_bound） 如果该有的质因数都有，显然可以整除 否则不可以整除 代码实现不提供。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>清北学堂</tag>
        <tag>玄学题面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3956「NOIP2017普及组」《棋盘》]]></title>
    <url>%2F2018-10-02%2FNOIP2017-PJ-Chess%2F</url>
    <content type="text"><![CDATA[使用什么法？mo法？说清楚？！ 题目链接 题目描述有一个$m \times m$的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。 任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 1个金币。 另外， 你可以花费 2 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。 现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？ Input / Output 格式 &amp; 样例输入格式第一行包含两个正整数$m, n$，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。 接下来的$n$行，每行三个正整数$x, y, c$， 分别表示坐标为$(x,y)$的格子有颜色$c$。 其中$c=1$ 代表黄色，$c=0$ 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为$(1, 1)$，右下角的坐标为$( m, m)$。 棋盘上其余的格子都是无色。保证棋盘的左上角，也就是 $(1,1)$ 一定是有颜色的。 输出格式一个整数，表示花费的金币的最小值，如果无法到达，输出-1。 输入样例Case #1: 123456785 71 1 01 2 02 2 13 3 13 4 04 4 15 5 0 Case #2: 1234565 51 1 01 2 02 2 13 3 15 5 0 输出样例Case #1: 18 Case #2: 1-1 样例解释 &amp; 其他说明对于 $30\%$的数据, $1 ≤ m ≤ 5, 1 ≤ n ≤ 10$ 对于 $60\%$数据, $1 ≤ m ≤ 20, 1 ≤ n ≤ 200$ 对于 $100\%$的数据, $1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$ 解题思路我们并不需要维护某一个点是否走过 我们需要判断边界、白格子、最优性剪枝和走到终点四种情况 用$mp$数组存图，规定0表示白色，1表示红色，2表示黄色 用$f_{i,j}$表示$1,1$到$i,j$的最少花费 本题主要的难点在于加入了膜法机制 那么DFS需要传递四个参数： intx坐标和y坐标 int当前使用的金币数量 bool当前是否使用了膜法 在四向DFS中，需要进行以下几点判断： 当前格是否有颜色若无颜色且并未使用膜法，则使用膜法，使用金币数量+2，继续DFS；若无颜色且使用过膜法，没救了 当前格颜色和下一格颜色是否相同若颜色相同，直接进行下一步DFS；若颜色不同，使用金币数量+1，继续DFS 要注意的是，$f$数组的赋值要在判断是否走到终点之前，最优性剪枝之后，不然可能出现赋值不上的情况 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXM = 100 + 10; int f[MAXM][MAXM]; int mp[MAXM][MAXM]; #define WHITE 0 #define RED 1 #define YELLOW 2 const int dx[5] = &#123;0, 0, 0, -1, 1&#125;; const int dy[5] = &#123;0, -1, 1, 0, 0&#125;; int m, n, ans = 2147482333; void DaFaShi(int x, int y, int nowSum, bool usedMogic) &#123; // 苟利国家生死以 // 岂因祸福避趋之 // 你们啊，不要总是想弄个大新闻 // 说什么使用膜法 // 再把我批判一番 if (x &lt; 1 || y &lt; 1 || x &gt; m || y &gt; m) return; // 边界 if (mp[x][y] == WHITE) return; // 走到白格子 if (nowSum &gt;= f[x][y]) return; // 最优性剪枝 f[x][y] = nowSum; if (x == m &amp;&amp; y == m) &#123; ans = std::min(nowSum, ans); return; // 搜索完成 &#125; For (i, 1, 4) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (mp[nx][ny] != WHITE) &#123; // 有颜色 if (mp[nx][ny] == mp[x][y]) DaFaShi(nx, ny, nowSum, false); // 颜色相同，继续往后搜 else DaFaShi(nx, ny, nowSum + 1, false); // 颜色不同，花费金币 &#125; else if (mp[nx][ny] == WHITE &amp;&amp; !usedMogic)&#123; // 没颜色且没用膜法 mp[nx][ny] = mp[x][y]; // 念诗，使用膜法 DaFaShi(nx, ny, nowSum + 2, true); // 使用膜法花费2金币 mp[nx][ny] = WHITE; // 回溯 &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; memset(f, 0x7f, sizeof(f)); m = getint(); n = getint(); For (i, 1, n) &#123; int x, y, c; x = getint(); y = getint(); c = getint(); mp[x][y] = c + 1; &#125; DaFaShi(1, 1, 0, false); if (ans == 2147482333) puts("-1"); else putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2040《打开所有的灯》]]></title>
    <url>%2F2018-10-02%2FLuogu-P2040%2F</url>
    <content type="text"><![CDATA[益(ruo)智(zhi)的小游戏 题目链接 题目背景pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。 题目描述这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。 例如 0 1 1 1 0 0 1 0 1 点一下最中间的灯【2,2】就变成了 0 0 1 0 1 1 1 1 1 再点一下左上角的灯【1,1】就变成了 1 1 1 1 1 1 1 1 1 达成目标。最少需要2步。 输出2即可。 Input / Output 格式 &amp; 样例输入格式九个数字，3*3的格式输入，每两个数字中间只有一个空格，表示灯初始的开关状态。（0表示关，1表示开） 输出格式1个整数，表示最少打开所有灯所需要的步数。 输入样例1230 1 11 0 01 0 1 输出样例12 解题思路易证得我们对于一个灯的开关，只需要按1或0次 所以只需要考虑这个开关按与不按即可 所以我们可以直接进行搜索，总运算次数不会超过$9^9$ 用$used$数组记录$used_i$这个开关是否已经按过，用$f$数组记录$f_{i,j}$的亮灭情况 代码实现（以后就这个码风了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; bool used[3 + 2][3 + 2]; int f[3 + 2][3 + 2], ans = 10; const int dx[5] = &#123;0, 0, 0, -1, 1&#125;; const int dy[5] = &#123;0, -1, 1, 0, 0&#125;; void modify(int x, int y) &#123; for (int i = 0; i &lt;= 4; ++i) &#123; f[x + dx[i]][y + dy[i]] = !f[x + dx[i]][y + dy[i]]; &#125; &#125; bool Check() &#123; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (!f[i][j]) return false; &#125; &#125; return true; &#125; void dfs(int steps) &#123; if (steps &gt;= ans) return; if (Check()) ans = std::min(ans, steps); for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (!used[i][j]) &#123; used[i][j] = true; modify(i, j); dfs(steps+1); modify(i, j); used[i][j] = false; &#125; &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; f[i][j] = FastIO::getint(); &#125; &#125; dfs(0); FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day2 题解]]></title>
    <url>%2F2018-10-02%2F2018AutumnQBXTDay2%2F</url>
    <content type="text"><![CDATA[由于缺少题面，故本篇无内容。 这里仅提供T1. coin的代码实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; // 中国有句古话叫做闷声ACCEPT // 我就什么都不写，才是坠吼的 &#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("coin.in", "r", stdin); freopen("coin.out", "w", stdout); #endif int t; cin &gt;&gt; t; char c; int x = 0, X = 0; while (t --&gt; 0) &#123; cin &gt;&gt; c; switch(c) &#123; case 'x' : ++x; break; case 'X' : ++X; break; &#125; &#125; if (x == X) &#123; puts("0"); return 0; &#125; int cnt = 0; if (x &lt; X) &#123; while (x != X) &#123; ++x, --X, ++cnt; &#125; &#125; if (X &lt; x) &#123; while (x != X) &#123; ++X, --x, ++cnt; &#125; &#125; FastIO::putint(cnt, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>清北学堂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 日记]]></title>
    <url>%2F2018-10-01%2F2018AutumnQBXTDiary%2F</url>
    <content type="text"><![CDATA[Handwer STD 好菜啊 Day1考试150pts 本来能拿200pts的 结果T1写炸了只拿了50pts 靠着这样的成绩居然玄学地拿到了第三名 第一名 200pts 第二名190pts 还拿到了一个有线鼠标 首战告捷（人生中第一次比赛拿奖 在提高被虐惯了） Day2考试140pts T1数据有锅 题面保证数据没有奇数，结果只有3组数据是偶数，导致我只拿了30pts 好在最后重测了 拿到了100pts T2和T3根本没看 T4打了个暴力，枚举边跑Dijkstra，期望得分60pts，结果把m写成n……只拿了40pts 最后还是水到了一个rk5 不过今天并没有鼠标 Day3考试爆炸 只拿了80pts 被zxk吊打 T1阅读题，根本没理清题意，0pt T2规律题 T3贪心，但由于没有认真阅读题目，导致只拿了60pts T4有技巧的数学题，打了个30pts的暴力结果只拿了20pts 最终居然还水进了前10 我好菜啊…… Day4今天的题目 好！简！单！啊！ 今天的是真的普及组题目了 T1和T2都是水题，T3暴力分也是足够的，凭220pts拿了个rank3 讲T2的时候被老师拉上去讲题，感觉整个人都在抖，毫无准备的就上去了，说话也是语无伦次，真是差点要吓死了 不过重点不在这个 今天下午三点的时候RainAir问我成绩和排名，我如实地告诉了他后面的事应该不需要想了，我被他膜了一下午 但！是！接近八点的时候，Logey先是问了一下「致远星战况如何？」然后就开始膜我……说时迟，那时快，iShq也开始膜我了接着，就是三个人一块膜我，我被膜了一晚上！这群人fAKe起来真是没有底线啊……他们甚至把群名改成了「王太阳fAKe群」！ 我写博客快要写死了，今天T2要不对着代码讲出来真是太麻烦了，果然我水平还是低啊一口气更了三篇博客，感觉自己身体素质越来越差了，熬夜都熬不了了 对了，现在时间是2018年10月5日凌晨0点04分 Day5今天题目暴力分给的真是够多的了 T1 AC，T2应该是90pts，T4应该是70pts，总分250pts，拿到了一个rank6 T2本来能A掉的，但是我正解在考完试20min之后才调出来 难受 又一次忙活到了23点 好累啊qaq Day6今天的题目不知为何我只拿了110pts qaq T1 100pts，T2 0，T3 0, T4只搜到了10pts 看着别人上去拿键盘 拿鼠标 心里有点羡慕（虽然我已经有一个鼠标了 这个句号虽然不够圆满，但是至少是完整的。]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day1 题解]]></title>
    <url>%2F2018-10-01%2F2018AutumnQBXTDay1%2F</url>
    <content type="text"><![CDATA[不知不觉弄了个鼠标回来（雾 T1. 扑克牌题面【题目描述】 这天， 小 Q 来到了小杜家， 找小杜玩起了扑克牌的游戏。 扑克牌有 54 张牌， 分别是数字 A,2,3,4,5,6,7,8,9,10,J,Q,K，每种数字有 4 个花色， 分别为红桃， 黑桃， 方块， 梅花， 还有两张大王和小王。 这天小 Q 和小杜玩起来比大小的游戏， 两人各拿出一张扑克牌比大小， 很显然 3&lt;4&lt;5&lt;6&lt;7&lt;8&lt;9&lt;10&lt;J&lt;Q&lt;K&lt;A&lt;2&lt;小王&lt;大王， 为了防止数字相同无法比较， 他们给花色也定了一个大小梅花&lt;方块&lt;黑桃&lt;红桃， 规定先比较数字， 数字相同再比较花色， 由于他们只有一副扑克牌， 拿出的两张牌不可能相同， 所以一定能比出大小。 【输入描述】 第一行一个数字 T， 表示小 Q 和小杜玩的次数。 接下来 T 行， 每行两个用空格隔开的数字。 其中 1-13 分别表示梅花 A,2,3,4,5,6,7,8,9,10,J,Q,K。 其中 14-26 分别表示方块 A,2,3,4,5,6,7,8,9,10,J,Q,K。 其中 27-39 分别表示黑桃 A,2,3,4,5,6,7,8,9,10,J,Q,K。 其中 40-52 分别表示红桃 A,2,3,4,5,6,7,8,9,10,J,Q,K。 53 表示小王， 54 表示大王。 第一个数表示小 Q 的牌， 第二个数表示小杜的牌。 【输出描述】 输出共 T 行， 每行一个字母 Q 或者 D， Q 表示小 Q 赢， D 表示小杜赢。 Input / Output 格式 &amp; 样例输入格式 &amp; 输出格式见题面。 输入样例1232 11 131 53 输出样例12QD 样例解释 &amp; 注意事项【样例解释】 第一局小 Q 是梅花 A， 小杜是梅花 K， 所以小 Q 大 第二局小 Q 是梅花 A， 小杜是小王， 所以小杜大。 【数据范围】 对于 30%的数据， 扑克牌的范围在[1,13]。 对于 50%的数据， 不会出现大小王。 对于 100%的数据， 1&lt;=T&lt;=100。 解题思路 照题意模拟 这里有一个小技巧 你可以对读入的数字（必须保证数字不代表大、小王） $mod\ 13$ 得到的新数字： 120 1 2 3 4 5 6 7 8 9 10 11 12K A 2 3 4 5 6 7 8 9 10 J Q 接着特判，把K改成13，把A改成14，把2改成15，把小王改成16，把大王改成17 最后直接比较新数字就行了 当新数字相同时依题意可直接比较原数字的大小 代码实现（依然毒瘤风格） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; int queryNum(int x) &#123; if (x &lt;= 52) &#123; x %= 13; if (x == 0) x = 13; if (x == 1) x = 14; if (x == 2) x = 15; return x; &#125; else return x - 52 + 15; &#125; char Judge(int q, int d) &#123; int qa = queryNum(q); int da = queryNum(d); if (qa == da) return q &lt; d ? 'D' : 'Q'; return qa &lt; da ? 'D' : 'Q'; &#125;&#125; int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("poker.in", "r", stdin); freopen("poker.out", "w", stdout); #endif using FastIO::getint; using FastIO::putint; int t = getint(); while (t --&gt; 0) &#123; int q = getint(); int d = getint(); cout &lt;&lt; Solution::Judge(q, d) &lt;&lt; endl; &#125; return 0;&#125; T2. 密码题面【题目描述】 小杜开始学习 C++， 小杜想进行一些练习， 于是小杜准备上某题库网站进行做题练习， 小杜发现这样的网站都需要进入注册之后， 才可以登录进行练习， 于是小杜准备注册一个账号。 在填写了一大堆信息之后， 网站要求小杜输入密码， 这让小杜犯了难， 网站对密码的有一定的要求， 密码只能包含大写字母， 小写字母， 并且必须包含至少一个大写字母， 至少一个小写字母， 那么对于小杜的密码， 是否符合该网站的要求呢？如果不符合网站的要求， 那么如何修改让密码变得符合要求呢，一次修改只能将密码的某一位修改成一个大写字母或小写字母， 如果有多个密码符合条件， 需要修改次数最少的， 对于修改次数相同的，输出字典序最小的（按 ASCII 码） 【输入描述】 第一行一个数字 T 表示数据组数。 接下来 T 行， 每行一个字符串表示小杜的密码。 【输出描述】 共 T 行。 若小杜的密码符合条件， 将密码直接输出即可， 否则输出修改后的密码 。 Input / Output 格式 &amp; 样例输入输出格式见题面。 输入样例1232abaCABAqwerty 输出样例12abaCABAAwerty 样例解释 &amp; 注意事项【数据范围】 对于 30%的数据， 只包含小写字母。对于另外 20%的数据， 只包含大写字母。对于 100%的数据， 1&lt;=T&lt;=100， 字符串长度不超过 100 并且大于等于 3，保证输入数据只包含大、小写字母。 解题思路 依然照题意模拟 我们贪心地认为字母A越靠前，字母a越靠后，整个字符串字典序就越小 那么本题分两种情况讨论： 只含有大写字母 只含有小写字母 含有特殊字符并没有 对于只含有大写字母的情况，把字符串末尾修改成a即可。 对于只含有小写字母的情况，把字符串开头修改成A即可。 代码实现（还是这种玄学码风 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;/* Constants Start *//* Constants End *//* Variants Start */string s;/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; bool Check(string str, int lenstr, bool &amp;hasUpper, bool &amp;hasLower) &#123; hasUpper = false; hasLower = false; Forw (i, 0, lenstr) &#123; if (isupper(str[i])) hasUpper = true; else if (islower(str[i])) hasLower = true; else return false; &#125; if (hasUpper &amp;&amp; hasLower) return true; return false; &#125; string Modify(string str, int lenstr, bool hasUpper, bool hasLower) &#123; string ret = str; if (hasUpper == false &amp;&amp; hasLower == false) &#123; Forw (i, 0, lenstr - 1) ret[i] = 'A'; ret[lenstr - 1] = 'a'; ret[lenstr] = '\0'; &#125; if (hasUpper == false &amp;&amp; hasLower) &#123; ret[0] = 'A'; &#125; if (hasUpper &amp;&amp; hasLower == false) &#123; ret[lenstr - 1] = 'a'; &#125; if (hasUpper &amp;&amp; hasLower) &#123; Forw (i, 0, lenstr) &#123; if (!isupper(ret[i]) &amp;&amp; !islower(ret[i])) &#123; ret[i] = 'A'; &#125; &#125; &#125; return ret; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("pass.in", "r", stdin); freopen("pass.out", "w", stdout); #endif int t = 0; cin &gt;&gt; t; while (t --&gt; 0) &#123; cin &gt;&gt; s; int lens = s.length(); bool hasUpper = false, hasLower = false; if (Solution::Check(s, lens, hasUpper, hasLower)) cout &lt;&lt; s &lt;&lt; endl; else cout &lt;&lt; Solution::Modify(s, lens, hasUpper, hasLower) &lt;&lt; endl; &#125; return 0;&#125; T3. 下棋题面【题目描述】 小 Q 拿出了一张 2 行 N 列的棋盘， 棋盘的每个位置可以放一颗黑棋或者一颗白棋。 若两个棋子颜色相同且位置相邻我们就认为这两个棋子连成了一片， 当然两个棋子都和另一个棋子连成一片， 我们也认为这两个棋子连成一片。 这天小杜突发奇想， 小杜想知道这个棋盘上有多少种放棋子的方法使得棋盘上的棋子片数为 K。 这个数目可能非常大， 请输出方法对 998244353 取模的结果。 【输入描述】 两个数 N 和 K， 用空格隔开。 【输出描述】 一个数字表示方案数。 Input &amp; Output 格式 &amp; 样例输入输出格式见题面。 输入样例13 4 输出样例112 样例解释 &amp; 注意事项【数据范围】 对于 30%的数据， 1&lt;=N&lt;=10,1&lt;=K&lt;=2N。 对于 50%的数据， 1&lt;=N&lt;=100,1&lt;=K&lt;=2N。 对于 100%的数据， 1&lt;=N&lt;=1000,1&lt;=K&lt;=2N。 解题思路考场上死活没看出这是DP 我们设dp[i][j]=k表示前$2\times i$个格子，有$j$片，最后一个$2\times i$的格子的状态为$k\ (0 \le k \le 3)$ 那么只需要枚举下一个$2\times i$的状态$p\ (0 \le p \le 3)$，进行转移即可 转移有$4\times4=16$种方案，可以先判断加$0$片和加$1$片的情况，剩下的就是加$2$片的情况，代码会简洁不少 不要忘了最后$ans$要$mod\ 998244353$ 代码实现（玄学码风无误了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int HA = 998244353; int Query(int x, int y) &#123; if (x == y) return 0; if (x == 0) return 1; if (x == 3) return 1; if (y == 0) return 0; if (y == 3) return 0; return 2; &#125; const int MAXN = 2000 + 10; long long int f[MAXN][4]; long long int x[MAXN][4]; long long int Work(int n, int k) &#123; f[1][0] = f[1][3] = 1; f[2][1] = f[2][2] = 1; Forw (i, 0, n - 1) &#123; memset(x, 0, sizeof(x)); For (j, 1, MAXN - 10) &#123; Forw (xx, 0, 4) &#123; Forw (y, 0, 4) &#123; x[j + Query(xx, y)][y] += f[j][xx]; x[j + Query(xx, y)][y] %= HA; &#125; &#125; &#125; std::swap(f, x); &#125; return (f[k][0] + f[k][1] + f[k][2] + f[k][3]) % HA; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("chess.in", "r", stdin); freopen("chess.out", "w", stdout); #endif int n = FastIO::getint(); int k = FastIO::getint(); FastIO::putint(Solution::Work(n, k), '\n'); return 0;&#125; T4. 堆积木太蒻不写]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>清北学堂</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 349B 《Color the Fence》]]></title>
    <url>%2F2018-09-30%2FCF349B%2F</url>
    <content type="text"><![CDATA[瞎贪心 题目描述 翻译来自洛谷 Igor深深爱上了Tanya. 现在, Igor想表达他的爱意, 他便在Tanya家对面的墙上写下一串数字. Igor认为, 数字写得越大, Tanya越喜欢他. 不幸的是, 他只有 $v$ 升油漆, 每个数字都会花掉一定的油漆 $a_i$ . Igor不喜欢 $0$ 所以数中不会出现 $0$. 问Igor能得到的最大的数是多少. Input / Output 格式 &amp; 样例输入格式第一行一个整数$v$，意义如题 第二行有九个数字$a_1,\ a_2,\ a_3,\ \dots \ ,\ a_9$，表示第$i$个数字需要$a_i$升油漆 输出格式一行一个整数，表示最大的Igor可以得到的数。 输入样例Case #1: 1255 4 3 2 1 2 3 4 5 Case #2: 1229 11 1 12 5 8 9 10 6 Case #3: 1201 1 1 1 1 1 1 1 1 输出样例Case #1: 155555 Case #2: 133 Case #3: 1-1 解题思路明显的贪心 先对这个序列排序（优先队列方便快捷），再从小到大依次计算可以画出的数字和画出数字的次数 接着从9到1进行枚举，看一看有没有什么可以替换一下的，替换成花费相对最小的数字 最后输出答案数组 代码实现玄学代码风格（雾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;/* Constants Start *//* Constants End *//* Variants Start */int v;int q[10]; // q[i].first = variant// q[i].second = idint ans[10];priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; pq;/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif v = FastIO::getint(); For (i, 1, 9) &#123; q[i] = FastIO::getint(); pq.push(std::make_pair(q[i], -i)); &#125; // 贪心选择当前最优 while (!pq.empty()) &#123; pair&lt;int, int&gt; pr = pq.top(); pq.pop(); ans[-pr.second] = v / pr.first; v %= pr.first; &#125; q[0] = 2147482333; // 进行替换 Bak (i, 9, 1) &#123; int tmp = 0; Bak (j, i - 1, 1) &#123; if (ans[j] &amp;&amp; q[j] &lt; q[tmp]) tmp = j; &#125; if (!tmp) continue; while (ans[tmp] &amp;&amp; v &amp;&amp; v &gt;= q[i] - q[tmp]) v -= q[i] - q[tmp], ++ans[i], --ans[tmp]; &#125; bool Printed = false; Bak (i, 9, 1) &#123; while (ans[i]) &#123; FastIO::__basic_putint(i); --ans[i]; Printed = true; &#125; &#125; // 程序并没有正确答案，输出-1 if (!Printed) puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 333A 《Secrets》]]></title>
    <url>%2F2018-09-30%2FCF333A%2F</url>
    <content type="text"><![CDATA[枚举 题目链接 题目大意Gerald 在卖一些国家机密，所有机密的花费相同——总价值为 $n$ 的钢镚。所有的钢镚的价值都是 $3^k\ (k ≥ 1)$。 某天来了一个交易者，他不会付出正好的价值，也就是说，Gerald 必须找钱给他。 求一个方案使得交易者付出的钢镚的价值 $≥n$ ，且付出最少额外价值的同时保证花费的钢镚数量最多。 Input / Output 格式 &amp; 样例输入样例一行一个整数 $n$ ，意义如题。 输出样例一行一个整数，即最多花费的钢镚数量。 输入样例Case #1: 11 Case #2: 14 输出样例Case #1: 11 Case #2: 12 解题思路显然，使用的金币面值越小，使用的金币数量就越大 那么答案就是第一个 $i$使得$\frac{n}{i}=1\ (i ≥ 1)$ 又因为交易者不会付出正好为 $n$ 价值的钢镚，所以答案就要 $+1$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; long long int n, now = 1l; cin &gt;&gt; n; while (true) &#123; now *= 3; if (n % now) &#123; cout &lt;&lt; n / now + 1 &lt;&lt; endl; return 0; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 295B 《Greg and Graph》]]></title>
    <url>%2F2018-09-30%2FCF295B%2F</url>
    <content type="text"><![CDATA[开倒车 倒序 Floyd 题目链接 题目描述 翻译来自洛谷 Greg有一个有边权的有向图，包含 $n$ 个点。这个图的每两个点之间都有两个方向的边。Greg喜欢用他的图玩游戏，现在他发明了一种新游戏： 游戏包含 $n$ 步。 第 $i$ 步Greg从图中删掉编号为 $x_i$ 的点。当删除一个点时，这个点的出边和入边都会被删除。 在执行每一步之前，Greg想知道所有点对间最短路长度的和。最短路可以经过任何没删掉的点。换句话说，如果我们假设 $d(i, v, u)$ 是在删掉 $x_i$ 前 $v$ 和 $u$ 间的最短路长度，那么Greg想知道下面这个求和的值：$$\sum_{v, u, v \neq u} d(i, v, u)$$ 帮帮Greg，输出每一步之前要求的值。 Input / Output 格式 &amp; 样例输入格式第一行包含一个整数 $n \ (1 \leq n \leq 500)$ ，代表图中的点数。 下面 $n$ 行每行包含 $n$ 个整数，代表边权：第 $i$ 行的第 $j$ 个数 $a_{ij} \ (1 \leq a_{ij} \leq 10^5, a_{ii} = 0)$ 代表从 $i$ 到 $j$ 的边权。 最后一行包含 $n$ 个整数： $x_1, x_2, \dots, x_n \ (1 \leq x_i \leq n)$ ，分别为Greg每一步删掉的点的编号。 输出格式输出 $n$ 个整数，第 $i$ 个数等于游戏的第 $i$ 步之前统计的求和值。 请不要在C++中使用%lld标志来输出64位整数long long，推荐使用cin, cout流或者用%I64d标志。 输入样例Case #1: 123101 Case #2: 123420 54 01 2 Case #3: 12345640 3 1 16 0 400 12 4 0 11 1 1 04 1 2 3 输出格式Case #1: 10 Case #2: 19 0 Case #3: 117 23 404 0 解题思路$n \le 500$ 很明显跑 Floyd 了 但是 Floyd 不支持删除操作 怎么办？ 开倒车 倒序添加！ 我们记录下删除点的信息，再倒着添加回去，在这个过程中套一个 Floyd 进去 要注意的是累计答案的时候判断点是否存在 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 500 + 10;int f[MAXN][MAXN];int seq[MAXN];long long int ans[MAXN];bool inGraph[MAXN];int n;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline void addEdge(int s, int t, int w) &#123; f[s][t] = f[t][s] = w;&#125;int main(int argc, char *const argv[]) &#123; n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = getint(); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; seq[i] = getint(); &#125; for (int l = n; l &gt; 0; --l) &#123; int k = seq[l]; inGraph[k] = true; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = std::min(f[i][j], f[i][k] + f[k][j]); if (inGraph[i] &amp;&amp; inGraph[j]) ans[l] += f[i][j]; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; ' '; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>图论算法</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1908《逆序对》]]></title>
    <url>%2F2018-09-15%2FLuogu-P1908%2F</url>
    <content type="text"><![CDATA[Based on 归并排序 题目地址 题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 Input / Output 格式输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过$10^9$ 输出格式给定序列中逆序对的数目。 输入样例1265 4 2 6 3 1 输出样例111 数据范围对于25%的数据，$n \leq 2500n$ 对于50%的数据，$n \leq 4 \times 10^4$ 对于所有数据，$n \leq 5 \times 10^5$ 请使用较快的输入输出 解题思路暴力做法$O(n)$枚举所有的点，$O(n)$比较数的大小，求出逆序对的个数 均摊$O(n^2)$ 正解分治 想想归并排序的过程 比如我们要对下面的区间进行归并排序 $$a_i\ \ mid=4\ \ a_j$$ $$2\ 4\ 7\ 8\ \ \ \ \ 1\ 5\ 6\ 24$$ 我们拿1去比较，此时可以构成的逆序对个数为4，把他放到$r_k$里，那么此时$i$是指向$a_1$的 接着继续比较，直到$a_i &lt; a_j$，就将$a_i$放到$r_k$里 以此类推，最终的逆序对个数就是中间求出的个数的和$=mid-i+1$的和 代码实现1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 5 * 1e5 + 10;int n, a[MAXN], tmp[MAXN];long long int ans;void mergeSort(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; mergeSort(l, mid); mergeSort(mid+1, r); int i = l, j = mid + 1, k = l; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) tmp[k] = a[i++], ++k; else tmp[k] = a[j++], ++k, ans += (long long int) mid - i + 1; &#125; while (i &lt;= mid) tmp[k++] = a[i++]; while (j &lt;= r) tmp[k++] = a[j++]; for (int i = l; i &lt;= r; ++i) a[i] = tmp[i];&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; mergeSort(1, n); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>分治</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度优先搜索]]></title>
    <url>%2F2018-09-15%2FDepthFirstSearch%2F</url>
    <content type="text"><![CDATA[常见算法 / 骗分技巧 洛谷P1605 迷宫题目地址 DFS 入门题 用一个数组mp存图，vis记录是否经过了这个点 12mp[i][j] = 0 表示有障碍mp[i][j] = 1 表示没有障碍 用一个函数dfs(x, y)来搜索 123当坐标为终点时，直接return，方案数++如果这个点没被访问过，而且这个点没有障碍，就把这个点设为访问过，然后dfs这个点 要注意的是起始点是访问过的 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;bool vis[6 + 2][6 + 2];int mp[6 + 2][6 + 2];const int dx[4] = &#123;0, 0, 1, -1&#125;;const int dy[4] = &#123;-1, 1, 0, 0&#125;;int tot, endx, endy, stx, sty, n, m, t;void dfs(int x, int y) &#123; if (x == endx &amp;&amp; y == endy) &#123; ++tot; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; int nowx = x + dx[i]; int nowy = y + dy[i]; if (!vis[nowx][nowy] &amp;&amp; mp[nowx][nowy]) &#123; vis[nowx][nowy] = true; dfs(nowx, nowy); vis[nowx][nowy] = false; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; mp[i][j] = (int) true; &#125; &#125; cin &gt;&gt; stx &gt;&gt; sty; cin &gt;&gt; endx &gt;&gt; endy; for (int i = 1; i &lt;= t; ++i) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; mp[l][r] = false; &#125; vis[stx][sty] = true; dfs(stx, sty); cout &lt;&lt; tot &lt;&lt; endl; return 0;&#125; 洛谷P1162 填涂颜色题目地址 本来这是一道 BFS 的题 但是有一种玄学的做法可以用 DFS 首先开两个mp存图，输入1时在第一个mp里存1，在第二个mp里存-1 具体就是搜索边界（每一行的第一个和第n个，每一列的第一个和第n个），在搜索的同时更新第一个mp为1 搜索完了就进行判断输出 123当第二个mp[i][j]为-1时输出1否则当第一个mp[i][j]为1时就输出2（被更新过了）否则输出0 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 30 + 5;int mp[MAXN][MAXN];int orz[MAXN][MAXN];int n;void dfs(int x, int y) &#123; if (x &gt; n || x &lt; 1 || y &gt; n || y &lt; 1 || mp[x][y] != 0) return; mp[x][y] = true; dfs(x+1, y); dfs(x-1, y); dfs(x, y+1); dfs(x, y-1);&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; cin &gt;&gt; mp[i][j]; if (mp[i][j] == 1) orz[i][j] = -1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (mp[i][1] != 1) dfs(i, 1); if (mp[i][n] != 1) dfs(i, n); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (mp[1][i] != 1) dfs(1, i); if (mp[n][i] != 1) dfs(n, i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (orz[i][j] == -1) cout &lt;&lt; 1 &lt;&lt; ' '; else if (mp[i][j] == 0) cout &lt;&lt; 2 &lt;&lt; ' '; else cout &lt;&lt; 0 &lt;&lt; ' '; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「五校联考」Round#1 Day1&amp;Day2 T1]]></title>
    <url>%2F2018-08-26%2F2018FSExamRound1T1%2F</url>
    <content type="text"><![CDATA[由于权限原因，暂不提供题面 &amp; 评测地址 Day1 T1 dice.cpp解题思路题目让我们求一个骰子每次滚动时最顶数字之和 随意观察可知一个骰子滚4圈所得的和 $=14$ 那么我们可以先让ans += ((m - 1) / 4) * 14 这样来处理每一行的主要部分 要是剩下还有点没求呢？ 那就直接暴力模拟，反正时间复杂度高不了多少 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;long long int ans;struct Dice &#123; long long int top; long long int front; long long int bottom; long long int behind; long long int left; long long int right; Dice() &#123; top = 1; front = 2; bottom = 6; behind = 5; left = 4; right = 3; &#125; void toTheRight() &#123; long long int origTop = top; top = left; left = bottom; bottom = right; right = origTop; ans += top; &#125; void toTheLeft() &#123; long long int origTop = top; top = right; right = bottom; bottom = left; left = origTop; ans += top; &#125; void toTheDownLine() &#123; long long int origTop = top; top = behind; behind = bottom; bottom = front; front = origTop; ans += top; &#125;&#125; d;long long int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; ans += ((m - 1) / 4 ) * 14; if (i &amp; 1) for (int j = 1; j &lt;= (m - 1) % 4; ++j) d.toTheRight(); else for (int j = 1; j &lt;= (m - 1) % 4; ++j) d.toTheLeft(); // 在 toTheRight 和 toTheLeft 和 toTheDownLine 中已经更新过答案 // 不必再更新 if (i != n) d.toTheDownLine(); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Day2 T1 meizi.cpp解题思路前言： 1zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！ 考虑一下暴力怎么写 把区间[l, r]全部+1，最终取个max 那么我们就可以把区间首+1，区间尾-1，然后做一遍前缀和 我们首先对每个区间差分，再把差分的区间加起来 最终做一遍前缀和，取一遍max 注意要先进行离散化，因为 $1 \le l_i \le\ r_i \le 10^9$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2 * 1e5 + 20;int n;int l[MAXN], r[MAXN];int tmp[MAXN * 2];// 离散化数组int s[MAXN * 2];// 前缀和数组// 开两倍是因为对于每一个妹子都需要记录l和r两个变量inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = getint(); r[i] = getint(); // 记录离散化数组 tmp[2 * i - 1] = l[i]; tmp[2 * i] = r[i]; &#125; // 开始离散化 sort(tmp + 1, tmp + 1 + 2 * n); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = lower_bound(tmp + 1, tmp + 1 + 2 * n, l[i]) - tmp; r[i] = lower_bound(tmp + 1, tmp + 1 + 2 * n, r[i]) - tmp; // 在离散化中顺便记录前缀和数组 ++s[l[i]]; --s[r[i] + 1]; &#125; // 处理前缀和 for (int i = 1; i &lt;= 2 * n; ++i) &#123; s[i] += s[i-1]; &#125; int ans = 0; for (int i = 1; i &lt;= 2 * n; ++i) ans = std::max(ans, s[i]); putint(ans, true); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>只有经历过的人才知道的世界</tag>
        <tag>自测</tag>
        <tag>五校联考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3884《[JLOI2009]二叉树问题》]]></title>
    <url>%2F2018-08-08%2FLuogu-P3884%2F</url>
    <content type="text"><![CDATA[不用倍增的 almost裸的LCA 题目描述如下图所示的一棵二叉树的深度、宽度及结点间距离分别为： 深度：4 宽度：4（同一层最多结点个数） 结点间距离： ⑧→⑥为8 (3×2+2=8) ⑥→⑦为3 （1×2+1=3） 注：结点间距离的定义：由结点向根方向（上行方向）时的边数×2， 与由根向叶结点方向（下行方向）时的边数之和。 图片来自洛谷 Input / Output 格式 &amp; 样例输入格式输入文件第一行为一个整数n(1≤n≤100)，表示二叉树结点个数。接下来的n-1行，表示从结点x到结点y（约定根结点为1），最后一行两个整数u、v，表示求从结点u到结点v的距离。 输出格式：三个数，每个数占一行，依次表示给定二叉树的深度、宽度及结点u到结点v间距离。 输入输出样例输入样例： 123456789101110 1 2 1 3 2 42 53 63 75 85 96 108 6 输出样例： 123448 解题思路树的深度可以取$max${$depth[i]$} 树的宽度可以在取深度的时候拿一个桶记录下来，再循环取一遍$max$ 两点之间的距离可以先求$LCA$，再用一个公式算出来 $$distance = (depth[u] - depth[lca]) \times 2 + depth[v] - depth[lca]$$ 其中$lca = LCA(u, v)$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 100 + 10;struct Edge &#123; int prev, next;&#125; edge[MAXN * 2];int head[MAXN], father[MAXN][22], lg[MAXN], depth[MAXN];int cnt, n, m, s;int KangShifu[MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline void addEdge(int prev, int next) &#123; edge[++cnt].prev = prev; edge[cnt].next = head[next]; head[next] = cnt; &#125; void dfsInit(int root, int fa) &#123; depth[root] = depth[fa] + 1; father[root][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[root]; ++i) &#123; father[root][i] = father[father[root][i-1]][i-1]; &#125; for (int e = head[root]; e; e = edge[e].next) &#123; if (edge[e].prev != fa) dfsInit(edge[e].prev, root); &#125;&#125;int LCA(int x, int y) &#123; if (depth[x] &lt; depth[y]) swap(x, y); while (depth[x] &gt; depth[y]) x = father[x][lg[depth[x] - depth[y]] - 1]; if (x == y) return x; for (int i = lg[depth[x]]; i &gt;= 0; --i) &#123; if (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i]; &#125; return father[x][0];&#125;int main(int argc, char *const argv[]) &#123; n = getint(); for (int i = 1; i &lt; n; ++i) &#123; int prev = getint(), next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; int u = getint(); int v = getint(); dfsInit(1, 0); for (int i = 1; i &lt;= n; ++i) &#123; lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); &#125; int lca = LCA(u, v); int Depth = -23333; for (int i = 1; i &lt;= n; ++i) &#123; Depth = std::max(Depth, depth[i]); ++KangShifu[depth[i]]; &#125; int width = -23333; for (int i = 1; i &lt;= Depth + 2; ++i) width = std::max(width, KangShifu[i]); putint(Depth, true); putint(width, true); putint((depth[u] - depth[lca]) * 2 + (depth[v] - depth[lca]), true); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论算法</tag>
        <tag>LCA</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近公共祖先 LCA]]></title>
    <url>%2F2018-08-07%2FLeastCommonAncestors%2F</url>
    <content type="text"><![CDATA[两个结点找共同的爸爸 LCA 的概念 在图论和计算机科学中，最近公共祖先（英语：lowest common ancestor）是指在一个树)或者有向无环图中同时拥有v和w作为后代的最深的节点。 ——Wikipedia 看不懂没关系 简单的来说，就是两个节点v和w的最近的祖先节点 如下图 6和7的LCA是2，3和7的LCA是1 LCA 的求法暴力求解让他们一步一步往上爬，直到相遇 节点背着那重重的编号呀 一步一步地往上爬 ——《蜗牛与黄鹂鸟》 显然，这样的算法会T到飞起 所以我们要使用倍增优化 倍增求解 所谓倍增，就是按2的倍数来增大，也就是跳 1、2、4 、8 、16、32 … 但是在这里，我们要考虑开倒车从大到小跳 因为如果我们从小到大跳，就会出现要「回溯」的情况，因为我们不一定能精准地跳，而从大到小跳可以避开这种情况 图源cnblogs 对于上面这一棵更复杂的树，我们考虑17和18的LCA 1217 -&gt;(跳4) 318 -&gt;(跳4) 5 -&gt;(跳1) -&gt; 3 是不是快多了，跳的次数大大减小 时间复杂度$O(nlogn)$ LCA 的代码 &amp; 实现流程实现流程首先我们要记录各个点的深度$depth[\ ]$和它们$2^i$级的祖先$father[\ ][\ ]$ 用$depth[i]$表示$i$点的深度，$father[i][j]$表示$i$点的$2^i$级的祖先 1234567891011// 预处理void dfsInit(int root, int fa) &#123; depth[root] = depth[fa] + 1; father[root][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[root]; ++i) &#123; father[root][i] = father[father[root][i-1]][i-1]; &#125; for (int e = head[root]; e; e = edge[e].next) &#123; if (edge[e].prev != fa) dfsInit(edge[e].prev, root); &#125;&#125; 接着我们就可以找LCA辣 对了，我们可以让它跑得更快 1234// 提前预处理出log2i + 1的值for (int i = 1; i &lt;= n; ++i) &#123; lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i);&#125; 在求 LCA 之前，我们先让两个节点蹦到同一层 但是跳的时候不能直接跳到 LCA 上，要跳到 LCA - 1 上，再输出 当前的父节点 就行了 因为直接蹦到 LCA 上可能会出现「误判」，比如上图中$4$和$8$，若不判断，则在跳的时候会输出1，但是答案是3 所以我们就可以让它们跳到$2$和$5$，然后输出父节点 123456789101112int LCA(int x, int y) &#123; // 我们设x的深度大于y的深度 if (depth[x] &lt; depth[y]) swap(x, y); while (depth[x] &gt; depth[y]) x = father[x][lg[depth[x] - depth[y]] - 1]; if (x == y) return x; // x 是 y 的祖先 for (int i = lg[depth[x]]; i &gt;= 0; --i) &#123; if (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i]; // 不相等就往上跳 &#125; return father[x][0];&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 500000 + 10;const int MAXM = 500000 + 10;struct Edge &#123; int prev, next;&#125; edge[MAXM * 2];int head[MAXN], father[MAXN][22], lg[MAXN], depth[MAXN];int cnt, n, m, s;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline void addEdge(int prev, int next) &#123; edge[++cnt].prev = prev; edge[cnt].next = head[next]; head[next] = cnt; &#125; // 预处理void dfsInit(int root, int fa) &#123; depth[root] = depth[fa] + 1; father[root][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[root]; ++i) &#123; father[root][i] = father[father[root][i-1]][i-1]; &#125; for (int e = head[root]; e; e = edge[e].next) &#123; if (edge[e].prev != fa) dfsInit(edge[e].prev, root); &#125;&#125;int LCA(int x, int y) &#123; // 我们设x的深度大于y的深度 if (depth[x] &lt; depth[y]) swap(x, y); while (depth[x] &gt; depth[y]) x = father[x][lg[depth[x] - depth[y]] - 1]; if (x == y) return x; // x 是 y 的祖先 for (int i = lg[depth[x]]; i &gt;= 0; --i) &#123; if (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i]; // 不相等就往上跳 &#125; return father[x][0];&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(), s = getint(); for (int i = 1; i &lt; n; ++i) &#123; int prev = getint(), next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; dfsInit(s, 0); for (int i = 1; i &lt;= n; ++i) &#123; lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x = getint(), y = getint(); putint(LCA(x, y), true); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>图论</tag>
        <tag>图论算法</tag>
        <tag>LCA</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1531《I Hate It》]]></title>
    <url>%2F2018-08-05%2FLuogu-P1531%2F</url>
    <content type="text"><![CDATA[暴力能过的线段树板子题 题目背景很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 题目描述不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩 Input / Output 格式 &amp; 样例输入格式第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。 当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为’U’的时候，表示这是一条更新操作，如果当前A学生的成绩低于B，则把ID为A的学生的成绩更改为B，否则不改动。 输出格式对于每一次询问操作，在一行里面输出最高成绩 输入输出样例输入样例： 123456785 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 输出样例： 12345659 解题思路单点修改，区间查询 …… 线段树 树状数组！ 对了，注意处理输入，含读入char的题目最好不要用快读 …… 别问我怎么知道的 线段树解法可以说是很裸的一道题了 只需要单点修改，lazyTag什么的不需要的 就简单把区间和查询改成区间最值查询就行了 代码实现线段树解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 200000 + 10;int a[MAXN], segt[MAXN * 4];int n, m;inline int leftChild(int x) &#123; return x &lt;&lt; 1;&#125;inline int rightChild(int x) &#123; return x &lt;&lt; 1 | 1;&#125;inline void pushUp(int root) &#123; segt[root] = std::max(segt[leftChild(root)], segt[rightChild(root)]); // 更新最大值&#125;inline void buildTree(int l, int r, int root) &#123; if (l == r) &#123; segt[root] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; buildTree(l, mid, leftChild(root)); buildTree(mid + 1, r, rightChild(root)); pushUp(root);&#125;inline int query(int l, int r, int ql, int qr, int root) &#123; int res = -2147483640; if (ql &lt;= l &amp;&amp; r &lt;= qr) return segt[root]; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) res = std::max(res, query(l, mid, ql, qr, leftChild(root))); if (mid &lt; qr) res = std::max(res, query(mid + 1, r, ql, qr, rightChild(root))); // 查询最大值 return res;&#125;inline void Modify(int l, int r, int dest, int root, int k) &#123; if (l == r) &#123; segt[root] = std::max(segt[root], k); return; &#125; int mid = (l + r) &gt;&gt; 1; if (dest &lt;= mid) Modify(l, mid, dest, leftChild(root), k); if (mid &lt; dest) Modify(mid + 1, r, dest, rightChild(root), k); pushUp(root);&#125;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; buildTree(1, n, 1); for (int i = 1; i &lt;= m; ++i) &#123; char op; int a, b; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; // 推荐使用std::cin！ switch(op) &#123; case 'Q': &#123; putint(query(1, n, a, b, 1), true); break; &#125; case 'U': &#123; Modify(1, n, a, 1, b); break; &#125; &#125; &#125; return 0;&#125; 暴力代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 200000 + 10;int segt[MAXN]; int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline int query(int l, int r) &#123; int res = -2147483640; for (int i = l; i &lt;= r; ++i) res = std::max(res, segt[i]); return res;&#125;inline void Modify(int r, int k) &#123; segt[r] = std::max(segt[r], k);&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; segt[i]; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; segt[i] &lt;&lt; ' '; cout &lt;&lt; endl; for (int i = 1; i &lt;= m; ++i) &#123; char op; int a, b; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; switch(op) &#123; case 'Q': &#123; cout &lt;&lt; query(a, b) &lt;&lt; endl; break; &#125; case 'U': &#123; Modify(a, b); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>模拟</tag>
        <tag>线段树</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1563「NOIP2016」《玩具谜题》]]></title>
    <url>%2F2018-08-05%2FLuogu-P1563%2F</url>
    <content type="text"><![CDATA[暴力模拟 题目描述小南有一套可爱的玩具小人, 它们各有不同的职业。 有一天, 这些玩具小人把小南的眼镜藏了起来。 小南发现玩具小人们围成了一个圈,它们有的面朝圈内,有的面朝圈外。如下图: 图片摘自洛谷 这时 singer 告诉小南一个谜題: “眼镜藏在我左数第3个玩具小人的右数第 1 个玩具小人的左数第 2 个玩具小人那里。 ” 小南发现, 这个谜题中玩具小人的朝向非常关键, 因为朝内和朝外的玩具小人的左右方向是相反的: 面朝圈内的玩具小人, 它的左边是顺时针方向, 右边是逆时针方向; 而面向圈外的玩具小人, 它的左边是逆时针方向, 右边是顺时针方向。 小南一边艰难地辨认着玩具小人, 一边数着: singer 朝内, 左数第 3 个是 archer 。 archer 朝外,右数第 1 个是 thinker 。 thinker 朝外, 左数第 2 个是 writer。 所以眼镜藏在 writer这里! 虽然成功找回了眼镜, 但小南并没有放心。 如果下次有更多的玩具小人藏他的眼镜, 或是谜題的长度更长, 他可能就无法找到眼镜了 。 所以小南希望你写程序帮他解决类似的谜題。 这样的谜題具体可以描述为: 有 n 个玩具小人围成一圈, 已知它们的职业和朝向。现在第 1 个玩具小人告诉小南一个包含 m 条指令的谜題, 其中第 z 条指令形如“左数/右数第 s ,个玩具小人”。 你需要输出依次数完这些指令后,到达的玩具小人的职业。 Input / Output 格式 &amp; 样例输入格式输入的第一行包含两个正整数 n,m ，表示玩具小人的个数和指令的条数。 接下来 n 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 0 表示朝向圈内， 1 表示朝向圈外。 保证不会出现其他的数。字符串长度不超过 10 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。 接下来 m 行，其中第 i 行包含两个整数 $ a_i,s_i$ ，表示第 i 条指令。若 $a_i=0$，表示向左数 $s_i$ 个人；若 $a_i=1$，表示向右数 $s_i$ 个人。 保证 $a_i$ 不会出现其他的数， $1 \le s_i &lt; n$ 。 输出格式输出一个字符串，表示从第一个读入的小人开始，依次数完 m 条指令后到达的小人的职业。 输入输出样例输入样例： 12345678910117 30 singer0 reader0 mengbier 1 thinker1 archer0 writer1 mogician 0 31 10 2 输出样例： 1writer 输入样例2： 12345678910111213141516171819202110 101 C0 r0 P1 d1 e1 m1 t1 y1 u0 V1 71 11 40 50 30 11 61 20 80 4 输出样例2： 1y 数据范围$1 \le n,m \le 100000$ 解题思路一看就是大 模拟 用一个结构体来存每个玩具的名字和朝向 123456struct Toy &#123; string name; bool faceTo; // 朝向&#125;Toy t[MAXN]; 约定true表示朝向圈外，false表示朝向圈内 在读入操作时，用一个变量now记录当前转到了哪个玩具 最后输出t[now].name即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;map&gt;using namespace std;const int MAXN = 100000 + 10;struct Toy &#123; string name; bool faceTo; // true 表示朝向圈外 // false 表示朝向圈内 &#125;;Toy t[MAXN];int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(); for (int i = 1; i &lt;= n; ++i) &#123; int to; cin &gt;&gt; to; string name; cin &gt;&gt; name; t[i].faceTo = (to == 1 ? true : false); t[i].name = name; &#125; int now = 1; for (int i = 1; i &lt;= m; ++i) &#123; int tA = getint(); bool right = tA == 1 ? true : false; // true 表示在右边 // false 表示在左边 int s = getint(); if (right) &#123; if (t[now].faceTo == true) now -= s; else now += s; &#125; else &#123; if (t[now].faceTo == true) now += s; else now -= s; &#125; if (now &gt; n) now -= n; if (now &lt; 1) &#123; int moved = 1 - now; now = n + 1 - moved; &#125; &#125; cout &lt;&lt; t[now].name &lt;&lt; endl; return 0;&#125; 最后：]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法逆元求法]]></title>
    <url>%2F2018-08-05%2Fmul-inverse-modulo%2F</url>
    <content type="text"><![CDATA[数论中的重要内容 注意：本文只讨论模数为质数的情况，因为当模数为合数时，不一定所有数都有逆元 定义在$mod\ p$的意义下，我们把$x$的乘法逆元写作$x^{-1}$。乘法逆元有这样一条性质： $$x \times x^{-1} \equiv 1\ (mod\ p)$$ 乘法逆元有什么用呢？ 模意义下的除法运算！ 除法运算对于模运算来说并不是「封闭」的，所以我们可以把除法转化成乘法 费马小定理求法前置知识：「快速幂」 $a^{p-1} \equiv 1 (mod\ p)%$ 经过变形，可得 $a \times a^{p-2} \equiv 1(mod\ p)$ 由定义可得，$a$的乘法逆元就是$a^{p-2}$ 这就要用到「快速幂」 1234567891011121314inline int slowPower(int a, int b, int p) &#123; int ans = 1; if (b == 1) return 1; while (b) &#123; if (b &amp; 1) ans = ans * a % p; a = a * a % p; b /= 1; &#125; return ans;&#125;inline int invMod(int x, int p) &#123; return slowPower(x, p-1, p);&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划练习题代码]]></title>
    <url>%2F2018-08-03%2FDP-Exercise%2F</url>
    <content type="text"><![CDATA[DP 是啥？能吃吗？ 本文内容难度：从普及-到普及+/提高 数字三角形问题给你一个数字三角形，计算出从三角形的顶至底的一条路径，使该路径经过的数字总和最大， 规定每一步只能从一个数走到下一层上和它最近的左边的数或者右边的数 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 100;/* * * 设f[i][j]表示从第i行第j列走到底部的最优答案 * 转移方程：f[i][j] = a[i][j] + max(f[i+1][j], f[i+1][j+1]) * 注意边界 * */int f[MAXN][MAXN];int a[MAXN][MAXN];int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; int ans = -23333333; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; f[i][j] = a[i][j] + std::max(f[i-1][j], f[i-1][j-1]); ans = std::max(ans, f[i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 一维线性动态规划最长上升子序列1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 10000 + 10;/* * * 注意子序列可以不连续 * * 设f[i]表示目前选第i个数时的最长上升子序列的长度 * 也就是以第i个数结尾的最长上升子序列的长度 * f[i] = std::max(1, f[j] + 1) * 其中1 &lt;= j &lt; i, a[j] &lt; a[i] * * 时间复杂度O(n^2) * */int f[MAXN], a[MAXN];int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (a[j] &lt; a[i]) f[i] = std::max(1, f[j] + 1); &#125; &#125; cout &lt;&lt; f[n];&#125; 「NOIP2004」合唱队形1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; std::endl;using namespace std;const int MAXN = 10000 + 10;/* * * 正着求一遍最长上升子序列，反着求一遍最长上升子序列 * （也就是接着求一遍最长下降子序列） * 用f数组存最长上升子序列长度 * 用g数组存最长下降子序列长度 * 答案是n - max(f[i] + g[i] - 1) * */int f[MAXN], g[MAXN], a[MAXN];int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (a[j] &lt; a[i]) f[i] = std::max(f[i], f[j] + 1); &#125; &#125; for (int i = n; i &gt;= 1; --i) &#123; for (int j = n+1; j &gt; i; --j) &#123; if (a[j] &lt; a[i]) g[i] = std::max(g[i], g[j] + 1); &#125; &#125; int ans = -23333333; for (int i = 1; i &lt;= n; ++i) &#123; ans = std::max(ans, f[i] + g[i] - 1); &#125; cout &lt;&lt; n - ans &lt;&lt; endl; return 0;&#125; 线段覆盖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* -- DP 做法 -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000000 + 10;/* * * 先对线段排序 * 再设f[i]表示前i条线段中不重叠的最大数量 * f[i] = max(f[i - 1], f[j] + 1) * 其中1 &lt;= j &lt; i, 第j条线段的右端点 &lt;= 第i条线段的左端点 * *//* 这个时间复杂度洛谷会RE（实为TLE） */struct Line &#123; int left, right;&#125; line[MAXN];int f[MAXN];bool stlCmp(Line x, Line y) &#123; return x.right &lt; y.right;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; line[i].left &gt;&gt; line[i].right; if (line[i].left &gt; line[i].right) swap(line[i].left, line[i].right); &#125; sort(line + 1, line + 1 + n, stlCmp); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; if (line[j].right &lt;= line[i].left) f[i] = std::max(f[i], f[j] + 1); &#125; &#125; int ans = -23333333; for (int i = 1; i &lt;= n; ++i) ans = std::max(ans, f[i]); cout &lt;&lt; ans + 1 &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526272829/* -- 贪心做法 -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000000 + 10;struct Line &#123; int left, right;&#125; line[MAXN];bool stlCmp(Line x, Line y) &#123; return x.right &lt; y.right; &#125;int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; line[i].left &gt;&gt; line[i].right; sort(line + 1, line + 1 + n, stlCmp); int maxRight = -23333333, lines = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (maxRight &lt;= line[i].left) ++lines, maxRight = line[i].right; &#125; cout &lt;&lt; lines &lt;&lt; endl; return 0;&#125; 多维动态规划「NOIP2008」传纸条12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAX = 50 + 5;/*/ * * 设dp[i][j][x][y] 表示第一张纸条传到了(i, j)，第二张纸条传到了(x, y)时 * 的最大答案 * dp[i][j][k][l] = std::max( * std::max( * dp[i-1][j][k-1][l], * dp[i][j-1][k-1][l] * ), * std::max( * dp[i-1][j][k][l-1], * dp[i][j-1][k][l-1] * ) * ) * + a[i][j] * + a[k][l] * * 其中 j+1 &lt;= l &lt;= n * 最终答案是dp[m][n-1][m-1][n] */*/int dp[MAX][MAX][MAX][MAX];int n, m, a[MAX][MAX];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; m = getint(), n = getint(); for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; a[i][j] = getint(); &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; for (int k = 1; k &lt;= m; ++k) &#123; for (int l = j + 1; l &lt;= n; ++l) &#123; dp[i][j][k][l] = std::max(std::max(dp[i-1][j][k-1][l], dp[i-1][j][k][l-1]), std::max(dp[i][j-1][k-1][l], dp[i][j-1][k][l-1])) + a[i][j] + a[k][l]; &#125; &#125; &#125; &#125; putint(dp[m][n-1][m-1][n], true); return 0;&#125; 「NOIP2008 普及」 传球游戏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 30 + 2;const int MAXM = 30 + 2;/*/ * * 设dp[i][j]表示球传到第i次，传到第j个小朋友手中时的方案数 * dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] * 其中dp[0][1] = 1，ans = dp[m][1] /*/int n, m;int dp[MAXM][MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(); dp[0][1] = 1; for (int i = 1; i &lt;= m; ++i) &#123; dp[i][1] = dp[i-1][2] + dp[i-1][n]; dp[i][n] = dp[i-1][1] + dp[i-1][n-1]; for (int j = 2; j &lt; n; ++j) &#123; dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]; &#125; &#125; putint(dp[m][1], true); return 0;&#125; 背包问题NASA 的食物计划普及-，很水 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 50 + 5;const int MAXVolume = 400 + 10;const int MAXWeight = 400;int maxVolume, maxWeight, n;int f[MAXVolume][MAXWeight];struct Food &#123; int Volume; int Weight; int Calories;&#125; food[MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool newLine) &#123; if (x &lt; 0) x = -x; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (newLine) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; maxVolume = getint(); maxWeight = getint(); n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; food[i].Volume = getint(); food[i].Weight = getint(); food[i].Calories = getint(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = maxVolume; j &gt;= food[i].Volume; --j) &#123; for (int k = maxWeight; k &gt;= food[i].Weight; --k) &#123; f[j][k] = std::max(f[j][k], f[j - food[i].Volume][k - food[i].Weight] + food[i].Calories); &#125; &#125; &#125; printf("%d\n", f[maxVolume][maxWeight]); return 0;&#125; 装箱问题真 · 背包问题模板题 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 30 + 5;const int MAXV = 20000; int item[MAXN];int f[MAXN][MAXV];int main(int argc, char *const argv[]) &#123; int n, v; cin &gt;&gt; v; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; item[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= v; ++j) &#123; if (j &gt;= item[i]) f[i][j] = std::max(f[i-1][j], f[i-1][j-item[i]] + item[i]); else f[i][j] = f[i-1][j]; &#125; &#125; cout &lt;&lt; v - f[n][v] &lt;&lt; endl; return 0;&#125; 榨取kkksc03实在想不通这题为啥是普及/提高-，不应该是普及-吗 所以这就是你评普及/提高-的理由？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const bool __RETURN = true;const bool __NO_RETURN = false;const int MAXN = 100 + 10;const int MAXM = 200 + 10;const int MAXT = 200 + 10;int n, m ,T; struct Dream &#123; int time; int cost;&#125; d[MAXN];int dp[MAXN][MAXM][MAXT];/* * * 设dp[i][j][k]表示当选择第i个愿望， * 时间不超过j，金钱不超过k时的最大数量 * dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-d[i].time][k-d[i].cost] + 1) * 其中 j &gt;= d[i].time, k &gt;= d[i].cost * */inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(), T = getint(); for (int i = 1; i &lt;= n; ++i) &#123; d[i].time = getint(); d[i].cost = getint(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; for (int k = 1; k &lt;= T; ++k) &#123; if (j &gt;= d[i].time &amp;&amp; k &gt;= d[i].cost) &#123; dp[i][j][k] = std::max(dp[i-1][j][k], dp[i-1][j - d[i].time][k - d[i].cost] + 1); &#125; else &#123; dp[i][j][k] = dp[i-1][j][k]; &#125; &#125; &#125; &#125; putint(dp[n][m][T], __RETURN); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>动态规划，DP</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1892《[BOI2003]团伙》]]></title>
    <url>%2F2018-07-28%2FLuogu-P1892%2F</url>
    <content type="text"><![CDATA[本题来自「2018 SDSC」Day 3 考试题目 题目链接 题目描述1920年的芝加哥，出现了一群强盗。如果两个强盗遇上了，那么他们要么是朋友，要么是敌人。而且有一点是肯定的，就是： 我朋友的朋友是我的朋友； 我敌人的敌人也是我的朋友。 两个强盗是同一团伙的条件是当且仅当他们是朋友。现在给你一些关于强盗们的信息，问你最多有多少个强盗团伙。 Input/Output 格式 &amp; 样例输入格式输入文件gangs.in的第一行是一个整数N(2&lt;=N&lt;=1000)，表示强盗的个数（从1编号到N）。 第二行M(1&lt;=M&lt;=5000)，表示关于强盗的信息条数。 以下M行，每行可能是F p q或是E p q（1&lt;=p q&lt;=N），F表示p和q是朋友，E表示p和q是敌人。输入数据保证不会产生信息的矛盾。 输出格式输出文件gangs.out只有一行，表示最大可能的团伙数。 输入样例12345664E 1 4F 3 5F 4 6E 1 2 输出样例13 解题思路很显然这是一道并查集的题目 初始时我们把每一个人单独列为一个团伙 由题可得，这道题主要有如下合并方式： 我的朋友是我的朋友 我的朋友的朋友是我的朋友 我的敌人的朋友是我的敌人 我的敌人的敌人是我的朋友 那么我们要另开一个$Enemy[\ ]$数组，$Enemy[i]$表示 $i$ 的其中一个敌人 每次合并敌人的时候，先判断是否有记录过敌人： 如果有，那么就把当前的敌人和记录的敌人合并在一个团伙里 如果没有，那么就把当前的敌人记录 最后开一个数组$count[\ ]$进行统计 这里要注意几个点： 开始时并查集数组要开两倍，因为你要把敌人和朋友存在一个数组里 合并敌人时要注意合并的不是敌人本身，而是$Find($敌人$)$ 最后统计的时候也要统计$Find($敌人$)$ 对了，注意输入…建议使用iostream…别问我为什么会写上这句话 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 1000 + 10;int U[MAXN * 2], Enemy[MAXN * 2], n, m;int count[MAXN * 2], cnt;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x) &#123; if (x &lt; 0) &#123; x = -x; &#125; if (x &gt;= 10) &#123; putint(x / 10); &#125; putchar(x % 10 + '0');&#125;int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] = y; return;&#125;int main(int argc, char *const argv[]) &#123; freopen("P1892.in", "r", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt;= n * 2; ++i) U[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; char c; int x, y; cin &gt;&gt; c &gt;&gt; x &gt;&gt; y; switch(c) &#123; case 'F': &#123; Union(x, y); break; &#125; case 'E': &#123; if (Enemy[x] == 0) Enemy[x] = Find(y); else Union(y, Enemy[x]); if (Enemy[y] == 0) Enemy[y] = Find(x); else Union(x, Enemy[y]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) ++count[Find(i)]; for (int i = 1; i &lt;= n; ++i) if (count[i]) ++cnt; printf("%d\n", cnt); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1821 《[USACO07FEB]银牛派对Silver Cow Party》]]></title>
    <url>%2F2018-07-20%2FLuogu-P1821%2F</url>
    <content type="text"><![CDATA[巧妙地把单终点最短路径问题转化为单源最短路径问题 题目地址 题目描述寒假到了，N头牛都要去参加一场在编号为X（1≤X≤N）的牛的农场举行的派对（1≤N≤1000），农场之间有M（1≤M≤100000）条有向路，每条路长Ti（1≤Ti≤100）。 每头牛参加完派对后都必须回家，无论是去参加派对还是回家，每头牛都会选择最短路径，求这N头牛的最短路径（一个来回）中最长的一条路径长度。 Input/Output 格式 &amp; 样例输入格式：第一行三个整数N，M, X； 第二行到第M+1行：每行有三个整数Ai，Bi, Ti ,表示有一条从Ai农场到Bi农场的道路，长度为Ti。 输出格式：一个整数，表示最长的最短路得长度。 输入样例#1：1234567894 8 21 2 41 3 21 4 72 1 12 3 53 1 23 4 44 2 3 输出样例#1：110 题目说明图片来自洛谷 解题思路单源最短路我们都会做，一遍SPFA或Dijkstra就行了。 单终点最短路呢？ 对于这道题，奶牛们从派对分别回家就是一个单源最短路问题，而奶牛们从家到派对就是一个单终点最短路问题。 如何把单终点最短路转化为单源最短路问题？注意：题目中建的是有向边 实在是想不出来的我翻了一波题解，发现他们都在输入的时候另建了一个图，反向存边，就完美地把一个单终点最短路转化为单源最短路因为单源和单终点的区别仅仅是方向改变，很显然这么做是对的 最后的答案是什么？正向建图的距离+反向建图的距离的最大值 代码实现我们在数组后加上「Reversed」，表示它存的是反向的图 评测记录 AC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; #include &lt;algorithm&gt;#include &lt;queue&gt; using namespace std;const int MAXN = 1000 + 10;const int MAXM = 100000 + 10;struct Edge &#123; int prev; int next; int weight;&#125; edge[MAXM], edgeReversed[MAXM];int n, m, x, cnt, maxWeight = -1;int dis[MAXN], head[MAXN], disReversed[MAXN], headReversed[MAXN];bool inQueue[MAXN], inQueueReversed[MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; (ch == '-') &amp;&amp; (x = -1); ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void addEdgeReversed(int prev, int next, int weight) &#123; edgeReversed[cnt].prev = prev; edgeReversed[cnt].weight = weight; edgeReversed[cnt].next = headReversed[next]; headReversed[next] = cnt;&#125;inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].prev = prev; edge[cnt].weight = weight; edge[cnt].next = head[next]; head[next] = cnt; addEdgeReversed(next, prev, weight);&#125;inline void Dijkstra(int s, int n) &#123; memset(inQueue, 0, sizeof(inQueue)); for (int i = 0; i &lt;= n; ++i) dis[i] = 2147483647; std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q; inQueue[s] = true; q.push(make_pair(s, 0)); dis[s] = 0; while (!q.empty()) &#123; int prev = q.top().first; int weight = q.top().second; q.pop(); inQueue[prev] = false; for (int e = head[prev]; e; e = edge[e].next) &#123; if (dis[edge[e].prev] &gt; edge[e].weight + weight) &#123; dis[edge[e].prev] = edge[e].weight + weight; q.push(make_pair(edge[e].prev, dis[edge[e].prev])); &#125; &#125; &#125;&#125;inline void DijkstraReversed(int s, int n) &#123; memset(inQueueReversed, 0, sizeof(inQueueReversed)); for (int i = 0; i &lt;= n; ++i) disReversed[i] = 2147483647; std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q; inQueueReversed[s] = true; q.push(make_pair(s, 0)); while (!q.empty()) &#123; int prev = q.top().first; int weight = q.top().second; q.pop(); inQueueReversed[prev] = false; for (int e = headReversed[prev]; e; e = edgeReversed[e].next) &#123; if (disReversed[edgeReversed[e].prev] &gt; edgeReversed[e].weight + weight) &#123; disReversed[edgeReversed[e].prev] = edgeReversed[e].weight + weight; q.push(make_pair(edgeReversed[e].prev, disReversed[edgeReversed[e].prev])); &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(), x = getint(); int tm = m; while (tm --&gt; 0) &#123; int prev = getint(), next = getint(), weight = getint(); addEdge(prev, next, weight); &#125; int tn = n; Dijkstra(x, n); DijkstraReversed(x, n); for (int i = 1; i &lt;= n; ++i) &#123; maxWeight = std::max(maxWeight, dis[i] + disReversed[i]); &#125; printf("%d\n", maxWeight); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1149《火柴棒等式》]]></title>
    <url>%2F2018-07-15%2FLuogu-P1149%2F</url>
    <content type="text"><![CDATA[「枚举」的入门题目 题目地址 题目描述给你n根火柴棍，你可以拼出多少个形如$ A+B=C$的等式？等式中的 $A 、 B 、 C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$ ）。用火柴棍拼数字 $0-9$ 的拼法如图所示： 图片来自洛谷 注意： 加号与等号各自需要两根火柴棍 如果 $A≠B$ ，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式( $A,B,C&gt;=0$ ) $n$ 根火柴棍必须全部用上 输入输出格式输入格式： 一个整数 $n$($n&lt;=24$) 。 输出格式： 一个整数，能拼成的不同等式的数目。 输入样例#1：114 输出样例#1：12 输入样例#2：118 输出样例#2：19 说明【输入输出样例1解释】 $2$ 个等式为 $0+1=1$ 和 $1+0=1$ 。 【输入输出样例2解释】 $9$ 个等式为： 1234567890+4=40+11=111+10=112+2=42+7=94+0=47+2=910+1=1111+0=11 解题思路枚举思路我们可以枚举$A$和$B$ 上界？ 手算啊 $n&lt;=24$，去掉符号用的4根火柴棒，相当于是「$n&lt;=20$」 再$\frac{n}{2}$（这里只考虑有$A$和$B$两个数字），可得 对于某一个数字，可调用的火柴棒共有10个 由于使用火柴棒数量最少的$1$要使用2根，所以我们假设两个数字都为$11111$，但是显然这样是不成立的，因为$2\times5 + 2 * 5$就已经达到$20$了，没有火柴棒再放第三个数字，那么由此可粗略得出 对于某一个数字，它最高有5位 于是我们可以选择枚举到$9999$，洛谷的评测机上也不会TLE 当然CCF的老爷机就不一定了（ 于是我们可以选择再精确一点 // 未完待续 枚举之后相加，取出所用的火柴棒数，进行判断就好了 预处理思路火柴棒数怎么求？ 新建一个数组 f[10000 * 2 + 10] ，表示i这个数字需要用f[i]根火柴 题目已经给出了f[0~9]，如何处理出f[10~(10000*2)]？ 123456f[i] = f[i/10] + f[i%10]; // (i &gt;= 10)/*这里的i/10可以取它除了个位上其他位的数，在前面已经处理过，所以可以直接使用；这里的i%10可以取它个位上的数，也处理过，可以直接使用。两个火柴棒数目一相加，就能获得火柴棒的总数。*/ 循环一遍就好了 代码实现12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int sticks[10001 * 2];int main(int argc, char *const argv[]) &#123; sticks[0] = sticks[6] = sticks[9] = 6; sticks[1] = 2; sticks[2] = sticks[3] = sticks[5] = 5; sticks[4] = 4; sticks[7] = 3; sticks[8] = 7; int n; cin &gt;&gt; n; int sum = 0; for (int i = 10; i &lt;= 20000; ++i) &#123; sticks[i] = sticks[i/10] + sticks[i%10]; &#125; for (int i = 0; i &lt;= 9999; ++i) &#123; for (int j = 0; j &lt;= 9999; ++j) &#123; if (sticks[i] + 2 + sticks[j] + 2 + sticks[i+j] == n) ++sum; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 国庆清北刷题冲刺班 《角谷猜想》]]></title>
    <url>%2F2018-07-04%2FKakutani%2F</url>
    <content type="text"><![CDATA[不错的字符串模拟 题目来自Air Begin 题目描述某个名字末尾是654321的小A同学是个大家眼中公认的学霸（虽然他永远不承认），他对题目的直觉到了一种可怕的地步，一眼看出题目的算法对他而言只是小 Case，他甚至能在看到一个证明的瞬间敏锐地判断出这个证明的真伪。 现在小A同学机缘巧合地看到了角古猜想（即对于$x$当它为奇数则$x=3x+1$,$x$为偶数，则$x=\frac{x}{2}$，一直重复这个步骤，则最终$x$会变为$1$），在看完这个猜想的一瞬间，他的直觉就来了——他认为角古猜想一定是错的！然后——他立刻就能找出反例！ 他立刻在纸上写满了$n$($1&lt;=n&lt;=1000$)个小于$10^L$($0&lt;=L&lt;=10^4$)的正整数，打算放到他的grand super computer 上去跑，可是他突然觉得有些正整数不是很吉利，可能会干扰到他的最终结果，所以他打算把一些正整数加工一下。 小A觉得4、7、13都是不吉利的数字，所以要把所有正整数里的4、7、13都去掉，如果去掉后得到的新数字里依旧有4、7、13，那么就要继续删掉，直到最后的数组不存在4、7、13，它才是一个吉利的数字。例如$1411733=&gt;111733=&gt;11133=&gt;113=&gt;1$特别规定，如果最后所有数字都被删掉了，就输出$0$小A觉得这个枯燥的工作不适合他这样的天才，于是就把这个工作交给了你。 当然，只要你能顺利解决，小A承诺会在那篇将会震惊世界的论文的特别感谢栏上署上你的大名。 Input/Output 格式 &amp; 样例Input 一共$n+1$行。 第一行一个正整数$n$($1&lt;=n&lt;=100$)，表示数字个数。 接下来每行一个正整数$x$。 Output 一共$n$行。 每行一个正整数，表示输入每个$x$对应的答案。 Sample Input 1 123456513713141713133333337258914117332147483647 Sample Output1 123450113333332589121836 数据范围对于$10%$的数据，$0&lt;=x&lt;=2147483647$对于另外的$10%$数据，给定的数字没有数码$3$对于另外的$10%$数据，$n=1$对于全部的数据，$n$($1&lt;=n&lt;=1000$)，$1&lt;=x&lt;=10^L$($0&lt;=L&lt;=10^4$) 解题思路「$1&lt;=x&lt;=10^L$($0&lt;=L&lt;=10^4$)」 显而易见的高精 进而联想到字符串模拟 这道题有两个点需要注意： 顺序不能乱 1先执行删除4和7的操作，再执行删除13的操作 在删除13时要检查是否残留 1234567样例里有一个数据1411733先删除4和7，得到11133再删除13，得到113假如只删除一次13，那么就会有残留的13出现所以要在删除之后进行检查，否则就需要递归，将13再次删除 代码实现评测记录 AC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;inline string eraseAll4s(string x) &#123; string ret = ""; int len = x.length(); for (int i = 0; i &lt; len; ++i) if (x[i] == '4') x[i] = '-'; // 删除的'4'用'-'表示 for (int i = 0; i &lt; len; ++i) if (isdigit(x[i])) ret += x[i]; // 采集存留的数字，组成一个新的字符串 return ret;&#125;inline string eraseAll7s(string x) &#123; // 代码思想一样，不再赘述 string ret = ""; int len = x.length(); for (int i = 0; i &lt; len; ++i) if (x[i] == '7') x[i] = '-'; for (int i = 0; i &lt; len; ++i) if (isdigit(x[i])) ret += x[i]; return ret;&#125;inline string eraseAll13s(string x) &#123; string ret = ""; int len = x.length(); for (int i = 0; i &lt; len - 1; ++i) &#123; if (x[i] == '1' &amp;&amp; x[i+1] == '3') x[i] = x[i+1] = '-'; // 注意这里要同时检测两个字符 &#125; bool b = false; for (int i = 0; i &lt; len; ++i) if (isdigit(x[i])) ret += x[i]; for (int i = 0; i &lt; len - 1; ++i) &#123; // 重新进行检查 if (ret[i] == '1' &amp;&amp; ret[i+1] == '3') &#123; b = true; break; &#125; &#125; if (b) &#123; ret = eraseAll13s(ret); // 递归删除 &#125; return ret;&#125;string Modify(string x) &#123; string ret = ""; ret = eraseAll4s(x); ret = eraseAll7s(ret); ret = eraseAll13s(ret); // 进行删除 if (ret == "") ret = "0"; return ret;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); int n; string v; cin &gt;&gt; n; while (n --&gt; 0) &#123; /* 这里是一个比较神奇的 while()， 效果相当于 for (int i = 0; i &lt; n; ++i)， 但是会对n进行修改，下标也是从n-1到0 */ cin &gt;&gt; v; cout &lt;&lt; Modify(v) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>自测题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2330 《[SCOI2005]繁忙的都市》]]></title>
    <url>%2F2018-07-04%2FLuogu-P2330%2F</url>
    <content type="text"><![CDATA[接近裸的最小生成树 题目地址 题目描述城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市C的道路是这样分布的：城市中有n个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求： 1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2．在满足要求1的情况下，改造的道路尽量少。 3．在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。 任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。 Input/Output 格式 &amp; 样例输入格式： 第一行有两个整数n,m表示城市有n个交叉路口，m条道路。 接下来m行是对每条道路的描述，u, v, c表示交叉路口u和v之间有道路相连，分值为c。(1≤n≤300，1≤c≤10000，1≤m≤50000) 输出格式： 两个整数s, max，表示你选出了几条道路，分值最大的那条道路的分值是多少。 输入样例#1：1234564 51 2 31 4 52 4 72 3 63 4 8 输出样例#1：13 6 数据范围前面已经提到过， $1 \le n \le 300, 1 \le c \le 10000, 1 \le m \le 50000$ 解题思路「1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。」 显然这是一道最小生成树的题目 但是题目中并没有要求输出最小的总权值，而是要输出最长边边权 所以它和裸的最小生成树还是有一些区别的 代码实现评测记录 AC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 300 + 10;const int MAXM = 50000 + 10;int U[MAXN];int cnt;int cntTree;int n, m;struct Edge &#123; int prev, next, w;&#125; edge[MAXM * 2];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;bool sortCmp(Edge x, Edge y) &#123; return x.w &lt; y.w;&#125;inline int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;int Kruskal() &#123; int ret = -1; int treeAns = 0; sort(edge + 1, edge + 1 + m, sortCmp); for (int i = 1; i &lt;= MAXN; ++i) U[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int eprev = Find(edge[i].prev); int enext = Find(edge[i].next); if (eprev == enext) continue; treeAns += edge[i].w; U[eprev] = enext; ret = max(ret, edge[i].w); // 更新权值 ++cntTree; if (cntTree == n - 1) break; &#125; return ret;&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(); for (int i = 1; i &lt;= m; ++i) &#123; int v = getint(), next = getint(), w = getint(); edge[i].prev = v; edge[i].next = next; edge[i].w = w; &#125; int ans = Kruskal(); printf("%d %d", n - 1, ans); // 显而易见，生成的树肯定有 n - 1 条边，所以直接输出 n - 1 就好 return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
        <tag>图论算法</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法]]></title>
    <url>%2F2018-07-03%2FShortestPath%2F</url>
    <content type="text"><![CDATA[较简单的图论算法 最短路算法有很多种，比较著名的有 Bellman-Ford SPFA（队列优化版 Bellman-Ford） Dijkstra Floyd（基于DP思想） 其中 Floyd 只适用于多源最短路径，SPFA 和 Bellman-Ford 代码易于理解但是效率低，Dijkstra 效率高但是不适用于图中有负边权的情况 至于其他算法……我见过某个dalao用线段树写最短路 本文只介绍单源最短路径中的 SPFA 和 Dijkstra （ Bellman-Ford 由于速度慢于 SPFA 所以忽略）。 SPFASPFA 可以处理图含有负边权的情况，同时又因为它效率较低，所以它更适合处理稀疏图 这里给出数组版代码 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int MAXINT = 2147483647;const int MAXN = 2500 + 5;const int MAXM = 6200 + 5;struct Edge &#123; int v, next, w;&#125;edge[MAXM * 2];int head[MAXN];int cnt;int dis[MAXN];bool inQueue[MAXN];inline void addEdge(int u, int v, int w) &#123; edge[++cnt].v = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;inline int SPFA(int s, int t, int n) &#123; for (int i = 1; i &lt;= n; ++i) dis[i] = MAXINT; dis[s] = 0; inQueue[s] = true; std::queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int v = q.front(); q.pop(); inQueue[v] = false; for (int e = head[v]; e; e = edge[e].next) &#123; if (dis[edge[e].v] &gt; edge[e].w + dis[v]) &#123; dis[edge[e].v] = edge[e].w + dis[v]; if (!inQueue[edge[e].v]) &#123; q.push(edge[e].v); inQueue[edge[e].v] = true; &#125; &#125; &#125; &#125; return dis[t];&#125;int main(int argc, char const *argv[]) &#123; int n, m, s, t; /* n for the nodes' count m for the edges' count s for the start node t for the end node */ scanf("%d %d %d %d\n", &amp;n, &amp;m, &amp;s, &amp;t); for (int i = 0; i &lt; m; ++i) &#123; int u, v, w; scanf("%d %d %d\n", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); addEdge(v, u, w); &#125; printf("%d\n", SPFA(s, t, n)); return 0;&#125; DijkstraDijkstra 不能解决图中有负边权的情况，算法效率较高，适合在不含负边权的稠密/稀疏图中使用 这里还是给出数组写法 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#define mp std::make_pairusing namespace std;const int MAXN = 1000 + 7;const int MAXM = 1000000 + 7;const int INF = 0x7fffffff;typedef long long int ll;typedef std::pair&lt;int, int&gt; Pair;int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') x = -x; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;struct Node &#123; int v, next, w;&#125;edge[MAXM];int num = 0, head[MAXN];bool inQueue[MAXN];ll dis[MAXN]; // dis[i] --&gt; the distance from i to ninline void addEdge(int u, int v, int w) &#123; edge[++num].v = v; edge[num].w = w; edge[num].next = head[u]; head[u] = num;&#125;inline int dijkstra(int s, int t, int n) &#123; // s for start, t for end, n for the count of the nodes for (int i = 1; i &lt;= n; ++i) dis[i] = INF; std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q; inQueue[s] = true; dis[1] = 0; q.push(mp(s,0)); while (!q.empty()) &#123; int v = q.top().first; int value = q.top().second; q.pop(); for (int e = head[v]; e; e = edge[e].next) &#123; if (dis[edge[e].v] &gt; value + edge[e].w) &#123; dis[edge[e].v] = (value + edge[e].w) ; q.push(mp(edge[e].v, dis[edge[e].v])); &#125; &#125; &#125; return dis[t];&#125;int main(int argc, char const *argv[]) &#123; n = getint(), m = getint(); for (int i = 0; i &lt; m; ++i) &#123; int x, y, z; x = getint(), y = getint(), z = getint(); addEdge(x, y, z); &#125; printf("%d\n", dijkstra(1, n, n)); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1955 《[NOI2015]程序自动分析》]]></title>
    <url>%2F2018-05-12%2FLuogu-P1955%2F</url>
    <content type="text"><![CDATA[第一道NOI的题目 洛谷 P1955 题解题目描述在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设x1,x2,x3…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 输入输出格式输入格式：从文件prog.in中读入数据。 输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj； 输出格式：输出到文件 prog.out 中。 输出文件包括t行。 输出文件的第 k行输出一个字符串“ YES” 或者“ NO”（不包含引号，字母全部大写），“ YES” 表示输入中的第k个问题判定为可以被满足，“ NO” 表示不可被满足。 输入输出样例输入 #11234567221 2 11 2 021 2 12 1 1 输出 #112NOYES 输入 #212345678910231 2 12 3 13 1 141 2 12 3 13 4 11 4 0 输出 #212YESNO 数据范围（图片来自洛谷） 解题思路把题目中的「x1=x2」看做x1和x2在同一个集合里，「x1≠x2」看做x1和x2不在同一个集合里…… 好了，显而易见这是道并查集的题目 读懂了题目，下手就很简单了 这里要注意：「x1≠x2」是无法进行的操作（因为你不能强制他们不在同一个集合里！若非要实现，就又要维护一个数组），把它看成查询操作。 而且「x1=x2」类似的操作要先做，「x1≠x2」类似的操作要最后做（因为后者对集合没有影响，它是一个查询操作） 1234567如果你遇到了类似这样的数据：...1 2 01 2 1...那么根据我们的思路， 「1 2 0」是一个查询操作，对集合没有影响，那么就相当于少了一个操作！必须要先进行「x1=x2」类似的合并操作，再做「x1≠x2」类似的查询操作 代码实现90分代码 评测记录（未离散化）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;const int MAXN = 100000 + 10;int U[MAXN], n, t;int e[MAXN], e0[MAXN], x[MAXN], y[MAXN];/* 快读 */inline int getInt() &#123; int s = 0, x = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') x = -x; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] = y; return;&#125;bool Main() &#123; n = getInt(); for (int i = 0; i &lt; MAXN; ++i) &#123; U[i] = i; &#125; memset(e, 0, sizeof(e)); memset(x, 0, sizeof(x)); memset(y, 0, sizeof(y)); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = getInt(), y[i] = getInt(), e[i] = getInt(); &#125; int j = 1; // 第一次做 「x1=y1」的合并操作 for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 1) Union(fx, fy); &#125; // 第二次做 「x1≠y1」的查询操作 for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 0) &#123; if(Find(fx) == Find(fy)) return false; &#125; &#125; return true;&#125;int main() &#123; ios::sync_with_stdio(false); t = getInt(); for (int i = 0; i &lt; t; ++i)&#123; if (Main()) puts("YES"); else puts("NO"); &#125;&#125; 离散化简介——引自百度百科12345离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：原数据：1,999,100000,15；处理后：1,3,4,2；原数据：&#123;100,200&#125;，&#123;20,50000&#125;，&#123;1,400&#125;；处理后：&#123;3,4&#125;，&#123;2,6&#125;，&#123;1,5&#125;； 对一堆数据进行离散化， 先排序 [ 推荐 std::sort() ]（针对有序序列进行离散化） 删除重复元素（节省空间） 对数据进行索引（最终目的） 而其中我们要用到STL提供的pair来储存变量。pair提供一个包含两个数据成员的结构体模板，可以快速访问其中的元素，就像一个压缩包一样（ 代码实现AC代码 评测记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#define Pair pair&lt;ll,ll&gt; using namespace std;typedef long long int ll;const int MAXN = 600000 + 10;int U[MAXN], n, t;int e[MAXN], x[MAXN], y[MAXN];Pair p[MAXN];inline int getInt() &#123; int s = 0, x = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') x = -x; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); U[x] = y; return;&#125;bool stlCmp(Pair x, Pair y) &#123; return (x.first &gt; y.first);&#125;void Disc(Pair a[], int A[]) &#123; int tot = 0; sort(a + 1, a + n*2 + 1, stlCmp); for (int i = 1; i &lt;= n*2; ++i) &#123; if (i == 1 || a[i].first != a[i-1].first) tot++; A[a[i].second] = tot; &#125; &#125; bool Main() &#123; n = getInt(); for (int i = 0; i &lt; 500010; ++i) &#123; U[i] = i; &#125; memset(e, 0, sizeof(e)); memset(x, 0, sizeof(x)); memset(y, 0, sizeof(y)); memset(p, 0, sizeof(p)); for (int i = 1; i &lt;= n; ++i) &#123; int ax = getInt(), ay = getInt(), ae = getInt(); e[i] = ae; p[i] = make_pair(ax, i); p[i + n] = make_pair(ay, i+n); &#125; Disc(p, x); for (int i = 1; i &lt;= n; ++i) y[i] = x[n + i]; for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 1) Union(fx, fy); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 0) &#123; if(Find(fx) == Find(fy)) return false; &#125; &#125; return true;&#125;int main() &#123; ios::sync_with_stdio(false); t = getInt(); for (int i = 0; i &lt; t; ++i)&#123; if (Main()) puts("YES"); else puts("NO"); &#125;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集模板]]></title>
    <url>%2F2018-04-14%2Funion-set%2F</url>
    <content type="text"><![CDATA[并查集模板 题目链接 题目描述如题，现在有一个并查集，你需要完成合并和查询操作。 输入输出格式输入格式： 第一行包含两个整数N、M，表示共有N个元素和M个操作。 接下来M行，每行包含三个整数Zi、Xi、Yi 当Zi=1时，将Xi与Yi所在的集合合并 当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N 输出格式： 如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N 输入输出样例输入输出样例1input: 123456784 72 1 21 1 22 1 21 3 42 1 41 2 32 1 4 output: 1234NYNY 数据说明时空限制：1000ms,128M 数据规模： 对于30%的数据，N&lt;=10，M&lt;=20； 对于70%的数据，N&lt;=100，M&lt;=1000； 对于100%的数据，N&lt;=10000，M&lt;=200000。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;const int MAXN = 10000 + 10;int U[MAXN], m, n;inline int Find(int x) &#123; if (U[x] &lt; 0) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] += U[y]; U[y] = x; &#125;int main() &#123; ios::sync_with_stdio(false); scanf("%d %d", &amp;n, &amp;m); for (int i = 1;i &lt; MAXN;i++) U[i] = -1; int z; for (int i = 0;i &lt; m;i++) &#123; scanf("%d", &amp;z); int x, y; switch(z) &#123; case 1:&#123; scanf("%d %d", &amp;x, &amp;y); Union(x, y); break; &#125; case 2:&#123; scanf("%d %d", &amp;x, &amp;y); if (Find(x) == Find(y)) puts("Y"); else puts("N"); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1536 《村村通》]]></title>
    <url>%2F2018-04-14%2FLuogu-P1536%2F</url>
    <content type="text"><![CDATA[并查集的好题目 题目地址 题目描述某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府“村村通工程”的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？ 输入输出格式输入格式：每个输入文件包含若干组测试测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目N（N&lt;1000）和道路数目M；随后的M行对应M条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从1到N编号。 注意：两个城市间可以有多条道路相通。例如： 3 3 1 2 1 2 2 1 这组数据也是合法的。当N为0时，输入结束。 输出格式：对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。 输入输出样例输入样例1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 输出样例1234102998 解题思路这是道并查集的题目，可以说接近是裸的并查集，但是你没法把这题理解为并查集这就很烦了啊喂 我们可以把它的公路理解成一条一条绳子，用来连接各个城市，可以把几个城市绑在一块（雾 那么这样就更像并查集了 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define DEBUG_CERR(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl;using namespace std;const int MAXN = 1000 + 5;int n, m;int u[MAXN];int Find(int x) &#123; if (u[x] &lt; 0) return x; return u[x] = Find(u[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; u[x] += u[y]; u[y] = x;&#125;int main() &#123; ios::sync_with_stdio(false); while (scanf("%d %d", &amp;n, &amp;m) == 2) &#123; for (int i = 1;i &lt; MAXN;i++) u[i] = -1; for (int i = 1;i &lt;= m;i++) &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); a = Find(a), b = Find(b); if (a != b) Union(a, b); &#125; int ans = 0; for (int i = 1;i &lt;= n;i++) &#123; if (u[i] &lt; 0) ans++; &#125; printf("%d\n", ans - 1); &#125; return 0;&#125; 提交记录]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 模板]]></title>
    <url>%2F2018-04-01%2Fsegmenttree%2F</url>
    <content type="text"><![CDATA[快速查找和修改区间 注意：本文包含洛谷 P3372 【模板】线段树 1 题解 线段树模板前言 什么是线段树？ 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 线段树的主要用途及好处？ 线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。 线段树的应用？ 最简单的应用就是记录线段是否被覆盖，随时查询当前被覆盖线段的总长度。 代码基础函数我们选择一个$O(1)$的取儿子函数： 123456789inline int leftChild(int p) &#123; return p &lt;&lt; 1;&#125;// 左子树 inline int rightChild(int p) &#123; return p &lt;&lt; 1 | 1;&#125;// 右子树 线段树的维护： 1234567891011121314void pushUp(int p) &#123; t[p] = t[leftChild(p)] + t[rightChild(p)];&#125;// 向上维护区间void pushUpMin(int p) &#123; t[p] = std::min(t[leftChild(p)], t[rightChild(p)]);&#125; // 向t[p]下放Min标签void pushUpMax(int p) &#123; t[p] = std::max(t[leftChild(p)], t[rightChild(p)]);&#125; // 向t[p]下放Max标签 递归建树： 123456789101112131415typedef long long int lli;void buildTree(lli p, lli l, lli r) &#123; if (l == r) &#123; ans[p] = a[l]; return; &#125; // 如果左右区间相同，则必是叶子节点 lli mid = (l + r) &gt;&gt; 1; buildTree(leftChild(p), l, mid); buildTree(rightChild(p), mid + 1, r); // 递归 pushUp(p); &#125; // 递归 + 二分建树 区间修改函数1234567891011121314151617181920212223242526272829303132inline void Record(lli p, lli l, lli r, lli k) &#123; tag[p] = tag[p] + k; ans[p] = ans[p] + k * (r - l + 1); // 因为是区间统一改变，所以ans要加元素个数 &#125;// 记录当前节点所代表的区间inline void pushDown(lli p, lli l, lli r) &#123; lli mid = (l + r) &gt;&gt; 1; Record(leftChild(p), l, mid, tag[p]); Record(rightChild(p), mid + 1, r, tag[p]); tag[p] = 0; // 每次更新两个儿子节点，不断向下传递 &#125; inline void update(lli nl, lli nr, lli l, lli r, lli p, lli k) &#123; // 将要修改从 nl 到 nr 的区间 // l,r 为当前节点所储存的区间 // p 为当前节点的编号 if (nl &lt;= l &amp;&amp; r &lt;= nr) &#123; ans[p] += k * (r - l + 1); tag[p] += k; return; &#125; pushDown(p, l, r); lli mid = (l + r) &gt;&gt; 1; if (nl &lt;= mid) update(nl, nr, l, mid, leftChild(p), k) if (nr &gt; mid) update(nl, nr,mid + 1, r, rightChild(p), k); pushUp(p);&#125;// 更新区间 查询区间函数12345678910inline lli query(lli qx, lli qy, lli l, lli r, lli p) &#123; lli res = 0; if (qx &lt;= l &amp;&amp; r &lt;= qy) return ans[p]; lli mid = (l + r) &gt;&gt; 1; pushDown(p, l, r); if (qx &lt;= mid) res += query(qx, qy, l, mid, leftChild(p)); if (mid + 1 &lt;= qy) res += query(qx, qy, mid + 1, r, rightChild(p)); return res; &#125;// 查询区间 依然采用二分的形式… 洛谷 P3372 题解题目描述已知一个数列，你需要进行下面两种操作： 1.将某区间每一个数加上x 2.求出某区间每一个数的和 输入格式第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。 第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。 接下来M行每行包含3或4个整数，表示一个操作，具体如下： 操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k 操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和 输出格式输出包含若干行整数，即为所有操作2的结果。 输入样例12345675 51 5 4 2 32 2 41 2 3 22 3 41 1 5 12 1 4 输出样例12311820 解题思路就是把上面的函数都复制下来就行了= = 没什么多解释的 注释见上面代码 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;// using namespace std;typedef long long int ll;typedef unsigned long long int ull;const int MAXN = 1000000 + 1;ull n, m, a[MAXN], ans[MAXN &lt;&lt; 2], tag[MAXN &lt;&lt; 2];inline ll ls(ll x) &#123; return x &lt;&lt; 1; &#125;inline ll rs(ll x) &#123; return x &lt;&lt; 1 | 1;&#125;void scan()&#123; scanf("%lld %lld", &amp;n, &amp;m); for (ll i = 1;i &lt;= n;i++) &#123; scanf("%lld", &amp;a[i]); &#125;&#125;inline void pushUp(ll p) &#123; ans[p] = ans[ls(p)] + ans[rs(p)];&#125; inline void build(ll p, ll l, ll r) &#123; tag[p] = 0; if (l == r) &#123; ans[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(ls(p), l, mid); build(rs(p), mid + 1, r); pushUp(p);&#125;inline void rec(ll p, ll l, ll r, ll k) &#123; tag[p] = tag[p] + k; ans[p] = ans[p] + k * (r - l + 1);&#125;inline void pushDown(ll p,ll l, ll r) &#123; ll mid = (l + r) &gt;&gt; 1; rec(ls(p), l, mid, tag[p]); rec(rs(p), mid + 1, r, tag[p]); tag[p] = 0;&#125;inline void update(ll nl, ll nr, ll l, ll r, ll p, ll k) &#123; if (nl &lt;= l &amp;&amp; r &lt;= nr) &#123; ans[p] += k * (r - l + 1); tag[p] += k; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if (nl &lt;= mid) update(nl, nr, l, mid, ls(p), k); if (nr &gt; mid) update(nl, nr, mid + 1, r, rs(p), k); pushUp(p);&#125;ll query(ll qx, ll qy, ll l, ll r, ll p) &#123; ll res = 0; if (qx &lt;= l &amp;&amp; r &lt;= qy) return ans[p]; ll mid = (l + r) &gt;&gt; 1; pushDown(p, l, r); if (qx &lt;= mid) res += query(qx, qy, l, mid, ls(p)); if (qy &gt; mid) res += query(qx, qy, mid + 1, r, rs(p)); return res;&#125;int main() &#123; // ios::sync_with_stdio(false); ll a1, b, c, d, e, f; scan(); build(1, 1, n); while (m--) &#123; scanf("%lld", &amp;a1); switch(a1) &#123; case 1:&#123; scanf("%lld %lld %lld", &amp;b, &amp;c, &amp;d); update(b, c, 1, n, 1, d); break; &#125; case 2:&#123; scanf("%lld %lld", &amp;e, &amp;f); printf("%lld\n", query(e, f, 1, n, 1)); break; &#125; &#125; &#125; return 0;&#125;// 注意一下，stdio 和 iostream 混用会出现很多奇怪的bug！]]></content>
      <tags>
        <tag>编程</tag>
        <tag>线段树</tag>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算π]]></title>
    <url>%2F2018-03-31%2Fcalculating-pi%2F</url>
    <content type="text"><![CDATA[计算$π$可不是件容易事 前情提要偶然在WA谷上看到一道题 不得不说很玄学 抱着好奇的心态我点开了题解 发现了一个打表的。。。。 于是心血来潮去搜了一下如何计算π 于是就有了这篇文章 题目描述Handwer STD 要你计算一下圆周率，要求最少为4000位（从小数部分第一位开始算起） 输入描述&amp;样例无输入 输出描述&amp;样例输出$π$，要求保留至少4000位小数。 样例： 13141592653589793...... 其他时限为5000ms 解题解题思路我们需要找到一个合适、可靠且快速的圆周率计算公式 我选择了基于级数的快速收敛公式 这是一个很快、精度也很高的算法 公式为： （懒得写MathJax码了 代码实现1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;long long n = 16366;long long d[16366 + 2];int main() &#123; ios::sync_with_stdio(false); double cost; long long i = 0; while (n - i) d[++i] = 2000; for (;n;n -= 14) &#123; long long p; for (p = 0,i = n;i;i--) &#123; p = p * i + d[i] * 10000; d[i] = p % (2 * i - 1); p /= 2 * i - 1; &#125; printf("%.4d",d[0] + p / 10000); d[0] = p % 10000; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 快速读入 模板]]></title>
    <url>%2F2018-03-23%2FCPP-Fast-RW%2F</url>
    <content type="text"><![CDATA[比某记者还快！ C++ 快速读入、输出在 C++ 上实现快速读入模板，这里是一个读取int 的示例。123456789101112inline int Quick_Read()&#123; int s = 0,w = 1; char ch = getchar(); while (ch &lt;= '0' || ch &gt; '9')&#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0' , ch = getchar(); return s * w;&#125;// 本代码来自 wyh's Blog// 地址: aor.sd.cn 在 C++ 上实现快速输出模板，这里是一个输出int 的示例。12345678910inline void Quick_Write(int x)&#123; if (x &lt; 0)&#123; putchar('-'); re = -re; &#125; // 判断负数 if (x &gt; 9) Quick_Write(x/10); // 判断是否大于10 putchar(x%10 + '0');&#125;]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵乘法]]></title>
    <url>%2F2018-03-10%2Fmatrix-mul%2F</url>
    <content type="text"><![CDATA[“简单”的矩阵乘法 矩阵乘法，就是将两个矩阵相乘 现要求写一个程序，可以实现矩阵相乘。 输入格式第一行三个正整数 $n$、$p$、$m$，表示矩阵的长宽。之后的$n$ 行，每行 $p$ 个整数，表示矩阵 $A$。之后的 $p$ 行，每行 $m$ 个整数，表示矩阵 $B$。 输出格式输出 $n$ 行，每行 $m$ 个整数，表示矩阵 $A×B$ ，每个数模 $10 ^ 9 + 7$ 输出。 输入样例123456783 4 5-2 -8 -9 8-10 0 6 -8-10 -6 6 94 -7 5 -5 910 -2 -10 5 5-3 -7 -3 8 -2-6 7 7 3 -2 良心数据 输出样例123999999898 149 153 999999929 999999951999999997 999999979 999999883 74 999999921 999999835 103 55 95 999999857 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 505;const int INF = 0x3f3f3f3f;const int MOD = 1e9+7;struct Matrix&#123; LL arr[maxn][maxn]; int n,m; Matrix operator * (const Matrix &amp;b)const&#123; // 重载运算符 Matrix res; memset(res.arr,0,sizeof(res.arr)); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; b.m;j++) for(int k = 0;k &lt; m;k++)&#123; (res.arr[i][j] += arr[i][k] * b.arr[k][j] % MOD) %= MOD; &#125; res.n = n;res.m = b.m; return res; &#125;&#125;a,b,ans;// 用结构体来储存矩阵int main()&#123; int n,p,m; scanf("%d %d %d",&amp;n,&amp;p,&amp;m); a.n = n;a.m = p; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; p;j++)&#123; scanf("%lld",&amp;a.arr[i][j]); &#125; // 输入矩阵 b.n = p;b.m = m; for(int i = 0;i &lt; p;i++) for(int j = 0;j &lt; m;j++)&#123; scanf("%lld",&amp;b.arr[i][j]); &#125; ans = a * b; for(int i = 0;i &lt; n;i++)&#123; for(int j = 0;j &lt; m - 1;j++)&#123; (ans.arr[i][j] += MOD) %= MOD; printf("%lld ",ans.arr[i][j]); &#125; (ans.arr[i][m - 1] += MOD) %= MOD; printf("%lld\n",ans.arr[i][m - 1]); &#125; // 输出矩阵 return 0;&#125; 图片 by simimg.com]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 体验记]]></title>
    <url>%2F2018-03-05%2Fwindows10%2F</url>
    <content type="text"><![CDATA[Windows 10 从入门到放弃到重拾再到（伪）精通 终于把Windows 10 的更新配置好了，再也不用5分钟开机了（ 先把方法记一下吧1234567891. DiskGenius 激活Windows分区（默认激活deepin 根目录分区）2. 重启之后引导就炸了3. （进入Windows）使用 EasyBCD 重建Windows引导（可以不添加deepin）4. 重启之后引导还是爆炸的5. （进入deepin）执行 sudo grub-install /dev/sda &amp;&amp; sudo update-grub6. 重启之后还是deepin的grub引导，但是活动分区是Windows的7. 下载Fall Creators更新8. 安装更新9. 正常使用 全程惊悚… 2018.3.5Windows 10 可以正常使用的第一天，同时今天也开学了QAQ 开学什么的，体验最差了，况且今天还有什么收心考试 好在今天作业少，终于有时间写代码了（ · v · ） 用 Dev-C++ 写了 P1179 P1420 P1567 这两道大水题 总体感觉还是不错的 Dev-C++ 界面还行，还能看 后台开着一个火萤桌面，一个Chrome和一个Markdown编辑器 不得不说 Dev-C++ 真的是轻量级，占的内存从不超过100MB，Atom开完100MB就没了 对于这种老爷机真的很有用 我好像可以Wine一个Dev-C++出来…但是不能编译 这次体验感觉还不错，或许我可以主力一段时间… 2018.3.13已经是深夜了，洗漱完又上洛谷打了个卡，写了一道入门难度的大水题 周六因为晚上需要写《矩阵乘法》，所以就没更这篇文章 （话说这个矩阵乘法耗了我一下午…我可能真的太弱了 周六我全天都在使用 Windows 10，除了更 Blog 需要重启到Linux 这几天体验下来，感觉还不错，态度慢慢好转 Windows 10 的触摸板手势真的爽！Deepin 15 的触摸板手势太不灵敏了，经常误触或无效操作全靠友商衬托.png （主要是 Windows 10 的电源调配真的比 Linux 好…耗电比 Linux 少 我现在已经是 Windows 10 主力了，Linux 用来更 Blog 等鼓捣好 Windows Subsystem for Linux （WSL） 之后应该就可以在 Windows 10 上更博客了微软强势拉用户.jpg 2018.3.14今天作业少 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 我在学校就完成了几乎全部的作业，到家就只剩下5个小题 做完作业后便欢欢喜喜地来搞 Windows Subsystem for Linux（WSL） 经过不懈的努力（其实就是重启一次）终于弄好了WSL 现在正在装 g++ 网慢死了QAQ PS：由于我没有截任务栏，所以比例有点奇怪 又用 Dev-C++ 写了一道记忆化搜索的大水题，感觉 Dev-C++ 比 Atom 好用多了，毕竟 Core i3 3110m 带不起 Atom 本来打算今天的 Blog 用 WSL 交，想想还是算了吧，出现意外没时间处理]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找&二分答案]]></title>
    <url>%2F2018-02-06%2FBSAnswer%2F</url>
    <content type="text"><![CDATA[友情提示：先看二分查找，再看二分答案！ 二分查找百度百科原话1二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 二分查找的时间复杂度是$O(log_{2}n)$ 要求 查找的序列必须采用顺序存储结构 查找的序列必须是有序排列的 思路 将需要查找的序列进行排序（一般为升序排列） 将序列中间位置记录的元素与关键字比较 如果相等，则12如果不相等，则```将序列分成左右两个子序列，若元素小于关键字，就到左子序列中查找；否则就到右子序列中查找 代码实现1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;inline bool BinarySearch(int l,int r,int t,int x[])&#123; while (l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if (x[mid] == t) return true; if (x[mid] &lt; t) l = mid + 1; if (x[mid] &gt; t) r = mid - 1; &#125; if (l &gt; r) return false;&#125;int main()&#123; int dest; cin &gt;&gt; dest; int n; cin &gt;&gt; n; int *p = new int[n + 1]; for (int i = 0;i &lt; n;i++) cin &gt;&gt; p[i]; printf("%s\n",BinarySearch(0,n - 1,dest,p)?"YES":"NO"); return 0;&#125; 二分答案看完了二分查找，你会发现二分并没有什么卵用。 对，二分的确没有什么用，但是从它身上衍生出来的二分答案却是一个很有用的东西！ 二分答案，就是通过二分的方式枚举出一个答案来，然后再验证你的查找结果是否正确，从而获取答案 要求&amp;特点 答案具有单调性 题面里包含与“最小的最大，最大的最小”相关的字眼 思路 先将给定的序列排序 参照二分查找，枚举一个答案mid 验证这个答案是否可行 如果可行，12如果不可行，```更新边界，继续寻找答案 代码实现一般模板 其中的check函数需要针对每一个题目进行验证 当然你会写暴力枚举的check也可以借鉴过来#(滑稽) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;inline bool check(int x)&#123; /* code here*/ return true;&#125;int main(int argc, char const *argv[]) &#123; int n,m; cin &gt;&gt; n &gt;&gt; m; int *p = new int[n + 2]; for (int i = 0;i &lt; n;i++) cin &gt;&gt; p[i]; // ----------------------------------- int l = 0,r = n - 1; int ans = 0; while (l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if (check(ans))&#123; l = mid + 1; ans = mid; &#125; else r = mid - 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; // ----------------------------------- return 0;&#125; 推荐题目 「洛谷P2678 跳房子」 出处：NOIP2015 提高组 「洛谷P1824 进击的奶牛」 出处：USACO]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1102 《A-B数对》]]></title>
    <url>%2F2018-02-01%2FLuogu-P1102%2F</url>
    <content type="text"><![CDATA[普及- 的“水”题 题目地址 提前说明：本题难度为普及- 题目描述给出一串数以及一个数字C，要求计算出所有A-B=C的数对的个数。（不同位置的数字一样的数对算不同的数对） 输入输出格式输入格式： 第一行包括2个非负整数N和C，中间用空格隔开。 第二行有N个整数，中间用空格隔开，作为要求处理的那串数。 输出格式： 输出一行，表示该串数中包含的所有满足A-B=C的数对的个数。 输入输出样例输入输出样例1input: 124 11 1 2 3 output: 13 数据说明对于73%的数据，N &lt;= 2000； 对于100%的数据，N &lt;= 200000。 所有输入数据都在longint范围内。 原题目2017/4/29新添数据两组 解析暴力解法粗略一看，这道题是不是特别水？ 只需要用$O(n^2)$的暴力解法不就可以了吗？ ​ 枚举A和B，再判断A-B是否为C 但是！ 你们Naive，没看见那个N&lt;=200000 吗 这样肯定会TLE的啊喂 测试记录 76分 正确解法作为C++选手，我们一定要发扬光大Alexander留给我们的STL 于是我们就可以用std::map映射来做这道题目（注意这是普及-的题目） 将A-B=C转换为A-C=B，然后找这N个数中有几个B就行了 测试记录 AC 代码实现暴力解法1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int *arr,n,c;inline void read()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; c; arr = new int[n]; for (int i = 0;i &lt; n;i++)&#123; cin &gt;&gt; arr[i]; &#125; return;&#125;inline int work()&#123; int ans = 0; for(int i = 0;i &lt; n;i++) for (int j = 0;j &lt; n;j++) if ((arr[i] - arr[j] == c)) ans++; return ans;&#125;int main(int argc, char const *argv[]) &#123; read(); cout &lt;&lt; work() &lt;&lt; endl; return 0;&#125; 正确解法1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int a[200001];inline void LetMeAccept()&#123; int n,c; scanf("%d %d",&amp;n,&amp;c); map&lt;int,int&gt; p; for(int i = 0;i &lt; n;i++)&#123; scanf("%d",a + i); p[a[i]]++; &#125; long long ans=0; for(int i = 0;i &lt; n;i++) ans += p[a[i] + c]; printf("%lld\n",ans);&#125;int main(int argc,char const *argv[])&#123; LetMeAccept(); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论之建立基础的图]]></title>
    <url>%2F2017-12-31%2FCreateGraph%2F</url>
    <content type="text"><![CDATA[背下来就行了 学（背）会建立一个基础的图，是写好图论算法的基础。 具体就是写一个循环，通过构造函数来创建一个一个的边和结点附代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define Inf 2e31-1#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl;#define MAXN 2500 + 5//设定图的最大结点值为2500struct Node;struct Edge;struct Node&#123; Edge *firstEdge; int dist; bool inQueue;&#125; node[MAXN];struct Edge&#123; Node *s,*t; int w; //权值 Edge *next; //下一条边 Edge(Node *s,Node *t,int w) : s(s),t(t),w(w),next(s-&gt;firstEdge); //构造函数&#125;;inline void add(const int &amp;s,const int &amp;t,const int &amp;w)&#123; node[s].firstEdge = new Edge(&amp;node[s],&amp;node[t],w); node[t].firstEdge = new Edge(&amp;node[t],&amp;node[s],w);&#125;/* code here * 请在这里写各种玄学的函数 */ int main(int argc, char const *argv[]) &#123; int n,m,s,t; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i = 1;i &lt;= m;i++)&#123; int u,v,w; cin &gt;&gt; u,v,w; add(u,v,w); &#125; /* code here*/ return 0; &#125; 好了，这样你就可以把一个简单玄学的图建立起来了。]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPFA]]></title>
    <url>%2F2017-12-30%2FSPFA%2F</url>
    <content type="text"><![CDATA[简单的SPFA最短路模板，适用于图的边权有负数的情况。 算法实现：我们用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。运用动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行操作，直至队列空为止。 代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;#define MAXN 2500 + 5#define DEBUG(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; xconst int Inf = 2e31-1;struct Node;struct Edge;struct Node&#123; Edge *firstEdge; int dist; bool inQueue;&#125; node[MAXN];struct Edge&#123; Node *s,*t; int w; Edge *next; Edge(Node *s,Node *t,int w) : s(s),t(t),w(w),next(s-&gt;firstEdge)&#123;&#125;&#125;;inline void add(const int &amp;s,const int &amp;t,const int &amp;w)&#123; node[s].firstEdge = new Edge(&amp;node[s],&amp;node[t],w); node[t].firstEdge = new Edge(&amp;node[t],&amp;node[s],w);&#125;inline int spfa(const int &amp;s,const int &amp;t,const int &amp;n)&#123; for (int i = 1;i &lt;= n;i++)&#123; node[i].dist = Inf; node[i].inQueue = false; //将所有节点的在队列的情况设为false &#125; queue&lt;Node *&gt; q; q.push(&amp;node[s]); node[s].dist = 0; node[s].inQueue = true; while (!q.empty())&#123; Node *u = q.front(); q.pop(); u-&gt;inQueue = false; for (Edge *e = u-&gt;firstEdge;e;e = e-&gt;next)&#123; Node *v = e-&gt;t; if (v-&gt;dist &gt; u-&gt;dist + e-&gt;w)&#123; v-&gt;dist = u-&gt;dist + e-&gt;w; if (!v-&gt;inQueue)&#123; q.push(v); v-&gt;inQueue = true; &#125; &#125; &#125; &#125; return node[t].dist;&#125;int main(int argc, char const *argv[]) &#123; int n,m,s,t; scanf("%d %d %d %d",&amp;n,&amp;m,&amp;s,&amp;t); for (int i = 1;i &lt;= m;i++)&#123; int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; printf("%d",spfa(s,t,n)); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017-10-25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
