<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[公告栏]]></title>
    <url>%2F2019-10-31%2FBulletinBoard%2F</url>
    <content type="text"><![CDATA[这里可能会挂些什么东西。 There may be something here. NOIP2018 RP++热烈庆祝CCF升级评测机配置！热烈庆祝CCF升级评测机配置！]]></content>
  </entry>
  <entry>
    <title><![CDATA[二分图染色学习笔记]]></title>
    <url>%2F2018-12-08%2FUVA10004-Bipartite-Graph-Coloring%2F</url>
    <content type="text"><![CDATA[本质上就是一个 BFS 模板题目地址 算法简介二分图是这样一个图：有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！无向图$G$为二分图的充分必要条件是，$G$至少有两个顶点,且其所有回路的长度均为偶数。判断二分图的常见方法是染色法： 开始对任意一未染色的顶点染色，之后判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色， 若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断，bfs和dfs可以搞定！ ——百度百科 算法流程我一般习惯用 BFS 做二分图染色，因为这样会更好理解。 首先我们确定一个搜索的起点start，一般我确定为$1$。 将这个起点Push()进你的广搜队列中，并将它随便指定为一种颜色（即染色），我一般习惯用1和-1。要注意的是尽量不要使用0，因为染色的color[]数组同时兼顾着vis[]数组的作用。 每次在队列中取出队头，并遍历每一条与它相连的边。 A. 如果当前邻接点 被染过与它相同的颜色，则直接失败。 B. 如果当前节点没被染过色，就将它加入队列。 C. 不管当前邻接点 染没染过色，将它染上与当前节点不同的颜色。 如果整个过程没有失败，则染色成功。 题目描述PDF源文件 输入输出格式输入格式： 输出格式： 输入输出样例1234567891011121314151617181920330 11 22 0320 11 2980 10 20 30 40 50 60 70 80 123NOT BICOLORABLE.BICOLORABLE.BICOLORABLE. 解题思路见上 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)#define RED 1;#define BLUE -1;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 200 + 10; const int MAXM = MAXN * MAXN + 10; struct Node &#123; int now, weight; Node() &#123; now = weight = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125; &#125;; struct Edge &#123; int now, next; Edge() &#123; now = next = 0; &#125; &#125; edge[MAXM]; int head[MAXN], cnt, n, l; short color[MAXN]; inline void Init() &#123; cnt = 0; memset(head, 0, sizeof(head)); memset(color, 0, sizeof(color)); for (int i = 1; i &lt;= cnt + 5; ++i) &#123; Edge tmp; tmp.now = tmp.next = 0; edge[i] = tmp; &#125; &#125; inline void addEdge(int prev, int next) &#123; edge[++cnt].now = next; edge[cnt].next = head[prev]; head[prev] = cnt; &#125; inline bool BoynextdoorFirstSearch(int start = 1) &#123; std::queue&lt;int&gt; q; q.push(start); color[start] = RED; while (!q.empty()) &#123; int now = q.front(); q.pop(); for (int e = head[now]; e; e = edge[e].next) &#123; int to = edge[e].now; if (color[to] == color[now]) return false; if (color[to] == 0) q.push(to); if (color[now] == 1) &#123; color[to] = -1; &#125; else &#123; color[to] = 1; &#125; &#125; &#125; return true; &#125;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using FastIO::getint; while (true) &#123; n = getint(); if (n == 0) break; l = getint(); Init(); for (int i = 1; i &lt;= l; ++i) &#123; int prev = getint(); int next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; if (BoynextdoorFirstSearch()) puts("BICOLORABLE."); else puts("NOT BICOLORABLE."); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
        <tag>图论算法</tag>
        <tag>BFS</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeForces 1073B 《Vasya and Books》]]></title>
    <url>%2F2018-12-08%2FCF1073B%2F</url>
    <content type="text"><![CDATA[很明显是栈了好吧 题目地址 题目大意给定 $n$ 本书,序号分别为$1$到$n$，现在执行$n$个操作， 第$i$个操作需要从栈内取出编号为$b_i$的书，如果该书已经取出，则输出$0$否则将该书从栈内取出，同时取出在栈内比$b_i$靠上的书，并且输出一共取出了几本书 输入输出格式输入格式The first line contains one integer $n~(1 \le n \le 2 \cdot 10^5)$ — the number of books in the stack. The second line contains $n$ integers $a_1, a_2, \dots, a_n~(1 \le a_i \le n)$ denoting the stack of books. The third line contains n n integers $b_1, b_2, \dots, b_n~(1 \le b_i \le n)$ denoting the steps Vasya is going to perform. All numbers $a_1 \dots a_n$ are distinct, the same goes for $b_1 \dots b_n$ . 输出格式Print $n$ integers. The $i$ -th of them should be equal to the number of books Vasya moves to his backpack during the $i$ -th step. 输入输出样例#112331 2 32 1 3 12 0 1 #212353 1 4 2 54 5 1 3 2 13 2 0 0 0 #312366 5 4 3 2 16 5 3 4 2 1 11 1 2 0 1 1 解题思路本文同步发布于洛谷博客 粗略看了一下 貌似没人和我的解法相同 那就来写一发题解吧 在读入的时候 我们用另一个数组lead[i]来存编号为i的书在读入的数组book[]的下标 这样我们在检测读入的书是否被取出时就不用遍历一遍book[] 弹出书本的时候，我们首先看一下这个书本是否被取出 如果是就直接输出0 否则就开始弹出书本 我们用一个变量now = 0记录当前弹出了几个书本，用一个数组vis[i]记录第i本书是否被弹出 在弹出之前，用一个变量orin记录一下还没更新的now 接着在每次弹出的时候更新vis[++now]为真，直到遇到当前要弹出的书本编号 最后orin - now即为答案 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;stack&gt;using std::cin;using std::cout;using std::endl;using std::string;const int MAXN = 2e5 + 10;int n;int book[MAXN];int lead[MAXN];bool vis[MAXN];int now = 0;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; ++i) &#123; scanf("%d", book + i); lead[book[i]] = i; // 让lead[]作为book[]的索引，查找的时候快一些 &#125; for (int i = 1; i &lt;= n; ++i) &#123; int o; scanf("%d", &amp;o); if (vis[lead[o]]) printf("0 "); // 被弹过了，输出0 else &#123; int orin = now; while (book[++now] != o) &#123; vis[now] = true; // 循环更新vis（弹出书本） &#125; vis[now] = true; printf("%d ", now - orin); &#125; &#125; return 0;&#125; 总感觉自己的代码能被 Hack]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P4568《飞行路线》]]></title>
    <url>%2F2018-11-25%2FBZOJ2763-Luogu-P4568-JLOI2011%2F</url>
    <content type="text"><![CDATA[入门级别的分层图最短路 题目地址双倍经验 前言先介绍一下分层图最短路。 分层图最短路是指在可以进行分层图的图上解决最短路问题。一般模型是：在图上，有k次机会可以直接通过一条边，问起点与终点之间的最短路径。 题目描述Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在nn个城市设有业务，设这些城市分别标记为00到n-1n−1，一共有mm种航线，每种航线连接两个城市，并且航线有一定的价格。 Alice和Bob现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多kk种航线上搭乘飞机。那么Alice和Bob这次出行最少花费多少？ 输入输出格式输入格式数据的第一行有三个整数，n,m,k，分别表示城市数，航线数和免费乘坐次数。 第二行有两个整数，s,t，分别表示他们出行的起点城市编号和终点城市编号。 接下来有m行，每行三个整数，a,b,c，表示存在一种航线，能从城市a到达城市b，或从城市b到达城市a，价格为c。 输出格式只有一行，包含一个整数，为最少花费。 输入输出样例输入样例#1： 123456785 6 10 40 1 51 2 52 3 53 4 52 3 30 2 100 输出样例#1： 18 解题思路这就是分层图最短路的模板但为什么是省选/NOI-呢 我们用DP的思想来看设dis[i][j]表示起点到i点在j层的最短路 如何分层？理解性记忆。例如本题最多有十层，第k层表示免费了k次的最短路 如何跑最短路？洛谷卡SPFA，BZOJ不卡SPFA，但是都要注意把空间开大10倍，不然是过不去的（5次TLE的惨痛经验）在跑 Dijkstra 的时候，我们用了一个pair来存当前到达的点和已走过的路径；这次我们需要多维护一个东西：当前的层数。 1234567891011121314struct Node &#123; int id; // 当前到达的点 int weight; // 已走过的路径 int now; // 当前的层数 Node() &#123; id = weight = now = 0; &#125; // 重载运算符，用于优先队列 bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125;&#125;; 在更新dis的时候，我们需要对这一层的点和下一层的点分别进行更新 123456789if (!vis[to][Floor] &amp;&amp; dis[to][Floor] &gt; dis[now][Floor] + edge[e].weight) &#123; dis[to][Floor] = dis[now][Floor] + edge[e].weight; q.push(NewNode(to, dis[to][Floor], Floor));&#125;if (!vis[to][Floor] &amp;&amp; Floor + 1 &lt;= K &amp;&amp; dis[to][Floor + 1] &gt; dis[now][Floor]) &#123; dis[to][Floor + 1] = dis[now][Floor]; q.push(NewNode(to, dis[to][Floor + 1], Floor + 1));&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; const int MAXM = 500000 + 10; const int MAXK = 10 + 5; struct Node &#123; int id, weight, now; Node() &#123; id = weight = now = 0; &#125; bool operator &lt; (const Node &amp;that) const &#123; return weight &gt; that.weight; &#125; &#125; head[MAXN]; struct Edge &#123; int now, next, weight; &#125; edge[MAXM]; int n, m, k, s, t, K, cnt, dis[MAXN][MAXK]; bool vis[MAXN][MAXK]; inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].now = next; edge[cnt].weight = weight; edge[cnt].next = head[prev].id; head[prev].id = cnt; &#125; Node NewNode(int id, int weight, int now) &#123; Node tmp; tmp.id = id; tmp.weight = weight; tmp.now = now; return tmp; &#125; void SPFA() &#123; memset(dis, 0x7f, sizeof(dis)); std::priority_queue&lt;Node&gt; q; For (i, 0, K) dis[s][i] = 0; q.push(NewNode(s, 0, 0)); while (!q.empty()) &#123; Node NowNode = q.top(); q.pop(); int Floor = NowNode.now; int now = NowNode.id; if (vis[now][Floor]) continue; vis[now][Floor] = true; for (int e = head[now].id; e; e = edge[e].next) &#123; int to = edge[e].now; if (!vis[to][Floor] &amp;&amp; dis[to][Floor] &gt; dis[now][Floor] + edge[e].weight) &#123; dis[to][Floor] = dis[now][Floor] + edge[e].weight; q.push(NewNode(to, dis[to][Floor], Floor)); &#125; if (!vis[to][Floor] &amp;&amp; Floor + 1 &lt;= K &amp;&amp; dis[to][Floor + 1] &gt; dis[now][Floor]) &#123; dis[to][Floor + 1] = dis[now][Floor]; q.push(NewNode(to, dis[to][Floor + 1], Floor + 1)); &#125; &#125; &#125; &#125;&#125;signed main() &#123; using namespace Solution; using FastIO::getint; n = getint(); m = getint(); k = getint(); s = getint(); t = getint(); K = k; For (i, 1, m) &#123; int prev = getint(); int next = getint(); int weight = getint(); addEdge(prev, next, weight); addEdge(next, prev, weight); &#125; SPFA(); int ans = 2147482333; for (int i = 0; i &lt;= k; ++i) &#123; ans = std::min(ans, dis[t][i]); &#125; FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>省选</tag>
        <tag>最短路</tag>
        <tag>分层图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让你的 PC 更加安全]]></title>
    <url>%2F2018-11-24%2FSecureYourPC%2F</url>
    <content type="text"><![CDATA[Password: 🔑 前言今天（2018.11.24）中午时分我被 Logey 绑住胳膊眼睁睁地看着 RainAir 机惨我RainAir 删除了我的用户密码Shq 修改了我的博客文件折腾了一个中午才恢复过来因为这样 我决定写下这篇文章 简介关于加密┌────────────┐│加密，是以某种特殊的算法││改变原有的信息数据，使得││未授权的用户即使获得了已││加密的信息，但因不知解密││的方法，仍然无法了解信息││的内容。 ——百度百科&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;│└────────────┘ 为什么要加密先不谈什么数据泄露、隐私恶意利用等诸如此类的事，我们来看机惨 一次机惨，轻则「I AK ***」，重则rm -rf / --no-preserve-root 所以锁好自己的电脑是非常重要的 Windows &amp; macOS 通用解决方案当然是设好自己的密码。尽量设复杂且好记的密码，并且保证自己打这个密码的速度足够快，不会让人记住。有生物识别系统的可以考虑安全性高的生物识别系统，像目前已经成熟的「指纹识别」和「Windows Hello」。 macOS 独占解决方案固件密码在开机时按住「⌘+R」，进入恢复模式；点击菜单栏中的「实用工具」，点击「启动安全性实用工具」；输入自己的密码并记牢；最后直接重启即可生效。 用途？设定固件密码之后，进入恢复模式就需要密码了。同样是在恢复模式下，用命令resetpassword可以更改密码！ FileVaultFileVault 会自动直接地对主目录的内容进行加密和解密。真正的安全感来自知道在没有获得允许的时候，没有人可以翻看你的文件。FileVault 使用最新的政府安全标准来保护你的辛勤劳动成果。它保护你主文件夹上的所有信息不被窥测，因此你的商业机密、假期购物单、以及个人财政记录仍然是秘密。FileVault 使用128位高级加密标准 Advanced Encryption Standard 对你主目录下的所有内容进行加密。这个高性能的算法会自动实时加密和解密，因此你甚至不知道它的发生。 ——百度百科 打开方式：「系统偏好设置」→「安全性与隐私」→「文件保险箱」 Time MachineTime Machine 是自动备份功能的一大突破，它内建於 Mac OS X，能为 Mac 上的一切建立最新拷贝，包括数位相片、音乐、家庭影片与文件。现在，只要您有需要，就能轻易回到过去恢复任何资料。 ——百度百科这种方法主要是用来预防被机惨后发生的所有特殊情况，例如博客文件被覆盖，重要文件丢失等等。打开方式：「系统偏好设置」→「时间机器」 加密映像如果有什么东西你想要用密码保护，那加密的映像确实是最好的工具。 方法：「Spotlight Search」Disk Utility.app【文件】【新建映像】【来自文件夹的映像】注意：映像默认只读，如果想让映像可读写，就必须要在「映像格式」里将「压缩」改成「读/写」 Windows 独占解决方案这里其实上面说的东西，Windows 都有替代品。固件密码有 BIOS 里的 Secure Lock，加密映像可以用 UltraISO，磁盘加密可以用 BitLocker ……]]></content>
      <tags>
        <tag>只有经历过的人才知道的世界</tag>
        <tag>使用指南</tag>
        <tag>毒瘤</tag>
        <tag>优化</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2010《回文日期》]]></title>
    <url>%2F2018-11-10%2FLuogu-P2010%2F</url>
    <content type="text"><![CDATA[枚举+判断 题目描述在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。 牛牛习惯用88位数字表示一个日期，其中，前44位代表年份，接下来22位代表月 份，最后22位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。 牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。现 在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存 在的日期是回文的。 一个88位数字是回文的，当且仅当对于所有的i ( 1 \le i \le 8)i(1≤i≤8)从左向右数的第i个 数字和第9-i9−i个数字（即从右向左数的第ii个数字）是相同的。 例如： •对于2016年11月19日，用88位数字2016111920161119表示，它不是回文的。 •对于2010年1月2日，用88位数字2010010220100102表示，它是回文的。 •对于2010年10月2日，用88位数字2010100220101002表示，它不是回文的。 每一年中都有1212个月份： 其中，1,3,5,7,8,10,121,3,5,7,8,10,12月每个月有3131天；4,6,9,114,6,9,11月每个月有3030天；而对于22月，闰年时有2929天，平年时有2828天。 一个年份是闰年当且仅当它满足下列两种情况其中的一种： 1.这个年份是44的整数倍，但不是100100的整数倍； 2.这个年份是400400的整数倍。 例如： •以下几个年份都是闰年：2000,2012,20162000,2012,2016。 •以下几个年份是平年：1900,2011,20141900,2011,2014。 Input / Output 格式 &amp; 样例输入格式两行，每行包括一个88位数字。 第一行表示牛牛指定的起始日期。 第二行表示牛牛指定的终止日期。 保证 $date_i$和都是真实存在的日期，且年份部分一定为4位数字，且首位数字不为0。 保证 $date_1$—定不晚于 $date_2$ 。 输出格式一个整数，表示在$date_1$和$date_2$之间，有多少个日期是回文的。 输入输出样例输入样例#1： 122011010120111231 输出样例#1： 11 输入样例#2： 122000010120101231 输出样例#2： 12 说明【样例说明】 对于样例1，符合条件的日期是20111102。 对于样例2，符合条件的日期是20011002和20100102。 【子任务】 对于$60\%$的数据，满足$date1 = date2$。 解题思路我们考虑直接枚举月和日。 对于每一个月，我们用M[i]表示第i月有多少天。这里要注意的是不用单独判闰年，2月29对应的是92200229，而9220是闰年。 构建字符串直接参照代码，最后比较一下即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */#define GetMonth(x) ((x / 100) % 100)#define GetDay(x) (x % 100)#define GetYear(x) (x / 10000)#define isFullYear(x) ((GetYear(x) % 400 == 0) || (GetYear(x) % 10 == 0 &amp;&amp; GetYear(x) % 4 != 0))using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int M[12 + 1] = &#123;0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;; int start; int endd; int ans;&#125;signed main() &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; cin &gt;&gt; start; cin &gt;&gt; endd; for (int i = 1; i &lt;= 12; ++i) &#123; for (int j = 1; j &lt;= M[i]; ++j) &#123; int now = 0; now += j; now += i * 100; now += 10000000 * (j % 10); now += 1000000 * (j / 10); now += 100000 * (i % 10); now += 10000 * (i / 10); if (start &lt;= now &amp;&amp; now &lt;= endd) ++ans; &#125; &#125; FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>枚举</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LYOI初中坑题组」模拟赛#2 题解]]></title>
    <url>%2F2018-11-05%2FLYOI-Mid-KT-Team-Contest2%2F</url>
    <content type="text"><![CDATA[暴力能过的题目 前言题面 &amp; 数据依然来自山河 评测 Powered by 洛谷OnlineJudge T1. 复制-粘贴题目描述小 y 是一个聪明的程序员，但是他懒到了极致，在输入程序时甚至不愿意多打一行代码。 有一次，小 y 发现他的一个程序需要输入 n 行一模一样的代码，怎么办呢？ 他首先输入了第 1 行，然后通过 1 次“复制-粘贴”命令得到了第 2 行，再通过 1 次“复制-粘贴”命令得到了第 3-4 行………..直到完成这 n 行代码的输入。 小 y 懒得得意洋洋，正好遇到初学编程的小 x，他就想考考小 x，顺便为难为难他以炫耀自己的聪明才智和编程水平。于是把“复制-粘贴”的伎俩告诉小 x，并让小 x 编程计算最少通过几次“复制-粘贴”命令可以得到正好 n 行的代码？ 输入输出格式输入格式：一行一个正整数 n, 输出格式：一行一个正整数，表示最少的“复制-粘贴”次数 输入输出样例输入样例#1：4输出样例#1：2 解题思路简单推一下就可以知道答案是$\lceil log_2n \rceil$ 这里要注意的是C++中的$log$是以$e$为底的求$\lceil log_2n \rceil$的代码为ceil(log(n) / log(2)) 代码实现12345678910#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; int a; cin &gt;&gt; a; cout &lt;&lt; ceil(log(a) / log(2)) &lt;&lt; endl; return 0;&#125; T2. 足球联赛题目描述一个足球联赛由 n 只球队构成。在一个赛季中，每只球队都要与其它球队各比赛两场。 一场比赛在主场，一场在客场。赢一场得 3 分，输一场不得分，平局两支队伍各得 1 分。现在，给你一个 n*n 的矩阵表示比赛情况。第 i 行第 j 列的字母表示在第 i 只队伍主场的比赛情况， W 表示主队赢， L 表示主队输， D 表示平局。 需要你求出得分最高的队伍的编号，如果有分数相同的，在一行中按字典序输出队伍编号。 输入输出格式输入格式：第一行，一个整数 n 。 接下来 n 行，每行 n 个字符，表示输赢情况。 第 i 行第 i 列为 - ,因为一只队伍不可能与自己比赛。 输出格式：得分最高的队伍编号。如有多个在一行中输出，用一个空格分开 输入输出样例输入样例#1： 12343 -WWW-WWW- 输出样例#1： 11 2 3 输入样例#2： 1234565 -DWWDL-WLLDD-WDDDL-LDDLL- 输出样例#2： 11 解题思路直接照题意模拟即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 50 + 10; int n; int score[MAXN]; char sc[MAXN][MAXN]; void Read() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; For (i, 1, n) &#123; For (j, 1, n) &#123; cin &gt;&gt; sc[i][j]; &#125; &#125; &#125; void Work() &#123; ios::sync_with_stdio(false); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (i == j) continue; switch(sc[i][j]) &#123; case 'W': &#123; score[i] += 3; break; &#125; case 'L': &#123; score[j] += 3; break; &#125; case 'D': &#123; score[i] += 1; score[j] += 1; break; &#125; &#125; &#125; &#125; int Max = -2147482333; For (i, 1, n) Max = std::max(Max, score[i]); For (i, 1, n) if (score[i] == Max) cout &lt;&lt; i &lt;&lt; ' '; cout &lt;&lt; endl; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; Read(); Work(); return 0;&#125; T3. 捕食关系题目描述在海洋中，有食肉类的鱼和食草类的鱼，某种食肉类的鱼捕食食草类的鱼当且仅当自己的体重大于对方。 现在给出两类鱼各自的体重，求有多少对捕食关系。 输入输出格式输入格式：每组测试数据有三行。 第一行有两个整数 m， n，分别代表食肉类的鱼的种类数和食草类的鱼的种类数。 第二行 m 个数，第三行 n 个数，代表各自的体重。 输出格式：一个整数，表示有多少对捕食关系。 输入输出样例输入样例#1：5 38 1 7 3 13 6 1输出样例#1：7 解题思路正解不会 暴力能过 我不知道纯暴力能不能过 反正我们要优化一下 首先把食草鱼体重从小到大排个序那么我们在枚举食肉鱼的时候，就可以遇见在第一个体重更大的食草鱼的时候break掉，做法的正确性是显然的 时间复杂度均摊$O(n^2)$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;#include &lt;cmath&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXNM = 20000 + 10; int n, m; int bigFish[MAXNM], smallFish[MAXNM]; void Read() &#123; using FastIO::getint; m = getint(); n = getint(); For (i, 1, m) &#123; bigFish[i] = getint(); &#125; For (i, 1, n) &#123; smallFish[i] = getint(); &#125; &#125; void Work() &#123; int cnt = 0; sort(smallFish + 1, smallFish + 1 + n); For (i, 1, m) &#123; For (j, 1, n) &#123; if (smallFish[j] &gt;= bigFish[i]) break; ++cnt; &#125; &#125; FastIO::putint(cnt, '\n'); &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; Read(); Work(); return 0;&#125; T4. 幻方题目描述大家都知道 n 阶奇数幻方吧？如下为一个 5 阶幻方： 17 24 1 8 15 23 5 7 14 16 4 6 13 20 22 10 12 19 21 3 11 18 25 2 9现在，输入奇数 n，输出该奇数幻方最右下角的元素值。 输入输出格式输入格式：一行一个数 n。 输出格式：一行一个数，表示该奇数幻方右下角的值。 输入输出样例输入样例#1：5输出样例#1：9 解题思路找规律 指点迷津 代码实现不给]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>自测</tag>
        <tag>比赛</tag>
        <tag>暴力</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LYOI初中坑题组」模拟赛#1 题解]]></title>
    <url>%2F2018-11-03%2FLYOI-Mid-KT-Team-Contest1%2F</url>
    <content type="text"><![CDATA[当一个选手比你小，还比你强…… 前言题面 &amp; 测试输入来自山河 T1. 求和题面小马克今年成为小学生。不久后她将进行她的第一次考试，其中包括数学考试。 她非常认真地复习，她认为自己已经准备好了。她的哥哥通过给她提出问题并解决的方式帮助她。 他的问题是给定一连串整数：依次由 1 个 1，2 个 2，3 个 3 等组成，即1223334444……。 现在他给马克两个整数 A 和 B； 他的任务是求出由第 A 个到第 B 个数的。如果 A 是 1， B是 3， 答案为 1+2+2=5。 给一个问题， 然后计算它们的和， 马克的哥哥能够验证答案正确与否。 输入输出格式 &amp; 样例输入格式：输入文件 instruckcije.in 只有一行， 包括正整数 A 和 B。 输出格式：输出文件 instruckcije.out 共一行， 为和的值。 输入样例#1：1 3输出样例#1：5 输入样例#2：1 1000输出样例#2：29280 数据范围$1 \leq A,B \leq 1000$ 解题思路首先这题是一个签到题无误了 数据范围如此之小，我们可以直接把序列初始化出来，再处理出一个前缀和数组，最后输出即可。 时间复杂度……$O(1)$？反正都是常数 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXLENGTH_1 = 1000 + 10; int seq[MAXLENGTH_1], sum[MAXLENGTH_1]; void Init() &#123; int now = 1, cur = 0, i = 0; while (i &lt;= 1001) &#123; ++cur; seq[++i] = now; if (cur == now) &#123; cur = 0; ++now; &#125; &#125; for (int i = 1; i &lt;= 1000; ++i) &#123; sum[i] = sum[i-1] + seq[i]; &#125; &#125; void Work1() &#123; using FastIO::getint; Init(); int x = getint(); int y = getint(); if (x &gt; y) swap(x, y); FastIO::putint(sum[y] - sum[x-1], '\n'); &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work1(); return 0;&#125; T2. 猜歌名题面“Guess the song” 是一项在年轻程序员中非常流行的游戏。它是一种集技能、智慧、 耐性于一体的游戏。这个游戏给玩游戏的人放音乐， 游戏者的目标是尽可能快地猜这首歌 的歌名。 Mirko 可能不是一个很好的程序员， 但他是一个世界级的猜歌者。 Mirko 总是在专辑里的某首歌播放出至少一半歌词的时候猜出歌名。所有歌名的单词是唯一的（没有一个单词会出现一次或更多次）。 写一个程序， 给出歌名和专辑名， 看看 Mirko 在这首歌的哪个点上（在多少个单词之后）猜出歌名。 输入输出格式 &amp; 样例输入格式：第一行：包含一个整数 N， 它是一首歌里的单词数目。接下来的 N 行每一行包含歌名的一个单词。第 N+2 行： 包含一个整数 M， 它是专辑里的单词数目。接下来的 M 行每一行包含专辑里的一个单词。歌名和专辑里的所有单词由 1 到 15 个小写英文字母组成。 输出格式：共一行， 包含一个数， 表示 Mirko 在第几个单词处猜出歌曲名。 输入样例#1：3sedamgladnihpatuljaka7sedamdanasedamnocisedamgladnihgodina 输出样例#1：6 解题思路我们称输入的N个单词为WN，输入的M个单词为WM 那么题目就是要求我们找出一个最小ANS，使得在WM中的前ANS个单词满足有至少一半的WN中的单词 那么数据范围依然极小，直接暴力算完 当然我看着貌似能二分答案太懒不写单调性显然，当$\text{ANS}$成立的时候，满足$\text{ANS} \leq \text{ANS}_1 \leq \text{M}$的$\text{ANS_1}$都是成立的。 这里要注意的是当N为奇数时，N的一半$=\lfloor\frac{N}{2}\rfloor + 1$，否则N的一半$=\frac{N}{2}$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 50 + 10; const int MAXM = 10000 + 10; string song[MAXN]; string album[MAXM]; map&lt;string, bool&gt; vis; int n, m, most; inline bool Check() &#123; int ret = 0; For (i, 1, n) if (vis[song[i]]) ++ret; return ret &gt;= most; &#125; void Work2() &#123; cin &gt;&gt; n; For(i, 1, n) &#123; cin &gt;&gt; song[i]; &#125; cin &gt;&gt; m; most = ((n % 2) == 0 ? n / 2 : n / 2 + 1); For(i, 1, m) &#123; cin &gt;&gt; album[i]; //cout &lt;&lt; album[i] &lt;&lt; endl; vis[album[i]] = true; if (Check()) &#123; printf("%d\n", i); return; &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work2(); return 0;&#125; T3. 黑白棋题面Lagno 是一种二人智力游戏。 游戏设有一个黑方和一个白方。游戏桌面是正方形的， 包含 8 行 8 列。 如果黑方玩家走出这样一步棋：将一枚黑子放在任一空格上， 而在这个空格的八个方向（上、下、左、右和 4 个对角线方向）的至少一个方向上有一排白子被夹在这枚新下的黑子和其他黑子之间， 任何方向， 在新黑子和原来黑子之间的所有白子都要变成黑子。为这个游戏设计一个程序， 计算一步棋中黑方能转变的白子数量的最大值。 输入输出格式 &amp; 样例输入格式：输入文件 lango.in 共 8 行， 每行 8 个字符；“.”代表一个空格；“B”代表黑子，“W” 代表白子。 输出格式：输出文件 lango.out 共一行， 有一个整数， 表示一步中黑方能吃掉白子的最大数， 如果无法吃掉就输出“0”。 输入输出样例输入样例#1： 12345678...........................BW......WB........................... （这个说实话不等宽不行 输出样例#1： 11 解题思路暴！力！能！过！输出0拿9分 暴力算法数据范围如此之小，我们不如直接枚举所有空格点，对这个点进行八向扩展，累加答案，最后取$max$即可 正解当然是DFS我们还是枚举每一个点，只不过这次不暴力扩展了。我们用dx[]和dy[]来记八个方向，根据它来扩展。dfs(int now, int x, int y)中的now就表示现在是第now个方向 边界肯定是要判的（x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8），当前是不是空格子也要判（s[i][j] == &#39;.&#39;），如果有任意一个满足就直接return -INF如果当前碰到了一个黑格子，说明到头了，return 0即可否则return dfs(now, x + dx[now], y + dy[now]) + 1 想是有点难想的，但是代码很好看懂。 代码实现暴力算法***毒瘤警告*** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int dx[8] = &#123;-1, 1, 0, 0, -1, -1, 1, 1&#125;; const int dy[8] = &#123; 0, 0, -1, 1, -1, 1, -1, 1&#125;; const int MAXX_Y = 8 + 2; short Map[MAXX_Y][MAXX_Y]; // 0: blank // 1: Black // 2: White int ans = 0; void Read() &#123; // 初始化 for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; char c; cin &gt;&gt; c; switch (c) &#123; case '.': &#123; Map[i][j] = 0; break; &#125; case 'B': &#123; Map[i][j] = 1; break; &#125; case 'W': &#123; Map[i][j] = 2; break; &#125; &#125; &#125; &#125; &#125; int getAnswer(int x, int y) &#123; // 获取上下左右的可扩展数量 int ret = 0; int current = 0; int ox = x; int oy = y; while (true) &#123; ++current; ++x; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (x == 8 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --x; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (x == 1 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; ++y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (y == 8 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if (y == 1 &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; return ret; &#125; int getAnswerAlt(int x, int y) &#123; // 获取四个对角线上的可扩展数量 int ret = 0; int current = 0; int ox = x; int oy = y; while (true) &#123; ++current; ++x; ++y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 8 || y == 8) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --x; --y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 1 || y == 1) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; --x; ++y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 1 || y == 8) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; while (true) &#123; ++current; ++x; --y; if (Map[x][y] == 0) &#123; current = 0; break; &#125; if (Map[x][y] == 1) break; if ((x == 8 || y == 1) &amp;&amp; Map[x][y] == 2) &#123; current = 0; break; &#125; &#125; if (current &gt; 0) --current; ret += current; current = 0; x = ox; y = oy; return ret; &#125; void Search() &#123; for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; if (Map[i][j] != 0) continue; ans = std::max(ans, getAnswer(i, j) + getAnswerAlt(i, j)); &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Read(); Search(); putint(ans, '\n'); return 0;&#125; 正解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int dx[8 + 1] = &#123;0, -1, -1, 0, 1, 1, 1, 0, -1&#125;; const int dy[8 + 1] = &#123;0, 0, 1, 1, 1, 0, -1, -1, -1&#125;; const int INF = 2147482333; char s[8 + 2][8 + 2]; int ans, Max; void Init() &#123; for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; cin &gt;&gt; s[i][j]; &#125; &#125; &#125; int DFS(int now, int x, int y) &#123; if (x &lt; 1 || x &gt; 8 || y &lt; 1 || y &gt; 8 || s[x][y] == '.') return -INF; if (s[x][y] == 'B') return 0; return DFS(now, x + dx[now], y + dy[now]) + 1; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Init(); for (int i = 1; i &lt;= 8; ++i) &#123; for (int j = 1; j &lt;= 8; ++j) &#123; for (int k = 1; k &lt;= 8; ++k) &#123; int p = 0; if (s[i][j] == '.') &#123; p = DFS(k, i + dx[k], j + dy[k]); if (p &gt; 0) ans += p; // 累计答案 &#125; &#125; Max = std::max(Max, ans); // 更新答案 ans = 0; &#125; &#125; putint(Max, '\n'); return 0;&#125; T4. 跳格子题面Nikola 现在已经成为一个游戏里的重要人物。这个游戏是由一行 N 个方格， N个方格 用 1 到 N 的数字表示。 Nikola 开始是在 1 号位置， 然后能够跳到其他的位置， Nikola 的第一跳必须跳到 2 号位置。随后的每一跳必须满足两个条件： 1、如果是向前跳， 必须比前面一跳远一个方格。 2、如果是向后跳， 必须和前面一跳一样远。 比如， 在第一跳之后（当在 2 号位置时）， Nikola 能够跳回 1 号位置， 或者向前跳到 4号位置。 每次他跳入一个位置， Nikola 必须付费。 Nikola 的目标是从一号位置尽可能便宜地跳到 N 号位置。 写一个程序， 看看 Nikola 跳到 N 号位置时最小的花费。 输入输出格式 &amp; 样例输入格式：共有 N+1 行。 第一行：包含一个整数 N， 它是位置的编号。 第 2..N+1 行：第 i+1 行表示第 I 个方格的费用， 是一个正整数 输出格式：只有一个数， 表示 Nikola 跳到 N 号位置时最小的花费。 输入输出样例 输入样例#1：6 1 2 3 4 5 6输出样例#1：12 输入样例#2：8 2 3 4 3 1 6 1 4输出样例#2：14 数据范围2≤N≤1000 费用不大于500 解题思路妥妥的DP 我们设 $\text{f[i][j]}$表示跳到第 $i$ 个格子上，可以向后跳 $j$ 个格子的时候的最小花费 转移方程： $\text{(default) f[i][j] = LESS_INF}$ 上一次向前跳，显然上一次跳了 $j$ 格。$\text{f[i][j] = min(f[i][j], f[i-j][j-1]}$ 上一次向后跳，显然上一次跳了 $j$ 格。 $\text{f[i][j] = min(f[i][j], f[i+j][j]}$ 最后加上本格的花费$\text{cost[i]}$就是$\text{f[i][j]}$ 需要注意的东西有两个，一个是边界，另一个是答案为$\text{min{f[n][i]} }(i \in [1, n-1])$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- */#include &lt;map&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 1000 + 10; int cost[MAXN]; int f[MAXN][MAXN]; int n; int DFS(int now, int step, int ncost) &#123; // 写挂了的搜索 if (now == n) return ncost; int ret = 2147482333; cout &lt;&lt; "now = " &lt;&lt; now &lt;&lt; endl; cout &lt;&lt; "ncost = " &lt;&lt; ncost &lt;&lt; endl; if (now + step + 1 &lt;= n) ret = std::min(ret, DFS(now + step + 1, step + 1, ncost + cost[now + step + 1])); if (now != 1 &amp;&amp; step != 0 &amp;&amp; now - step &gt; 0) ret = std::min(ret, DFS(now - step, step, ncost + cost[now - step])); return ret; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; n = getint(); For (i, 1, n) cost[i] = getint(); int step = 0; //putint(DFS(1, 0, cost[1]), '\n'); //for (int i = 1; i &lt; n; ++i) &#123; // int now = 2147482333; //&#125; int Min = 2147482333; for (int i = 2; i &lt;= n; ++i) f[i][0] = 0x3f3f3f3f; for (int j = 1; j &lt; n; ++j) &#123; for (int i = n; i &gt;= 1; --i) &#123; f[i][j] = 0x3f3f3f3f; if (i &gt; j) f[i][j] = f[i - j][j - 1]; if (i + j &lt;= n) f[i][j] = std::min(f[i][j], f[i + j][j]); if (f[i][j] != 0x3f3f3f3f) f[i][j] += cost[i]; if (i == n) Min = std::min(Min, f[i][j]); &#125; &#125; putint(Min, '\n'); return 0;&#125; 果然我还是太弱了 这题并没有A掉 差这题就AK了]]></content>
      <tags>
        <tag>编程</tag>
        <tag>自测</tag>
        <tag>比赛</tag>
        <tag>枚举</tag>
        <tag>自测题</tag>
        <tag>动态规划，DP</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCF 钦定评测系统 Arbiter 使用指南]]></title>
    <url>%2F2018-11-02%2FArbiter%2F</url>
    <content type="text"><![CDATA[Developed by GAIT 什么是 ArbiterArbiter 是NOI信息学竞赛唯一指定评测工具，分为网络版和单机版，支持目前主流的 Linux 发行版本，多种语言支持（C, C++ 和 Free Pascal），功能多样，配置灵活，并具有精确的时间控制。 下载 &amp; 安装Deb 包我没有找到关于 Deb 包的任何信息，可能 CCF 暂时移除了。 NOI Linux首先，打开这个网址下载 NOI Linux 并安装（实体机虚拟机均可）默认密码 123456 配置打开程序在 NOI Linux 中，你可以在左上角的「应用程序」中找到它。 打开之后，它的主界面是这样的。 新建竞赛点击「NEW」按钮，输入比赛名称，选择存储目录，点击确定。 打开竞赛如果你已经创建过的话，点击「OPEN」，选择竞赛的配置文件(.cfg)，点击确定即可。 配置竞赛试题配置打开竞赛之后，它会显示这样的一个界面。我们右键单击试题概要下面的空白处，选择添加考试，它会添加一场名为「第一场——机试」的考试。如何改名下面会说。 我们右键这场考试，选择添加试题，并点击「+」号展开这场比赛。试题默认的名字是「Unknow1」，可以自己修改。 在这里，你可以修改针对每一个试题的配置。我个人比较偏好的设置如下图。 关于其他的「比较方式」，在「/path/to/your/contest/filter/readme.txt」中可以了解，对应的比较方式也有源代码。 数据配置所有的数据文件都放在「/path/to/your/contest/evaldata/」里，且无任何子文件夹。 所有的输入数据的名称都应该是「题目名称 + 编号 + .in」，如下图。 评测选手文件所有的选手文件夹都放在.../players/里 像 NOIP 一样，所有的选手文件都需要建立子文件夹。 12345678910| .../players/|||--| SD-66666||------| ccf||----------&gt; ccf.cpp||------| cheat||----------&gt; cheat.cpp||------| money||----------&gt; money.cpp| 开始评测切换到「试题评测」界面，点击「添加选手」，输入姓名和编号，点击确定。点击「导入名单」可以进行批量导入我没试过。 这里要注意编号是和文件夹名相同的。 首先我们要将「评测第0场」改一下，再点击「全选」，「评定选定选手」就开始评测了。 统计信息评测完之后，程序会自动显示评测的结果。 更加详细的信息可以到「成绩统计」里看。「成绩统计」分为4个模块：总体统计、分组统计、试题统计和等级统计。总体统计分组统计试题统计等级统计 不得不说分组统计和等级统计就是专门为 NOIP 系列赛事开发的…… 你可以选择导出或打印。 对了，成绩为什么多30pts我也不得而知（ FAQs想问的可以在评论里问或发送邮件到我的邮箱我会抽一些整理出来 Q1：如何给考试改名？A1：当然是万能的配置文件。打开day1.info，更改NAME=后面的内容。]]></content>
      <tags>
        <tag>使用指南</tag>
        <tag>比赛</tag>
        <tag>评测系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP2018游记]]></title>
    <url>%2F2018-11-02%2FNOIP2018-PJ%2F</url>
    <content type="text"><![CDATA[&amp;GaiGeKaiFang(40)Nian 随手一记NOIP2018 游记12rp = 0x3f3f3f3f;rp++; 出征！ Day 1上午今天在学生活动中心肝了一个上午又做了几道题 顺便写了一发题解希望能涨涨RP吧 下午等待进场的时间真是漫长。看着队伍一点一点地往前走，我的心也开始激动了起来。 进场发现有人居然动鼠标，监考老师还不管考前5min就发了密码 T1水题，上来5min切了不过我居然奶中了，T1就是求一个字符串中有多少字符 T2是个暴力，最开始想出了$O(n^2)$的做法，后来改了一下就成了一个$O(n)$的做法，没意外应该能拿满 T3……我被T3切了打了个最大计算量$10^{10}$的算法，结果极限大样例答案不对！心态崩了 T4随便判了几个情况，希望能骗一点分 顺便表扬CCF终于换评测机了 正经的Day0 成堆的人在开包，成堆的人出橙了，成堆的人掉rp。 不得不说去昌邑的路真漫长，貌似SDSC的时候都没这么长时间。 下了车第一件事就是拍照，补上SDSC没有拍照的遗憾，毕竟昌邑一中的绿化面积和水系的面积是极大的！这就是我戏称昌邑一中为“昌邑第一自然保护区”的原因。 晚上去试机，不得不说习惯了 Macbook Pro 2017 的蝶式键盘就真的回不来了。还有对应 Alt 键的 ⌘ 键，实在是习惯了，到那保存就是一个劲地按 Alt + S……敲了一遍代码的默认模板，5分钟敲过，和我预想中的差不多快。 Day1 上午去了学生活动中心做题，一口气切了8道题——但是都是「普及-」的题目，这可能是这三天我的活动安排的败笔。我应该做「普及/提高-」的题目的啊…… 中午写了篇题解扔到博客上了，希望能rp++ 下午去的时候手机居然没电了，好自闭啊。还没到2:30就带着一瓶今麦郎的凉白开进了场，居然不到时间就发了密码。第一道题我居然说中了……考试前一天我还在说一道求字符串长度的题，于是用getline5分钟切了。第二题依然是水题，先想到的是$O(n^2)$的做法，发现只能拿80分，于是就开始想正解。很快想到了一个$O(n)$的做法就开始敲，结果最大的样例过不了，然后简单分析了一下发现需要开long long int。不过，我在开了long long int之后只把表示∞的值提高了一点，在Day2的自测中才发现……所以我写$O(n)$的做法跟没写一样，开long long跟没开一样！看到自测的成绩后我心态是真的崩死了。第三题第一眼是DP，但是推不出式子来，于是就开始想贪心做法。写了一个暴力，然后最大的样例死活调不过，浪费了近1个小时。第四题一看就知道不大可做，然后尝试写暴力也没写出来，最后随便判了几个情况算完。 Day2上午在学生活动中心把题目写了一遍，发现第二题∞的值设的过小，预测了一下省一线 NOIP2018 普及组题解占坑 禁赛预定]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>NOIP</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher 算法介绍]]></title>
    <url>%2F2018-11-01%2FManacher%2F</url>
    <content type="text"><![CDATA[$O(n)$回文串 Manacher 是什么Manacher 是一种可以在$O(n)$的时间复杂度内求出一个字符串的最长回文子串的算法。 Manacher，中文一般念做「马拉车」。 Manacher Algorithm 的思想首先我们来看一道题洛谷P3805【模板】manacher算法。 考虑一下暴力做法，就是枚举字串的边界并进行验证，时间复杂度$O(n^3)$ 考虑一下优化，我们可以枚举所有“回文子串”的对称轴（尽管它现在不一定是回文子串）并向两边进行扩展，用一个数组external[i]记录第i个字符可向外扩展的数量，显然数组中最大值的二倍就是答案，时间复杂度均摊$O(n^2)$。 但这还不够快……毕竟$\text{|s|} \leq 11000000$ 于是我们考虑在优化的思想基础上进行再次优化。 在此之前，我们首先要解决一个棘手的问题——字符串的长度。一个字符串子串的对称轴是在字母中间还是在字母上，是由子串长度为偶数还是奇数决定的。于是，为了统一对于奇数长度字符串和偶数长度字符串的做法，我们需要对字符串进行修改。（代码见「代码实现」Pre()部分） 1234567就比如说 - - - - - -|%|%|%|w|y|h|我们要用一些无关紧要的字符填一下 - - - - - - - - - - -|%|!|%|!|%|!|w|!|y|!|h|这样更好处理 修改完了之后，就是真正的Manacher()过程了首先，我们要用一个变量maxRight记录「当前的 最靠右的 回文子串的 右端点」，和一个变量mid记录「当前的 最靠右的 回文子串的 对称轴所在的 字符的 下标」，注意这里的mid是可以不赋初值的 我们循环枚举经过处理的字符串的每一个字符。对于每一个字符的下标i，如果i &lt; maxRight，那么我们就可以获取external[i]的部分信息（external[i]的意义和上文相同），否则就只能将external[i]设为1 接着就是和暴力一样的扩展了，我这里选择用for语句实现（ 最后更新一下maxRight和mid即可 最终答案就是external[]的最大值——而不是2倍，因为这是我们扩展过的字符串，最终答案还要$\times \frac{1}{2}$。 Manacher Algorithm 的代码实现同样也是「manacher模版」的代码实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 31000000 + 10; // 没错，就是要开这么大 int n, external[MAXN]; char s[MAXN], str[MAXN &lt;&lt; 1]; void Pre() &#123; str[0] = str[1] = '~'; for (int i = 0; i &lt; n; ++i) &#123; str[i * 2 + 2] = s[i]; str[i * 2 + 3] = '~'; &#125; n = n * 2 + 2; str[n] = 0; &#125; void Manacher() &#123; int maxRight = 0, mid = 0; // mid 初值无所谓 for (int i = 1; i &lt; n; ++i) &#123; if (i &lt; maxRight) &#123; external[i] = std::min(external[(mid &lt;&lt; 1) - i], external[mid] + mid - i); &#125; else &#123; external[i] = 1; &#125; for (; str[i + external[i]] == str[i - external[i]]; ++external[i]); if (external[i] + i &gt; maxRight) &#123; maxRight = external[i] + i; mid = i; &#125; &#125; &#125; void Work() &#123; cin &gt;&gt; s; n = (int) strlen(s); Pre(); Manacher(); int ans = 1; for (int i = 0; i &lt; n; ++i) ans = std::max(ans, external[i]); cout &lt;&lt; ans - 1 &lt;&lt; endl; &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work(); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1280《尼克的任务》]]></title>
    <url>%2F2018-11-01%2FLuogu-P1280%2F</url>
    <content type="text"><![CDATA[线性DP 题目🔗 题目描述尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。 尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T-1分钟结束。 写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。 Input / Output 格式 &amp; 样例输入格式输入数据第一行含两个用空格隔开的整数$N$和$K(1≤N≤10000，1≤K≤10000)$，$N$表示尼克的工作时间，单位为分钟，$K$表示任务总数。 接下来共有$K$行，每一行有两个用空格隔开的整数$P$和$T$，表示该任务从第$P$分钟开始，持续时间为$T$分钟，其中$1≤P≤N$，$1≤P+T-1≤N$。 输出格式输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。 输入样例123456715 61 21 64 118 58 111 5 输出样例14 解题思路DP 我们设f[i]表示在前i分钟内的最大空闲时间但是发现第i分钟的空闲时间是由后面的任务决定的所以我们考虑倒着扫一遍 我们设f[i]表示在第i$\rightarrow$n分钟内的最大空闲时间转移方程： 当第i分钟没有任务时，f[i] = f[i + 1] + 1 当第i分钟有任务时，f[i] = std::max(f[i], f[i + seq[j]].time)，其中seq[j].time表示第j个任务的耗时 如何判断当前有没有任务？我们开一个数组sum[i]表示第i分钟的任务个数更新就很好更新了——++sum[seq[j].startTime]，其中seq[j].startTime表示第j个任务的开始时间 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; /*/ * * 设f[i]表示i-n的空闲时间 * f[i] = f[i+1] + 1（无任务） * f[i] = max(f[i], f[i + seq[x]])（有任务） * /*/ const int MAXK = 10000 + 10; const int MAXN = MAXK; struct QwQ &#123; int start, time; &#125; qwq[MAXK]; int n, k; int sum[MAXN]; int f[MAXN]; int num = 1; bool stlCmp(QwQ x, QwQ y) &#123; return x.start &gt; y.start; &#125; void Work() &#123; using FastIO::getint; n = getint(); k = getint(); For (i, 1, k) &#123; qwq[i].start = getint(); qwq[i].time = getint(); ++sum[qwq[i].start]; &#125; sort(qwq + 1, qwq + 1 + k, stlCmp); // 既然是倒序，所以输入也要排序 for (int i = n; i &gt;= 1; --i) &#123; if (sum[i] == 0) f[i] = f[i + 1] + 1; // 当前时刻没有任务 else &#123; for (int j = 1; j &lt;= sum[i]; ++j) &#123; f[i] = std::max(f[i], f[i + qwq[num].time]); // 当前时刻有至少一个任务，把它们都扫一遍 ++num; // 用一个变量 num 表示当前扫到的任务 &#125; &#125; &#125; FastIO::putint(f[1], '\n'); // 输出 &#125;&#125;int main(int argc, char *const argv[]) &#123;#define HANDWER_FILE#ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout);#endif using namespace Solution; using namespace FastIO; Work(); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1577《切绳子》]]></title>
    <url>%2F2018-10-31%2FLuogu-P1577%2F</url>
    <content type="text"><![CDATA[突然想起《割绳子》 题面🔗 题面描述有N条绳子，它们的长度分别为Li。如果从它们中切割出K条长度相同的绳子，这K条绳子每条最长能有多长？答案保留到小数点后2位。 Input / Output 格式 &amp; 样例输入格式第一行两个整数N和K，接下来N行，描述了每条绳子的长度Li。 输出格式切割后每条绳子的最大长度。 输入样例123454 118.027.434.575.39 输出样例12.00 解题思路首先这题涉及到了int和double之间的精度转换 所以我们可以把输入的double都乘100转为int（题目要求保留两位小数） 不难看出来这题可以枚举答案 但是显然会炸 于是我们要想点优化——二分答案！ 我们选择二分绳子的最大长度 这题的单调性是显然的，我就不证了（ Check(int mid)怎么写？ 我们扫一遍绳子长度L[]，令$ ans=\sum_{i=1}^{n}\lfloor\frac{L[i]}{mid}\rfloor $ 即最终绳子被分成的段数 如果$ans \geq k$（题目中的$\text{k}$）则把左边界赋值为mid + 1，否则把右边界赋值为mid - 1 这里要注意的是如果mid == 0就直接退出循环 最后cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (double) r / 100.0 &lt;&lt; endl; 代码实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iomanip&gt;using namespace std;const int MAXN = 10000 + 10;const double MAXL = 100000.00;int n, k;int L[MAXN];bool Check(int x) &#123; int ans = 0; for (int i = 1; i &lt;= n; ++i) ans += L[i] / x; return ans &gt;= k;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; ++i) &#123; double P; cin &gt;&gt; P; L[i] = (int) (P * 100.0); &#125; int l = 0, r = 19260817 + 1; while (l &lt;= r) &#123; int mid = (l + r) &gt;&gt; 1; if (mid == 0) break; if (Check(mid)) l = mid + 1; else r = mid - 1; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (double) r / 100.0 &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1032《字串变换》]]></title>
    <url>%2F2018-10-30%2FLuogu-P1032%2F</url>
    <content type="text"><![CDATA[NO ANSWER! 题目描述已知有两个字串$A,B$及一组字串变换的规则（至多$6$个规则）: $A_1 \rightarrow B_1$ $A_2 \rightarrow B_2$​规则的含义为：在 $A$ 中的子串 $A_1$ 可以变换为 $B_1$，$A_2$可以变换为 $B_2 \dots$ 例如：$A=$’$abcdabcd$’，$B＝$’$xyzxyz$’ 变换规则为： ‘$abc$’$\rightarrow$‘$xu$’ ‘$ud$’$\rightarrow$‘$y$’ ‘$y$’$\rightarrow$‘$yz$’ 则此时，$A$可以经过一系列的变换变为$B$，其变换的过程为： ‘$abcd$’$\rightarrow$‘$xud$’$\rightarrow$‘$xy$’$\rightarrow$‘$xyz$’ 共进行了$3$次变换，使得$A$变换为$B$。 Input / Output 格式 &amp; 样例输入格式：输入格式如下： $A$ $B$ $A_1$ $B_1$​$A_2$ $B_2$​$|\rightarrow$ 变换规则 … … / 所有字符串长度的上限为$20$。 输出格式：输出至屏幕。格式如下： 若在$10$步（包含$10$步）以内能将$A$变换为$B$，则输出最少的变换步数；否则输出”NO ANSWER!” 输入样例1234abcd xyzabc xuud yy yz 输出样例13 解题思路这是一个 BFS 题目刚上来就有一个坑 输入不给行数 只知道最多六行 于是我们用一个变量l来记录输入的行数 我这里选择用A[0]和B[0]来存两个原字符串 首先如果l == 0而且A[0] != B[0]，那直接输出NO ANSWER! 否则用一个变量v来记录BFS()的返回值 如何搜索？ www.baidu.com 我们建两个队列q和step，分别存需要修改的字符串和这个字符串所对应的步数 循环的时候就不能只判!q.empty()，还要判q.front() != B[0] /* 字符串还需要修改 */和step.front() &lt;= 10 /* 限制只能修改10次 */ 我们还需要用一个map&lt;string, bool&gt;来判重 剩下的一些解释我直接扔到代码注释里面了 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int MAXN = 6 + 3;map&lt;string, bool&gt; KangShifu;string A[MAXN], B[MAXN];int BoynextdoorFaqSearch(int l) &#123; int ans = 0; queue&lt;string&gt; q; queue&lt;int&gt; step; q.push(A[0]); step.push(0); while (!q.empty() &amp;&amp; q.front() != B[0] &amp;&amp; step.front() &lt;= 10) &#123; if (KangShifu[q.front()]) &#123; q.pop(); step.pop(); continue; // 去重 &#125; KangShifu[q.front()] = true; for (int i = 1; i &lt;= l; ++i) &#123; string s = q.front(); // 用一个string记录下当前需要修改的字符串 while (true) &#123; // 可能不止修改一次 int loc = s.find(A[i]); if (loc == -1) break; // 并没有找到 string ss = q.front(); // 再复制一份需要修改的字符串 ss.replace(loc, A[i].size(), B[i]); // 修改 q.push(ss); // 把它扔进队列 step.push(step.front() + 1); // 步骤数 + 1 s[loc] = '~'; // 把这个能搜到的地方用一个无关紧要的放起来 // 防止下次还能被搜到 &#125; &#125; q.pop(); step.pop(); // 处理完毕 &#125; if (q.empty() || step.front() &gt; 10) ans = -1; // 如果队列空了或超过10步了，输出NO ANSWER! else ans = step.front(); // 否则输出真正的答案 return ans;&#125;int main(int argc, const char * argv[]) &#123; int l = 0; while (cin &gt;&gt; A[l] &gt;&gt; B[l]) ++l; --l; if (l == 0 &amp;&amp; A[0] != B[0]) puts("NO ANSWER!"); else &#123; int v = BoynextdoorFaqSearch(l); // Boy Next Door if (v == -1) puts("NO ANSWER!"); else cout &lt;&lt; v &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>字符串</tag>
        <tag>BFS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3952《时间复杂度》]]></title>
    <url>%2F2018-10-29%2FLuogu-P3952%2F</url>
    <content type="text"><![CDATA[继《玩具谜题》后的又一力作 题目地址 题目描述小明正在学习一种新的编程语言 A++，刚学会循环语句的他激动地写了好多程序并 给出了他自己算出的时间复杂度，可他的编程老师实在不想一个一个检查小明的程序， 于是你的机会来啦！下面请你编写程序来判断小明对他的每个程序给出的时间复杂度是否正确。 A++语言的循环结构如下： 123F i x y 循环体E 其中 $\text{F i x y}$ 表示新建变量 $i$（变量 $i$ 不可与未被销毁的变量重名）并初始化为 $x$， 然后判断 $i$ 和 $y$ 的大小关系，若 $i$ 小于等于 $y$ 则进入循环，否则不进入。每次循环结束后 $i$ 都会被修改成 $i+1$，一旦 $i$ 大于 $y$ 终止循环。 $x​$ 和 $y​$ 可以是正整数（$x​$ 和 $y​$ 的大小关系不定）或变量 $n​$。$n​$ 是一个表示数据规模的变量，在时间复杂度计算中需保留该变量而不能将其视为常数，该数远大于 100。 “$\text{E}$”表示循环体结束。循环体结束时，这个循环体新建的变量也被销毁。 注：本题中为了书写方便，在描述复杂度时，使用大写英文字母“$O$”表示通常意义下“$Θ$”的概念。 Input / Output 格式 &amp; 样例输入格式：输入文件第一行一个正整数 $t$，表示有 $t$（$t \le 10$）个程序需要计算时间复杂度。 每个程序我们只需抽取其中 $\text{F i x y}$和$\text{E}$即可计算时间复杂度。注意：循环结构 允许嵌套。 接下来每个程序的第一行包含一个正整数 $L$ 和一个字符串，$L$ 代表程序行数，字符 串表示这个程序的复杂度，O(1)表示常数复杂度，O(n^w)表示复杂度为$n^w$，其中$w$是一个小于100的正整数（输入中不包含引号），输入保证复杂度只有O(1)和O(n^w) 两种类型。 接下来 $L$ 行代表程序中循环结构中的$\text{F i x y}$或者 $\text{E}$。 程序行若以$\text{F}$开头，表示进入一个循环，之后有空格分离的三个字符（串）$\text{i x y}$， 其中 $i$ 是一个小写字母（保证不为$n$），表示新建的变量名，$x$ 和 $y$ 可能是正整数或 $n$ ，已知若为正整数则一定小于 100。 程序行若以$E$开头，则表示循环体结束。 输出格式：输出文件共 $t$ 行，对应输入的 $t$ 个程序，每行输出Yes或No或者ERR，若程序实际复杂度与输入给出的复杂度一致则输出Yes，不一致则输出No，若程序有语法错误（其中语法错误只有: ① $\text{F}$ 和 $\text{E}$ 不匹配 ②新建的变量与已经存在但未被销毁的变量重复两种情况），则输出ERR 。 注意：即使在程序不会执行的循环体中出现了语法错误也会编译错误，要输出 ERR。 输入样例1234567891011121314151617181920212223242526272829303132333482 O(1)F i 1 1E2 O(n^1)F x 1 nE1 O(1)F x 1 n4 O(n^2)F x 5 nF y 10 nEE4 O(n^2)F x 9 nEF y 2 nE4 O(n^1)F x 9 nF y n 4EE4 O(1)F y n 4F x 9 nEE4 O(n^2)F x 1 nF x 1 10EE 输出样例12345678YesYesERRYesNoYesYesERR 解题思路首先我们肯定一眼就能看出这题是个没有任何优化的大模拟 那么如何模拟？ 首先我们为了方便，把循环体离线下来，用字符串存着 根据题意，我们写一个函数GetNumber()把字符串里的数字存下来 具体和快读差不多 我们先把小明给出的时间复杂度的$n$的指数记为$\text{w}$，这里注意$O(1)$的情况要用$0$代替 接着便是求真正的时间复杂度了 首先是判断ERR 这个比较简单 我们用一个栈来储存所有的循环体的变量名 当$\text{E}$已经读完但是栈不空 当$\text{E}$未读完但是栈空 当储存的变量名与现在的变量名冲突 这个过程穿插在代码各处 当读到$\text{F}$的时候往栈里 Push 循环体变量名，注意要一块把记录变量名的数组used进行判断并更新 之后，我们用GetNumber获取一下$x$和$y$两个数，分情况讨论一下 当$y$是$n$的时候，如果这次循环可以执行，++答案 当$y&lt;x$的时候，循环不执行，更新一下「最早不能循环的循环体」 剩下一种情况就是常数，可以不写 当读到$\text{E}$的时候，先检查栈里还有没有东西，再 Pop 出来，注意要检查一下这个变量是不是「最早不能循环的循环体」的变量 最后扫完数据，判一下栈是不是还有东西没 Pop 出来，然后验一下答案，输出 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;stack&gt;using namespace std;const int MAX = 100 + 10;string Code[MAX];int t;int GetNumber(int &amp;X, string s) &#123; int len = s.length(); while (!isdigit(s[X]) &amp;&amp; X &lt; len) &#123; if (s[X] == 'n') &#123; ++X; return 19260817; &#125; ++X; &#125; int ret = 0; while (isdigit(s[X])) &#123; ret = ret * 10 + s[X] - '0'; ++X; &#125; return ret;&#125;int getO(string s) &#123; if (s[2] == 'n') &#123; int _ = 3; // 必须要传实参进去 return GetNumber(_, s); &#125; return 0;&#125;int GetO(int l) &#123; int ret = 0; int now = 0; char earliestVariant = -1; // 「最早不能循环的循环体」 int x = 0, y = 0; stack&lt;int&gt; stk; bool used[27] = &#123; false &#125;; bool ran[27] = &#123; false &#125;; for (int i = 1; i &lt;= l; ++i) &#123; if (Code[i][0] == 'F') &#123; char varName = Code[i][2]; if (used[varName - 'a']) return -1; stk.push(varName); used[varName - 'a'] = true; // Get X int X = 4; x = GetNumber(X, Code[i]); // Get Y y = GetNumber(X, Code[i]); if (y - x &gt; 1000) &#123; // y = n if (earliestVariant == -1) &#123; ++now; ret = std::max(ret, now); ran[varName - 'a'] = true; &#125; &#125; else if (x &gt; y) &#123; if (earliestVariant == -1) earliestVariant = varName; &#125; &#125; else &#123; if (stk.empty()) return -1; char nowVarName = stk.top(); stk.pop(); used[nowVarName - 'a'] = false; if (earliestVariant == nowVarName) earliestVariant = -1; if (ran[nowVarName - 'a']) &#123; ran[nowVarName - 'a'] = false; --now; &#125; &#125; &#125; if (!stk.empty()) return -1; return ret;&#125;int main() &#123; scanf("%d", &amp;t); while (t --&gt; 0) &#123; int w, nw, l; scanf("%d ", &amp;l); string o; getline(cin, o); nw = getO(o); for (int i = 1; i &lt;= l; ++i) &#123; getline(cin, Code[i]); &#125; w = GetO(l); if (w == -1) puts("ERR"); else &#123; if (w == nw) puts("Yes"); else puts("No"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>栈</tag>
        <tag>NOIP</tag>
        <tag>毒瘤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1525《关押罪犯》]]></title>
    <url>%2F2018-10-20%2FLuogu-P1525%2F</url>
    <content type="text"><![CDATA[敌人的敌人就是朋友！ 题目地址 题目描述S城现有两座监狱，一共关押着 N 名罪犯，编号分别为 1−N 。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 c 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 c 的冲突事件。 每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。 在详细考察了 N 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。 那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？ Input / Output 格式 &amp; 样例输入格式每行中两个数之间用一个空格隔开。第一行为两个正整数N,M，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的M行每行为三个正整数$a_j,b_j,c_j$，表示$a_j$号和$b_j$号罪犯之间存在仇恨，其怨气值为$c_j$。数据保证$1&lt;aj≤bj≤N,0 &lt; cj≤ 1,000,000,000$，且每对罪犯组合只出现一次。 输出格式共 1 行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 0。 输入样例12345674 61 4 25342 3 35121 2 283511 3 66182 4 18053 4 12884 输出样例13512 解题思路显然这是一个并查集 首先我们把输入记录下来，按照权值从大到小排个序 然后对于每一条关系，如果它们的祖先相同，就说明发生了冲突，此时直接输出 + return 0就好 否则就进行合并 如何合并？ 根据“敌人的敌人就是朋友”的原则，我们维护一个Enemy[i]表示i的的敌人 然后对于每一个人，更新它的敌人（如果它的敌人目前没被更新过）否则就合并另一个人和他的敌人 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 20000 + 10;const int MAXM = 100000 + 10;struct Relative &#123; int x, y, weight;&#125; rel[MAXM];int n, m, U[MAXM * 2], E[MAXN * 2];inline void Init() &#123; for (int i = 1; i &lt;= n; ++i) U[i] = i;&#125;int Find(int x) &#123; if (x == U[x]) return x; return U[x] = Find(U[x]);&#125;void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] = y;&#125;bool stlCmp(Relative x, Relative y) &#123; return x.weight &gt; y.weight;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m; Init(); for (int i = 1; i &lt;= m; ++i) &#123; int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; rel[i].x = x; rel[i].y = y; rel[i].weight = w; &#125; sort(rel + 1, rel + 1 + m, stlCmp); for (int i = 1; i &lt;= m; ++i) &#123; int x = rel[i].x, y = rel[i].y; int fx = Find(x), fy = Find(y); if (fx == fy) &#123; printf("%d", rel[i].weight); return 0; &#125; if (E[x] == 0) E[x] = y; else Union(E[x], y); if (E[y] == 0) E[y] = x; else Union(E[y], x); &#125; printf("0"); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>NOIP</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SP3377《A Bug's Life》]]></title>
    <url>%2F2018-10-20%2FSP3377%2F</url>
    <content type="text"><![CDATA[谁闲的没事研究同性恋。。。 题目地址 本文同步发布于：Handwer’s 洛谷博客 题目大意就是一个奇怪的ke学家，他专门研究虫子是否存在同性恋。。。 他为每一只虫子都标上了序号。 通过这个奇怪的ke学家的研究，找出了在这些虫子中的所有关系的虫子，题目询问在这么多有关系的虫子中是否存在“同性恋”。 输入格式 &amp; 样例第一行， 输入一个数，表示有t组数据对于每组数据，第一行输入n,m，表示有n只虫子，有m个关系接下来行每行两个数x,y，表示x,y有关系 1234567823 31 22 31 34 21 23 4 输出格式 &amp; 样例对于每一组数据： 先输出：”Scenario #i” ，表示第i组数据 然后如果有同性恋的输出”Suspicious bugs found!” 否则输出”No suspicious bugs found!” 1234Scenario #1:Suspicious bugs found!Scenario #2:No suspicious bugs found! 解题思路显然这是一个并查集，但并不是一个裸的并查集 我们要多维护一个数组rel[]，其中rel[i]表示i和它的祖先的关系（relative）。我们定义rel[i]表示两种性别，当根节点相同且rel[]相同时，它们就是同性恋 rel[]的更新方式： 12(in Find(x))rel[x] = (rel[x] + rel[U[x]]) % 2; 1234(in Union(x, y))int fx = Find(x), fy = Find(y);...rel[fx] = (rel[x] + rel[y] + 1) % 2; rel[]的判断方式：12345(in Union(x, y))if (fx == fy) &#123; if (rel[x] == rel[y]) suspiciousFound = true; return;&#125; 剩下的照常写就行 注意路径压缩要分开写，先创建一个变量存它的祖先节点再更新 按秩合并没写过不知道 代码实现你们最喜欢的代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXM = 1000000 + 10;int n, m;int U[MAXM], rel[MAXM];bool flag;int Find(int x) &#123; if (x != U[x]) &#123; // 把路径压缩撑开写 int fux = Find(U[x]); rel[x] = (rel[x] + rel[U[x]]) % 2; // 更新rel数组 // 1 1 -&gt; 0 // 1 0 / 0 1 -&gt; 1 // 0 0 -&gt; 0 // 其实是一个异或的过程 U[x] = fux； // qwq &#125; return U[x];&#125;void Union(int x, int y) &#123; int fx = Find(x), fy = Find(y); if (fx == fy) &#123; if (rel[x] == rel[y]) flag = true; // 判断是否同性 return; &#125; U[fx] = fy; rel[fx] = (rel[x] + rel[y] + 1) % 2; // 更新rel数组&#125;int main(int argc, char *const argv[]) &#123; int t; scanf("%d", &amp;t); int _t = 0; while (t --&gt; 0) &#123; memset(U, 0, sizeof(U)); memset(rel, 0, sizeof(rel)); n = 0, m = 0, flag = false; scanf("%d %d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) U[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); Union(x, y); &#125; printf("Scenario #%d:\n", ++_t); if (flag) printf("Suspicious bugs found!\n"); else printf("No suspicious bugs found!\n"); &#125; return 3; // qwq&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2866《[USACO06NOV]糟糕的一天Bad Hair Day》]]></title>
    <url>%2F2018-10-06%2FLuogu-P2866%2F</url>
    <content type="text"><![CDATA[有点难想的单调栈模板题 题目地址 暂不提供题面，请自行到洛谷查看题面。 Input / Output 格式 &amp; 样例输入格式第一行：一个数N表示奶牛的数量。 第2到N+1行：第i+1行包含一个整数表示第i头奶牛的高。 输出格式第一行：一个整数，即c1到cN的和 输入样例1234567610374122 输出样例15 解题思路这就是一个单调栈的模板 循环读入，每次push读入的数进一个单调栈并维护这个栈的单调性，最后答案累加栈的大小-1即可（显然题意说明奶牛是看不见自己的发型的，要把自己减去） 以上操作的推导过程： 我们对于当前读进去的奶牛的高度，计算栈中还有多少比它矮的，把它们pop出来（维护单调性） 这个过程其实就是在计算当前的奶牛能被多少奶牛看见 接下来累计答案 最后将当前奶牛的高度push进去 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 80000 + 10; struct Stack &#123; int seq[MAXN]; int tail; Stack() &#123; memset(seq, 0, sizeof(seq)); tail = 0; &#125; void Pop() &#123; tail--; &#125; int Top() &#123; return seq[tail]; &#125; bool isEmpty() &#123; return tail == 0; &#125; void Push(int x) &#123; while (!isEmpty() &amp;&amp; Top() &lt;= x) Pop(); seq[++tail] = x; &#125; int Size() &#123; return tail; &#125; int __tail_location() &#123; return tail; &#125; &#125; stk; // 手写栈无所畏惧 int n;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); long long int ans = 0; For (i, 1, n) &#123; int x = getint(); stk.Push(x); ans += stk.Size() - 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>栈</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1981《表达式求值》]]></title>
    <url>%2F2018-10-06%2FLuogu-P1981%2F</url>
    <content type="text"><![CDATA[新技能：手写计算器 题目描述给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。 Input / Output 格式 &amp; 样例输入格式一行，为需要你计算的表达式，表达式中只包含数字、加法运算符“$+$”和乘法运算符“ $\times$ ”，且没有括号，所有参与运算的数字均为 $0$ 到 $2^{31}$的整数。 输入数据保证这一行只有 $0−9$、$+$、 $\times$ 这 $12$ 种字符。 输出格式一个整数，表示这个表达式的值。 注意：当答案长度多于 4 位时，请只输出最后 4 位，前导 0 不输出。 输入样例Case #1:11+1*3+4 Case #2:11+1234567890*1 Case #3:11+1000000003*1 输出样例Case #1:18 Case #2:17891 Case #3:14 数据范围对于 30\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100； 对于 80\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤1000； 对于100\%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100000。 解题思路我们开两个单调栈，一个栈num来存储数字，一个栈operators来存储符号 其中operators的操作逻辑是这样的： 首先把~push进去，作为一个占位符 我们对运算符标一个优先级，规定~ &lt; + &lt; *且相同运算符优先级低（满足从左到右的运算顺序），写一个判断函数 当push进去的运算符优先级比栈顶的低时，解决所有优先级低的运算符（维护单调性质）再push进去 当push进去的运算符优先级比栈顶的高时，不用管，直接push进去（满足单调性质） 处理完输入之后，我们再对数字栈里剩下的数字进行处理 最后输出即可 代码实现这里面所有的注释都是我在DEBUG的时候手推的样例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; stack&lt;int&gt; num; stack&lt;int&gt; operators; // 1: + - // 2: * / const int MOD = 10000; long long int ans = 0; bool Priority(char op1, char op2) &#123; // false -&gt; op1 is lower // true -&gt; op1 is higher if (op1 == op2) return false; if (op1 == '~') return false; if (op1 == '+' &amp;&amp; op2 == '*') return false; if (op1 == '*' &amp;&amp; op2 == '+') return true; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; // 1+1*3+4 int ans = 0, now = 0; char op = 0; cin &gt;&gt; ans; // 1 num.push(ans % MOD); // &lt; 1 operators.push('~'); // &lt; ~ while (cin &gt;&gt; op &gt;&gt; now) &#123; // +1 // *3 // +4 char op1 = operators.top(); // ~ // + // * while (Priority(op1, op)) &#123; // false // false // true // false int opNum = num.top(); // // // 3 num.pop(); // // // &lt; 1 1 int opNum2 = num.top(); // // // 1 num.pop(); // // // &lt; 1 if (op1 == '+') num.push((opNum + opNum2) % MOD); // // // false if (op1 == '*') num.push(opNum * opNum2 % MOD); // // // &lt; 1 3 operators.pop(); // &lt; + op1 = operators.top(); // + &#125; operators.push(op); // &lt; + // &lt; + * // &lt; + + num.push(now); // &lt; 1 1 // &lt; 1 1 3 // &lt; 1 3 4 &#125; while (num.size() &gt; 1) &#123; // true // true // false int op = num.top(); // 4 // 7 num.pop(); // &lt; 1 3 // &lt; 1 int op2 = num.top(); // 3 // 1 num.pop(); // &lt; 1 // &lt; char ope = operators.top(); operators.pop(); if (ope == '+') num.push((op + op2) % MOD); // &lt; 1 7 // &lt; 8 if (ope == '*') num.push(op * op2 % MOD); &#125; FastIO::putint(num.top() % MOD, '\n'); // 8 return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>栈</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1750《出栈序列》]]></title>
    <url>%2F2018-10-06%2FLuogu-P1750%2F</url>
    <content type="text"><![CDATA[这题和栈有多少关系 题目描述给定一个由n个元素构成的序列，你需要将其中的元素按顺序压入一个大小为c的栈并弹出。元素按它们的出栈顺序进行排列，会得到一个新的序列。我们知道，这样的序列会有很多种，请输出所有新序列中第一个元素最小的序列（若第一个元素最小的序列有多个，则令第二个尽可能小；若仍有多个，则令第三个最小，以此类推）。 Input / Output 格式 &amp; 样例输入格式第一行，两个数n,c 第二行n个数，为序列中n个元素的值 输出格式输出n个数，为满足要求的序列。 输入样例126 35 2 3 8 7 4 输出样例12 3 5 4 7 8 数据范围对于40%的数据，n&lt;=12 对于100%的数据，c&lt;=n&lt;=10000，元素大小均在2*10^9以内。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 10000 + 10; struct Stack &#123; private: int __builtin_sequence[MAXN]; int tail; public: Stack() &#123; memset(__builtin_sequence, 0, sizeof(__builtin_sequence)); tail = 0; &#125; void push(int x) &#123; __builtin_sequence[++tail] = x; &#125; void pop() &#123; --tail; &#125; int top() &#123; return __builtin_sequence[tail]; &#125; bool empty() &#123; return tail == 0; &#125; int size() &#123; return tail; &#125; &#125; stk; int n, c; int seq[MAXN];&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); c = getint(); int used = 0; int unusedNum = 1; For (i, 1, n) &#123; seq[i] = getint(); &#125; while (stk.size() + used &lt; n) &#123; int inQueue = stk.size(); int origUnusedNum = unusedNum; int minN = 2147482333; int len = c - inQueue; for (int i = origUnusedNum; i &lt;= n &amp;&amp; i &lt; origUnusedNum + len; ++i) &#123; if (seq[i] &lt; minN) &#123; unusedNum = i; minN = seq[i]; &#125; &#125; if (stk.empty() || minN &lt; stk.top()) &#123; For (i, origUnusedNum, unusedNum) &#123; stk.push(seq[i]); &#125; ++unusedNum; &#125; else unusedNum = origUnusedNum; putint(stk.top(), ' '); ++used; stk.pop(); &#125; while (!stk.empty()) &#123; putint(stk.top(), ' '); stk.pop(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day5 题解]]></title>
    <url>%2F2018-10-05%2F2018AutumnQBXTDay5%2F</url>
    <content type="text"><![CDATA[暴力分！暴力分！ Problem A. climb题目描述Bob 在一旁看 Alice 爬台阶玩， Alice 突发奇想让 Bob 闭上眼记录他爬了多少台阶，规则是这样的： Alice每次会想好爬多少级台阶，每爬一级都会数数，爬完之后走回到最底层，注意走回去的那些台阶是不算级数的。 Bob 闭上眼通过 Alice 的报数来统计 Alice 总共爬了几次，每次爬了多少级。 输入格式第一行包含一个整数 N(1 ≤ 100000)，表示 Alice 的报数次数。 第二行包含 N 个正整数 Ai(1 ≤ Ai ≤ 1000)，表示 Alice 的报数序列。 输出格式第一行包含一个整数，表示 Alice 爬的次数 T。第二行包含 T 个整数，第 i 个整数表示 Alice 每 i 次爬的台阶数。 输入样例1271 2 3 1 2 3 4 输出样例1223 4 子任务对于 40% 的数据， N ≤ 20。 对于 70% 的数据， N ≤ 1000。 对于 100% 的数据， N ≤ 100000。 解题思路A不掉的退役吧 显然这题就是让你求有多少个1和每两个1之间的距离 当然这题题面有点歧义 求每个1之前的数也可以（数据水 就没了 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; int n; int seq[MAXN]; int T; vector&lt;int&gt; cnt; void Work() &#123; For (i, 1, n) &#123; if (seq[i] == 1) ++T, cnt.push_back(seq[i-1]); &#125; cnt.push_back(seq[n]); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("climb.in", "r", stdin); freopen("climb.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); For (i, 1, n) seq[i] = getint(); Work(); putint(T, '\n'); int siz = cnt.size(); Forw (i, 1, siz - 1) putint(cnt[i], ' '); putint(cnt[siz - 1], '\n'); return 0;&#125; Problem B. remove题目描述给出一个字符串 s，字符串中只会包含⼩写字母 a − z。现在需要通过重复下面这个算法符串中删去 k 个字符：• 如果当前字符串中还存在字符 a，就删去字符串中最前面的一个 a 字符，结束算法• 如果当前字符串中还存在字符 b，就删去字符串中最前面的一个 b 字符，结束算法• …• 如果当前字符串中还存在字符 z，就删去字符串中最前面的一个 z 字符，结束算法求删完 k 个字符后的字符串。 输入格式第一行包含两个整数 n; k(1 ≤ k ≤ n ≤ 100000)， n 表示字符串长度， k 表示删去的字符个数。 第二行包含一个字符串 s。 输出格式一行，包含删去k个字符的字符串。 输入样例Case #1:1215 3cccaabababaccbc Case #2:1215 9cccaabababaccbc 输出样例Case #1:1cccbbabaccbc Case #2:1cccccc 子任务对于 40% 的数据， 1 ≤ k ≤ n ≤ 100。 对于 70% 的数据， 1 ≤ k ≤ n ≤ 1000。 对于 100% 的数据， 1 ≤ k ≤ n ≤ 100000。 解题思路这道题我在考试结束之后20min敲出了正解。。。。。。 我们开一个桶，把所有的字母记录下来 接着把桶扫一遍： 如果当前的k大于当前的字母数alphabet[i]，就让k -= alphabet[i]，然后把alphabet[i]置为0 否则让alphabet[i] -= k，然后把k置为0，最后break掉即可 此时，alphabet的意义已经从字母数量变成了经过删除后的还可输出字母数量 之后，我们开一个bool数组chk[i]表示str[i]是否还能被输出，并倒序（注意是倒序，因为题目要求从前面开始删，显然我们要保留后面几位）枚举 $i\ (0 &lt; i &lt; n)$ 当alphabet[str[i] - &#39;a&#39;] &gt; 0时，将chk[i]设为true并--alphabet[str[i] - &#39;a&#39;] 最后，从头扫一遍chk，如果chk[i] == true就输出str[i] 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; int n, k; string s; bool chk[MAXN]; string Work(string str) &#123; // 此为暴力做法 For (i, 1, k) &#123; Forw (j, 0, 26) &#123; cout &lt;&lt; str &lt;&lt; endl; int findnow = str.find(j + 'a'); // printf("%c\n", j + 'a'); if (findnow != string::npos) &#123; str[findnow] = '-'; break; &#125; &#125; &#125; return str; &#125; void nowWork(string str) &#123; // 此为正解 int alphabet[26 + 2] = &#123; 0 &#125;; bool printal[26] = &#123; true &#125;; Forw (i, 0, n) alphabet[str[i] - 'a']++; Forw (i, 0, 26) &#123; //cerr &lt;&lt; (char)(i + 'a')&lt;&lt; '='; //cerr &lt;&lt; alphabet[i] &lt;&lt; endl; if (alphabet[i] &lt; k) &#123; k -= alphabet[i]; alphabet[i] = 0; &#125; else &#123; alphabet[i] -= k; k = 0; break; &#125; &#125; Bak (i, n-1, 0) &#123; if (alphabet[str[i] - 'a'] == 0) continue; chk[i] = true; --alphabet[str[i] - 'a']; &#125; Forw (i, 0, n) if (chk[i]) putchar(str[i]); &#125; void Print(string str) &#123; // 此为暴力做法的输出 Forw (i, 0, n) if (str[i] != '-') putchar(str[i]); &#125;&#125; int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("remove.in", "r", stdin); freopen("remove.out", "w", stdout); #endif using namespace Solution; ios::sync_with_stdio(false);// int t = clock(); cin &gt;&gt; n &gt;&gt; k; cin &gt;&gt; s; //Print(Work(s)); nowWork(s); // cerr &lt;&lt; clock() - t &lt;&lt; endl; return 0;&#125; Problem C. cut题目描述给出一个字符串 s，其中每个字符都是 0 9 的数字。现在需要把字符串 s 分割开，这样每个部分就可以看做一个数，求这些数中最多有多少个数是 3 的倍数。 如对于字符串 3121，可以分割为 3 | 12 | 1，这样会有两个数是 3 的倍数，如果分割为 31 | 2 | 1，这样就没有数是 3 的倍数了。0 是 3 的倍数，如果 1200045 被拆分为 120 | 0045，则认为分割出来的两个数是 120 和 45，即忽略前导零。 输入格式一行包含一个字符串s，$|s|\le100000$ 输出格式一行包含一个整数，表示最多有多少个数是3的倍数。 输入样例Case #1:13121 Case #2:1201920181 输出样例Case #1：12 Case #2:14 样例解释第一个样例中可以拆分为 3 | 12 | 1。 第二个样例中可以拆分为 201 | 9 | 2 | 0 | 18 | 1。 解题思路首先我们对读进来的序列整体mod 3 接着对这个序列扫一遍 如果当前读到的数是0，根据贪心策略，直接在后面划上一道 否则如果当前读的数的下标大于0，就看前面的数如果这个数与上个数的和能被3整除，而且下个数没有被选过，就在后面划上一道 否则如果当前读的数的下标大于1，继续看前面的数如果这个数与前面两个数的和能被3整除，而且两个数都没有选过，就在后面划上一道 否则什么都不干 最后输出即可 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100000 + 10; bool vis[MAXN]; int seq[MAXN]; int len; int Work() &#123; int ret = 0; For (i, 1, len) &#123; if (seq[i] == 0) &#123; ++ret; vis[i] = true; &#125; else if (i &gt; 0 &amp;&amp; (seq[i] + seq[i - 1]) % 3 == 0 &amp;&amp; !vis[i - 1]) &#123; ++ret; vis[i] = true; &#125; else if (i &gt; 1 &amp;&amp; (seq[i] + seq[i - 1] + seq[i - 2]) % 3 == 0 &amp;&amp; !vis[i - 1] &amp;&amp; !vis[i - 2]) &#123; ++ret; vis[i] = true; &#125; &#125; return ret; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; string s; cin &gt;&gt; s; len = s.length(); For (i, 1, len) seq[i] = (s[i-1] - '0') % 3; int ans = Work(); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Problem D. sum题目描述某些数有奇怪的性质：它十进制下的各位数的平方和的 T 倍等于它本身。求在 [A, B] 范围内的数有多少满足这个性质 输入格式第一行包含三个整数 T, A, B(1 ≤ T; A; B ≤ 10^18; A ≤ B)。 输出格式一个整数，表示满足条件的数量。 输入样例151 5000 10000 输出样例13 子任务对于 40% 的数据， 1 ≤ T; A; B ≤ 100000; A ≤ B。对于 100% 的数据， 1 ≤ T; A; B ≤ 10^18; A ≤ B。 代码实现此为标程12345678long long calc(long long x) &#123; long long ans = 0; while (x) &#123; ans += (x % 10) * (x % 10); x /= 10; &#125; return ans;&#125; 1234567891011long long k, a, b, ans = 0; scanf("%lld%lld%lld", &amp;k, &amp;a, &amp;b); for(int i = 1; i &lt;= 1600; i++) &#123; if (a &lt;= k * i &amp;&amp; i &lt;= b / k) if (calc(k * i) == i) &#123; printf("%lld\n", k * i); ans++; &#125; &#125; printf("%lld\n", ans); return 0;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>清北学堂</tag>
        <tag>模拟</tag>
        <tag>贪心</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的代码默认模板]]></title>
    <url>%2F2018-10-04%2FMyTemplate%2F</url>
    <content type="text"><![CDATA[运行效率++; &nbsp; 可读性--; 下面是我在写程序时常用的快读/写模板（虽然它不仅仅只是快读/写）不仅提高了运行效率，还让编写时的体验更加舒适。 假如布局安排合理的话，可读性不但不会减少，反而会进一步上升。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterators -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- External Headers -- *//* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)/* -- Defined Words -- */using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>毒瘤</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1886《滑动窗口》]]></title>
    <url>%2F2018-10-04%2FLuogu-P1886%2F</url>
    <content type="text"><![CDATA[单调队列的应用 题目描述现在有一堆数字共N个数字（N&lt;=10^6），以及一个大小为k的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。 例如： The array is [1 3 -1 -3 5 3 6 7], and k = 3. 图片来自洛谷 Input / Output 格式 &amp; 样例输入格式输入一共有两行，第一行为n,k。 第二行为n个数($n&lt;2^{31}-1$). 输出格式输出共两行，第一行为每次窗口滑动的最小值 第二行为每次窗口滑动的最大值 输入样例128 31 3 -1 -3 5 3 6 7 输出样例12-1 -3 -3 -3 3 33 3 5 5 6 7 数据范围50%的数据，n&lt;=10^5 100%的数据，n&lt;=10^6 解题思路最经典的单调队列题目 暴力妥妥的T，不用多说（不过居然有70pts） 我们先研究最大值怎么求 每次往单调队列里面扔一个数，显然不管队列里发生了什么改变，单调性并不变。我们开一个id数组，记录当前的数被push进去的时间 接着扫描id数组，将所有过期的数全都pop出去 最后当循环了至少k次时，输出答案。 最小值同理，把单调队列改一下即可。 （《单调队列学习笔记》将不久后更新） 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 1000000 + 10; struct Queue &#123; int q[MAXN]; int head, tail; Queue() &#123; memset(q, 0, sizeof(q)); head = 1; tail = 0; &#125; void push(int s) &#123; // 维护单调递增的队列 while (s &gt;= q[tail] &amp;&amp; head &lt;= tail) --tail; q[++tail] = s; &#125; void push_back(int s) &#123; // 维护单调递减的序列 while (s &lt;= q[tail] &amp;&amp; head &lt;= tail) --tail; q[++tail] = s; &#125; void pop() &#123; ++head; &#125; int front() &#123; return q[head]; &#125; int size() &#123; return tail - head + 1; &#125; bool empty() &#123; return tail - head + 1; &#125; void clear() &#123; Queue(); &#125; int __tail_location() &#123; return tail; &#125; int __head_location() &#123; return head; &#125; &#125; q1, q2; int n, k; int seq[MAXN]; int id[MAXN]; void GetMax() &#123; For (i, 1, n) &#123; q1.push(seq[i]); id[q1.__tail_location()] = i; while (id[q1.__head_location()] &lt;= i - k) q1.pop(); // 清理过期的数 if (i &gt;= k) FastIO::putint(q1.front(), ' '); // 输出 &#125; &#125; void GetMin() &#123; For (i, 1, n) &#123; q2.push_back(seq[i]); id[q2.__tail_location()] = i; while (id[q2.__head_location()] &lt;= i - k) q2.pop(); if (i &gt;= k) FastIO::putint(q2.front(), ' '); &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(); k = getint(); For (i, 1, n) &#123; seq[i] = getint(); &#125; GetMin(); puts(""); GetMax(); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day4 题解]]></title>
    <url>%2F2018-10-04%2F2018AutumnQBXTDay4%2F</url>
    <content type="text"><![CDATA[没人AC的题目和没人得分的题目 T1. 牛奶没AC的退役吧 问题描述为了增加营养，你决定每天喝牛奶，牛奶的营养含量十分固定，下表示牛奶上写的营养成分表。 项目 每100mL 能量 284kJ 蛋白质 3.2g 脂肪 4.0g 碳水化合物 4.8g 钠 62mg 钙 100mg 这天你喝了N mL的牛奶，那么你摄入的营养成分分别为多少呢？ 输入格式一个整数N 输出格式6个用空格隔开的数字，分别表示6项营养成分的数值，单位和表上单位相同，四舍五入保留一位小数。 输入样例1100 输出样例1284.0 3.2 4.0 4.8 62.0 100.0 数据范围对于30%的数据，N是100的倍数。 对于50%的数据，N&lt;=1000。 对于100%的数据，1&lt;=N&lt;=10000。 解题思路没什么好说的，浮点数运算而已 这题唯一也是最毒瘤的的坑点就是浮点数运算 代码实现毒瘤代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace Solution &#123; const double energy100 = (double) 284; // kJ const double protein100 = (double) 3.2; // g const double fats100 = (double) 4.0; // g const double carbohydrate100 = (double) 4.8; // g const double sodium100 = (double) 62; // mg const double calcium100 = (double) 100; // mg&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("milk.in", "r", stdin); freopen("milk.out", "w", stdout); #endif using namespace Solution; double n = 1.0; scanf("%lf", &amp;n); n *= 1.0; double anse = (double) n * (double) energy100 * 1.0; double ansp = (double) n * (double) protein100 * 1.0; double ansf = (double) n * (double) fats100 * 1.0; double ansc = (double) n * (double) carbohydrate100 * 1.0; double anss = (double) n * (double) sodium100 * 1.0; double ansl = (double) n * (double) calcium100 * 1.0; printf("%0.1lf %0.1lf %0.1lf %0.1lf %0.1lf %0.1lf\n", anse / 100.0, ansp / 100.0, ansf / 100.0, ansc / 100.0, anss / 100.0, ansl / 100.0 ); return 0;&#125; T2. 上课问题描述这天，学校正上着课，学校有n个教室，每个教室坐着$a_i$个人正在上课。 突然来了m个人也要上课，每个人都可以选择n个教室中的任意一个教室上课，由于学校需要提供教室的座位，学校想知道这m个人来之后，最多人的那个教室人数的最小值和最大值分别为多少。 输入格式第一行两个数n和m，用空格隔开。 第二行n个数字用空格隔开，表示$a_i$。 输出格式两个用空格隔开的数字，分别表示最小值和最大值 输入样例124 61 1 1 1 输出样例13 7 数据范围对于30%的数据，n=1。 对于50%的数据，m&lt;=10000。 对于100%的数据，1&lt;=n,ai&lt;=100,1&lt;=m&lt;=10^9。 解题思路我们随便想一想就能想出贪心策略 首先最大值是人最多的班级的人数+m 这没什么好说的 最小值也很好求 既然是最小值，那么就要保证m的平均分配 那么我们排个序，从最小的数字依次$O(n)$扫 对于每个数字$a_i$，计算它和最大值的差，记为$d$ 当$d\ge m$时，直接输出$d$（因为将$m$全部安排到这个班里去也不能让这个班的人数比最大值大，所以答案即是最大值）否则让$m$减去$d$，将$a_i$赋值为最大值（把这个班的人数变成最大值） 扫完一遍之后，如果$m$变成0了，就直接输出最大值（m个人被正好安排完了）否则就再把剩下的人一个一个地分别安排到每个班中（可能有一个班分配多人的情况），最后取个max值即可 这里有个小技巧，就是我们把m整除n的结果记为place，然后把整个序列都加上place，表示每个班都还要分配place个人 再把m模n的结果记为 lm，循环把这最后lm个人分别分配到每个班中，最后取max即可 讲起来还是挺麻烦的 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 100; int n, m; int seq[MAXN]; bool stlCmp(int x, int y) &#123; return x &gt; y; &#125; void PrintAnswer(int maxAns, int minAns) &#123; FastIO::putint(minAns, ' '); FastIO::putint(maxAns, '\n'); &#125; &#125;int main(int argc, char *const argv[]) &#123; // Wrong Algorithm #ifndef HANDWER_FILE freopen("class.in", "r", stdin); freopen("class.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; n = getint(), m = getint(); int maxSiz = -233333; For (i, 1, n) &#123; seq[i] = getint(); maxSiz = std::max(seq[i], maxSiz); &#125; sort(seq + 1, seq + 1 + n); int maxAns = m + seq[n]; For (i, 1, n) &#123; int differ = maxSiz - seq[i]; if (differ &gt;= m) &#123; PrintAnswer(maxAns, maxSiz); return 0; &#125; seq[i] = maxSiz; m -= differ; &#125; if (m == 0) &#123; PrintAnswer(maxAns, maxSiz); return 0; &#125; /*/ sort(seq + 1, seq + 1 + n, stlCmp); long long int maxAns = m + seq[n]; long long int minAns = 0; /*/ /*/ int j = n; For (i, 1, m) &#123; ++seq[j--]; if (j == 0) j = n; &#125; /*/ int place = m / n; For (i, 1, n) seq[i] += place; int mod = m % n; int i = n; while (mod --&gt; 0) &#123; ++seq[i--]; &#125; int minAns = *(max_element(seq + 1, seq + 1 + n)); PrintAnswer(maxAns, minAns); return 0;&#125; T3. 维生素问题描述商店里卖着n种果汁，每种果汁都有它的价格ci，每种果汁有一些维生素，维生素有三种类型，维生素A，维生素B，维生素C，每种果汁可以含有其中一种或多种维生素。 你需要3种维生素来保持身体健康，那么你最少需要购买多少价格的果汁才能保证购买的这些果汁包含3种维生素呢？ 输入格式第一行包含一个整数n。 接下来n行，每行包含一个整数ci和一个字符串si，si表示其中蕴含的维生素种类，只包含字母ABC且每个字母最多出现一次。 输出格式输出最小能满足条件的价格，如果不能满足，输出-1。 输入样例1234545 C6 B16 BAC4 A 输出样例115 数据范围对于30%的数据，1&lt;=n&lt;=20。 对于另外20%的数据，所有果汁只包含单种维生素。 对于100%的数据，1&lt;=n&lt;=1000, 1&lt;=ci&lt;=100000。 解题思路DP 我们设$f_{i,j}$表示前i种果汁状态为j时的价格，其中 $j$的值 代表意思 1 含有维生素A 2 含有维生素B 3 含有维生素C 4 含有维生素AB 5 含有维生素BC 6 含有维生素AC 7 含有维生素ABC 转移方程： a[i|w] = min(a[i|w], a[i] + c[i]) w = w | (1 左移 (str[i] - &#39;A&#39;))，其中1 ≤ i ≤ str.length() 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif int n; cin &gt;&gt; n; int t[8 + 2]; for (int i = 0; i &lt;= 8; ++i) t[i] = 60; t[0] = 0; string s; for (int i = 1; i &lt;= n; ++i) &#123; int x; cin &gt;&gt; x; cin &gt;&gt; s; int len = s.length(); int v = 0; for (int j = 1; j &lt;= len; ++j) v |= (1 &lt;&lt; s[j-1] - 'A'); for (int j = 0; j &lt; 8; ++j) t[j | v] = std::min(t[j | v], t[j] + x); &#125; if (t[7] &gt; 1e8) puts("-1"); else cout &lt;&lt; t[7] &lt;&lt; endl; return 0;&#125; T4. 队列挖坑待填]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>清北学堂</tag>
        <tag>贪心</tag>
        <tag>浮点数运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3110 《[USACO14DEC]驮运Piggy Back》]]></title>
    <url>%2F2018-10-04%2FLuogu-P3110%2F</url>
    <content type="text"><![CDATA[披着蓝题的皮跑3遍SPFA的绿题 题目链接 题面由于翻译缺失，暂不提供翻译，这里仅提供英文题面。 题目描述Bessie and her sister Elsie graze in different fields during the day, and in the evening they both want to walk back to the barn to rest. Being clever bovines, they come up with a plan to minimize the total amount of energy they both spend while walking. Bessie spends B units of energy when walking from a field to an adjacent field, and Elsie spends E units of energy when she walks to an adjacent field. However, if Bessie and Elsie are together in the same field, Bessie can carry Elsie on her shoulders and both can move to an adjacent field while spending only P units of energy (where P might be considerably less than B+E, the amount Bessie and Elsie would have spent individually walking to the adjacent field). If P is very small, the most energy-efficient solution may involve Bessie and Elsie traveling to a common meeting field, then traveling together piggyback for the rest of the journey to the barn. Of course, if P is large, it may still make the most sense for Bessie and Elsie to travel separately. On a side note, Bessie and Elsie are both unhappy with the term “piggyback”, as they don’t see why the pigs on the farm should deserve all the credit for this remarkable form of transportation. Given B, E, and P, as well as the layout of the farm, please compute the minimum amount of energy required for Bessie and Elsie to reach the barn. 输入输出格式INPUT: (file piggyback.in) The first line of input contains the positive integers B, E, P, N, and M. All of these are at most 40,000. B, E, and P are described above. N is the number of fields in the farm (numbered 1..N, where N &gt;= 3), and M is the number of connections between fields. Bessie and Elsie start in fields 1 and 2, respectively. The barn resides in field N. The next M lines in the input each describe a connection between a pair of different fields, specified by the integer indices of the two fields. Connections are bi-directional. It is always possible to travel from field 1 to field N, and field 2 to field N, along a series of such connections. OUTPUT: (file piggyback.out) A single integer specifying the minimum amount of energy Bessie and Elsie collectively need to spend to reach the barn. In the example shown here, Bessie travels from 1 to 4 and Elsie travels from 2 to 3 to 4. Then, they travel together from 4 to 7 to 8. 输入样例1234567894 4 5 8 8 1 4 2 3 3 4 4 7 2 5 5 6 6 8 7 8 输出样例122 解题思路为什么这是蓝题&nbsp;这应该是绿题啊 首先肯定是跑最短路 两只牛有这样两种选择： 各自走回家 走到任意一点之后 Bessie 背着 Elsie 回家 那么我们就跑3遍SPFA即可 以 Bessie 为起点（即1点） 以 Elsie 为起点（即2点） 以家为起点（即n点） 这里有个小技巧，不需要写3遍不同的SPFA，只需要把3个dis数组当做参数传进去即可 最后暴力枚举图中的所有点$i$ 如果设$(u,v)$为$u\rightarrow v$的最短路长度的话， 答案就是最小的$ (1,i)+(2,i)+(n,i)$ 注意判断点不连通（距离为INF）的情况 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXN = 4000000 + 10; const int MAXM = 4000000 + 10; const int INF = 0x3f3f3f3f; int b, e, p, n, m; int head[MAXN], disB[MAXN], disE[MAXN], disN[MAXN]; bool inQueue[MAXN]; int cnt; struct Edge &#123; int prev, next, weight; &#125; edge[MAXM]; inline void addEdge(int prev, int next) &#123; edge[++cnt].prev = prev; edge[cnt].next = head[next]; head[next] = cnt; edge[cnt].weight = 1; &#125; void SPFA(int dis[], int s) &#123; //memset(dis, 0, sizeof(dis)); For (i, 0, n) dis[i] = INF; dis[s] = 0; queue&lt;int&gt; q; q.push(s); inQueue[s] = true; while (!q.empty()) &#123; int prev = q.front(); q.pop(); inQueue[prev] = false; for (int e = head[prev]; e; e = edge[e].next) &#123; if (dis[edge[e].prev] &gt; dis[prev] + edge[e].weight) &#123; dis[edge[e].prev] = dis[prev] + edge[e].weight; if (!inQueue[edge[e].prev]) &#123; q.push(edge[e].prev); inQueue[edge[e].prev] = true; &#125; &#125; &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; b = getint(); e = getint(); p = getint(); n = getint(); m = getint(); For (i, 1, m) &#123; int prev, next; prev = getint(); next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; SPFA(disB, 1); SPFA(disE, 2); SPFA(disN, n); int ans = 2147482333; For (i, 1, n) &#123; if (disN[1] == INF || disN[2] == INF || disB[i] == INF || disE[i] == INF || disN[i] == INF ) continue; ans = std::min(ans, b * disB[i] + e * disE[i] + p * disN[i]); &#125; putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>图论算法</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day3 题解]]></title>
    <url>%2F2018-10-03%2F2018AutumnQBXTDay3%2F</url>
    <content type="text"><![CDATA[不同寻常的题面 T1. H因子问题描述h因子是一种评价学术成就的新方法。一名科研人员的h因子是指他至少有h篇论文分别被引用了不少于h次。Alice已经发表了很多论文了，现给出一个序列a0，a1，a2，…，an，其中 $a_i$ 表示有 $a_i$ 篇文章分别被引用了i次。 请你求出Alice的h因子。 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含一个正整数n（1≤n≤200,000） 。 每组数据的第二行包含n个正整数a0，a1，a2，……，an（1≤ai≤1000,000,000），表示序列中的每个数。 输出格式对于每组数据，输出一行，包含一个整数，表示该组数据的h因子 。 样例输入1234567311 221 2 330 0 0 0 样例输出123120 解题思路首先要把题看懂！！！ 首先要把题看懂！！！ 首先要把题看懂！！！ （我就因为题意理解错误而完美爆零） 我们从n开始，从大到小枚举h因子 一个有效的h因子为i当且仅当有大于等于i篇文章被引用了大于等于i次 所以我们可以用一个sum来存当前有多少篇文章被引用了大于等于当前i次 第一个满足sum &gt;= i的i即为最大的h因子 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start */const int MAXN = 200000 + 10;/* Constants End *//* Variants Start */int seq[MAXN];/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace FastIO; int t = getint(); while (t --&gt; 0) &#123; int n = getint(); for (int i = 0; i &lt;= n; ++i) &#123; seq[i] = getint(); &#125; int sum = 0; for (int i = n; i &gt;= 0; --i) &#123; sum += seq[i]; if (sum &gt;= i) &#123; putint(i, '\n'); break; &#125; &#125; &#125; return 0;&#125; T2. 超回文字符串问题描述给出一个只由小写字母的字符串，要求在最少的操作数下将它转成一个超回文字符串。每次操作仅可以改变字符串中的一个字符。 一个字符串被称为超回文字符串，当且仅当它的所有奇数长度的子串都是回文串（回文串是指一个字符串从前往后与从后往前读是一样的）。 输入格式第一行包含一个正整数T（1≤T≤100），表示有多少组数据。 对于每组数据，只有单独一行，包含一个仅由小写字母组成的字符串。保证字符串的长度不超过100。 输出格式对于每组数据，输出一行，包含一个整数，表示最少的操作数。 样例输入12343ncncnaaaabaaaaabb 样例输出123012 解题思路简单分析之后，我们发现满足题目要求的字符串存在当且仅当这个字符串的奇数位、偶数位分别相同 那么直接暴力就好 我们枚举每一个奇数位上的字母，计算有多少个奇数位上的字母与它不同（即要修改多少次） 取个min即为答案 偶数位同理 将两个min相加即为答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif int t; cin &gt;&gt; t; string s; while (t --&gt; 0) &#123; cin &gt;&gt; s; int len = s.length(); int min1 = len, min2 = len; for (int i = 0; i &lt; len; i += 2) &#123; int now = 0; for (int j = 0; j &lt; len; j += 2) &#123; if (s[i] != s[j]) ++now; &#125; min1 = std::min(min1, now); &#125; if (len == 1) min2 = 0; for (int i = 1; i &lt; len; i += 2) &#123; int now = 0; for (int j = 1; j &lt; len; j += 2) &#123; if (s[i] != s[j]) ++now; &#125; min2 = std::min(min2, now); &#125; cout &lt;&lt; min1 + min2 &lt;&lt; endl; &#125; return 0;&#125; T3. 移动桌子问题描述题面略（表格太多） 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含一个正整数n（1≤n≤200,000），表示要移动n张桌子 。 每组数据的接下来n行，每行包含2个正整数a和b，表示该张桌子原本在房间a，需要移动到房间b。 输出格式对于每组数据，输出一行，包含一个整数，表示移动完n张桌子所需要的最少时间 。 输入样例123456789101112133410 2030 4050 6070 8021 32 200310 10020 8030 50 输出样例123102030 解题思路我们对于每一个桌子的区间头和区间尾都加一再除以二（将房间化为走廊） 接着开一个长度为250的桶，把走廊长度累计到这个桶里面（暴力区间加1） 最后取最大值，乘以10（一次移动桌子10十分钟）就是最终答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start */int way[250 + 10];/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace FastIO; int t = getint(); while (t --&gt; 0) &#123; memset(way, 0, sizeof(way)); int n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; int s = getint(); int t = getint(); s = (s + 1) &gt;&gt; 1; t = (t + 1) &gt;&gt; 1; for (int j = s; j &lt;= t; ++j) ++way[j]; &#125; int ans = 0; for (int i = 1; i &lt;= 250; ++i) ans = std::max(ans, way[i]); putint(ans * 10, '\n'); &#125; return 0;&#125; T4. 口算问题描述Alice口算能力非常强。Bob为了考考Alice，给了她一个长度为n的正整数序列a1，a2，……，an，同时抛出了m个问题。 每个问题给出三个正整数。 Alice需要快速判断出$a_l\times a_{l+1}\times \dots \times a_{r-1} \times a_r $ 是不是d的倍数。 Alice凭借她强大的口算能力快速给出了答案。然而Bob很菜，他并不知道正确答案是什么。请写一个程序帮助Bob计算这些问题的答案。 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含两个正整数n，m（1≤n,m≤100,000），分别表示序列长度以及问题个数。 第二行包含n个正整数a1，a2，……，an（1≤ai≤100,000），表示序列中的每个数。 接下来的m行，每行包含3个正整数l,r,d（1≤l≤r≤n，1≤d≤100,000），表示每个问题。 输出格式对于每个问题，输出一行，若是倍数，输出Yes，否则输出No。 输入样例1234567815 56 4 7 2 51 2 241 3 182 5 173 5 351 3 21 输出样例12345YesNoNoYesYes 数据规模【数据规模】 对于30%数据，1≤T≤5，1≤n,m≤50，且保证对于每一个问题，$a_l\times a_{l+1}\times \dots \times a_{r-1} \times a_r $不超过long long的数据范围。 对于60%数据，1≤T≤10，1≤n,m≤1000，1≤ai≤1000 对于100%数据，1≤T≤10，1≤n,m≤100,000，1≤ai≤100,000 解题思路暴力做法30pts 的模拟 （伪）正解进行质因数分解，暴力判断 正解在（伪）正解的基础上进行优化 预处理：将所有的数进行质因数分解，按照顺序把所有质数的出现的下标push_back进每个质数专门的vector里 将读入的d进行质因数分解，同上push_back进一个专门的vector里 然后在给定的区间里进行寻找质因数（使用lower_bound和upper_bound） 如果该有的质因数都有，显然可以整除 否则不可以整除 代码实现不提供。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>清北学堂</tag>
        <tag>玄学题面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day3 题解]]></title>
    <url>%2F2018-10-03%2F2018AutumnQBXTDay3%20(1)%2F</url>
    <content type="text"><![CDATA[不同寻常的题面 T1. H因子问题描述h因子是一种评价学术成就的新方法。一名科研人员的h因子是指他至少有h篇论文分别被引用了不少于h次。Alice已经发表了很多论文了，现给出一个序列a0，a1，a2，…，an，其中 $a_i$ 表示有 $a_i$ 篇文章分别被引用了i次。 请你求出Alice的h因子。 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含一个正整数n（1≤n≤200,000） 。 每组数据的第二行包含n个正整数a0，a1，a2，……，an（1≤ai≤1000,000,000），表示序列中的每个数。 输出格式对于每组数据，输出一行，包含一个整数，表示该组数据的h因子 。 样例输入1234567311 221 2 330 0 0 0 样例输出123120 解题思路首先要把题看懂！！！ 首先要把题看懂！！！ 首先要把题看懂！！！ （我就因为题意理解错误而完美爆零） 我们从n开始，从大到小枚举h因子 一个有效的h因子为i当且仅当有大于等于i篇文章被引用了大于等于i次 所以我们可以用一个sum来存当前有多少篇文章被引用了大于等于当前i次 第一个满足sum &gt;= i的i即为最大的h因子 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start */const int MAXN = 200000 + 10;/* Constants End *//* Variants Start */int seq[MAXN];/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace FastIO; int t = getint(); while (t --&gt; 0) &#123; int n = getint(); for (int i = 0; i &lt;= n; ++i) &#123; seq[i] = getint(); &#125; int sum = 0; for (int i = n; i &gt;= 0; --i) &#123; sum += seq[i]; if (sum &gt;= i) &#123; putint(i, '\n'); break; &#125; &#125; &#125; return 0;&#125; T2. 超回文字符串问题描述给出一个只由小写字母的字符串，要求在最少的操作数下将它转成一个超回文字符串。每次操作仅可以改变字符串中的一个字符。 一个字符串被称为超回文字符串，当且仅当它的所有奇数长度的子串都是回文串（回文串是指一个字符串从前往后与从后往前读是一样的）。 输入格式第一行包含一个正整数T（1≤T≤100），表示有多少组数据。 对于每组数据，只有单独一行，包含一个仅由小写字母组成的字符串。保证字符串的长度不超过100。 输出格式对于每组数据，输出一行，包含一个整数，表示最少的操作数。 样例输入12343ncncnaaaabaaaaabb 样例输出123012 解题思路简单分析之后，我们发现满足题目要求的字符串存在当且仅当这个字符串的奇数位、偶数位分别相同 那么直接暴力就好 我们枚举每一个奇数位上的字母，计算有多少个奇数位上的字母与它不同（即要修改多少次） 取个min即为答案 偶数位同理 将两个min相加即为答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif int t; cin &gt;&gt; t; string s; while (t --&gt; 0) &#123; cin &gt;&gt; s; int len = s.length(); int min1 = len, min2 = len; for (int i = 0; i &lt; len; i += 2) &#123; int now = 0; for (int j = 0; j &lt; len; j += 2) &#123; if (s[i] != s[j]) ++now; &#125; min1 = std::min(min1, now); &#125; if (len == 1) min2 = 0; for (int i = 1; i &lt; len; i += 2) &#123; int now = 0; for (int j = 1; j &lt; len; j += 2) &#123; if (s[i] != s[j]) ++now; &#125; min2 = std::min(min2, now); &#125; cout &lt;&lt; min1 + min2 &lt;&lt; endl; &#125; return 0;&#125; T3. 移动桌子问题描述题面略（表格太多） 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含一个正整数n（1≤n≤200,000），表示要移动n张桌子 。 每组数据的接下来n行，每行包含2个正整数a和b，表示该张桌子原本在房间a，需要移动到房间b。 输出格式对于每组数据，输出一行，包含一个整数，表示移动完n张桌子所需要的最少时间 。 输入样例123456789101112133410 2030 4050 6070 8021 32 200310 10020 8030 50 输出样例123102030 解题思路我们对于每一个桌子的区间头和区间尾都加一再除以二（将房间化为走廊） 接着开一个长度为250的桶，把走廊长度累计到这个桶里面（暴力区间加1） 最后取最大值，乘以10（一次移动桌子10十分钟）就是最终答案 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;/* Constants Start *//* Constants End *//* Variants Start */int way[250 + 10];/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace FastIO; int t = getint(); while (t --&gt; 0) &#123; memset(way, 0, sizeof(way)); int n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; int s = getint(); int t = getint(); s = (s + 1) &gt;&gt; 1; t = (t + 1) &gt;&gt; 1; for (int j = s; j &lt;= t; ++j) ++way[j]; &#125; int ans = 0; for (int i = 1; i &lt;= 250; ++i) ans = std::max(ans, way[i]); putint(ans * 10, '\n'); &#125; return 0;&#125; T4. 口算问题描述Alice口算能力非常强。Bob为了考考Alice，给了她一个长度为n的正整数序列a1，a2，……，an，同时抛出了m个问题。 每个问题给出三个正整数。 Alice需要快速判断出$a_l\times a_{l+1}\times \dots \times a_{r-1} \times a_r $ 是不是d的倍数。 Alice凭借她强大的口算能力快速给出了答案。然而Bob很菜，他并不知道正确答案是什么。请写一个程序帮助Bob计算这些问题的答案。 输入格式第一行包含一个正整数T（1≤T≤10），表示有多少组数据。 每组数据的第一行包含两个正整数n，m（1≤n,m≤100,000），分别表示序列长度以及问题个数。 第二行包含n个正整数a1，a2，……，an（1≤ai≤100,000），表示序列中的每个数。 接下来的m行，每行包含3个正整数l,r,d（1≤l≤r≤n，1≤d≤100,000），表示每个问题。 输出格式对于每个问题，输出一行，若是倍数，输出Yes，否则输出No。 输入样例1234567815 56 4 7 2 51 2 241 3 182 5 173 5 351 3 21 输出样例12345YesNoNoYesYes 数据规模【数据规模】 对于30%数据，1≤T≤5，1≤n,m≤50，且保证对于每一个问题，$a_l\times a_{l+1}\times \dots \times a_{r-1} \times a_r $不超过long long的数据范围。 对于60%数据，1≤T≤10，1≤n,m≤1000，1≤ai≤1000 对于100%数据，1≤T≤10，1≤n,m≤100,000，1≤ai≤100,000 解题思路暴力做法30pts 的模拟 （伪）正解进行质因数分解，暴力判断 正解在（伪）正解的基础上进行优化 预处理：将所有的数进行质因数分解，按照顺序把所有质数的出现的下标push_back进每个质数专门的vector里 将读入的d进行质因数分解，同上push_back进一个专门的vector里 然后在给定的区间里进行寻找质因数（使用lower_bound和upper_bound） 如果该有的质因数都有，显然可以整除 否则不可以整除 代码实现不提供。]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>清北学堂</tag>
        <tag>玄学题面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3956「NOIP2017普及组」《棋盘》]]></title>
    <url>%2F2018-10-02%2FNOIP2017-PJ-Chess%2F</url>
    <content type="text"><![CDATA[使用什么法？mo法？说清楚？！ 题目链接 题目描述有一个$m \times m$的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。 任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、 下、左、 右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 1个金币。 另外， 你可以花费 2 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。 现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？ Input / Output 格式 &amp; 样例输入格式第一行包含两个正整数$m, n$，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。 接下来的$n$行，每行三个正整数$x, y, c$， 分别表示坐标为$(x,y)$的格子有颜色$c$。 其中$c=1$ 代表黄色，$c=0$ 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为$(1, 1)$，右下角的坐标为$( m, m)$。 棋盘上其余的格子都是无色。保证棋盘的左上角，也就是 $(1,1)$ 一定是有颜色的。 输出格式一个整数，表示花费的金币的最小值，如果无法到达，输出-1。 输入样例Case #1: 123456785 71 1 01 2 02 2 13 3 13 4 04 4 15 5 0 Case #2: 1234565 51 1 01 2 02 2 13 3 15 5 0 输出样例Case #1: 18 Case #2: 1-1 样例解释 &amp; 其他说明对于 $30\%$的数据, $1 ≤ m ≤ 5, 1 ≤ n ≤ 10$ 对于 $60\%$数据, $1 ≤ m ≤ 20, 1 ≤ n ≤ 200$ 对于 $100\%$的数据, $1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$ 解题思路我们并不需要维护某一个点是否走过 我们需要判断边界、白格子、最优性剪枝和走到终点四种情况 用$mp$数组存图，规定0表示白色，1表示红色，2表示黄色 用$f_{i,j}$表示$1,1$到$i,j$的最少花费 本题主要的难点在于加入了膜法机制 那么DFS需要传递四个参数： intx坐标和y坐标 int当前使用的金币数量 bool当前是否使用了膜法 在四向DFS中，需要进行以下几点判断： 当前格是否有颜色若无颜色且并未使用膜法，则使用膜法，使用金币数量+2，继续DFS；若无颜色且使用过膜法，没救了 当前格颜色和下一格颜色是否相同若颜色相同，直接进行下一步DFS；若颜色不同，使用金币数量+1，继续DFS 要注意的是，$f$数组的赋值要在判断是否走到终点之前，最优性剪枝之后，不然可能出现赋值不上的情况 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int MAXM = 100 + 10; int f[MAXM][MAXM]; int mp[MAXM][MAXM]; #define WHITE 0 #define RED 1 #define YELLOW 2 const int dx[5] = &#123;0, 0, 0, -1, 1&#125;; const int dy[5] = &#123;0, -1, 1, 0, 0&#125;; int m, n, ans = 2147482333; void DaFaShi(int x, int y, int nowSum, bool usedMogic) &#123; // 苟利国家生死以 // 岂因祸福避趋之 // 你们啊，不要总是想弄个大新闻 // 说什么使用膜法 // 再把我批判一番 if (x &lt; 1 || y &lt; 1 || x &gt; m || y &gt; m) return; // 边界 if (mp[x][y] == WHITE) return; // 走到白格子 if (nowSum &gt;= f[x][y]) return; // 最优性剪枝 f[x][y] = nowSum; if (x == m &amp;&amp; y == m) &#123; ans = std::min(nowSum, ans); return; // 搜索完成 &#125; For (i, 1, 4) &#123; int nx = x + dx[i]; int ny = y + dy[i]; if (mp[nx][ny] != WHITE) &#123; // 有颜色 if (mp[nx][ny] == mp[x][y]) DaFaShi(nx, ny, nowSum, false); // 颜色相同，继续往后搜 else DaFaShi(nx, ny, nowSum + 1, false); // 颜色不同，花费金币 &#125; else if (mp[nx][ny] == WHITE &amp;&amp; !usedMogic)&#123; // 没颜色且没用膜法 mp[nx][ny] = mp[x][y]; // 念诗，使用膜法 DaFaShi(nx, ny, nowSum + 2, true); // 使用膜法花费2金币 mp[nx][ny] = WHITE; // 回溯 &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; using namespace FastIO; memset(f, 0x7f, sizeof(f)); m = getint(); n = getint(); For (i, 1, n) &#123; int x, y, c; x = getint(); y = getint(); c = getint(); mp[x][y] = c + 1; &#125; DaFaShi(1, 1, 0, false); if (ans == 2147482333) puts("-1"); else putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2040《打开所有的灯》]]></title>
    <url>%2F2018-10-02%2FLuogu-P2040%2F</url>
    <content type="text"><![CDATA[益(ruo)智(zhi)的小游戏 题目链接 题目背景pmshz在玩一个益(ruo)智(zhi)的小游戏，目的是打开九盏灯所有的灯，这样的游戏难倒了pmshz。。。 题目描述这个灯很奇(fan)怪(ren)，点一下就会将这个灯和其周围四盏灯的开关状态全部改变。现在你的任务就是就是告诉pmshz要全部打开这些灯。 例如 0 1 1 1 0 0 1 0 1 点一下最中间的灯【2,2】就变成了 0 0 1 0 1 1 1 1 1 再点一下左上角的灯【1,1】就变成了 1 1 1 1 1 1 1 1 1 达成目标。最少需要2步。 输出2即可。 Input / Output 格式 &amp; 样例输入格式九个数字，3*3的格式输入，每两个数字中间只有一个空格，表示灯初始的开关状态。（0表示关，1表示开） 输出格式1个整数，表示最少打开所有灯所需要的步数。 输入样例1230 1 11 0 01 0 1 输出样例12 解题思路易证得我们对于一个灯的开关，只需要按1或0次 所以只需要考虑这个开关按与不按即可 所以我们可以直接进行搜索，总运算次数不会超过$9^9$ 用$used$数组记录$used_i$这个开关是否已经按过，用$f$数组记录$f_{i,j}$的亮灭情况 代码实现（以后就这个码风了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; bool used[3 + 2][3 + 2]; int f[3 + 2][3 + 2], ans = 10; const int dx[5] = &#123;0, 0, 0, -1, 1&#125;; const int dy[5] = &#123;0, -1, 1, 0, 0&#125;; void modify(int x, int y) &#123; for (int i = 0; i &lt;= 4; ++i) &#123; f[x + dx[i]][y + dy[i]] = !f[x + dx[i]][y + dy[i]]; &#125; &#125; bool Check() &#123; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (!f[i][j]) return false; &#125; &#125; return true; &#125; void dfs(int steps) &#123; if (steps &gt;= ans) return; if (Check()) ans = std::min(ans, steps); for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; if (!used[i][j]) &#123; used[i][j] = true; modify(i, j); dfs(steps+1); modify(i, j); used[i][j] = false; &#125; &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif using namespace Solution; for (int i = 1; i &lt;= 3; ++i) &#123; for (int j = 1; j &lt;= 3; ++j) &#123; f[i][j] = FastIO::getint(); &#125; &#125; dfs(0); FastIO::putint(ans, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day2 题解]]></title>
    <url>%2F2018-10-02%2F2018AutumnQBXTDay2%2F</url>
    <content type="text"><![CDATA[由于缺少题面，故本篇无内容。 这里仅提供T1. coin的代码实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; // 中国有句古话叫做闷声ACCEPT // 我就什么都不写，才是坠吼的 &#125;int main(int argc, char *const argv[]) &#123; #ifndef HANDWER_FILE freopen("coin.in", "r", stdin); freopen("coin.out", "w", stdout); #endif int t; cin &gt;&gt; t; char c; int x = 0, X = 0; while (t --&gt; 0) &#123; cin &gt;&gt; c; switch(c) &#123; case 'x' : ++x; break; case 'X' : ++X; break; &#125; &#125; if (x == X) &#123; puts("0"); return 0; &#125; int cnt = 0; if (x &lt; X) &#123; while (x != X) &#123; ++x, --X, ++cnt; &#125; &#125; if (X &lt; x) &#123; while (x != X) &#123; ++X, --x, ++cnt; &#125; &#125; FastIO::putint(cnt, '\n'); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>清北学堂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 日记]]></title>
    <url>%2F2018-10-01%2F2018AutumnQBXTDiary%2F</url>
    <content type="text"><![CDATA[Handwer STD 好菜啊 Day1考试150pts 本来能拿200pts的 结果T1写炸了只拿了50pts 靠着这样的成绩居然玄学地拿到了第三名 第一名 200pts 第二名190pts 还拿到了一个有线鼠标 首战告捷（人生中第一次比赛拿奖 在提高被虐惯了） Day2考试140pts T1数据有锅 题面保证数据没有奇数，结果只有3组数据是偶数，导致我只拿了30pts 好在最后重测了 拿到了100pts T2和T3根本没看 T4打了个暴力，枚举边跑Dijkstra，期望得分60pts，结果把m写成n……只拿了40pts 最后还是水到了一个rk5 不过今天并没有鼠标 Day3考试爆炸 只拿了80pts 被zxk吊打 T1阅读题，根本没理清题意，0pt T2规律题 T3贪心，但由于没有认真阅读题目，导致只拿了60pts T4有技巧的数学题，打了个30pts的暴力结果只拿了20pts 最终居然还水进了前10 我好菜啊…… Day4今天的题目 好！简！单！啊！ 今天的是真的普及组题目了 T1和T2都是水题，T3暴力分也是足够的，凭220pts拿了个rank3 讲T2的时候被老师拉上去讲题，感觉整个人都在抖，毫无准备的就上去了，说话也是语无伦次，真是差点要吓死了 不过重点不在这个 今天下午三点的时候RainAir问我成绩和排名，我如实地告诉了他后面的事应该不需要想了，我被他膜了一下午 但！是！接近八点的时候，Logey先是问了一下「致远星战况如何？」然后就开始膜我……说时迟，那时快，iShq也开始膜我了接着，就是三个人一块膜我，我被膜了一晚上！这群人fAKe起来真是没有底线啊……他们甚至把群名改成了「王太阳fAKe群」！ 我写博客快要写死了，今天T2要不对着代码讲出来真是太麻烦了，果然我水平还是低啊一口气更了三篇博客，感觉自己身体素质越来越差了，熬夜都熬不了了 对了，现在时间是2018年10月5日凌晨0点04分 Day5今天题目暴力分给的真是够多的了 T1 AC，T2应该是90pts，T4应该是70pts，总分250pts，拿到了一个rank6 T2本来能A掉的，但是我正解在考完试20min之后才调出来 难受 又一次忙活到了23点 好累啊qaq Day6今天的题目不知为何我只拿了110pts qaq T1 100pts，T2 0，T3 0, T4只搜到了10pts 看着别人上去拿键盘 拿鼠标 心里有点羡慕（虽然我已经有一个鼠标了 这个句号虽然不够圆满，但是至少是完整的。]]></content>
      <tags>
        <tag>清北学堂</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Autumn 清北学堂普及刷题班 Day1 题解]]></title>
    <url>%2F2018-10-01%2F2018AutumnQBXTDay1%2F</url>
    <content type="text"><![CDATA[不知不觉弄了个鼠标回来（雾 T1. 扑克牌题面【题目描述】 这天， 小 Q 来到了小杜家， 找小杜玩起了扑克牌的游戏。 扑克牌有 54 张牌， 分别是数字 A,2,3,4,5,6,7,8,9,10,J,Q,K，每种数字有 4 个花色， 分别为红桃， 黑桃， 方块， 梅花， 还有两张大王和小王。 这天小 Q 和小杜玩起来比大小的游戏， 两人各拿出一张扑克牌比大小， 很显然 3&lt;4&lt;5&lt;6&lt;7&lt;8&lt;9&lt;10&lt;J&lt;Q&lt;K&lt;A&lt;2&lt;小王&lt;大王， 为了防止数字相同无法比较， 他们给花色也定了一个大小梅花&lt;方块&lt;黑桃&lt;红桃， 规定先比较数字， 数字相同再比较花色， 由于他们只有一副扑克牌， 拿出的两张牌不可能相同， 所以一定能比出大小。 【输入描述】 第一行一个数字 T， 表示小 Q 和小杜玩的次数。 接下来 T 行， 每行两个用空格隔开的数字。 其中 1-13 分别表示梅花 A,2,3,4,5,6,7,8,9,10,J,Q,K。 其中 14-26 分别表示方块 A,2,3,4,5,6,7,8,9,10,J,Q,K。 其中 27-39 分别表示黑桃 A,2,3,4,5,6,7,8,9,10,J,Q,K。 其中 40-52 分别表示红桃 A,2,3,4,5,6,7,8,9,10,J,Q,K。 53 表示小王， 54 表示大王。 第一个数表示小 Q 的牌， 第二个数表示小杜的牌。 【输出描述】 输出共 T 行， 每行一个字母 Q 或者 D， Q 表示小 Q 赢， D 表示小杜赢。 Input / Output 格式 &amp; 样例输入格式 &amp; 输出格式见题面。 输入样例1232 11 131 53 输出样例12QD 样例解释 &amp; 注意事项【样例解释】 第一局小 Q 是梅花 A， 小杜是梅花 K， 所以小 Q 大 第二局小 Q 是梅花 A， 小杜是小王， 所以小杜大。 【数据范围】 对于 30%的数据， 扑克牌的范围在[1,13]。 对于 50%的数据， 不会出现大小王。 对于 100%的数据， 1&lt;=T&lt;=100。 解题思路 照题意模拟 这里有一个小技巧 你可以对读入的数字（必须保证数字不代表大、小王） $mod\ 13$ 得到的新数字： 120 1 2 3 4 5 6 7 8 9 10 11 12K A 2 3 4 5 6 7 8 9 10 J Q 接着特判，把K改成13，把A改成14，把2改成15，把小王改成16，把大王改成17 最后直接比较新数字就行了 当新数字相同时依题意可直接比较原数字的大小 代码实现（依然毒瘤风格） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; int queryNum(int x) &#123; if (x &lt;= 52) &#123; x %= 13; if (x == 0) x = 13; if (x == 1) x = 14; if (x == 2) x = 15; return x; &#125; else return x - 52 + 15; &#125; char Judge(int q, int d) &#123; int qa = queryNum(q); int da = queryNum(d); if (qa == da) return q &lt; d ? 'D' : 'Q'; return qa &lt; da ? 'D' : 'Q'; &#125;&#125; int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("poker.in", "r", stdin); freopen("poker.out", "w", stdout); #endif using FastIO::getint; using FastIO::putint; int t = getint(); while (t --&gt; 0) &#123; int q = getint(); int d = getint(); cout &lt;&lt; Solution::Judge(q, d) &lt;&lt; endl; &#125; return 0;&#125; T2. 密码题面【题目描述】 小杜开始学习 C++， 小杜想进行一些练习， 于是小杜准备上某题库网站进行做题练习， 小杜发现这样的网站都需要进入注册之后， 才可以登录进行练习， 于是小杜准备注册一个账号。 在填写了一大堆信息之后， 网站要求小杜输入密码， 这让小杜犯了难， 网站对密码的有一定的要求， 密码只能包含大写字母， 小写字母， 并且必须包含至少一个大写字母， 至少一个小写字母， 那么对于小杜的密码， 是否符合该网站的要求呢？如果不符合网站的要求， 那么如何修改让密码变得符合要求呢，一次修改只能将密码的某一位修改成一个大写字母或小写字母， 如果有多个密码符合条件， 需要修改次数最少的， 对于修改次数相同的，输出字典序最小的（按 ASCII 码） 【输入描述】 第一行一个数字 T 表示数据组数。 接下来 T 行， 每行一个字符串表示小杜的密码。 【输出描述】 共 T 行。 若小杜的密码符合条件， 将密码直接输出即可， 否则输出修改后的密码 。 Input / Output 格式 &amp; 样例输入输出格式见题面。 输入样例1232abaCABAqwerty 输出样例12abaCABAAwerty 样例解释 &amp; 注意事项【数据范围】 对于 30%的数据， 只包含小写字母。对于另外 20%的数据， 只包含大写字母。对于 100%的数据， 1&lt;=T&lt;=100， 字符串长度不超过 100 并且大于等于 3，保证输入数据只包含大、小写字母。 解题思路 依然照题意模拟 我们贪心地认为字母A越靠前，字母a越靠后，整个字符串字典序就越小 那么本题分两种情况讨论： 只含有大写字母 只含有小写字母 含有特殊字符并没有 对于只含有大写字母的情况，把字符串末尾修改成a即可。 对于只含有小写字母的情况，把字符串开头修改成A即可。 代码实现（还是这种玄学码风 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;/* Constants Start *//* Constants End *//* Variants Start */string s;/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; bool Check(string str, int lenstr, bool &amp;hasUpper, bool &amp;hasLower) &#123; hasUpper = false; hasLower = false; Forw (i, 0, lenstr) &#123; if (isupper(str[i])) hasUpper = true; else if (islower(str[i])) hasLower = true; else return false; &#125; if (hasUpper &amp;&amp; hasLower) return true; return false; &#125; string Modify(string str, int lenstr, bool hasUpper, bool hasLower) &#123; string ret = str; if (hasUpper == false &amp;&amp; hasLower == false) &#123; Forw (i, 0, lenstr - 1) ret[i] = 'A'; ret[lenstr - 1] = 'a'; ret[lenstr] = '\0'; &#125; if (hasUpper == false &amp;&amp; hasLower) &#123; ret[0] = 'A'; &#125; if (hasUpper &amp;&amp; hasLower == false) &#123; ret[lenstr - 1] = 'a'; &#125; if (hasUpper &amp;&amp; hasLower) &#123; Forw (i, 0, lenstr) &#123; if (!isupper(ret[i]) &amp;&amp; !islower(ret[i])) &#123; ret[i] = 'A'; &#125; &#125; &#125; return ret; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("pass.in", "r", stdin); freopen("pass.out", "w", stdout); #endif int t = 0; cin &gt;&gt; t; while (t --&gt; 0) &#123; cin &gt;&gt; s; int lens = s.length(); bool hasUpper = false, hasLower = false; if (Solution::Check(s, lens, hasUpper, hasLower)) cout &lt;&lt; s &lt;&lt; endl; else cout &lt;&lt; Solution::Modify(s, lens, hasUpper, hasLower) &lt;&lt; endl; &#125; return 0;&#125; T3. 下棋题面【题目描述】 小 Q 拿出了一张 2 行 N 列的棋盘， 棋盘的每个位置可以放一颗黑棋或者一颗白棋。 若两个棋子颜色相同且位置相邻我们就认为这两个棋子连成了一片， 当然两个棋子都和另一个棋子连成一片， 我们也认为这两个棋子连成一片。 这天小杜突发奇想， 小杜想知道这个棋盘上有多少种放棋子的方法使得棋盘上的棋子片数为 K。 这个数目可能非常大， 请输出方法对 998244353 取模的结果。 【输入描述】 两个数 N 和 K， 用空格隔开。 【输出描述】 一个数字表示方案数。 Input &amp; Output 格式 &amp; 样例输入输出格式见题面。 输入样例13 4 输出样例112 样例解释 &amp; 注意事项【数据范围】 对于 30%的数据， 1&lt;=N&lt;=10,1&lt;=K&lt;=2N。 对于 50%的数据， 1&lt;=N&lt;=100,1&lt;=K&lt;=2N。 对于 100%的数据， 1&lt;=N&lt;=1000,1&lt;=K&lt;=2N。 解题思路考场上死活没看出这是DP 我们设dp[i][j]=k表示前$2\times i$个格子，有$j$片，最后一个$2\times i$的格子的状态为$k\ (0 \le k \le 3)$ 那么只需要枚举下一个$2\times i$的状态$p\ (0 \le p \le 3)$，进行转移即可 转移有$4\times4=16$种方案，可以先判断加$0$片和加$1$片的情况，剩下的就是加$2$片的情况，代码会简洁不少 不要忘了最后$ans$要$mod\ 998244353$ 代码实现（玄学码风无误了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Forw(a,x,y) for (int a = x; a &lt; y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;/* Constants Start *//* Constants End *//* Variants Start *//* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;namespace Solution &#123; const int HA = 998244353; int Query(int x, int y) &#123; if (x == y) return 0; if (x == 0) return 1; if (x == 3) return 1; if (y == 0) return 0; if (y == 3) return 0; return 2; &#125; const int MAXN = 2000 + 10; long long int f[MAXN][4]; long long int x[MAXN][4]; long long int Work(int n, int k) &#123; f[1][0] = f[1][3] = 1; f[2][1] = f[2][2] = 1; Forw (i, 0, n - 1) &#123; memset(x, 0, sizeof(x)); For (j, 1, MAXN - 10) &#123; Forw (xx, 0, 4) &#123; Forw (y, 0, 4) &#123; x[j + Query(xx, y)][y] += f[j][xx]; x[j + Query(xx, y)][y] %= HA; &#125; &#125; &#125; std::swap(f, x); &#125; return (f[k][0] + f[k][1] + f[k][2] + f[k][3]) % HA; &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("chess.in", "r", stdin); freopen("chess.out", "w", stdout); #endif int n = FastIO::getint(); int k = FastIO::getint(); FastIO::putint(Solution::Work(n, k), '\n'); return 0;&#125; T4. 堆积木太蒻不写]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>清北学堂</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 349B 《Color the Fence》]]></title>
    <url>%2F2018-09-30%2FCF349B%2F</url>
    <content type="text"><![CDATA[瞎贪心 题目描述 翻译来自洛谷 Igor深深爱上了Tanya. 现在, Igor想表达他的爱意, 他便在Tanya家对面的墙上写下一串数字. Igor认为, 数字写得越大, Tanya越喜欢他. 不幸的是, 他只有 $v$ 升油漆, 每个数字都会花掉一定的油漆 $a_i$ . Igor不喜欢 $0$ 所以数中不会出现 $0$. 问Igor能得到的最大的数是多少. Input / Output 格式 &amp; 样例输入格式第一行一个整数$v$，意义如题 第二行有九个数字$a_1,\ a_2,\ a_3,\ \dots \ ,\ a_9$，表示第$i$个数字需要$a_i$升油漆 输出格式一行一个整数，表示最大的Igor可以得到的数。 输入样例Case #1: 1255 4 3 2 1 2 3 4 5 Case #2: 1229 11 1 12 5 8 9 10 6 Case #3: 1201 1 1 1 1 1 1 1 1 输出样例Case #1: 155555 Case #2: 133 Case #3: 1-1 解题思路明显的贪心 先对这个序列排序（优先队列方便快捷），再从小到大依次计算可以画出的数字和画出数字的次数 接着从9到1进行枚举，看一看有没有什么可以替换一下的，替换成花费相对最小的数字 最后输出答案数组 代码实现玄学代码风格（雾 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/* -- Basic Headers -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;/* -- STL Iterator -- */#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;queue&gt;/* -- Defined Functions -- */#define For(a,x,y) for (int a = x; a &lt;= y; ++a)#define Bak(a,y,x) for (int a = y; a &gt;= x; --a)using namespace std;/* Constants Start *//* Constants End *//* Variants Start */int v;int q[10]; // q[i].first = variant// q[i].second = idint ans[10];priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt; &gt;, greater&lt;pair&lt;int, int&gt; &gt; &gt; pq;/* Variants End */namespace FastIO &#123; void DEBUG(char comment[], int x) &#123; cerr &lt;&lt; comment &lt;&lt; x &lt;&lt; endl; &#125; inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x; &#125; inline void __basic_putint(int x) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) __basic_putint(x / 10); putchar(x % 10 + '0'); &#125; inline void putint(int x, char external) &#123; __basic_putint(x); putchar(external); &#125;&#125;int main(int argc, char *const argv[]) &#123; #ifdef HANDWER_FILE freopen("testdata.in", "r", stdin); freopen("testdata.out", "w", stdout); #endif v = FastIO::getint(); For (i, 1, 9) &#123; q[i] = FastIO::getint(); pq.push(std::make_pair(q[i], -i)); &#125; // 贪心选择当前最优 while (!pq.empty()) &#123; pair&lt;int, int&gt; pr = pq.top(); pq.pop(); ans[-pr.second] = v / pr.first; v %= pr.first; &#125; q[0] = 2147482333; // 进行替换 Bak (i, 9, 1) &#123; int tmp = 0; Bak (j, i - 1, 1) &#123; if (ans[j] &amp;&amp; q[j] &lt; q[tmp]) tmp = j; &#125; if (!tmp) continue; while (ans[tmp] &amp;&amp; v &amp;&amp; v &gt;= q[i] - q[tmp]) v -= q[i] - q[tmp], ++ans[i], --ans[tmp]; &#125; bool Printed = false; Bak (i, 9, 1) &#123; while (ans[i]) &#123; FastIO::__basic_putint(i); --ans[i]; Printed = true; &#125; &#125; // 程序并没有正确答案，输出-1 if (!Printed) puts("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 333A 《Secrets》]]></title>
    <url>%2F2018-09-30%2FCF333A%2F</url>
    <content type="text"><![CDATA[枚举 题目链接 题目大意Gerald 在卖一些国家机密，所有机密的花费相同——总价值为 $n$ 的钢镚。所有的钢镚的价值都是 $3^k\ (k ≥ 1)$。 某天来了一个交易者，他不会付出正好的价值，也就是说，Gerald 必须找钱给他。 求一个方案使得交易者付出的钢镚的价值 $≥n$ ，且付出最少额外价值的同时保证花费的钢镚数量最多。 Input / Output 格式 &amp; 样例输入样例一行一个整数 $n$ ，意义如题。 输出样例一行一个整数，即最多花费的钢镚数量。 输入样例Case #1: 11 Case #2: 14 输出样例Case #1: 11 Case #2: 12 解题思路显然，使用的金币面值越小，使用的金币数量就越大 那么答案就是第一个 $i$使得$\frac{n}{i}=1\ (i ≥ 1)$ 又因为交易者不会付出正好为 $n$ 价值的钢镚，所以答案就要 $+1$ 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; long long int n, now = 1l; cin &gt;&gt; n; while (true) &#123; now *= 3; if (n % now) &#123; cout &lt;&lt; n / now + 1 &lt;&lt; endl; return 0; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 295B 《Greg and Graph》]]></title>
    <url>%2F2018-09-30%2FCF295B%2F</url>
    <content type="text"><![CDATA[开倒车 倒序 Floyd 题目链接 题目描述 翻译来自洛谷 Greg有一个有边权的有向图，包含 $n$ 个点。这个图的每两个点之间都有两个方向的边。Greg喜欢用他的图玩游戏，现在他发明了一种新游戏： 游戏包含 $n$ 步。 第 $i$ 步Greg从图中删掉编号为 $x_i$ 的点。当删除一个点时，这个点的出边和入边都会被删除。 在执行每一步之前，Greg想知道所有点对间最短路长度的和。最短路可以经过任何没删掉的点。换句话说，如果我们假设 $d(i, v, u)$ 是在删掉 $x_i$ 前 $v$ 和 $u$ 间的最短路长度，那么Greg想知道下面这个求和的值：$$\sum_{v, u, v \neq u} d(i, v, u)$$ 帮帮Greg，输出每一步之前要求的值。 Input / Output 格式 &amp; 样例输入格式第一行包含一个整数 $n \ (1 \leq n \leq 500)$ ，代表图中的点数。 下面 $n$ 行每行包含 $n$ 个整数，代表边权：第 $i$ 行的第 $j$ 个数 $a_{ij} \ (1 \leq a_{ij} \leq 10^5, a_{ii} = 0)$ 代表从 $i$ 到 $j$ 的边权。 最后一行包含 $n$ 个整数： $x_1, x_2, \dots, x_n \ (1 \leq x_i \leq n)$ ，分别为Greg每一步删掉的点的编号。 输出格式输出 $n$ 个整数，第 $i$ 个数等于游戏的第 $i$ 步之前统计的求和值。 请不要在C++中使用%lld标志来输出64位整数long long，推荐使用cin, cout流或者用%I64d标志。 输入样例Case #1: 123101 Case #2: 123420 54 01 2 Case #3: 12345640 3 1 16 0 400 12 4 0 11 1 1 04 1 2 3 输出格式Case #1: 10 Case #2: 19 0 Case #3: 117 23 404 0 解题思路$n \le 500$ 很明显跑 Floyd 了 但是 Floyd 不支持删除操作 怎么办？ 开倒车 倒序添加！ 我们记录下删除点的信息，再倒着添加回去，在这个过程中套一个 Floyd 进去 要注意的是累计答案的时候判断点是否存在 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 500 + 10;int f[MAXN][MAXN];int seq[MAXN];long long int ans[MAXN];bool inGraph[MAXN];int n;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline void addEdge(int s, int t, int w) &#123; f[s][t] = f[t][s] = w;&#125;int main(int argc, char *const argv[]) &#123; n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = getint(); &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; seq[i] = getint(); &#125; for (int l = n; l &gt; 0; --l) &#123; int k = seq[l]; inGraph[k] = true; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; f[i][j] = std::min(f[i][j], f[i][k] + f[k][j]); if (inGraph[i] &amp;&amp; inGraph[j]) ans[l] += f[i][j]; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; ' '; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>图论算法</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1908《逆序对》]]></title>
    <url>%2F2018-09-15%2FLuogu-P1908%2F</url>
    <content type="text"><![CDATA[Based on 归并排序 题目地址 题目描述猫猫TOM和小老鼠JERRY最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。最近，TOM老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中ai&gt;aj且i&lt;j的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。 Input / Output 格式输入格式第一行，一个数n，表示序列中有n个数。 第二行n个数，表示给定的序列。序列中每个数字不超过$10^9$ 输出格式给定序列中逆序对的数目。 输入样例1265 4 2 6 3 1 输出样例111 数据范围对于25%的数据，$n \leq 2500n$ 对于50%的数据，$n \leq 4 \times 10^4$ 对于所有数据，$n \leq 5 \times 10^5$ 请使用较快的输入输出 解题思路暴力做法$O(n)$枚举所有的点，$O(n)$比较数的大小，求出逆序对的个数 均摊$O(n^2)$ 正解分治 想想归并排序的过程 比如我们要对下面的区间进行归并排序 $$a_i\ \ mid=4\ \ a_j$$ $$2\ 4\ 7\ 8\ \ \ \ \ 1\ 5\ 6\ 24$$ 我们拿1去比较，此时可以构成的逆序对个数为4，把他放到$r_k$里，那么此时$i$是指向$a_1$的 接着继续比较，直到$a_i &lt; a_j$，就将$a_i$放到$r_k$里 以此类推，最终的逆序对个数就是中间求出的个数的和$=mid-i+1$的和 代码实现1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 5 * 1e5 + 10;int n, a[MAXN], tmp[MAXN];long long int ans;void mergeSort(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; mergeSort(l, mid); mergeSort(mid+1, r); int i = l, j = mid + 1, k = l; while (i &lt;= mid &amp;&amp; j &lt;= r) &#123; if (a[i] &lt;= a[j]) tmp[k] = a[i++], ++k; else tmp[k] = a[j++], ++k, ans += (long long int) mid - i + 1; &#125; while (i &lt;= mid) tmp[k++] = a[i++]; while (j &lt;= r) tmp[k++] = a[j++]; for (int i = l; i &lt;= r; ++i) a[i] = tmp[i];&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; mergeSort(1, n); cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>分治</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度优先搜索]]></title>
    <url>%2F2018-09-15%2FDepthFirstSearch%2F</url>
    <content type="text"><![CDATA[常见算法 / 骗分技巧 洛谷P1605 迷宫题目地址 DFS 入门题 用一个数组mp存图，vis记录是否经过了这个点 12mp[i][j] = 0 表示有障碍mp[i][j] = 1 表示没有障碍 用一个函数dfs(x, y)来搜索 123当坐标为终点时，直接return，方案数++如果这个点没被访问过，而且这个点没有障碍，就把这个点设为访问过，然后dfs这个点 要注意的是起始点是访问过的 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;bool vis[6 + 2][6 + 2];int mp[6 + 2][6 + 2];const int dx[4] = &#123;0, 0, 1, -1&#125;;const int dy[4] = &#123;-1, 1, 0, 0&#125;;int tot, endx, endy, stx, sty, n, m, t;void dfs(int x, int y) &#123; if (x == endx &amp;&amp; y == endy) &#123; ++tot; return; &#125; for (int i = 0; i &lt; 4; ++i) &#123; int nowx = x + dx[i]; int nowy = y + dy[i]; if (!vis[nowx][nowy] &amp;&amp; mp[nowx][nowy]) &#123; vis[nowx][nowy] = true; dfs(nowx, nowy); vis[nowx][nowy] = false; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; mp[i][j] = (int) true; &#125; &#125; cin &gt;&gt; stx &gt;&gt; sty; cin &gt;&gt; endx &gt;&gt; endy; for (int i = 1; i &lt;= t; ++i) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; mp[l][r] = false; &#125; vis[stx][sty] = true; dfs(stx, sty); cout &lt;&lt; tot &lt;&lt; endl; return 0;&#125; 洛谷P1162 填涂颜色题目地址 本来这是一道 BFS 的题 但是有一种玄学的做法可以用 DFS 首先开两个mp存图，输入1时在第一个mp里存1，在第二个mp里存-1 具体就是搜索边界（每一行的第一个和第n个，每一列的第一个和第n个），在搜索的同时更新第一个mp为1 搜索完了就进行判断输出 123当第二个mp[i][j]为-1时输出1否则当第一个mp[i][j]为1时就输出2（被更新过了）否则输出0 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 30 + 5;int mp[MAXN][MAXN];int orz[MAXN][MAXN];int n;void dfs(int x, int y) &#123; if (x &gt; n || x &lt; 1 || y &gt; n || y &lt; 1 || mp[x][y] != 0) return; mp[x][y] = true; dfs(x+1, y); dfs(x-1, y); dfs(x, y+1); dfs(x, y-1);&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; cin &gt;&gt; mp[i][j]; if (mp[i][j] == 1) orz[i][j] = -1; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (mp[i][1] != 1) dfs(i, 1); if (mp[i][n] != 1) dfs(i, n); &#125; for (int i = 1; i &lt;= n; ++i) &#123; if (mp[1][i] != 1) dfs(1, i); if (mp[n][i] != 1) dfs(n, i); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (orz[i][j] == -1) cout &lt;&lt; 1 &lt;&lt; ' '; else if (mp[i][j] == 0) cout &lt;&lt; 2 &lt;&lt; ' '; else cout &lt;&lt; 0 &lt;&lt; ' '; &#125; puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「五校联考」Round#1 Day1&amp;Day2 T1]]></title>
    <url>%2F2018-08-26%2F2018FSExamRound1T1%2F</url>
    <content type="text"><![CDATA[由于权限原因，暂不提供题面 &amp; 评测地址 Day1 T1 dice.cpp解题思路题目让我们求一个骰子每次滚动时最顶数字之和 随意观察可知一个骰子滚4圈所得的和 $=14$ 那么我们可以先让ans += ((m - 1) / 4) * 14 这样来处理每一行的主要部分 要是剩下还有点没求呢？ 那就直接暴力模拟，反正时间复杂度高不了多少 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;long long int ans;struct Dice &#123; long long int top; long long int front; long long int bottom; long long int behind; long long int left; long long int right; Dice() &#123; top = 1; front = 2; bottom = 6; behind = 5; left = 4; right = 3; &#125; void toTheRight() &#123; long long int origTop = top; top = left; left = bottom; bottom = right; right = origTop; ans += top; &#125; void toTheLeft() &#123; long long int origTop = top; top = right; right = bottom; bottom = left; left = origTop; ans += top; &#125; void toTheDownLine() &#123; long long int origTop = top; top = behind; behind = bottom; bottom = front; front = origTop; ans += top; &#125;&#125; d;long long int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; ans = 1; for (int i = 1; i &lt;= n; ++i) &#123; ans += ((m - 1) / 4 ) * 14; if (i &amp; 1) for (int j = 1; j &lt;= (m - 1) % 4; ++j) d.toTheRight(); else for (int j = 1; j &lt;= (m - 1) % 4; ++j) d.toTheLeft(); // 在 toTheRight 和 toTheLeft 和 toTheDownLine 中已经更新过答案 // 不必再更新 if (i != n) d.toTheDownLine(); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Day2 T1 meizi.cpp解题思路前言： 1zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！zzs人赢！ 考虑一下暴力怎么写 把区间[l, r]全部+1，最终取个max 那么我们就可以把区间首+1，区间尾-1，然后做一遍前缀和 我们首先对每个区间差分，再把差分的区间加起来 最终做一遍前缀和，取一遍max 注意要先进行离散化，因为 $1 \le l_i \le\ r_i \le 10^9$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2 * 1e5 + 20;int n;int l[MAXN], r[MAXN];int tmp[MAXN * 2];// 离散化数组int s[MAXN * 2];// 前缀和数组// 开两倍是因为对于每一个妹子都需要记录l和r两个变量inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = getint(); r[i] = getint(); // 记录离散化数组 tmp[2 * i - 1] = l[i]; tmp[2 * i] = r[i]; &#125; // 开始离散化 sort(tmp + 1, tmp + 1 + 2 * n); for (int i = 1; i &lt;= n; ++i) &#123; l[i] = lower_bound(tmp + 1, tmp + 1 + 2 * n, l[i]) - tmp; r[i] = lower_bound(tmp + 1, tmp + 1 + 2 * n, r[i]) - tmp; // 在离散化中顺便记录前缀和数组 ++s[l[i]]; --s[r[i] + 1]; &#125; // 处理前缀和 for (int i = 1; i &lt;= 2 * n; ++i) &#123; s[i] += s[i-1]; &#125; int ans = 0; for (int i = 1; i &lt;= 2 * n; ++i) ans = std::max(ans, s[i]); putint(ans, true); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>自测</tag>
        <tag>五校联考</tag>
        <tag>只有经历过的人才知道的世界</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P3884《[JLOI2009]二叉树问题》]]></title>
    <url>%2F2018-08-08%2FLuogu-P3884%2F</url>
    <content type="text"><![CDATA[不用倍增的 almost裸的LCA 题目描述如下图所示的一棵二叉树的深度、宽度及结点间距离分别为： 深度：4 宽度：4（同一层最多结点个数） 结点间距离： ⑧→⑥为8 (3×2+2=8) ⑥→⑦为3 （1×2+1=3） 注：结点间距离的定义：由结点向根方向（上行方向）时的边数×2， 与由根向叶结点方向（下行方向）时的边数之和。 图片来自洛谷 Input / Output 格式 &amp; 样例输入格式输入文件第一行为一个整数n(1≤n≤100)，表示二叉树结点个数。接下来的n-1行，表示从结点x到结点y（约定根结点为1），最后一行两个整数u、v，表示求从结点u到结点v的距离。 输出格式：三个数，每个数占一行，依次表示给定二叉树的深度、宽度及结点u到结点v间距离。 输入输出样例输入样例： 123456789101110 1 2 1 3 2 42 53 63 75 85 96 108 6 输出样例： 123448 解题思路树的深度可以取$max${$depth[i]$} 树的宽度可以在取深度的时候拿一个桶记录下来，再循环取一遍$max$ 两点之间的距离可以先求$LCA$，再用一个公式算出来 $$distance = (depth[u] - depth[lca]) \times 2 + depth[v] - depth[lca]$$ 其中$lca = LCA(u, v)$ 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 100 + 10;struct Edge &#123; int prev, next;&#125; edge[MAXN * 2];int head[MAXN], father[MAXN][22], lg[MAXN], depth[MAXN];int cnt, n, m, s;int KangShifu[MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline void addEdge(int prev, int next) &#123; edge[++cnt].prev = prev; edge[cnt].next = head[next]; head[next] = cnt; &#125; void dfsInit(int root, int fa) &#123; depth[root] = depth[fa] + 1; father[root][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[root]; ++i) &#123; father[root][i] = father[father[root][i-1]][i-1]; &#125; for (int e = head[root]; e; e = edge[e].next) &#123; if (edge[e].prev != fa) dfsInit(edge[e].prev, root); &#125;&#125;int LCA(int x, int y) &#123; if (depth[x] &lt; depth[y]) swap(x, y); while (depth[x] &gt; depth[y]) x = father[x][lg[depth[x] - depth[y]] - 1]; if (x == y) return x; for (int i = lg[depth[x]]; i &gt;= 0; --i) &#123; if (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i]; &#125; return father[x][0];&#125;int main(int argc, char *const argv[]) &#123; n = getint(); for (int i = 1; i &lt; n; ++i) &#123; int prev = getint(), next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; int u = getint(); int v = getint(); dfsInit(1, 0); for (int i = 1; i &lt;= n; ++i) &#123; lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); &#125; int lca = LCA(u, v); int Depth = -23333; for (int i = 1; i &lt;= n; ++i) &#123; Depth = std::max(Depth, depth[i]); ++KangShifu[depth[i]]; &#125; int width = -23333; for (int i = 1; i &lt;= Depth + 2; ++i) width = std::max(width, KangShifu[i]); putint(Depth, true); putint(width, true); putint((depth[u] - depth[lca]) * 2 + (depth[v] - depth[lca]), true); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论算法</tag>
        <tag>LCA</tag>
        <tag>各省省选</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近公共祖先 LCA]]></title>
    <url>%2F2018-08-07%2FLeastCommonAncestors%2F</url>
    <content type="text"><![CDATA[两个结点找共同的爸爸 LCA 的概念 在图论和计算机科学中，最近公共祖先（英语：lowest common ancestor）是指在一个树)或者有向无环图中同时拥有v和w作为后代的最深的节点。 ——Wikipedia 看不懂没关系 简单的来说，就是两个节点v和w的最近的祖先节点 如下图 6和7的LCA是2，3和7的LCA是1 LCA 的求法暴力求解让他们一步一步往上爬，直到相遇 节点背着那重重的编号呀 一步一步地往上爬 ——《蜗牛与黄鹂鸟》 显然，这样的算法会T到飞起 所以我们要使用倍增优化 倍增求解 所谓倍增，就是按2的倍数来增大，也就是跳 1、2、4 、8 、16、32 … 但是在这里，我们要考虑开倒车从大到小跳 因为如果我们从小到大跳，就会出现要「回溯」的情况，因为我们不一定能精准地跳，而从大到小跳可以避开这种情况 图源cnblogs 对于上面这一棵更复杂的树，我们考虑17和18的LCA 1217 -&gt;(跳4) 318 -&gt;(跳4) 5 -&gt;(跳1) -&gt; 3 是不是快多了，跳的次数大大减小 时间复杂度$O(nlogn)$ LCA 的代码 &amp; 实现流程实现流程首先我们要记录各个点的深度$depth[\ ]$和它们$2^i$级的祖先$father[\ ][\ ]$ 用$depth[i]$表示$i$点的深度，$father[i][j]$表示$i$点的$2^i$级的祖先 1234567891011// 预处理void dfsInit(int root, int fa) &#123; depth[root] = depth[fa] + 1; father[root][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[root]; ++i) &#123; father[root][i] = father[father[root][i-1]][i-1]; &#125; for (int e = head[root]; e; e = edge[e].next) &#123; if (edge[e].prev != fa) dfsInit(edge[e].prev, root); &#125;&#125; 接着我们就可以找LCA辣 对了，我们可以让它跑得更快 1234// 提前预处理出log2i + 1的值for (int i = 1; i &lt;= n; ++i) &#123; lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i);&#125; 在求 LCA 之前，我们先让两个节点蹦到同一层 但是跳的时候不能直接跳到 LCA 上，要跳到 LCA - 1 上，再输出 当前的父节点 就行了 因为直接蹦到 LCA 上可能会出现「误判」，比如上图中$4$和$8$，若不判断，则在跳的时候会输出1，但是答案是3 所以我们就可以让它们跳到$2$和$5$，然后输出父节点 123456789101112int LCA(int x, int y) &#123; // 我们设x的深度大于y的深度 if (depth[x] &lt; depth[y]) swap(x, y); while (depth[x] &gt; depth[y]) x = father[x][lg[depth[x] - depth[y]] - 1]; if (x == y) return x; // x 是 y 的祖先 for (int i = lg[depth[x]]; i &gt;= 0; --i) &#123; if (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i]; // 不相等就往上跳 &#125; return father[x][0];&#125; 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 500000 + 10;const int MAXM = 500000 + 10;struct Edge &#123; int prev, next;&#125; edge[MAXM * 2];int head[MAXN], father[MAXN][22], lg[MAXN], depth[MAXN];int cnt, n, m, s;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline void addEdge(int prev, int next) &#123; edge[++cnt].prev = prev; edge[cnt].next = head[next]; head[next] = cnt; &#125; // 预处理void dfsInit(int root, int fa) &#123; depth[root] = depth[fa] + 1; father[root][0] = fa; for (int i = 1; (1 &lt;&lt; i) &lt;= depth[root]; ++i) &#123; father[root][i] = father[father[root][i-1]][i-1]; &#125; for (int e = head[root]; e; e = edge[e].next) &#123; if (edge[e].prev != fa) dfsInit(edge[e].prev, root); &#125;&#125;int LCA(int x, int y) &#123; // 我们设x的深度大于y的深度 if (depth[x] &lt; depth[y]) swap(x, y); while (depth[x] &gt; depth[y]) x = father[x][lg[depth[x] - depth[y]] - 1]; if (x == y) return x; // x 是 y 的祖先 for (int i = lg[depth[x]]; i &gt;= 0; --i) &#123; if (father[x][i] != father[y][i]) x = father[x][i], y = father[y][i]; // 不相等就往上跳 &#125; return father[x][0];&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(), s = getint(); for (int i = 1; i &lt; n; ++i) &#123; int prev = getint(), next = getint(); addEdge(prev, next); addEdge(next, prev); &#125; dfsInit(s, 0); for (int i = 1; i &lt;= n; ++i) &#123; lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); &#125; for (int i = 1; i &lt;= m; ++i) &#123; int x = getint(), y = getint(); putint(LCA(x, y), true); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>图论</tag>
        <tag>图论算法</tag>
        <tag>LCA</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1531《I Hate It》]]></title>
    <url>%2F2018-08-05%2FLuogu-P1531%2F</url>
    <content type="text"><![CDATA[暴力能过的线段树板子题 题目背景很多学校流行一种比较的习惯。老师们很喜欢询问，从某某到某某当中，分数最高的是多少。这让很多学生很反感。 题目描述不管你喜不喜欢，现在需要你做的是，就是按照老师的要求，写一个程序，模拟老师的询问。当然，老师有时候需要更新某位同学的成绩 Input / Output 格式 &amp; 样例输入格式第一行，有两个正整数 N 和 M ( 0&lt;N&lt;=200000,0&lt;M&lt;5000 )，分别代表学生的数目和操作的数目。 学生ID编号分别从1编到N。 第二行包含N个整数，代表这N个学生的初始成绩，其中第i个数代表ID为i的学生的成绩。 接下来有M行。每一行有一个字符 C (只取’Q’或’U’) ，和两个正整数A，B。 当C为’Q’的时候，表示这是一条询问操作，它询问ID从A到B(包括A,B)的学生当中，成绩最高的是多少。 当C为’U’的时候，表示这是一条更新操作，如果当前A学生的成绩低于B，则把ID为A的学生的成绩更改为B，否则不改动。 输出格式对于每一次询问操作，在一行里面输出最高成绩 输入输出样例输入样例： 123456785 61 2 3 4 5Q 1 5U 3 6Q 3 4Q 4 5U 2 9Q 1 5 输出样例： 12345659 解题思路单点修改，区间查询 …… 线段树 树状数组！ 对了，注意处理输入，含读入char的题目最好不要用快读 …… 别问我怎么知道的 线段树解法可以说是很裸的一道题了 只需要单点修改，lazyTag什么的不需要的 就简单把区间和查询改成区间最值查询就行了 代码实现线段树解法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 200000 + 10;int a[MAXN], segt[MAXN * 4];int n, m;inline int leftChild(int x) &#123; return x &lt;&lt; 1;&#125;inline int rightChild(int x) &#123; return x &lt;&lt; 1 | 1;&#125;inline void pushUp(int root) &#123; segt[root] = std::max(segt[leftChild(root)], segt[rightChild(root)]); // 更新最大值&#125;inline void buildTree(int l, int r, int root) &#123; if (l == r) &#123; segt[root] = a[l]; return; &#125; int mid = (l + r) &gt;&gt; 1; buildTree(l, mid, leftChild(root)); buildTree(mid + 1, r, rightChild(root)); pushUp(root);&#125;inline int query(int l, int r, int ql, int qr, int root) &#123; int res = -2147483640; if (ql &lt;= l &amp;&amp; r &lt;= qr) return segt[root]; int mid = (l + r) &gt;&gt; 1; if (ql &lt;= mid) res = std::max(res, query(l, mid, ql, qr, leftChild(root))); if (mid &lt; qr) res = std::max(res, query(mid + 1, r, ql, qr, rightChild(root))); // 查询最大值 return res;&#125;inline void Modify(int l, int r, int dest, int root, int k) &#123; if (l == r) &#123; segt[root] = std::max(segt[root], k); return; &#125; int mid = (l + r) &gt;&gt; 1; if (dest &lt;= mid) Modify(l, mid, dest, leftChild(root), k); if (mid &lt; dest) Modify(mid + 1, r, dest, rightChild(root), k); pushUp(root);&#125;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; buildTree(1, n, 1); for (int i = 1; i &lt;= m; ++i) &#123; char op; int a, b; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; // 推荐使用std::cin！ switch(op) &#123; case 'Q': &#123; putint(query(1, n, a, b, 1), true); break; &#125; case 'U': &#123; Modify(1, n, a, 1, b); break; &#125; &#125; &#125; return 0;&#125; 暴力代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 200000 + 10;int segt[MAXN]; int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;inline int query(int l, int r) &#123; int res = -2147483640; for (int i = l; i &lt;= r; ++i) res = std::max(res, segt[i]); return res;&#125;inline void Modify(int r, int k) &#123; segt[r] = std::max(segt[r], k);&#125;int main(int argc, char *const argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; segt[i]; for (int i = 1; i &lt;= n; ++i) cout &lt;&lt; segt[i] &lt;&lt; ' '; cout &lt;&lt; endl; for (int i = 1; i &lt;= m; ++i) &#123; char op; int a, b; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; switch(op) &#123; case 'Q': &#123; cout &lt;&lt; query(a, b) &lt;&lt; endl; break; &#125; case 'U': &#123; Modify(a, b); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>模拟</tag>
        <tag>线段树</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1563「NOIP2016」《玩具谜题》]]></title>
    <url>%2F2018-08-05%2FLuogu-P1563%2F</url>
    <content type="text"><![CDATA[暴力模拟 题目描述小南有一套可爱的玩具小人, 它们各有不同的职业。 有一天, 这些玩具小人把小南的眼镜藏了起来。 小南发现玩具小人们围成了一个圈,它们有的面朝圈内,有的面朝圈外。如下图: 图片摘自洛谷 这时 singer 告诉小南一个谜題: “眼镜藏在我左数第3个玩具小人的右数第 1 个玩具小人的左数第 2 个玩具小人那里。 ” 小南发现, 这个谜题中玩具小人的朝向非常关键, 因为朝内和朝外的玩具小人的左右方向是相反的: 面朝圈内的玩具小人, 它的左边是顺时针方向, 右边是逆时针方向; 而面向圈外的玩具小人, 它的左边是逆时针方向, 右边是顺时针方向。 小南一边艰难地辨认着玩具小人, 一边数着: singer 朝内, 左数第 3 个是 archer 。 archer 朝外,右数第 1 个是 thinker 。 thinker 朝外, 左数第 2 个是 writer。 所以眼镜藏在 writer这里! 虽然成功找回了眼镜, 但小南并没有放心。 如果下次有更多的玩具小人藏他的眼镜, 或是谜題的长度更长, 他可能就无法找到眼镜了 。 所以小南希望你写程序帮他解决类似的谜題。 这样的谜題具体可以描述为: 有 n 个玩具小人围成一圈, 已知它们的职业和朝向。现在第 1 个玩具小人告诉小南一个包含 m 条指令的谜題, 其中第 z 条指令形如“左数/右数第 s ,个玩具小人”。 你需要输出依次数完这些指令后,到达的玩具小人的职业。 Input / Output 格式 &amp; 样例输入格式输入的第一行包含两个正整数 n,m ，表示玩具小人的个数和指令的条数。 接下来 n 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 0 表示朝向圈内， 1 表示朝向圈外。 保证不会出现其他的数。字符串长度不超过 10 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。 接下来 m 行，其中第 i 行包含两个整数 $ a_i,s_i$ ，表示第 i 条指令。若 $a_i=0$，表示向左数 $s_i$ 个人；若 $a_i=1$，表示向右数 $s_i$ 个人。 保证 $a_i$ 不会出现其他的数， $1 \le s_i &lt; n$ 。 输出格式输出一个字符串，表示从第一个读入的小人开始，依次数完 m 条指令后到达的小人的职业。 输入输出样例输入样例： 12345678910117 30 singer0 reader0 mengbier 1 thinker1 archer0 writer1 mogician 0 31 10 2 输出样例： 1writer 输入样例2： 12345678910111213141516171819202110 101 C0 r0 P1 d1 e1 m1 t1 y1 u0 V1 71 11 40 50 30 11 61 20 80 4 输出样例2： 1y 数据范围$1 \le n,m \le 100000$ 解题思路一看就是大 模拟 用一个结构体来存每个玩具的名字和朝向 123456struct Toy &#123; string name; bool faceTo; // 朝向&#125;Toy t[MAXN]; 约定true表示朝向圈外，false表示朝向圈内 在读入操作时，用一个变量now记录当前转到了哪个玩具 最后输出t[now].name即可 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;map&gt;using namespace std;const int MAXN = 100000 + 10;struct Toy &#123; string name; bool faceTo; // true 表示朝向圈外 // false 表示朝向圈内 &#125;;Toy t[MAXN];int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(); for (int i = 1; i &lt;= n; ++i) &#123; int to; cin &gt;&gt; to; string name; cin &gt;&gt; name; t[i].faceTo = (to == 1 ? true : false); t[i].name = name; &#125; int now = 1; for (int i = 1; i &lt;= m; ++i) &#123; int tA = getint(); bool right = tA == 1 ? true : false; // true 表示在右边 // false 表示在左边 int s = getint(); if (right) &#123; if (t[now].faceTo == true) now -= s; else now += s; &#125; else &#123; if (t[now].faceTo == true) now += s; else now -= s; &#125; if (now &gt; n) now -= n; if (now &lt; 1) &#123; int moved = 1 - now; now = n + 1 - moved; &#125; &#125; cout &lt;&lt; t[now].name &lt;&lt; endl; return 0;&#125; 最后：]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘法逆元求法]]></title>
    <url>%2F2018-08-05%2Fmul-inverse-modulo%2F</url>
    <content type="text"><![CDATA[数论中的重要内容 注意：本文只讨论模数为质数的情况，因为当模数为合数时，不一定所有数都有逆元 定义在$mod\ p$的意义下，我们把$x$的乘法逆元写作$x^{-1}$。乘法逆元有这样一条性质： $$x \times x^{-1} \equiv 1\ (mod\ p)$$ 乘法逆元有什么用呢？ 模意义下的除法运算！ 除法运算对于模运算来说并不是「封闭」的，所以我们可以把除法转化成乘法 费马小定理求法前置知识：「快速幂」 $a^{p-1} \equiv 1 (mod\ p)%$ 经过变形，可得 $a \times a^{p-2} \equiv 1(mod\ p)$ 由定义可得，$a$的乘法逆元就是$a^{p-2}$ 这就要用到「快速幂」 1234567891011121314inline int slowPower(int a, int b, int p) &#123; int ans = 1; if (b == 1) return 1; while (b) &#123; if (b &amp; 1) ans = ans * a % p; a = a * a % p; b /= 1; &#125; return ans;&#125;inline int invMod(int x, int p) &#123; return slowPower(x, p-1, p);&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>乘法逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划练习题代码]]></title>
    <url>%2F2018-08-03%2FDP-Exercise%2F</url>
    <content type="text"><![CDATA[DP 是啥？能吃吗？ 本文内容难度：从普及-到普及+/提高 数字三角形问题给你一个数字三角形，计算出从三角形的顶至底的一条路径，使该路径经过的数字总和最大， 规定每一步只能从一个数走到下一层上和它最近的左边的数或者右边的数 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 100;/* * * 设f[i][j]表示从第i行第j列走到底部的最优答案 * 转移方程：f[i][j] = a[i][j] + max(f[i+1][j], f[i+1][j+1]) * 注意边界 * */int f[MAXN][MAXN];int a[MAXN][MAXN];int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; int ans = -23333333; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; cin &gt;&gt; a[i][j]; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; f[i][j] = a[i][j] + std::max(f[i-1][j], f[i-1][j-1]); ans = std::max(ans, f[i][j]); &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl;&#125; 一维线性动态规划最长上升子序列1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 10000 + 10;/* * * 注意子序列可以不连续 * * 设f[i]表示目前选第i个数时的最长上升子序列的长度 * 也就是以第i个数结尾的最长上升子序列的长度 * f[i] = std::max(1, f[j] + 1) * 其中1 &lt;= j &lt; i, a[j] &lt; a[i] * * 时间复杂度O(n^2) * */int f[MAXN], a[MAXN];int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (a[j] &lt; a[i]) f[i] = std::max(1, f[j] + 1); &#125; &#125; cout &lt;&lt; f[n];&#125; 「NOIP2004」合唱队形1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; std::endl;using namespace std;const int MAXN = 10000 + 10;/* * * 正着求一遍最长上升子序列，反着求一遍最长上升子序列 * （也就是接着求一遍最长下降子序列） * 用f数组存最长上升子序列长度 * 用g数组存最长下降子序列长度 * 答案是n - max(f[i] + g[i] - 1) * */int f[MAXN], g[MAXN], a[MAXN];int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (a[j] &lt; a[i]) f[i] = std::max(f[i], f[j] + 1); &#125; &#125; for (int i = n; i &gt;= 1; --i) &#123; for (int j = n+1; j &gt; i; --j) &#123; if (a[j] &lt; a[i]) g[i] = std::max(g[i], g[j] + 1); &#125; &#125; int ans = -23333333; for (int i = 1; i &lt;= n; ++i) &#123; ans = std::max(ans, f[i] + g[i] - 1); &#125; cout &lt;&lt; n - ans &lt;&lt; endl; return 0;&#125; 线段覆盖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* -- DP 做法 -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000000 + 10;/* * * 先对线段排序 * 再设f[i]表示前i条线段中不重叠的最大数量 * f[i] = max(f[i - 1], f[j] + 1) * 其中1 &lt;= j &lt; i, 第j条线段的右端点 &lt;= 第i条线段的左端点 * *//* 这个时间复杂度洛谷会RE（实为TLE） */struct Line &#123; int left, right;&#125; line[MAXN];int f[MAXN];bool stlCmp(Line x, Line y) &#123; return x.right &lt; y.right;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; line[i].left &gt;&gt; line[i].right; if (line[i].left &gt; line[i].right) swap(line[i].left, line[i].right); &#125; sort(line + 1, line + 1 + n, stlCmp); for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) &#123; if (line[j].right &lt;= line[i].left) f[i] = std::max(f[i], f[j] + 1); &#125; &#125; int ans = -23333333; for (int i = 1; i &lt;= n; ++i) ans = std::max(ans, f[i]); cout &lt;&lt; ans + 1 &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526272829/* -- 贪心做法 -- */#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000000 + 10;struct Line &#123; int left, right;&#125; line[MAXN];bool stlCmp(Line x, Line y) &#123; return x.right &lt; y.right; &#125;int main(int argc, char *const argv[]) &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; line[i].left &gt;&gt; line[i].right; sort(line + 1, line + 1 + n, stlCmp); int maxRight = -23333333, lines = 0; for (int i = 1; i &lt;= n; ++i) &#123; if (maxRight &lt;= line[i].left) ++lines, maxRight = line[i].right; &#125; cout &lt;&lt; lines &lt;&lt; endl; return 0;&#125; 多维动态规划「NOIP2008」传纸条12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAX = 50 + 5;/*/ * * 设dp[i][j][x][y] 表示第一张纸条传到了(i, j)，第二张纸条传到了(x, y)时 * 的最大答案 * dp[i][j][k][l] = std::max( * std::max( * dp[i-1][j][k-1][l], * dp[i][j-1][k-1][l] * ), * std::max( * dp[i-1][j][k][l-1], * dp[i][j-1][k][l-1] * ) * ) * + a[i][j] * + a[k][l] * * 其中 j+1 &lt;= l &lt;= n * 最终答案是dp[m][n-1][m-1][n] */*/int dp[MAX][MAX][MAX][MAX];int n, m, a[MAX][MAX];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; m = getint(), n = getint(); for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; a[i][j] = getint(); &#125; &#125; for (int i = 1; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; for (int k = 1; k &lt;= m; ++k) &#123; for (int l = j + 1; l &lt;= n; ++l) &#123; dp[i][j][k][l] = std::max(std::max(dp[i-1][j][k-1][l], dp[i-1][j][k][l-1]), std::max(dp[i][j-1][k-1][l], dp[i][j-1][k][l-1])) + a[i][j] + a[k][l]; &#125; &#125; &#125; &#125; putint(dp[m][n-1][m-1][n], true); return 0;&#125; 「NOIP2008 普及」 传球游戏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 30 + 2;const int MAXM = 30 + 2;/*/ * * 设dp[i][j]表示球传到第i次，传到第j个小朋友手中时的方案数 * dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] * 其中dp[0][1] = 1，ans = dp[m][1] /*/int n, m;int dp[MAXM][MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(); dp[0][1] = 1; for (int i = 1; i &lt;= m; ++i) &#123; dp[i][1] = dp[i-1][2] + dp[i-1][n]; dp[i][n] = dp[i-1][1] + dp[i-1][n-1]; for (int j = 2; j &lt; n; ++j) &#123; dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]; &#125; &#125; putint(dp[m][1], true); return 0;&#125; 背包问题NASA 的食物计划普及-，很水 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 50 + 5;const int MAXVolume = 400 + 10;const int MAXWeight = 400;int maxVolume, maxWeight, n;int f[MAXVolume][MAXWeight];struct Food &#123; int Volume; int Weight; int Calories;&#125; food[MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool newLine) &#123; if (x &lt; 0) x = -x; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (newLine) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; maxVolume = getint(); maxWeight = getint(); n = getint(); for (int i = 1; i &lt;= n; ++i) &#123; food[i].Volume = getint(); food[i].Weight = getint(); food[i].Calories = getint(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = maxVolume; j &gt;= food[i].Volume; --j) &#123; for (int k = maxWeight; k &gt;= food[i].Weight; --k) &#123; f[j][k] = std::max(f[j][k], f[j - food[i].Volume][k - food[i].Weight] + food[i].Calories); &#125; &#125; &#125; printf("%d\n", f[maxVolume][maxWeight]); return 0;&#125; 装箱问题真 · 背包问题模板题 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 30 + 5;const int MAXV = 20000; int item[MAXN];int f[MAXN][MAXV];int main(int argc, char *const argv[]) &#123; int n, v; cin &gt;&gt; v; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; item[i]; &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= v; ++j) &#123; if (j &gt;= item[i]) f[i][j] = std::max(f[i-1][j], f[i-1][j-item[i]] + item[i]); else f[i][j] = f[i-1][j]; &#125; &#125; cout &lt;&lt; v - f[n][v] &lt;&lt; endl; return 0;&#125; 榨取kkksc03实在想不通这题为啥是普及/提高-，不应该是普及-吗 所以这就是你评普及/提高-的理由？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const bool __RETURN = true;const bool __NO_RETURN = false;const int MAXN = 100 + 10;const int MAXM = 200 + 10;const int MAXT = 200 + 10;int n, m ,T; struct Dream &#123; int time; int cost;&#125; d[MAXN];int dp[MAXN][MAXM][MAXT];/* * * 设dp[i][j][k]表示当选择第i个愿望， * 时间不超过j，金钱不超过k时的最大数量 * dp[i][j][k] = max(dp[i-1][j][k], dp[i-1][j-d[i].time][k-d[i].cost] + 1) * 其中 j &gt;= d[i].time, k &gt;= d[i].cost * */inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x, bool returnValue) &#123; if (x &lt; 0) &#123; x = -x; putchar('-'); &#125; if (x &gt;= 10) putint(x / 10, false); putchar(x % 10 + '0'); if (returnValue) putchar('\n');&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(), T = getint(); for (int i = 1; i &lt;= n; ++i) &#123; d[i].time = getint(); d[i].cost = getint(); &#125; for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; for (int k = 1; k &lt;= T; ++k) &#123; if (j &gt;= d[i].time &amp;&amp; k &gt;= d[i].cost) &#123; dp[i][j][k] = std::max(dp[i-1][j][k], dp[i-1][j - d[i].time][k - d[i].cost] + 1); &#125; else &#123; dp[i][j][k] = dp[i-1][j][k]; &#125; &#125; &#125; &#125; putint(dp[n][m][T], __RETURN); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>NOIP</tag>
        <tag>动态规划，DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1892《[BOI2003]团伙》]]></title>
    <url>%2F2018-07-28%2FLuogu-P1892%2F</url>
    <content type="text"><![CDATA[本题来自「2018 SDSC」Day 3 考试题目 题目链接 题目描述1920年的芝加哥，出现了一群强盗。如果两个强盗遇上了，那么他们要么是朋友，要么是敌人。而且有一点是肯定的，就是： 我朋友的朋友是我的朋友； 我敌人的敌人也是我的朋友。 两个强盗是同一团伙的条件是当且仅当他们是朋友。现在给你一些关于强盗们的信息，问你最多有多少个强盗团伙。 Input/Output 格式 &amp; 样例输入格式输入文件gangs.in的第一行是一个整数N(2&lt;=N&lt;=1000)，表示强盗的个数（从1编号到N）。 第二行M(1&lt;=M&lt;=5000)，表示关于强盗的信息条数。 以下M行，每行可能是F p q或是E p q（1&lt;=p q&lt;=N），F表示p和q是朋友，E表示p和q是敌人。输入数据保证不会产生信息的矛盾。 输出格式输出文件gangs.out只有一行，表示最大可能的团伙数。 输入样例12345664E 1 4F 3 5F 4 6E 1 2 输出样例13 解题思路很显然这是一道并查集的题目 初始时我们把每一个人单独列为一个团伙 由题可得，这道题主要有如下合并方式： 我的朋友是我的朋友 我的朋友的朋友是我的朋友 我的敌人的朋友是我的敌人 我的敌人的敌人是我的朋友 那么我们要另开一个$Enemy[\ ]$数组，$Enemy[i]$表示 $i$ 的其中一个敌人 每次合并敌人的时候，先判断是否有记录过敌人： 如果有，那么就把当前的敌人和记录的敌人合并在一个团伙里 如果没有，那么就把当前的敌人记录 最后开一个数组$count[\ ]$进行统计 这里要注意几个点： 开始时并查集数组要开两倍，因为你要把敌人和朋友存在一个数组里 合并敌人时要注意合并的不是敌人本身，而是$Find($敌人$)$ 最后统计的时候也要统计$Find($敌人$)$ 对了，注意输入…建议使用iostream…别问我为什么会写上这句话 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 1000 + 10;int U[MAXN * 2], Enemy[MAXN * 2], n, m;int count[MAXN * 2], cnt;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void putint(int x) &#123; if (x &lt; 0) &#123; x = -x; &#125; if (x &gt;= 10) &#123; putint(x / 10); &#125; putchar(x % 10 + '0');&#125;int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] = y; return;&#125;int main(int argc, char *const argv[]) &#123; freopen("P1892.in", "r", stdin); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt;= n * 2; ++i) U[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; char c; int x, y; cin &gt;&gt; c &gt;&gt; x &gt;&gt; y; switch(c) &#123; case 'F': &#123; Union(x, y); break; &#125; case 'E': &#123; if (Enemy[x] == 0) Enemy[x] = Find(y); else Union(y, Enemy[x]); if (Enemy[y] == 0) Enemy[y] = Find(x); else Union(x, Enemy[y]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) ++count[Find(i)]; for (int i = 1; i &lt;= n; ++i) if (count[i]) ++cnt; printf("%d\n", cnt); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1821 《[USACO07FEB]银牛派对Silver Cow Party》]]></title>
    <url>%2F2018-07-20%2FLuogu-P1821%2F</url>
    <content type="text"><![CDATA[巧妙地把单终点最短路径问题转化为单源最短路径问题 题目地址 题目描述寒假到了，N头牛都要去参加一场在编号为X（1≤X≤N）的牛的农场举行的派对（1≤N≤1000），农场之间有M（1≤M≤100000）条有向路，每条路长Ti（1≤Ti≤100）。 每头牛参加完派对后都必须回家，无论是去参加派对还是回家，每头牛都会选择最短路径，求这N头牛的最短路径（一个来回）中最长的一条路径长度。 Input/Output 格式 &amp; 样例输入格式：第一行三个整数N，M, X； 第二行到第M+1行：每行有三个整数Ai，Bi, Ti ,表示有一条从Ai农场到Bi农场的道路，长度为Ti。 输出格式：一个整数，表示最长的最短路得长度。 输入样例#1：1234567894 8 21 2 41 3 21 4 72 1 12 3 53 1 23 4 44 2 3 输出样例#1：110 题目说明图片来自洛谷 解题思路单源最短路我们都会做，一遍SPFA或Dijkstra就行了。 单终点最短路呢？ 对于这道题，奶牛们从派对分别回家就是一个单源最短路问题，而奶牛们从家到派对就是一个单终点最短路问题。 如何把单终点最短路转化为单源最短路问题？注意：题目中建的是有向边 实在是想不出来的我翻了一波题解，发现他们都在输入的时候另建了一个图，反向存边，就完美地把一个单终点最短路转化为单源最短路因为单源和单终点的区别仅仅是方向改变，很显然这么做是对的 最后的答案是什么？正向建图的距离+反向建图的距离的最大值 代码实现我们在数组后加上「Reversed」，表示它存的是反向的图 评测记录 AC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt; #include &lt;algorithm&gt;#include &lt;queue&gt; using namespace std;const int MAXN = 1000 + 10;const int MAXM = 100000 + 10;struct Edge &#123; int prev; int next; int weight;&#125; edge[MAXM], edgeReversed[MAXM];int n, m, x, cnt, maxWeight = -1;int dis[MAXN], head[MAXN], disReversed[MAXN], headReversed[MAXN];bool inQueue[MAXN], inQueueReversed[MAXN];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; (ch == '-') &amp;&amp; (x = -1); ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline void addEdgeReversed(int prev, int next, int weight) &#123; edgeReversed[cnt].prev = prev; edgeReversed[cnt].weight = weight; edgeReversed[cnt].next = headReversed[next]; headReversed[next] = cnt;&#125;inline void addEdge(int prev, int next, int weight) &#123; edge[++cnt].prev = prev; edge[cnt].weight = weight; edge[cnt].next = head[next]; head[next] = cnt; addEdgeReversed(next, prev, weight);&#125;inline void Dijkstra(int s, int n) &#123; memset(inQueue, 0, sizeof(inQueue)); for (int i = 0; i &lt;= n; ++i) dis[i] = 2147483647; std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q; inQueue[s] = true; q.push(make_pair(s, 0)); dis[s] = 0; while (!q.empty()) &#123; int prev = q.top().first; int weight = q.top().second; q.pop(); inQueue[prev] = false; for (int e = head[prev]; e; e = edge[e].next) &#123; if (dis[edge[e].prev] &gt; edge[e].weight + weight) &#123; dis[edge[e].prev] = edge[e].weight + weight; q.push(make_pair(edge[e].prev, dis[edge[e].prev])); &#125; &#125; &#125;&#125;inline void DijkstraReversed(int s, int n) &#123; memset(inQueueReversed, 0, sizeof(inQueueReversed)); for (int i = 0; i &lt;= n; ++i) disReversed[i] = 2147483647; std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q; inQueueReversed[s] = true; q.push(make_pair(s, 0)); while (!q.empty()) &#123; int prev = q.top().first; int weight = q.top().second; q.pop(); inQueueReversed[prev] = false; for (int e = headReversed[prev]; e; e = edgeReversed[e].next) &#123; if (disReversed[edgeReversed[e].prev] &gt; edgeReversed[e].weight + weight) &#123; disReversed[edgeReversed[e].prev] = edgeReversed[e].weight + weight; q.push(make_pair(edgeReversed[e].prev, disReversed[edgeReversed[e].prev])); &#125; &#125; &#125;&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(), x = getint(); int tm = m; while (tm --&gt; 0) &#123; int prev = getint(), next = getint(), weight = getint(); addEdge(prev, next, weight); &#125; int tn = n; Dijkstra(x, n); DijkstraReversed(x, n); for (int i = 1; i &lt;= n; ++i) &#123; maxWeight = std::max(maxWeight, dis[i] + disReversed[i]); &#125; printf("%d\n", maxWeight); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1149《火柴棒等式》]]></title>
    <url>%2F2018-07-15%2FLuogu-P1149%2F</url>
    <content type="text"><![CDATA[「枚举」的入门题目 题目地址 题目描述给你n根火柴棍，你可以拼出多少个形如$ A+B=C$的等式？等式中的 $A 、 B 、 C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$ ）。用火柴棍拼数字 $0-9$ 的拼法如图所示： 图片来自洛谷 注意： 加号与等号各自需要两根火柴棍 如果 $A≠B$ ，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式( $A,B,C&gt;=0$ ) $n$ 根火柴棍必须全部用上 输入输出格式输入格式： 一个整数 $n$($n&lt;=24$) 。 输出格式： 一个整数，能拼成的不同等式的数目。 输入样例#1：114 输出样例#1：12 输入样例#2：118 输出样例#2：19 说明【输入输出样例1解释】 $2$ 个等式为 $0+1=1$ 和 $1+0=1$ 。 【输入输出样例2解释】 $9$ 个等式为： 1234567890+4=40+11=111+10=112+2=42+7=94+0=47+2=910+1=1111+0=11 解题思路枚举思路我们可以枚举$A$和$B$ 上界？ 手算啊 $n&lt;=24$，去掉符号用的4根火柴棒，相当于是「$n&lt;=20$」 再$\frac{n}{2}$（这里只考虑有$A$和$B$两个数字），可得 对于某一个数字，可调用的火柴棒共有10个 由于使用火柴棒数量最少的$1$要使用2根，所以我们假设两个数字都为$11111$，但是显然这样是不成立的，因为$2\times5 + 2 * 5$就已经达到$20$了，没有火柴棒再放第三个数字，那么由此可粗略得出 对于某一个数字，它最高有5位 于是我们可以选择枚举到$9999$，洛谷的评测机上也不会TLE 当然CCF的老爷机就不一定了（ 于是我们可以选择再精确一点 // 未完待续 枚举之后相加，取出所用的火柴棒数，进行判断就好了 预处理思路火柴棒数怎么求？ 新建一个数组 f[10000 * 2 + 10] ，表示i这个数字需要用f[i]根火柴 题目已经给出了f[0~9]，如何处理出f[10~(10000*2)]？ 123456f[i] = f[i/10] + f[i%10]; // (i &gt;= 10)/*这里的i/10可以取它除了个位上其他位的数，在前面已经处理过，所以可以直接使用；这里的i%10可以取它个位上的数，也处理过，可以直接使用。两个火柴棒数目一相加，就能获得火柴棒的总数。*/ 循环一遍就好了 代码实现12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int sticks[10001 * 2];int main(int argc, char *const argv[]) &#123; sticks[0] = sticks[6] = sticks[9] = 6; sticks[1] = 2; sticks[2] = sticks[3] = sticks[5] = 5; sticks[4] = 4; sticks[7] = 3; sticks[8] = 7; int n; cin &gt;&gt; n; int sum = 0; for (int i = 10; i &lt;= 20000; ++i) &#123; sticks[i] = sticks[i/10] + sticks[i%10]; &#125; for (int i = 0; i &lt;= 9999; ++i) &#123; for (int j = 0; j &lt;= 9999; ++j) &#123; if (sticks[i] + 2 + sticks[j] + 2 + sticks[i+j] == n) ++sum; &#125; &#125; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配学习笔记 & HDU2063 题解]]></title>
    <url>%2F2018-07-06%2FBipartiteGraph%2F</url>
    <content type="text"><![CDATA[二分图真是个奇怪又好玩的东西 注：本文包含《HDU2063 过山车》题解 本文部分内容有误（因为作者太弱），等待修正 二分图概念设图$G=(V,E)$是一个无向图，若顶点集合$V$可分割为两个互不相交的子集$X$和$Y$，且图中每条边连接的顶点一个在$X$中，一个在$Y$中，则称$G$是一个二分图。 判定若某一图是联通的， 1231. 任选一个点V作为顶点，定义距离标号为02. 将V的邻接点标号设为1，接着将它的未标号的邻接点的标号设为2，以此类推 3. 将所有标号为奇数的点归为X，标号为偶数的点归为Y 以上内容可以采用BFS完成 依次检查每一条边，看看是否满足顶点一个在$X$中，一个在$Y$中 若某一图不连通，就在每个联通块里进行判定 二分图匹配定义给定一个二分图$G$，在$G$的子图$M$中，$M$的边集${E}$中的任意两条边都不依附于同一个顶点，则称$M$是一个匹配。 图中蓝色的边是数量为2的匹配 最大匹配 &amp; 完全匹配选择边数最大的子图称为「二分图的最大匹配问题」 如果一个匹配中图的每一个顶点都和某条边相关联，则称此匹配为「完全匹配」（或「完备匹配」） 图中为一个完全匹配 增广路径定义设$M$为二分图$G$已匹配边的集合，若$P$是$G$上其中一条联通两个未匹配顶点的路径（起点在$X$部，终点在$Y$部），且属$M$的边和不属$M$的边在$P$上交替出现，则称$P$为相对于$M$的一条增广路径 寻找增广路设$M$为二分图$G$所有已匹配边的集合， 如图，蓝色为在$M$里的边，黄色为不在$M$里的边 从$x_4$到$y_2$找一条路径： $x_4 \rightarrow y_3 \rightarrow x_2 \rightarrow y1 \rightarrow x1 \rightarrow y2$ 这条路径就是「增广路径」 其中属于$M$的边有：${x2,y3}, {x1,y1}$ 不属于$M$的边有：${x4,y3}, {x2,y1},{x1,y2}$ 显然，不属于$M$的边比属于$M$的边要多一条 将这条增广路上的边全都「反色」，如图 可以发现，匹配仍然合法，但是匹配数多了一对 另外，单独的一条连接两个未匹配点的边显然也是增广路 那么可知，当不能再找到增广轨时，就得到了一个「最大匹配」，这就是匈牙利算法的基本思路 增广路径性质由增广路的定义可以推出下述三个结论： P的路径长度必定为奇数，第一条边和最后一条边都不属于M，因为两个端点分属两个集合，且未匹配。 P经过取反操作可以得到一个更大的匹配M’。 M为G的最大匹配当且仅当不存在相对于M的增广路径。 匈牙利算法用增广路求最大匹配（称作匈牙利算法，匈牙利数学家Edmonds于1965年提出） 算法步骤 置$M$为空 找出一条增广路$P$，通过取反操作获得更大的匹配$M‘$代替$M$ 重复2直到找不出增广路 找增广路径的算法我们采用DFS的办法找一条增广路径： 从X部一个未匹配的顶点u开始，找一个未访问的邻接点v（v一定是Y部顶点）。 对于$v$，分两种情况： 如果$v$未匹配，则已经找到一条增广路 如果$v$已经匹配，则取出$v$的匹配顶点$w$($w$一定是$X$部顶点)，边$(w,v)$目前是匹配的，根据“取反”的想法，要将$(w,v)$改为未匹配，$(u,v)$设为匹配，能实现这一点的条件是看从$w$为起点能否新找到一条增广路径$P’$。如果行，则$u \rightarrow v \rightarrow P’$就是一条以$u$为起点的增广路径。 算法实现mx[i]表示与X部i点匹配的Y部顶点编号 my[i]表示与Y部i点匹配的X部顶点编号 12345678910111213bool dfs(int u)//寻找从u出发的增广路径&#123; for each v∈u的邻接点 if(v未访问)&#123; 标记v已访问; if(v未匹配||dfs(my[v]))&#123; mx[u]=v; my[v]=u; return true;//有从u出发的增广路径 &#125; &#125; return false;//无法找到从u出发的增广路径&#125; 《HDU2063 过山车》题解题目描述RPG girls今天和大家一起去游乐场玩，终于可以坐上梦寐以求的过山车了。可是，过山车的每一排只有两个座位，而且还有条不成文的规矩，就是每个女生必须找个个男生做partner和她同坐。但是，每个女孩都有各自的想法，举个例子把，Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner。考虑到经费问题，boss刘决定只让找到partner的人去坐过山车，其他的人，嘿嘿，就站在下面看着吧。聪明的Acmer，你可以帮忙算算最多有多少对组合可以坐上过山车吗？ Input/Output 格式 &amp; 样例Input 输入数据的第一行是三个整数$K , M , N$，分别表示可能的组合数目，女生的人数，男生的人数。$0&lt;K&lt;=1000,1&lt;=N,M&lt;=500$.接下来的$K$行，每行有两个数，分别表示女生$A_i$愿意和男生$B_j$做partner。最后一个$0$结束输入。 Output 对于每组数据，输出一个整数，表示可以坐上过山车的最多组合数。 Sample Input123456786 3 31 11 21 32 12 33 10 Sample Output13 解题思路「每个女生必须找个个男生做partner和她同坐」 好了，可以看出这是匹配问题，问你如何匹配 「Rabbit只愿意和XHD或PQK做partner，Grass只愿意和linle或LL做partner，PrincessSnow愿意和水域浪子或伪酷儿做partner」 这句话告诉了我们如何建边： 123把所有女生的顶点放到集合X中，所有男生的顶点放到集合Y中，从Rabbit分别建一条到XHD的边和一条到PQK的边，从Grass分别建一条到linle的边和一条到LL的边…… 那么显然这就是一个二分图，而本题要求的就是这个二分图的最大匹配 又是一道模板题 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 500 + 10;int t[MAXN][MAXN], map[MAXN];bool vis[MAXN];int k, m, n;bool dfs(int u) &#123; // 核心代码 for (int i = 1; i &lt;= n; ++i) &#123; if (t[u][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (!map[i] || dfs(map[i])) &#123; map[i] = u; return true; &#125; &#125; &#125; return false;&#125;int main(int argc, char *const argv[]) &#123; while (scanf("%d %d %d", &amp;k, &amp;m, &amp;n), k != 0) &#123; memset(t, 0, sizeof(t)); memset(vis, 0, sizeof(vis)); memset(map, 0, sizeof(map)); for (int i = 0; i &lt; k; ++i) &#123; int x, y; scanf("%d %d", &amp;x, &amp;y); t[x][y] = 1; &#125; int ans = 0; for (int i = 1; i &lt;= m; ++i) &#123; memset(vis, 0, sizeof(vis)); if (dfs(i)) ++ans; &#125; printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 国庆清北刷题冲刺班 《角谷猜想》]]></title>
    <url>%2F2018-07-04%2FKakutani%2F</url>
    <content type="text"><![CDATA[不错的字符串模拟 题目来自Air Begin 题目描述某个名字末尾是654321的小A同学是个大家眼中公认的学霸（虽然他永远不承认），他对题目的直觉到了一种可怕的地步，一眼看出题目的算法对他而言只是小 Case，他甚至能在看到一个证明的瞬间敏锐地判断出这个证明的真伪。 现在小A同学机缘巧合地看到了角古猜想（即对于$x$当它为奇数则$x=3x+1$,$x$为偶数，则$x=\frac{x}{2}$，一直重复这个步骤，则最终$x$会变为$1$），在看完这个猜想的一瞬间，他的直觉就来了——他认为角古猜想一定是错的！然后——他立刻就能找出反例！ 他立刻在纸上写满了$n$($1&lt;=n&lt;=1000$)个小于$10^L$($0&lt;=L&lt;=10^4$)的正整数，打算放到他的grand super computer 上去跑，可是他突然觉得有些正整数不是很吉利，可能会干扰到他的最终结果，所以他打算把一些正整数加工一下。 小A觉得4、7、13都是不吉利的数字，所以要把所有正整数里的4、7、13都去掉，如果去掉后得到的新数字里依旧有4、7、13，那么就要继续删掉，直到最后的数组不存在4、7、13，它才是一个吉利的数字。例如$1411733=&gt;111733=&gt;11133=&gt;113=&gt;1$特别规定，如果最后所有数字都被删掉了，就输出$0$小A觉得这个枯燥的工作不适合他这样的天才，于是就把这个工作交给了你。 当然，只要你能顺利解决，小A承诺会在那篇将会震惊世界的论文的特别感谢栏上署上你的大名。 Input/Output 格式 &amp; 样例Input 一共$n+1$行。 第一行一个正整数$n$($1&lt;=n&lt;=100$)，表示数字个数。 接下来每行一个正整数$x$。 Output 一共$n$行。 每行一个正整数，表示输入每个$x$对应的答案。 Sample Input 1 123456513713141713133333337258914117332147483647 Sample Output1 123450113333332589121836 数据范围对于$10%$的数据，$0&lt;=x&lt;=2147483647$对于另外的$10%$数据，给定的数字没有数码$3$对于另外的$10%$数据，$n=1$对于全部的数据，$n$($1&lt;=n&lt;=1000$)，$1&lt;=x&lt;=10^L$($0&lt;=L&lt;=10^4$) 解题思路「$1&lt;=x&lt;=10^L$($0&lt;=L&lt;=10^4$)」 显而易见的高精 进而联想到字符串模拟 这道题有两个点需要注意： 顺序不能乱 1先执行删除4和7的操作，再执行删除13的操作 在删除13时要检查是否残留 1234567样例里有一个数据1411733先删除4和7，得到11133再删除13，得到113假如只删除一次13，那么就会有残留的13出现所以要在删除之后进行检查，否则就需要递归，将13再次删除 代码实现评测记录 AC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;inline string eraseAll4s(string x) &#123; string ret = ""; int len = x.length(); for (int i = 0; i &lt; len; ++i) if (x[i] == '4') x[i] = '-'; // 删除的'4'用'-'表示 for (int i = 0; i &lt; len; ++i) if (isdigit(x[i])) ret += x[i]; // 采集存留的数字，组成一个新的字符串 return ret;&#125;inline string eraseAll7s(string x) &#123; // 代码思想一样，不再赘述 string ret = ""; int len = x.length(); for (int i = 0; i &lt; len; ++i) if (x[i] == '7') x[i] = '-'; for (int i = 0; i &lt; len; ++i) if (isdigit(x[i])) ret += x[i]; return ret;&#125;inline string eraseAll13s(string x) &#123; string ret = ""; int len = x.length(); for (int i = 0; i &lt; len - 1; ++i) &#123; if (x[i] == '1' &amp;&amp; x[i+1] == '3') x[i] = x[i+1] = '-'; // 注意这里要同时检测两个字符 &#125; bool b = false; for (int i = 0; i &lt; len; ++i) if (isdigit(x[i])) ret += x[i]; for (int i = 0; i &lt; len - 1; ++i) &#123; // 重新进行检查 if (ret[i] == '1' &amp;&amp; ret[i+1] == '3') &#123; b = true; break; &#125; &#125; if (b) &#123; ret = eraseAll13s(ret); // 递归删除 &#125; return ret;&#125;string Modify(string x) &#123; string ret = ""; ret = eraseAll4s(x); ret = eraseAll7s(ret); ret = eraseAll13s(ret); // 进行删除 if (ret == "") ret = "0"; return ret;&#125;int main(int argc, char *const argv[]) &#123; ios::sync_with_stdio(false); int n; string v; cin &gt;&gt; n; while (n --&gt; 0) &#123; /* 这里是一个比较神奇的 while()， 效果相当于 for (int i = 0; i &lt; n; ++i)， 但是会对n进行修改，下标也是从n-1到0 */ cin &gt;&gt; v; cout &lt;&lt; Modify(v) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>字符串</tag>
        <tag>自测题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P2330 《[SCOI2005]繁忙的都市》]]></title>
    <url>%2F2018-07-04%2FLuogu-P2330%2F</url>
    <content type="text"><![CDATA[接近裸的最小生成树 题目地址 题目描述城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市C的道路是这样分布的：城市中有n个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求： 1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2．在满足要求1的情况下，改造的道路尽量少。 3．在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。 任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。 Input/Output 格式 &amp; 样例输入格式： 第一行有两个整数n,m表示城市有n个交叉路口，m条道路。 接下来m行是对每条道路的描述，u, v, c表示交叉路口u和v之间有道路相连，分值为c。(1≤n≤300，1≤c≤10000，1≤m≤50000) 输出格式： 两个整数s, max，表示你选出了几条道路，分值最大的那条道路的分值是多少。 输入样例#1：1234564 51 2 31 4 52 4 72 3 63 4 8 输出样例#1：13 6 数据范围前面已经提到过， $1 \le n \le 300, 1 \le c \le 10000, 1 \le m \le 50000$ 解题思路「1．改造的那些道路能够把所有的交叉路口直接或间接的连通起来。」 显然这是一道最小生成树的题目 但是题目中并没有要求输出最小的总权值，而是要输出最长边边权 所以它和裸的最小生成树还是有一些区别的 代码实现评测记录 AC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;const int MAXN = 300 + 10;const int MAXM = 50000 + 10;int U[MAXN];int cnt;int cntTree;int n, m;struct Edge &#123; int prev, next, w;&#125; edge[MAXM * 2];inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (!isdigit(ch)) &#123; if (ch == '-') x = -1; ch = getchar(); &#125; while (isdigit(ch)) &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;bool sortCmp(Edge x, Edge y) &#123; return x.w &lt; y.w;&#125;inline int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;int Kruskal() &#123; int ret = -1; int treeAns = 0; sort(edge + 1, edge + 1 + m, sortCmp); for (int i = 1; i &lt;= MAXN; ++i) U[i] = i; for (int i = 1; i &lt;= m; ++i) &#123; int eprev = Find(edge[i].prev); int enext = Find(edge[i].next); if (eprev == enext) continue; treeAns += edge[i].w; U[eprev] = enext; ret = max(ret, edge[i].w); // 更新权值 ++cntTree; if (cntTree == n - 1) break; &#125; return ret;&#125;int main(int argc, char *const argv[]) &#123; n = getint(), m = getint(); for (int i = 1; i &lt;= m; ++i) &#123; int v = getint(), next = getint(), w = getint(); edge[i].prev = v; edge[i].next = next; edge[i].w = w; &#125; int ans = Kruskal(); printf("%d %d", n - 1, ans); // 显而易见，生成的树肯定有 n - 1 条边，所以直接输出 n - 1 就好 return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>图论算法</tag>
        <tag>并查集</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径算法]]></title>
    <url>%2F2018-07-03%2FShortestPath%2F</url>
    <content type="text"><![CDATA[较简单的图论算法 最短路算法有很多种，比较著名的有 Bellman-Ford SPFA（队列优化版 Bellman-Ford） Dijkstra Floyd（基于DP思想） 其中 Floyd 只适用于多源最短路径，SPFA 和 Bellman-Ford 代码易于理解但是效率低，Dijkstra 效率高但是不适用于图中有负边权的情况 至于其他算法……我见过某个dalao用线段树写最短路 本文只介绍单源最短路径中的 SPFA 和 Dijkstra （ Bellman-Ford 由于速度慢于 SPFA 所以忽略）。 SPFASPFA 可以处理图含有负边权的情况，同时又因为它效率较低，所以它更适合处理稀疏图 这里给出数组版代码 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int MAXINT = 2147483647;const int MAXN = 2500 + 5;const int MAXM = 6200 + 5;struct Edge &#123; int v, next, w;&#125;edge[MAXM * 2];int head[MAXN];int cnt;int dis[MAXN];bool inQueue[MAXN];inline void addEdge(int u, int v, int w) &#123; edge[++cnt].v = v; edge[cnt].w = w; edge[cnt].next = head[u]; head[u] = cnt;&#125;inline int SPFA(int s, int t, int n) &#123; for (int i = 1; i &lt;= n; ++i) dis[i] = MAXINT; dis[s] = 0; inQueue[s] = true; std::queue&lt;int&gt; q; q.push(s); while (!q.empty()) &#123; int v = q.front(); q.pop(); inQueue[v] = false; for (int e = head[v]; e; e = edge[e].next) &#123; if (dis[edge[e].v] &gt; edge[e].w + dis[v]) &#123; dis[edge[e].v] = edge[e].w + dis[v]; if (!inQueue[edge[e].v]) &#123; q.push(edge[e].v); inQueue[edge[e].v] = true; &#125; &#125; &#125; &#125; return dis[t];&#125;int main(int argc, char const *argv[]) &#123; int n, m, s, t; /* n for the nodes' count m for the edges' count s for the start node t for the end node */ scanf("%d %d %d %d\n", &amp;n, &amp;m, &amp;s, &amp;t); for (int i = 0; i &lt; m; ++i) &#123; int u, v, w; scanf("%d %d %d\n", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); addEdge(v, u, w); &#125; printf("%d\n", SPFA(s, t, n)); return 0;&#125; DijkstraDijkstra 不能解决图中有负边权的情况，算法效率较高，适合在不含负边权的稠密/稀疏图中使用 这里还是给出数组写法 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cmath&gt;#define mp std::make_pairusing namespace std;const int MAXN = 1000 + 7;const int MAXM = 1000000 + 7;const int INF = 0x7fffffff;typedef long long int ll;typedef std::pair&lt;int, int&gt; Pair;int n, m;inline int getint() &#123; int s = 0, x = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') x = -x; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;struct Node &#123; int v, next, w;&#125;edge[MAXM];int num = 0, head[MAXN];bool inQueue[MAXN];ll dis[MAXN]; // dis[i] --&gt; the distance from i to ninline void addEdge(int u, int v, int w) &#123; edge[++num].v = v; edge[num].w = w; edge[num].next = head[u]; head[u] = num;&#125;inline int dijkstra(int s, int t, int n) &#123; // s for start, t for end, n for the count of the nodes for (int i = 1; i &lt;= n; ++i) dis[i] = INF; std::priority_queue&lt;std::pair&lt;int, int&gt;, std::vector&lt;std::pair&lt;int, int&gt; &gt;, std::greater&lt;std::pair&lt;int, int&gt; &gt; &gt; q; inQueue[s] = true; dis[1] = 0; q.push(mp(s,0)); while (!q.empty()) &#123; int v = q.top().first; int value = q.top().second; q.pop(); for (int e = head[v]; e; e = edge[e].next) &#123; if (dis[edge[e].v] &gt; value + edge[e].w) &#123; dis[edge[e].v] = (value + edge[e].w) ; q.push(mp(edge[e].v, dis[edge[e].v])); &#125; &#125; &#125; return dis[t];&#125;int main(int argc, char const *argv[]) &#123; n = getint(), m = getint(); for (int i = 0; i &lt; m; ++i) &#123; int x, y, z; x = getint(), y = getint(), z = getint(); addEdge(x, y, z); &#125; printf("%d\n", dijkstra(1, n, n)); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>图论算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1955 《[NOI2015]程序自动分析》]]></title>
    <url>%2F2018-05-12%2FLuogu-P1955%2F</url>
    <content type="text"><![CDATA[第一道NOI的题目 洛谷 P1955 题解题目描述在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设x1,x2,x3…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 输入输出格式输入格式：从文件prog.in中读入数据。 输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj； 输出格式：输出到文件 prog.out 中。 输出文件包括t行。 输出文件的第 k行输出一个字符串“ YES” 或者“ NO”（不包含引号，字母全部大写），“ YES” 表示输入中的第k个问题判定为可以被满足，“ NO” 表示不可被满足。 输入输出样例输入 #11234567221 2 11 2 021 2 12 1 1 输出 #112NOYES 输入 #212345678910231 2 12 3 13 1 141 2 12 3 13 4 11 4 0 输出 #212YESNO 数据范围（图片来自洛谷） 解题思路把题目中的「x1=x2」看做x1和x2在同一个集合里，「x1≠x2」看做x1和x2不在同一个集合里…… 好了，显而易见这是道并查集的题目 读懂了题目，下手就很简单了 这里要注意：「x1≠x2」是无法进行的操作（因为你不能强制他们不在同一个集合里！若非要实现，就又要维护一个数组），把它看成查询操作。 而且「x1=x2」类似的操作要先做，「x1≠x2」类似的操作要最后做（因为后者对集合没有影响，它是一个查询操作） 1234567如果你遇到了类似这样的数据：...1 2 01 2 1...那么根据我们的思路， 「1 2 0」是一个查询操作，对集合没有影响，那么就相当于少了一个操作！必须要先进行「x1=x2」类似的合并操作，再做「x1≠x2」类似的查询操作 代码实现90分代码 评测记录（未离散化）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;const int MAXN = 100000 + 10;int U[MAXN], n, t;int e[MAXN], e0[MAXN], x[MAXN], y[MAXN];/* 快读 */inline int getInt() &#123; int s = 0, x = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') x = -x; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] = y; return;&#125;bool Main() &#123; n = getInt(); for (int i = 0; i &lt; MAXN; ++i) &#123; U[i] = i; &#125; memset(e, 0, sizeof(e)); memset(x, 0, sizeof(x)); memset(y, 0, sizeof(y)); for (int i = 1; i &lt;= n; ++i) &#123; x[i] = getInt(), y[i] = getInt(), e[i] = getInt(); &#125; int j = 1; // 第一次做 「x1=y1」的合并操作 for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 1) Union(fx, fy); &#125; // 第二次做 「x1≠y1」的查询操作 for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 0) &#123; if(Find(fx) == Find(fy)) return false; &#125; &#125; return true;&#125;int main() &#123; ios::sync_with_stdio(false); t = getInt(); for (int i = 0; i &lt; t; ++i)&#123; if (Main()) puts("YES"); else puts("NO"); &#125;&#125; 离散化简介——引自百度百科12345离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。通俗的说，离散化是在不改变数据相对大小的条件下，对数据进行相应的缩小。例如：原数据：1,999,100000,15；处理后：1,3,4,2；原数据：&#123;100,200&#125;，&#123;20,50000&#125;，&#123;1,400&#125;；处理后：&#123;3,4&#125;，&#123;2,6&#125;，&#123;1,5&#125;； 对一堆数据进行离散化， 先排序 [ 推荐 std::sort() ]（针对有序序列进行离散化） 删除重复元素（节省空间） 对数据进行索引（最终目的） 而其中我们要用到STL提供的pair来储存变量。pair提供一个包含两个数据成员的结构体模板，可以快速访问其中的元素，就像一个压缩包一样（ 代码实现AC代码 评测记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#define Pair pair&lt;ll,ll&gt; using namespace std;typedef long long int ll;const int MAXN = 600000 + 10;int U[MAXN], n, t;int e[MAXN], x[MAXN], y[MAXN];Pair p[MAXN];inline int getInt() &#123; int s = 0, x = 1; char ch = getchar(); while (ch &gt; '9' || ch &lt; '0') &#123; if (ch == '-') x = -x; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; s = s * 10 + ch - '0'; ch = getchar(); &#125; return s * x;&#125;inline int Find(int x) &#123; if (U[x] == x) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); U[x] = y; return;&#125;bool stlCmp(Pair x, Pair y) &#123; return (x.first &gt; y.first);&#125;void Disc(Pair a[], int A[]) &#123; int tot = 0; sort(a + 1, a + n*2 + 1, stlCmp); for (int i = 1; i &lt;= n*2; ++i) &#123; if (i == 1 || a[i].first != a[i-1].first) tot++; A[a[i].second] = tot; &#125; &#125; bool Main() &#123; n = getInt(); for (int i = 0; i &lt; 500010; ++i) &#123; U[i] = i; &#125; memset(e, 0, sizeof(e)); memset(x, 0, sizeof(x)); memset(y, 0, sizeof(y)); memset(p, 0, sizeof(p)); for (int i = 1; i &lt;= n; ++i) &#123; int ax = getInt(), ay = getInt(), ae = getInt(); e[i] = ae; p[i] = make_pair(ax, i); p[i + n] = make_pair(ay, i+n); &#125; Disc(p, x); for (int i = 1; i &lt;= n; ++i) y[i] = x[n + i]; for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 1) Union(fx, fy); &#125; for (int i = 1; i &lt;= n; ++i) &#123; int fe = e[i], fx = x[i], fy = y[i]; if (fe == 0) &#123; if(Find(fx) == Find(fy)) return false; &#125; &#125; return true;&#125;int main() &#123; ios::sync_with_stdio(false); t = getInt(); for (int i = 0; i &lt; t; ++i)&#123; if (Main()) puts("YES"); else puts("NO"); &#125;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集模板]]></title>
    <url>%2F2018-04-14%2Funion-set%2F</url>
    <content type="text"><![CDATA[并查集模板 题目链接 题目描述如题，现在有一个并查集，你需要完成合并和查询操作。 输入输出格式输入格式： 第一行包含两个整数N、M，表示共有N个元素和M个操作。 接下来M行，每行包含三个整数Zi、Xi、Yi 当Zi=1时，将Xi与Yi所在的集合合并 当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N 输出格式： 如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N 输入输出样例输入输出样例1input: 123456784 72 1 21 1 22 1 21 3 42 1 41 2 32 1 4 output: 1234NYNY 数据说明时空限制：1000ms,128M 数据规模： 对于30%的数据，N&lt;=10，M&lt;=20； 对于70%的数据，N&lt;=100，M&lt;=1000； 对于100%的数据，N&lt;=10000，M&lt;=200000。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;const int MAXN = 10000 + 10;int U[MAXN], m, n;inline int Find(int x) &#123; if (U[x] &lt; 0) return x; return U[x] = Find(U[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; U[x] += U[y]; U[y] = x; &#125;int main() &#123; ios::sync_with_stdio(false); scanf("%d %d", &amp;n, &amp;m); for (int i = 1;i &lt; MAXN;i++) U[i] = -1; int z; for (int i = 0;i &lt; m;i++) &#123; scanf("%d", &amp;z); int x, y; switch(z) &#123; case 1:&#123; scanf("%d %d", &amp;x, &amp;y); Union(x, y); break; &#125; case 2:&#123; scanf("%d %d", &amp;x, &amp;y); if (Find(x) == Find(y)) puts("Y"); else puts("N"); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1536 《村村通》]]></title>
    <url>%2F2018-04-14%2FLuogu-P1536%2F</url>
    <content type="text"><![CDATA[并查集的好题目 题目地址 题目描述某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府“村村通工程”的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？ 输入输出格式输入格式：每个输入文件包含若干组测试测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目N（N&lt;1000）和道路数目M；随后的M行对应M条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从1到N编号。 注意：两个城市间可以有多条道路相通。例如： 3 3 1 2 1 2 2 1 这组数据也是合法的。当N为0时，输入结束。 输出格式：对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。 输入输出样例输入样例1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 输出样例1234102998 解题思路这是道并查集的题目，可以说接近是裸的并查集，但是你没法把这题理解为并查集这就很烦了啊喂 我们可以把它的公路理解成一条一条绳子，用来连接各个城市，可以把几个城市绑在一块（雾 那么这样就更像并查集了 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define DEBUG_CERR(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl;using namespace std;const int MAXN = 1000 + 5;int n, m;int u[MAXN];int Find(int x) &#123; if (u[x] &lt; 0) return x; return u[x] = Find(u[x]);&#125;inline void Union(int x, int y) &#123; x = Find(x), y = Find(y); if (x == y) return; u[x] += u[y]; u[y] = x;&#125;int main() &#123; ios::sync_with_stdio(false); while (scanf("%d %d", &amp;n, &amp;m) == 2) &#123; for (int i = 1;i &lt; MAXN;i++) u[i] = -1; for (int i = 1;i &lt;= m;i++) &#123; int a, b; scanf("%d %d", &amp;a, &amp;b); a = Find(a), b = Find(b); if (a != b) Union(a, b); &#125; int ans = 0; for (int i = 1;i &lt;= n;i++) &#123; if (u[i] &lt; 0) ans++; &#125; printf("%d\n", ans - 1); &#125; return 0;&#125; 提交记录]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树 模板]]></title>
    <url>%2F2018-04-01%2Fsegmenttree%2F</url>
    <content type="text"><![CDATA[快速查找和修改区间 注意：本文包含洛谷 P3372 【模板】线段树 1 题解 线段树模板前言 什么是线段树？ 线段树是一种二叉搜索树，与区间树相似，它将一个区间划分成一些单元区间，每个单元区间对应线段树中的一个叶结点。 线段树的主要用途及好处？ 线段树可以快速的查找某一个节点在若干条线段中出现的次数，时间复杂度为O(logN）。 线段树的应用？ 最简单的应用就是记录线段是否被覆盖，随时查询当前被覆盖线段的总长度。 代码基础函数我们选择一个$O(1)$的取儿子函数： 123456789inline int leftChild(int p) &#123; return p &lt;&lt; 1;&#125;// 左子树 inline int rightChild(int p) &#123; return p &lt;&lt; 1 | 1;&#125;// 右子树 线段树的维护： 1234567891011121314void pushUp(int p) &#123; t[p] = t[leftChild(p)] + t[rightChild(p)];&#125;// 向上维护区间void pushUpMin(int p) &#123; t[p] = std::min(t[leftChild(p)], t[rightChild(p)]);&#125; // 向t[p]下放Min标签void pushUpMax(int p) &#123; t[p] = std::max(t[leftChild(p)], t[rightChild(p)]);&#125; // 向t[p]下放Max标签 递归建树： 123456789101112131415typedef long long int lli;void buildTree(lli p, lli l, lli r) &#123; if (l == r) &#123; ans[p] = a[l]; return; &#125; // 如果左右区间相同，则必是叶子节点 lli mid = (l + r) &gt;&gt; 1; buildTree(leftChild(p), l, mid); buildTree(rightChild(p), mid + 1, r); // 递归 pushUp(p); &#125; // 递归 + 二分建树 区间修改函数1234567891011121314151617181920212223242526272829303132inline void Record(lli p, lli l, lli r, lli k) &#123; tag[p] = tag[p] + k; ans[p] = ans[p] + k * (r - l + 1); // 因为是区间统一改变，所以ans要加元素个数 &#125;// 记录当前节点所代表的区间inline void pushDown(lli p, lli l, lli r) &#123; lli mid = (l + r) &gt;&gt; 1; Record(leftChild(p), l, mid, tag[p]); Record(rightChild(p), mid + 1, r, tag[p]); tag[p] = 0; // 每次更新两个儿子节点，不断向下传递 &#125; inline void update(lli nl, lli nr, lli l, lli r, lli p, lli k) &#123; // 将要修改从 nl 到 nr 的区间 // l,r 为当前节点所储存的区间 // p 为当前节点的编号 if (nl &lt;= l &amp;&amp; r &lt;= nr) &#123; ans[p] += k * (r - l + 1); tag[p] += k; return; &#125; pushDown(p, l, r); lli mid = (l + r) &gt;&gt; 1; if (nl &lt;= mid) update(nl, nr, l, mid, leftChild(p), k) if (nr &gt; mid) update(nl, nr,mid + 1, r, rightChild(p), k); pushUp(p);&#125;// 更新区间 查询区间函数12345678910inline lli query(lli qx, lli qy, lli l, lli r, lli p) &#123; lli res = 0; if (qx &lt;= l &amp;&amp; r &lt;= qy) return ans[p]; lli mid = (l + r) &gt;&gt; 1; pushDown(p, l, r); if (qx &lt;= mid) res += query(qx, qy, l, mid, leftChild(p)); if (mid + 1 &lt;= qy) res += query(qx, qy, mid + 1, r, rightChild(p)); return res; &#125;// 查询区间 依然采用二分的形式… 洛谷 P3372 题解题目描述已知一个数列，你需要进行下面两种操作： 1.将某区间每一个数加上x 2.求出某区间每一个数的和 输入格式第一行包含两个整数N、M，分别表示该数列数字的个数和操作的总个数。 第二行包含N个用空格分隔的整数，其中第i个数字表示数列第i项的初始值。 接下来M行每行包含3或4个整数，表示一个操作，具体如下： 操作1： 格式：1 x y k 含义：将区间[x,y]内每个数加上k 操作2： 格式：2 x y 含义：输出区间[x,y]内每个数的和 输出格式输出包含若干行整数，即为所有操作2的结果。 输入样例12345675 51 5 4 2 32 2 41 2 3 22 3 41 1 5 12 1 4 输出样例12311820 解题思路就是把上面的函数都复制下来就行了= = 没什么多解释的 注释见上面代码 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;// using namespace std;typedef long long int ll;typedef unsigned long long int ull;const int MAXN = 1000000 + 1;ull n, m, a[MAXN], ans[MAXN &lt;&lt; 2], tag[MAXN &lt;&lt; 2];inline ll ls(ll x) &#123; return x &lt;&lt; 1; &#125;inline ll rs(ll x) &#123; return x &lt;&lt; 1 | 1;&#125;void scan()&#123; scanf("%lld %lld", &amp;n, &amp;m); for (ll i = 1;i &lt;= n;i++) &#123; scanf("%lld", &amp;a[i]); &#125;&#125;inline void pushUp(ll p) &#123; ans[p] = ans[ls(p)] + ans[rs(p)];&#125; inline void build(ll p, ll l, ll r) &#123; tag[p] = 0; if (l == r) &#123; ans[p] = a[l]; return; &#125; ll mid = (l + r) &gt;&gt; 1; build(ls(p), l, mid); build(rs(p), mid + 1, r); pushUp(p);&#125;inline void rec(ll p, ll l, ll r, ll k) &#123; tag[p] = tag[p] + k; ans[p] = ans[p] + k * (r - l + 1);&#125;inline void pushDown(ll p,ll l, ll r) &#123; ll mid = (l + r) &gt;&gt; 1; rec(ls(p), l, mid, tag[p]); rec(rs(p), mid + 1, r, tag[p]); tag[p] = 0;&#125;inline void update(ll nl, ll nr, ll l, ll r, ll p, ll k) &#123; if (nl &lt;= l &amp;&amp; r &lt;= nr) &#123; ans[p] += k * (r - l + 1); tag[p] += k; return; &#125; pushDown(p, l, r); ll mid = (l + r) &gt;&gt; 1; if (nl &lt;= mid) update(nl, nr, l, mid, ls(p), k); if (nr &gt; mid) update(nl, nr, mid + 1, r, rs(p), k); pushUp(p);&#125;ll query(ll qx, ll qy, ll l, ll r, ll p) &#123; ll res = 0; if (qx &lt;= l &amp;&amp; r &lt;= qy) return ans[p]; ll mid = (l + r) &gt;&gt; 1; pushDown(p, l, r); if (qx &lt;= mid) res += query(qx, qy, l, mid, ls(p)); if (qy &gt; mid) res += query(qx, qy, mid + 1, r, rs(p)); return res;&#125;int main() &#123; // ios::sync_with_stdio(false); ll a1, b, c, d, e, f; scan(); build(1, 1, n); while (m--) &#123; scanf("%lld", &amp;a1); switch(a1) &#123; case 1:&#123; scanf("%lld %lld %lld", &amp;b, &amp;c, &amp;d); update(b, c, 1, n, 1, d); break; &#125; case 2:&#123; scanf("%lld %lld", &amp;e, &amp;f); printf("%lld\n", query(e, f, 1, n, 1)); break; &#125; &#125; &#125; return 0;&#125;// 注意一下，stdio 和 iostream 混用会出现很多奇怪的bug！]]></content>
      <tags>
        <tag>编程</tag>
        <tag>线段树</tag>
        <tag>模板</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算π]]></title>
    <url>%2F2018-03-31%2Fcalculating-pi%2F</url>
    <content type="text"><![CDATA[计算$π$可不是件容易事 前情提要偶然在WA谷上看到一道题 不得不说很玄学 抱着好奇的心态我点开了题解 发现了一个打表的。。。。 于是心血来潮去搜了一下如何计算π 于是就有了这篇文章 题目描述Handwer STD 要你计算一下圆周率，要求最少为4000位（从小数部分第一位开始算起） 输入描述&amp;样例无输入 输出描述&amp;样例输出$π$，要求保留至少4000位小数。 样例： 13141592653589793...... 其他时限为5000ms 解题解题思路我们需要找到一个合适、可靠且快速的圆周率计算公式 我选择了基于级数的快速收敛公式 这是一个很快、精度也很高的算法 公式为： （懒得写MathJax码了 代码实现1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;long long n = 16366;long long d[16366 + 2];int main() &#123; ios::sync_with_stdio(false); double cost; long long i = 0; while (n - i) d[++i] = 2000; for (;n;n -= 14) &#123; long long p; for (p = 0,i = n;i;i--) &#123; p = p * i + d[i] * 10000; d[i] = p % (2 * i - 1); p /= 2 * i - 1; &#125; printf("%.4d",d[0] + p / 10000); d[0] = p % 10000; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 快速读入 模板]]></title>
    <url>%2F2018-03-23%2FCPP-Fast-RW%2F</url>
    <content type="text"><![CDATA[比某记者还快！ C++ 快速读入、输出在 C++ 上实现快速读入模板，这里是一个读取int 的示例。123456789101112inline int Quick_Read()&#123; int s = 0,w = 1; char ch = getchar(); while (ch &lt;= '0' || ch &gt; '9')&#123; if (ch == '-') w = -1; ch = getchar(); &#125; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') s = s * 10 + ch - '0' , ch = getchar(); return s * w;&#125;// 本代码来自 wyh's Blog// 地址: aor.sd.cn 在 C++ 上实现快速输出模板，这里是一个输出int 的示例。12345678910inline void Quick_Write(int x)&#123; if (x &lt; 0)&#123; putchar('-'); re = -re; &#125; // 判断负数 if (x &gt; 9) Quick_Write(x/10); // 判断是否大于10 putchar(x%10 + '0');&#125;]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵乘法]]></title>
    <url>%2F2018-03-10%2Fmatrix-mul%2F</url>
    <content type="text"><![CDATA[“简单”的矩阵乘法 矩阵乘法，就是将两个矩阵相乘 现要求写一个程序，可以实现矩阵相乘。 输入格式第一行三个正整数 $n$、$p$、$m$，表示矩阵的长宽。之后的$n$ 行，每行 $p$ 个整数，表示矩阵 $A$。之后的 $p$ 行，每行 $m$ 个整数，表示矩阵 $B$。 输出格式输出 $n$ 行，每行 $m$ 个整数，表示矩阵 $A×B$ ，每个数模 $10 ^ 9 + 7$ 输出。 输入样例123456783 4 5-2 -8 -9 8-10 0 6 -8-10 -6 6 94 -7 5 -5 910 -2 -10 5 5-3 -7 -3 8 -2-6 7 7 3 -2 良心数据 输出样例123999999898 149 153 999999929 999999951999999997 999999979 999999883 74 999999921 999999835 103 55 95 999999857 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn = 505;const int INF = 0x3f3f3f3f;const int MOD = 1e9+7;struct Matrix&#123; LL arr[maxn][maxn]; int n,m; Matrix operator * (const Matrix &amp;b)const&#123; // 重载运算符 Matrix res; memset(res.arr,0,sizeof(res.arr)); for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; b.m;j++) for(int k = 0;k &lt; m;k++)&#123; (res.arr[i][j] += arr[i][k] * b.arr[k][j] % MOD) %= MOD; &#125; res.n = n;res.m = b.m; return res; &#125;&#125;a,b,ans;// 用结构体来储存矩阵int main()&#123; int n,p,m; scanf("%d %d %d",&amp;n,&amp;p,&amp;m); a.n = n;a.m = p; for(int i = 0;i &lt; n;i++) for(int j = 0;j &lt; p;j++)&#123; scanf("%lld",&amp;a.arr[i][j]); &#125; // 输入矩阵 b.n = p;b.m = m; for(int i = 0;i &lt; p;i++) for(int j = 0;j &lt; m;j++)&#123; scanf("%lld",&amp;b.arr[i][j]); &#125; ans = a * b; for(int i = 0;i &lt; n;i++)&#123; for(int j = 0;j &lt; m - 1;j++)&#123; (ans.arr[i][j] += MOD) %= MOD; printf("%lld ",ans.arr[i][j]); &#125; (ans.arr[i][m - 1] += MOD) %= MOD; printf("%lld\n",ans.arr[i][m - 1]); &#125; // 输出矩阵 return 0;&#125; 图片 by simimg.com]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 体验记]]></title>
    <url>%2F2018-03-05%2Fwindows10%2F</url>
    <content type="text"><![CDATA[Windows 10 从入门到放弃到重拾再到（伪）精通 终于把Windows 10 的更新配置好了，再也不用5分钟开机了（ 先把方法记一下吧1234567891. DiskGenius 激活Windows分区（默认激活deepin 根目录分区）2. 重启之后引导就炸了3. （进入Windows）使用 EasyBCD 重建Windows引导（可以不添加deepin）4. 重启之后引导还是爆炸的5. （进入deepin）执行 sudo grub-install /dev/sda &amp;&amp; sudo update-grub6. 重启之后还是deepin的grub引导，但是活动分区是Windows的7. 下载Fall Creators更新8. 安装更新9. 正常使用 全程惊悚… 2018.3.5Windows 10 可以正常使用的第一天，同时今天也开学了QAQ 开学什么的，体验最差了，况且今天还有什么收心考试 好在今天作业少，终于有时间写代码了（ · v · ） 用 Dev-C++ 写了 P1179 P1420 P1567 这两道大水题 总体感觉还是不错的 Dev-C++ 界面还行，还能看 后台开着一个火萤桌面，一个Chrome和一个Markdown编辑器 不得不说 Dev-C++ 真的是轻量级，占的内存从不超过100MB，Atom开完100MB就没了 对于这种老爷机真的很有用 我好像可以Wine一个Dev-C++出来…但是不能编译 这次体验感觉还不错，或许我可以主力一段时间… 2018.3.13已经是深夜了，洗漱完又上洛谷打了个卡，写了一道入门难度的大水题 周六因为晚上需要写《矩阵乘法》，所以就没更这篇文章 （话说这个矩阵乘法耗了我一下午…我可能真的太弱了 周六我全天都在使用 Windows 10，除了更 Blog 需要重启到Linux 这几天体验下来，感觉还不错，态度慢慢好转 Windows 10 的触摸板手势真的爽！Deepin 15 的触摸板手势太不灵敏了，经常误触或无效操作全靠友商衬托.png （主要是 Windows 10 的电源调配真的比 Linux 好…耗电比 Linux 少 我现在已经是 Windows 10 主力了，Linux 用来更 Blog 等鼓捣好 Windows Subsystem for Linux （WSL） 之后应该就可以在 Windows 10 上更博客了微软强势拉用户.jpg 2018.3.14今天作业少 哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈 我在学校就完成了几乎全部的作业，到家就只剩下5个小题 做完作业后便欢欢喜喜地来搞 Windows Subsystem for Linux（WSL） 经过不懈的努力（其实就是重启一次）终于弄好了WSL 现在正在装 g++ 网慢死了QAQ PS：由于我没有截任务栏，所以比例有点奇怪 又用 Dev-C++ 写了一道记忆化搜索的大水题，感觉 Dev-C++ 比 Atom 好用多了，毕竟 Core i3 3110m 带不起 Atom 本来打算今天的 Blog 用 WSL 交，想想还是算了吧，出现意外没时间处理]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找&二分答案]]></title>
    <url>%2F2018-02-06%2FBSAnswer%2F</url>
    <content type="text"><![CDATA[友情提示：先看二分查找，再看二分答案！ 二分查找百度百科原话1二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 二分查找的时间复杂度是$O(log_{2}n)$ 要求 查找的序列必须采用顺序存储结构 查找的序列必须是有序排列的 思路 将需要查找的序列进行排序（一般为升序排列） 将序列中间位置记录的元素与关键字比较 如果相等，则12如果不相等，则```将序列分成左右两个子序列，若元素小于关键字，就到左子序列中查找；否则就到右子序列中查找 代码实现1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;inline bool BinarySearch(int l,int r,int t,int x[])&#123; while (l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if (x[mid] == t) return true; if (x[mid] &lt; t) l = mid + 1; if (x[mid] &gt; t) r = mid - 1; &#125; if (l &gt; r) return false;&#125;int main()&#123; int dest; cin &gt;&gt; dest; int n; cin &gt;&gt; n; int *p = new int[n + 1]; for (int i = 0;i &lt; n;i++) cin &gt;&gt; p[i]; printf("%s\n",BinarySearch(0,n - 1,dest,p)?"YES":"NO"); return 0;&#125; 二分答案看完了二分查找，你会发现二分并没有什么卵用。 对，二分的确没有什么用，但是从它身上衍生出来的二分答案却是一个很有用的东西！ 二分答案，就是通过二分的方式枚举出一个答案来，然后再验证你的查找结果是否正确，从而获取答案 要求&amp;特点 答案具有单调性 题面里包含与“最小的最大，最大的最小”相关的字眼 思路 先将给定的序列排序 参照二分查找，枚举一个答案mid 验证这个答案是否可行 如果可行，12如果不可行，```更新边界，继续寻找答案 代码实现一般模板 其中的check函数需要针对每一个题目进行验证 当然你会写暴力枚举的check也可以借鉴过来#(滑稽) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;inline bool check(int x)&#123; /* code here*/ return true;&#125;int main(int argc, char const *argv[]) &#123; int n,m; cin &gt;&gt; n &gt;&gt; m; int *p = new int[n + 2]; for (int i = 0;i &lt; n;i++) cin &gt;&gt; p[i]; // ----------------------------------- int l = 0,r = n - 1; int ans = 0; while (l &lt;= r)&#123; int mid = (l + r) &gt;&gt; 1; if (check(ans))&#123; l = mid + 1; ans = mid; &#125; else r = mid - 1; &#125; cout &lt;&lt; ans &lt;&lt; endl; // ----------------------------------- return 0;&#125; 推荐题目 「洛谷P2678 跳房子」 出处：NOIP2015 提高组 「洛谷P1824 进击的奶牛」 出处：USACO]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷P1102 《A-B数对》]]></title>
    <url>%2F2018-02-01%2FLuogu-P1102%2F</url>
    <content type="text"><![CDATA[普及- 的“水”题 题目地址 提前说明：本题难度为普及- 题目描述给出一串数以及一个数字C，要求计算出所有A-B=C的数对的个数。（不同位置的数字一样的数对算不同的数对） 输入输出格式输入格式： 第一行包括2个非负整数N和C，中间用空格隔开。 第二行有N个整数，中间用空格隔开，作为要求处理的那串数。 输出格式： 输出一行，表示该串数中包含的所有满足A-B=C的数对的个数。 输入输出样例输入输出样例1input: 124 11 1 2 3 output: 13 数据说明对于73%的数据，N &lt;= 2000； 对于100%的数据，N &lt;= 200000。 所有输入数据都在longint范围内。 原题目2017/4/29新添数据两组 解析暴力解法粗略一看，这道题是不是特别水？ 只需要用$O(n^2)$的暴力解法不就可以了吗？ ​ 枚举A和B，再判断A-B是否为C 但是！ 你们Naive，没看见那个N&lt;=200000 吗 这样肯定会TLE的啊喂 测试记录 76分 正确解法作为C++选手，我们一定要发扬光大Alexander留给我们的STL 于是我们就可以用std::map映射来做这道题目（注意这是普及-的题目） 将A-B=C转换为A-C=B，然后找这N个数中有几个B就行了 测试记录 AC 代码实现暴力解法1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int *arr,n,c;inline void read()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; c; arr = new int[n]; for (int i = 0;i &lt; n;i++)&#123; cin &gt;&gt; arr[i]; &#125; return;&#125;inline int work()&#123; int ans = 0; for(int i = 0;i &lt; n;i++) for (int j = 0;j &lt; n;j++) if ((arr[i] - arr[j] == c)) ans++; return ans;&#125;int main(int argc, char const *argv[]) &#123; read(); cout &lt;&lt; work() &lt;&lt; endl; return 0;&#125; 正确解法1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;map&gt;using namespace std;int a[200001];inline void LetMeAccept()&#123; int n,c; scanf("%d %d",&amp;n,&amp;c); map&lt;int,int&gt; p; for(int i = 0;i &lt; n;i++)&#123; scanf("%d",a + i); p[a[i]]++; &#125; long long ans=0; for(int i = 0;i &lt; n;i++) ans += p[a[i] + c]; printf("%lld\n",ans);&#125;int main(int argc,char const *argv[])&#123; LetMeAccept(); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图论之建立基础的图]]></title>
    <url>%2F2017-12-31%2FCreateGraph%2F</url>
    <content type="text"><![CDATA[背下来就行了 学（背）会建立一个基础的图，是写好图论算法的基础。 具体就是写一个循环，通过构造函数来创建一个一个的边和结点附代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define Inf 2e31-1#define DEBUG(x) std::cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; x &lt;&lt; endl;#define MAXN 2500 + 5//设定图的最大结点值为2500struct Node;struct Edge;struct Node&#123; Edge *firstEdge; int dist; bool inQueue;&#125; node[MAXN];struct Edge&#123; Node *s,*t; int w; //权值 Edge *next; //下一条边 Edge(Node *s,Node *t,int w) : s(s),t(t),w(w),next(s-&gt;firstEdge); //构造函数&#125;;inline void add(const int &amp;s,const int &amp;t,const int &amp;w)&#123; node[s].firstEdge = new Edge(&amp;node[s],&amp;node[t],w); node[t].firstEdge = new Edge(&amp;node[t],&amp;node[s],w);&#125;/* code here * 请在这里写各种玄学的函数 */ int main(int argc, char const *argv[]) &#123; int n,m,s,t; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i = 1;i &lt;= m;i++)&#123; int u,v,w; cin &gt;&gt; u,v,w; add(u,v,w); &#125; /* code here*/ return 0; &#125; 好了，这样你就可以把一个简单玄学的图建立起来了。]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPFA]]></title>
    <url>%2F2017-12-30%2FSPFA%2F</url>
    <content type="text"><![CDATA[简单的SPFA最短路模板，适用于图的边权有负数的情况。 算法实现：我们用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。运用动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行操作，直至队列空为止。 代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;#define MAXN 2500 + 5#define DEBUG(x) cerr &lt;&lt; #x &lt;&lt; '=' &lt;&lt; xconst int Inf = 2e31-1;struct Node;struct Edge;struct Node&#123; Edge *firstEdge; int dist; bool inQueue;&#125; node[MAXN];struct Edge&#123; Node *s,*t; int w; Edge *next; Edge(Node *s,Node *t,int w) : s(s),t(t),w(w),next(s-&gt;firstEdge)&#123;&#125;&#125;;inline void add(const int &amp;s,const int &amp;t,const int &amp;w)&#123; node[s].firstEdge = new Edge(&amp;node[s],&amp;node[t],w); node[t].firstEdge = new Edge(&amp;node[t],&amp;node[s],w);&#125;inline int spfa(const int &amp;s,const int &amp;t,const int &amp;n)&#123; for (int i = 1;i &lt;= n;i++)&#123; node[i].dist = Inf; node[i].inQueue = false; //将所有节点的在队列的情况设为false &#125; queue&lt;Node *&gt; q; q.push(&amp;node[s]); node[s].dist = 0; node[s].inQueue = true; while (!q.empty())&#123; Node *u = q.front(); q.pop(); u-&gt;inQueue = false; for (Edge *e = u-&gt;firstEdge;e;e = e-&gt;next)&#123; Node *v = e-&gt;t; if (v-&gt;dist &gt; u-&gt;dist + e-&gt;w)&#123; v-&gt;dist = u-&gt;dist + e-&gt;w; if (!v-&gt;inQueue)&#123; q.push(v); v-&gt;inQueue = true; &#125; &#125; &#125; &#125; return node[t].dist;&#125;int main(int argc, char const *argv[]) &#123; int n,m,s,t; scanf("%d %d %d %d",&amp;n,&amp;m,&amp;s,&amp;t); for (int i = 1;i &lt;= m;i++)&#123; int u,v,w; scanf("%d %d %d",&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; printf("%d",spfa(s,t,n)); return 0;&#125;]]></content>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[已锁定的文章]]></title>
    <url>%2F2017-12-30%2FLockedPage%2F</url>
    <content type="text"><![CDATA[本文转自Shq’s Blog原文访问密码：password Be Safe！ 即使是最简单的密码功能也足以阻止90%的访问者 一、前言一开始使用Hexo的时候，是喜欢它的简单：因为可以直接编译成纯静态文件，方便部署。可是在使用过程中，又发现诸多不便：也因为它全是纯静态页面。突发奇想，能不能给文章加上一个加密访问的功能…… 在经过实践之后，运用到自己博客中，发现有不少的访客对这个功能甚是感兴趣，所以也就在这里找个时间写写自己加密的小诀窍吧算是。 二、原理由于 Hexo 最终编译出来的文件是纯静态的，也就意味着文章的所有信息其实还是原封不动展示在页面中的，当你输入一篇文章的网址，所有的内容就已经跟随网络传输过来了。那我博客使用的加密是怎么实现的呢？ 这就要讲到 js 的阻塞机制了，在以往的经验中，当页面中有调用alert();函数的时候，整个页面会停止运行，直到你点击确定之后，页面的中的代码才会继续执行下去。我们这里需要的也是这样一个假象，阻止整个页面的渲染，直到你输入了正确的密码才能让页面继续渲染实际的文章。可是alert只有提醒的功能，没有输入的功能，所以这里要用到的是promt函数。例子参见如下：12var password = promt('请输入文章密码');alert(password); 三、实践究竟要把上述代码加在哪里呢？找到themes-&gt;next-&gt;layout-&gt;_partials-&gt;head.swig文件。按道理是添加在任何地方都行，但是推荐加在所有的1234567891011```&lt;script&gt; (function()&#123; if(&apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; if (prompt(&apos;请输入文章密码&apos;,&apos;&apos;) !== &apos;&#123;&#123; page.password &#125;&#125;&apos;)&#123; alert(&apos;密码错误！&apos;); history.back(); &#125; &#125; &#125;)();&lt;/script&gt; 如果你好奇page.password是什么东西，那么恭喜你，你对 Hexo 的结构还是很熟悉的。page这个变量就是你在hexo new的时候生成文件中最顶部的东西，以下我给出这篇文章的头部参考：123456789title: Hexo文章简单加密访问date: 2016-12-01 10:45:29tags: hexocategories: 博客keywords: - Hexo - 加密description: 文章访问密码：passwordpassword: password 这样我们就好像使用静态页面完成了部分只有动态页面能完成的东西。 四、总结本来只是简单的纯静态页面，但是经历不断的更新和改进，便有了静态页面统计访问量的工具；有了静态页面添加评论的工具；甚至有了静态页面进行搜索的功能等等。个人想出来的静态页面加密功能根本算不上技术上的创新，只能说是一点小技巧的应用吧，小技巧也能迷惑住大家的眼睛，也算是喜事一件。]]></content>
  </entry>
</search>
